# Generated from postgreSQLParser.g4 by ANTLR 4.9.2
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3\u027a")
        buf.write("\u1ef4\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\4\32\t\32\4\33\t\33\4\34\t\34\4\35\t\35\4\36\t\36")
        buf.write("\4\37\t\37\4 \t \4!\t!\4\"\t\"\4#\t#\4$\t$\4%\t%\4&\t")
        buf.write("&\4\'\t\'\4(\t(\4)\t)\4*\t*\4+\t+\4,\t,\4-\t-\4.\t.\4")
        buf.write("/\t/\4\60\t\60\4\61\t\61\4\62\t\62\4\63\t\63\4\64\t\64")
        buf.write("\4\65\t\65\4\66\t\66\4\67\t\67\48\t8\49\t9\4:\t:\4;\t")
        buf.write(";\4<\t<\4=\t=\4>\t>\4?\t?\4@\t@\4A\tA\4B\tB\4C\tC\4D\t")
        buf.write("D\4E\tE\4F\tF\4G\tG\4H\tH\4I\tI\4J\tJ\4K\tK\4L\tL\4M\t")
        buf.write("M\4N\tN\4O\tO\4P\tP\4Q\tQ\4R\tR\4S\tS\4T\tT\4U\tU\4V\t")
        buf.write("V\4W\tW\4X\tX\4Y\tY\4Z\tZ\4[\t[\4\\\t\\\4]\t]\4^\t^\4")
        buf.write("_\t_\4`\t`\4a\ta\4b\tb\4c\tc\4d\td\4e\te\4f\tf\4g\tg\4")
        buf.write("h\th\4i\ti\4j\tj\4k\tk\4l\tl\4m\tm\4n\tn\4o\to\4p\tp\4")
        buf.write("q\tq\4r\tr\4s\ts\4t\tt\4u\tu\4v\tv\4w\tw\4x\tx\4y\ty\4")
        buf.write("z\tz\4{\t{\4|\t|\4}\t}\4~\t~\4\177\t\177\4\u0080\t\u0080")
        buf.write("\4\u0081\t\u0081\4\u0082\t\u0082\4\u0083\t\u0083\4\u0084")
        buf.write("\t\u0084\4\u0085\t\u0085\4\u0086\t\u0086\4\u0087\t\u0087")
        buf.write("\4\u0088\t\u0088\4\u0089\t\u0089\4\u008a\t\u008a\4\u008b")
        buf.write("\t\u008b\4\u008c\t\u008c\4\u008d\t\u008d\4\u008e\t\u008e")
        buf.write("\4\u008f\t\u008f\4\u0090\t\u0090\4\u0091\t\u0091\4\u0092")
        buf.write("\t\u0092\4\u0093\t\u0093\4\u0094\t\u0094\4\u0095\t\u0095")
        buf.write("\4\u0096\t\u0096\4\u0097\t\u0097\4\u0098\t\u0098\4\u0099")
        buf.write("\t\u0099\4\u009a\t\u009a\4\u009b\t\u009b\4\u009c\t\u009c")
        buf.write("\4\u009d\t\u009d\4\u009e\t\u009e\4\u009f\t\u009f\4\u00a0")
        buf.write("\t\u00a0\4\u00a1\t\u00a1\4\u00a2\t\u00a2\4\u00a3\t\u00a3")
        buf.write("\4\u00a4\t\u00a4\4\u00a5\t\u00a5\4\u00a6\t\u00a6\4\u00a7")
        buf.write("\t\u00a7\4\u00a8\t\u00a8\4\u00a9\t\u00a9\4\u00aa\t\u00aa")
        buf.write("\4\u00ab\t\u00ab\4\u00ac\t\u00ac\4\u00ad\t\u00ad\4\u00ae")
        buf.write("\t\u00ae\4\u00af\t\u00af\4\u00b0\t\u00b0\4\u00b1\t\u00b1")
        buf.write("\4\u00b2\t\u00b2\4\u00b3\t\u00b3\4\u00b4\t\u00b4\4\u00b5")
        buf.write("\t\u00b5\4\u00b6\t\u00b6\4\u00b7\t\u00b7\4\u00b8\t\u00b8")
        buf.write("\4\u00b9\t\u00b9\4\u00ba\t\u00ba\4\u00bb\t\u00bb\4\u00bc")
        buf.write("\t\u00bc\4\u00bd\t\u00bd\4\u00be\t\u00be\4\u00bf\t\u00bf")
        buf.write("\4\u00c0\t\u00c0\4\u00c1\t\u00c1\4\u00c2\t\u00c2\4\u00c3")
        buf.write("\t\u00c3\4\u00c4\t\u00c4\4\u00c5\t\u00c5\4\u00c6\t\u00c6")
        buf.write("\4\u00c7\t\u00c7\4\u00c8\t\u00c8\4\u00c9\t\u00c9\4\u00ca")
        buf.write("\t\u00ca\4\u00cb\t\u00cb\4\u00cc\t\u00cc\4\u00cd\t\u00cd")
        buf.write("\4\u00ce\t\u00ce\4\u00cf\t\u00cf\4\u00d0\t\u00d0\4\u00d1")
        buf.write("\t\u00d1\4\u00d2\t\u00d2\4\u00d3\t\u00d3\4\u00d4\t\u00d4")
        buf.write("\4\u00d5\t\u00d5\4\u00d6\t\u00d6\4\u00d7\t\u00d7\4\u00d8")
        buf.write("\t\u00d8\4\u00d9\t\u00d9\4\u00da\t\u00da\4\u00db\t\u00db")
        buf.write("\4\u00dc\t\u00dc\4\u00dd\t\u00dd\4\u00de\t\u00de\4\u00df")
        buf.write("\t\u00df\4\u00e0\t\u00e0\4\u00e1\t\u00e1\4\u00e2\t\u00e2")
        buf.write("\4\u00e3\t\u00e3\4\u00e4\t\u00e4\4\u00e5\t\u00e5\4\u00e6")
        buf.write("\t\u00e6\4\u00e7\t\u00e7\4\u00e8\t\u00e8\4\u00e9\t\u00e9")
        buf.write("\4\u00ea\t\u00ea\4\u00eb\t\u00eb\4\u00ec\t\u00ec\4\u00ed")
        buf.write("\t\u00ed\4\u00ee\t\u00ee\4\u00ef\t\u00ef\4\u00f0\t\u00f0")
        buf.write("\4\u00f1\t\u00f1\4\u00f2\t\u00f2\4\u00f3\t\u00f3\4\u00f4")
        buf.write("\t\u00f4\4\u00f5\t\u00f5\4\u00f6\t\u00f6\4\u00f7\t\u00f7")
        buf.write("\4\u00f8\t\u00f8\4\u00f9\t\u00f9\4\u00fa\t\u00fa\4\u00fb")
        buf.write("\t\u00fb\4\u00fc\t\u00fc\4\u00fd\t\u00fd\4\u00fe\t\u00fe")
        buf.write("\4\u00ff\t\u00ff\4\u0100\t\u0100\4\u0101\t\u0101\4\u0102")
        buf.write("\t\u0102\4\u0103\t\u0103\4\u0104\t\u0104\4\u0105\t\u0105")
        buf.write("\4\u0106\t\u0106\4\u0107\t\u0107\4\u0108\t\u0108\4\u0109")
        buf.write("\t\u0109\4\u010a\t\u010a\4\u010b\t\u010b\4\u010c\t\u010c")
        buf.write("\4\u010d\t\u010d\4\u010e\t\u010e\4\u010f\t\u010f\4\u0110")
        buf.write("\t\u0110\4\u0111\t\u0111\4\u0112\t\u0112\4\u0113\t\u0113")
        buf.write("\4\u0114\t\u0114\4\u0115\t\u0115\4\u0116\t\u0116\4\u0117")
        buf.write("\t\u0117\4\u0118\t\u0118\4\u0119\t\u0119\4\u011a\t\u011a")
        buf.write("\4\u011b\t\u011b\4\u011c\t\u011c\4\u011d\t\u011d\4\u011e")
        buf.write("\t\u011e\4\u011f\t\u011f\4\u0120\t\u0120\4\u0121\t\u0121")
        buf.write("\4\u0122\t\u0122\4\u0123\t\u0123\4\u0124\t\u0124\4\u0125")
        buf.write("\t\u0125\4\u0126\t\u0126\4\u0127\t\u0127\4\u0128\t\u0128")
        buf.write("\4\u0129\t\u0129\4\u012a\t\u012a\4\u012b\t\u012b\4\u012c")
        buf.write("\t\u012c\4\u012d\t\u012d\4\u012e\t\u012e\4\u012f\t\u012f")
        buf.write("\4\u0130\t\u0130\4\u0131\t\u0131\4\u0132\t\u0132\4\u0133")
        buf.write("\t\u0133\4\u0134\t\u0134\4\u0135\t\u0135\4\u0136\t\u0136")
        buf.write("\4\u0137\t\u0137\4\u0138\t\u0138\4\u0139\t\u0139\4\u013a")
        buf.write("\t\u013a\4\u013b\t\u013b\4\u013c\t\u013c\4\u013d\t\u013d")
        buf.write("\4\u013e\t\u013e\4\u013f\t\u013f\4\u0140\t\u0140\4\u0141")
        buf.write("\t\u0141\4\u0142\t\u0142\4\u0143\t\u0143\4\u0144\t\u0144")
        buf.write("\4\u0145\t\u0145\4\u0146\t\u0146\4\u0147\t\u0147\4\u0148")
        buf.write("\t\u0148\4\u0149\t\u0149\4\u014a\t\u014a\4\u014b\t\u014b")
        buf.write("\4\u014c\t\u014c\4\u014d\t\u014d\4\u014e\t\u014e\4\u014f")
        buf.write("\t\u014f\4\u0150\t\u0150\4\u0151\t\u0151\4\u0152\t\u0152")
        buf.write("\4\u0153\t\u0153\4\u0154\t\u0154\4\u0155\t\u0155\4\u0156")
        buf.write("\t\u0156\4\u0157\t\u0157\4\u0158\t\u0158\4\u0159\t\u0159")
        buf.write("\4\u015a\t\u015a\4\u015b\t\u015b\4\u015c\t\u015c\4\u015d")
        buf.write("\t\u015d\4\u015e\t\u015e\4\u015f\t\u015f\4\u0160\t\u0160")
        buf.write("\4\u0161\t\u0161\4\u0162\t\u0162\4\u0163\t\u0163\4\u0164")
        buf.write("\t\u0164\4\u0165\t\u0165\4\u0166\t\u0166\4\u0167\t\u0167")
        buf.write("\4\u0168\t\u0168\4\u0169\t\u0169\4\u016a\t\u016a\4\u016b")
        buf.write("\t\u016b\4\u016c\t\u016c\4\u016d\t\u016d\4\u016e\t\u016e")
        buf.write("\4\u016f\t\u016f\4\u0170\t\u0170\4\u0171\t\u0171\4\u0172")
        buf.write("\t\u0172\4\u0173\t\u0173\4\u0174\t\u0174\4\u0175\t\u0175")
        buf.write("\4\u0176\t\u0176\4\u0177\t\u0177\4\u0178\t\u0178\4\u0179")
        buf.write("\t\u0179\4\u017a\t\u017a\4\u017b\t\u017b\4\u017c\t\u017c")
        buf.write("\4\u017d\t\u017d\4\u017e\t\u017e\4\u017f\t\u017f\4\u0180")
        buf.write("\t\u0180\4\u0181\t\u0181\4\u0182\t\u0182\4\u0183\t\u0183")
        buf.write("\4\u0184\t\u0184\4\u0185\t\u0185\4\u0186\t\u0186\4\u0187")
        buf.write("\t\u0187\4\u0188\t\u0188\4\u0189\t\u0189\4\u018a\t\u018a")
        buf.write("\3\2\5\2\u0316\n\2\3\2\7\2\u0319\n\2\f\2\16\2\u031c\13")
        buf.write("\2\3\2\3\2\6\2\u0320\n\2\r\2\16\2\u0321\3\2\5\2\u0325")
        buf.write("\n\2\7\2\u0327\n\2\f\2\16\2\u032a\13\2\3\2\3\2\3\3\3\3")
        buf.write("\3\3\3\4\5\4\u0332\n\4\3\4\3\4\3\4\3\5\3\5\3\5\7\5\u033a")
        buf.write("\n\5\f\5\16\5\u033d\13\5\3\5\3\5\3\6\5\6\u0342\n\6\3\6")
        buf.write("\3\6\5\6\u0346\n\6\3\6\3\6\3\7\5\7\u034b\n\7\3\7\3\7\3")
        buf.write("\7\7\7\u0350\n\7\f\7\16\7\u0353\13\7\3\7\3\7\3\b\3\b\3")
        buf.write("\b\5\b\u035a\n\b\3\t\3\t\3\t\3\t\5\t\u0360\n\t\3\n\3\n")
        buf.write("\5\n\u0364\n\n\3\13\3\13\3\13\3\13\5\13\u036a\n\13\5\13")
        buf.write("\u036c\n\13\3\13\3\13\3\13\7\13\u0371\n\13\f\13\16\13")
        buf.write("\u0374\13\13\5\13\u0376\n\13\3\13\3\13\5\13\u037a\n\13")
        buf.write("\3\13\3\13\5\13\u037e\n\13\3\13\5\13\u0381\n\13\3\13\3")
        buf.write("\13\3\13\3\13\5\13\u0387\n\13\3\13\3\13\3\13\3\13\5\13")
        buf.write("\u038d\n\13\5\13\u038f\n\13\3\13\3\13\3\13\3\13\3\13\3")
        buf.write("\13\5\13\u0397\n\13\3\13\3\13\5\13\u039b\n\13\3\13\3\13")
        buf.write("\5\13\u039f\n\13\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\3\f\5")
        buf.write("\f\u03aa\n\f\3\f\3\f\3\f\3\f\3\f\5\f\u03b1\n\f\3\f\5\f")
        buf.write("\u03b4\n\f\3\r\3\r\5\r\u03b8\n\r\3\r\3\r\3\r\7\r\u03bd")
        buf.write("\n\r\f\r\16\r\u03c0\13\r\3\r\3\r\3\r\3\r\5\r\u03c6\n\r")
        buf.write("\3\r\5\r\u03c9\n\r\3\16\3\16\3\16\3\16\3\16\3\16\3\16")
        buf.write("\3\16\3\16\5\16\u03d4\n\16\3\16\5\16\u03d7\n\16\3\17\3")
        buf.write("\17\3\17\3\17\5\17\u03dd\n\17\3\17\3\17\5\17\u03e1\n\17")
        buf.write("\3\17\5\17\u03e4\n\17\3\17\3\17\3\17\3\17\5\17\u03ea\n")
        buf.write("\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\3\17\5\17\u03f4")
        buf.write("\n\17\3\20\3\20\3\20\3\20\3\20\3\20\5\20\u03fc\n\20\3")
        buf.write("\20\3\20\3\20\3\20\3\20\7\20\u0403\n\20\f\20\16\20\u0406")
        buf.write("\13\20\3\20\3\20\3\20\5\20\u040b\n\20\3\20\5\20\u040e")
        buf.write("\n\20\3\20\3\20\5\20\u0412\n\20\3\20\3\20\3\20\3\20\3")
        buf.write("\20\3\20\3\20\5\20\u041b\n\20\5\20\u041d\n\20\3\20\3\20")
        buf.write("\3\20\3\20\3\20\5\20\u0424\n\20\3\20\3\20\5\20\u0428\n")
        buf.write("\20\3\20\3\20\3\20\3\20\5\20\u042e\n\20\3\20\3\20\5\20")
        buf.write("\u0432\n\20\3\20\3\20\3\20\3\20\3\20\5\20\u0439\n\20\3")
        buf.write("\20\3\20\3\20\3\20\3\20\3\20\5\20\u0441\n\20\3\20\3\20")
        buf.write("\3\20\3\20\5\20\u0447\n\20\3\20\3\20\3\20\5\20\u044c\n")
        buf.write("\20\3\20\5\20\u044f\n\20\3\20\3\20\3\20\3\20\3\20\3\20")
        buf.write("\7\20\u0457\n\20\f\20\16\20\u045a\13\20\3\20\3\20\5\20")
        buf.write("\u045e\n\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3\20\3")
        buf.write("\20\7\20\u0469\n\20\f\20\16\20\u046c\13\20\3\20\3\20\3")
        buf.write("\20\3\20\3\20\3\20\5\20\u0474\n\20\3\21\3\21\5\21\u0478")
        buf.write("\n\21\3\21\5\21\u047b\n\21\3\21\3\21\3\21\3\21\7\21\u0481")
        buf.write("\n\21\f\21\16\21\u0484\13\21\3\21\3\21\5\21\u0488\n\21")
        buf.write("\3\21\3\21\3\22\3\22\3\22\3\22\3\22\3\22\5\22\u0492\n")
        buf.write("\22\5\22\u0494\n\22\3\23\3\23\3\23\3\23\3\23\3\23\7\23")
        buf.write("\u049c\n\23\f\23\16\23\u049f\13\23\3\23\3\23\5\23\u04a3")
        buf.write("\n\23\3\24\3\24\3\24\5\24\u04a8\n\24\3\24\5\24\u04ab\n")
        buf.write("\24\3\24\5\24\u04ae\n\24\3\24\5\24\u04b1\n\24\3\24\3\24")
        buf.write("\3\24\5\24\u04b6\n\24\3\24\3\24\3\24\3\25\3\25\3\25\3")
        buf.write("\25\5\25\u04bf\n\25\3\25\3\25\3\25\3\25\3\25\3\25\3\25")
        buf.write("\3\25\3\25\5\25\u04ca\n\25\3\26\3\26\5\26\u04ce\n\26\3")
        buf.write("\26\3\26\5\26\u04d2\n\26\3\27\3\27\3\27\5\27\u04d7\n\27")
        buf.write("\3\30\3\30\3\30\7\30\u04dc\n\30\f\30\16\30\u04df\13\30")
        buf.write("\3\31\3\31\3\31\3\31\3\31\7\31\u04e6\n\31\f\31\16\31\u04e9")
        buf.write("\13\31\3\31\3\31\5\31\u04ed\n\31\3\32\3\32\3\32\3\32\7")
        buf.write("\32\u04f3\n\32\f\32\16\32\u04f6\13\32\3\32\3\32\3\32\5")
        buf.write("\32\u04fb\n\32\3\32\5\32\u04fe\n\32\3\32\5\32\u0501\n")
        buf.write("\32\3\32\5\32\u0504\n\32\5\32\u0506\n\32\3\33\3\33\5\33")
        buf.write("\u050a\n\33\3\33\3\33\5\33\u050e\n\33\3\34\3\34\5\34\u0512")
        buf.write("\n\34\3\35\3\35\3\35\3\35\3\35\3\35\5\35\u051a\n\35\3")
        buf.write("\36\3\36\3\36\3\36\3\36\5\36\u0521\n\36\3\36\3\36\3\36")
        buf.write("\3\36\5\36\u0527\n\36\3\36\3\36\5\36\u052b\n\36\5\36\u052d")
        buf.write("\n\36\3\37\3\37\3\37\5\37\u0532\n\37\3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3")
        buf.write(" \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \3 \5 \u055c")
        buf.write("\n \3 \3 \3 \3 \3 \5 \u0563\n \3!\3!\3!\3!\3!\3!\3!\3")
        buf.write("!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3!\3")
        buf.write("!\3!\3!\3!\3!\3!\3!\3!\3!\3!\5!\u0588\n!\3\"\3\"\3\"\3")
        buf.write("\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\3\"\5\"\u0597\n\"\3")
        buf.write("#\3#\3#\3#\3#\3#\3#\5#\u05a0\n#\3#\3#\3#\3#\5#\u05a6\n")
        buf.write("#\3#\3#\3#\3#\3#\3#\5#\u05ae\n#\3$\3$\5$\u05b2\n$\3$\3")
        buf.write("$\3$\3$\3$\5$\u05b9\n$\3$\3$\5$\u05bd\n$\6$\u05bf\n$\r")
        buf.write("$\16$\u05c0\3$\5$\u05c4\n$\3$\3$\3$\5$\u05c9\n$\3$\3$")
        buf.write("\3$\3$\5$\u05cf\n$\3%\3%\3%\3%\5%\u05d5\n%\3&\3&\3&\3")
        buf.write("&\3\'\3\'\3\'\3\'\3\'\5\'\u05e0\n\'\5\'\u05e2\n\'\3\'")
        buf.write("\3\'\5\'\u05e6\n\'\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\5(\u0607\n(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\5(\u061a\n(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3")
        buf.write("(\3(\3(\3(\3(\3(\3(\3(\3(\3(\3(\5(\u0642\n(\3)\3)\3)\3")
        buf.write(")\3*\5*\u0649\n*\3*\3*\3*\3*\5*\u064f\n*\3+\5+\u0652\n")
        buf.write("+\3+\3+\5+\u0656\n+\3+\5+\u0659\n+\3+\3+\5+\u065d\n+\3")
        buf.write("+\3+\3+\7+\u0662\n+\f+\16+\u0665\13+\3+\3+\5+\u0669\n")
        buf.write("+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3+\3")
        buf.write("+\3+\3+\5+\u067f\n+\3,\3,\5,\u0683\n,\3,\5,\u0686\n,\3")
        buf.write(",\3,\3,\5,\u068b\n,\3,\5,\u068e\n,\3,\3,\5,\u0692\n,\3")
        buf.write(",\3,\5,\u0696\n,\3,\3,\3,\3,\3,\3,\3,\5,\u069f\n,\3,\3")
        buf.write(",\3,\3,\3,\3,\3,\5,\u06a8\n,\3,\3,\3,\3,\3,\3,\3,\3,\3")
        buf.write(",\3,\3,\3,\3,\3,\3,\3,\5,\u06ba\n,\3,\3,\3,\3,\3,\3,\3")
        buf.write(",\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3")
        buf.write(",\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\3,\5,\u06e3\n")
        buf.write(",\3,\3,\3,\3,\5,\u06e9\n,\3,\5,\u06ec\n,\5,\u06ee\n,\3")
        buf.write("-\3-\5-\u06f2\n-\3-\3-\3-\5-\u06f7\n-\3-\3-\5-\u06fb\n")
        buf.write("-\3-\3-\3-\3-\3-\3-\5-\u0703\n-\3-\3-\3-\3-\3-\5-\u070a")
        buf.write("\n-\3-\3-\3-\5-\u070f\n-\3-\3-\3-\3-\3-\3-\3-\3-\3-\3")
        buf.write("-\6-\u071b\n-\r-\16-\u071c\5-\u071f\n-\3.\3.\3.\3.\5.")
        buf.write("\u0725\n.\3.\3.\3.\3.\6.\u072b\n.\r.\16.\u072c\3.\3.\5")
        buf.write(".\u0731\n.\3/\3/\3/\3/\3/\5/\u0738\n/\3/\3/\3/\3/\5/\u073e")
        buf.write("\n/\3/\5/\u0741\n/\5/\u0743\n/\3\60\3\60\3\61\3\61\3\61")
        buf.write("\3\61\3\62\3\62\3\62\5\62\u074e\n\62\3\62\3\62\5\62\u0752")
        buf.write("\n\62\3\63\5\63\u0755\n\63\3\63\3\63\3\64\3\64\3\64\3")
        buf.write("\65\3\65\3\65\5\65\u075f\n\65\3\65\3\65\3\65\3\65\3\65")
        buf.write("\3\65\3\65\7\65\u0768\n\65\f\65\16\65\u076b\13\65\3\65")
        buf.write("\3\65\3\65\3\65\3\65\5\65\u0772\n\65\3\65\3\65\5\65\u0776")
        buf.write("\n\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65\3\65")
        buf.write("\3\65\3\65\3\65\3\65\5\65\u0786\n\65\3\65\3\65\3\65\3")
        buf.write("\65\3\65\5\65\u078d\n\65\3\65\3\65\3\65\3\65\3\65\5\65")
        buf.write("\u0794\n\65\3\66\3\66\3\66\5\66\u0799\n\66\3\67\3\67\5")
        buf.write("\67\u079d\n\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67\3\67")
        buf.write("\3\67\3\67\3\67\5\67\u07aa\n\67\3\67\3\67\5\67\u07ae\n")
        buf.write("\67\38\38\38\38\38\58\u07b5\n8\38\38\38\38\38\38\58\u07bd")
        buf.write("\n8\38\38\58\u07c1\n8\38\38\38\38\38\38\38\38\38\58\u07cc")
        buf.write("\n8\39\39\39\39\39\59\u07d3\n9\39\39\39\59\u07d8\n9\3")
        buf.write("9\39\3:\3:\3:\5:\u07df\n:\5:\u07e1\n:\3:\3:\3:\7:\u07e6")
        buf.write("\n:\f:\16:\u07e9\13:\3:\3:\3:\3:\3:\3:\7:\u07f1\n:\f:")
        buf.write("\16:\u07f4\13:\3:\3:\5:\u07f8\n:\5:\u07fa\n:\3:\3:\3:")
        buf.write("\3:\3:\5:\u0801\n:\5:\u0803\n:\3:\3:\3:\3:\3:\3:\5:\u080b")
        buf.write("\n:\5:\u080d\n:\3:\3:\3:\3:\3:\5:\u0814\n:\5:\u0816\n")
        buf.write(":\3:\3:\5:\u081a\n:\3:\3:\5:\u081e\n:\3;\3;\3;\3;\3<\3")
        buf.write("<\5<\u0826\n<\3<\3<\3<\3<\5<\u082c\n<\3<\5<\u082f\n<\7")
        buf.write("<\u0831\n<\f<\16<\u0834\13<\3<\3<\5<\u0838\n<\3=\3=\5")
        buf.write("=\u083c\n=\3=\3=\3=\3>\3>\5>\u0843\n>\3>\3>\3>\3>\3>\5")
        buf.write(">\u084a\n>\3>\3>\3>\3>\3>\5>\u0851\n>\3>\3>\3>\3>\3>\3")
        buf.write(">\3>\3>\3>\3>\5>\u085d\n>\3?\3?\3?\5?\u0862\n?\3?\3?\3")
        buf.write("?\3?\3?\3?\3?\3?\3?\3?\3?\3?\5?\u0870\n?\3?\3?\5?\u0874")
        buf.write("\n?\3@\3@\3@\3@\5@\u087a\n@\3@\3@\3@\3@\3@\5@\u0881\n")
        buf.write("@\3@\3@\3@\3@\3@\3@\3@\7@\u088a\n@\f@\16@\u088d\13@\5")
        buf.write("@\u088f\n@\3A\3A\5A\u0893\nA\3A\3A\3A\3A\3A\5A\u089a\n")
        buf.write("A\3A\3A\3A\3A\3A\3A\5A\u08a2\nA\3A\3A\3A\3A\3A\3A\5A\u08aa")
        buf.write("\nA\3A\3A\3A\3A\3A\3A\3A\3A\3A\3A\3A\3A\3A\3A\3A\5A\u08bb")
        buf.write("\nA\3B\3B\3B\3B\3B\3C\3C\3C\5C\u08c5\nC\3C\3C\5C\u08c9")
        buf.write("\nC\3D\3D\3D\3D\3D\3D\3D\5D\u08d2\nD\3D\3D\3D\5D\u08d7")
        buf.write("\nD\3D\3D\3D\3D\3D\3D\5D\u08df\nD\3D\3D\3D\3D\3D\3D\3")
        buf.write("D\3D\3D\7D\u08ea\nD\fD\16D\u08ed\13D\3D\3D\3D\3D\3D\7")
        buf.write("D\u08f4\nD\fD\16D\u08f7\13D\3D\3D\5D\u08fb\nD\3E\3E\3")
        buf.write("E\3E\3E\3E\3E\3E\3E\3E\3E\5E\u0908\nE\3E\3E\3E\3E\3E\3")
        buf.write("E\3E\3E\3E\3E\5E\u0914\nE\3F\3F\3F\3F\3G\3G\5G\u091c\n")
        buf.write("G\3G\3G\3G\3G\3G\5G\u0923\nG\3H\3H\3H\3H\3H\3H\5H\u092b")
        buf.write("\nH\3H\3H\3H\3H\3H\3H\3H\3H\5H\u0935\nH\3I\3I\3I\3I\3")
        buf.write("I\3I\3I\3I\7I\u093f\nI\fI\16I\u0942\13I\3I\3I\3I\3I\5")
        buf.write("I\u0948\nI\3I\3I\3I\3I\3I\3I\3I\3I\3I\5I\u0953\nI\3I\3")
        buf.write("I\5I\u0957\nI\3J\3J\3J\3J\3J\5J\u095e\nJ\3J\5J\u0961\n")
        buf.write("J\3J\3J\3J\5J\u0966\nJ\3J\3J\5J\u096a\nJ\3J\3J\3J\3J\3")
        buf.write("J\5J\u0971\nJ\3J\3J\3J\5J\u0976\nJ\3J\5J\u0979\nJ\5J\u097b")
        buf.write("\nJ\3K\3K\3K\3K\3K\3K\5K\u0983\nK\3L\3L\3L\3L\3M\3M\3")
        buf.write("M\3N\5N\u098d\nN\3N\3N\5N\u0991\nN\3N\5N\u0994\nN\3N\5")
        buf.write("N\u0997\nN\3N\3N\5N\u099b\nN\3N\3N\3N\3O\3O\5O\u09a2\n")
        buf.write("O\3O\3O\5O\u09a6\nO\3O\5O\u09a9\nO\3O\5O\u09ac\nO\3O\5")
        buf.write("O\u09af\nO\3P\3P\3P\3P\7P\u09b5\nP\fP\16P\u09b8\13P\3")
        buf.write("P\3P\3Q\3Q\5Q\u09be\nQ\3Q\3Q\3Q\3Q\7Q\u09c4\nQ\fQ\16Q")
        buf.write("\u09c7\13Q\3Q\3Q\5Q\u09cb\nQ\3Q\5Q\u09ce\nQ\3Q\5Q\u09d1")
        buf.write("\nQ\3R\3R\3R\3R\3R\7R\u09d8\nR\fR\16R\u09db\13R\3R\3R")
        buf.write("\3S\3S\3S\3T\3T\5T\u09e4\nT\3T\3T\5T\u09e8\nT\3T\3T\5")
        buf.write("T\u09ec\nT\3T\3T\3T\5T\u09f1\nT\5T\u09f3\nT\3T\3T\3T\5")
        buf.write("T\u09f8\nT\5T\u09fa\nT\3T\5T\u09fd\nT\3U\3U\5U\u0a01\n")
        buf.write("U\3U\5U\u0a04\nU\3U\5U\u0a07\nU\3U\3U\3U\3U\3U\3U\5U\u0a0f")
        buf.write("\nU\3U\3U\5U\u0a13\nU\5U\u0a15\nU\3V\3V\3V\3V\3V\3V\3")
        buf.write("V\3V\3V\3V\3V\3V\7V\u0a23\nV\fV\16V\u0a26\13V\3V\3V\5")
        buf.write("V\u0a2a\nV\6V\u0a2c\nV\rV\16V\u0a2d\5V\u0a30\nV\3V\3V")
        buf.write("\3V\3V\3W\3W\3W\3W\3W\3W\3W\7W\u0a3d\nW\fW\16W\u0a40\13")
        buf.write("W\5W\u0a42\nW\3W\3W\3W\3W\3W\3W\7W\u0a4a\nW\fW\16W\u0a4d")
        buf.write("\13W\5W\u0a4f\nW\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\5W\u0a63\nW\3W\3W\3W\3W\3W\3W\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\5W\u0a75\nW\7W\u0a77\nW\fW\16W")
        buf.write("\u0a7a\13W\3W\5W\u0a7d\nW\3W\3W\3W\3W\3W\5W\u0a84\nW\3")
        buf.write("W\5W\u0a87\nW\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u0aa4\nW\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3W\3")
        buf.write("W\3W\3W\3W\3W\3W\3W\3W\3W\3W\5W\u0ac2\nW\7W\u0ac4\nW\f")
        buf.write("W\16W\u0ac7\13W\3W\3W\5W\u0acb\nW\3X\3X\3X\5X\u0ad0\n")
        buf.write("X\3X\3X\3X\3X\3X\7X\u0ad7\nX\fX\16X\u0ada\13X\3Y\3Y\5")
        buf.write("Y\u0ade\nY\3Y\3Y\3Y\5Y\u0ae3\nY\3Y\3Y\5Y\u0ae7\nY\3Y\3")
        buf.write("Y\3Y\3Y\3Y\5Y\u0aee\nY\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\3Z\7")
        buf.write("Z\u0afa\nZ\fZ\16Z\u0afd\13Z\3Z\3Z\3[\3[\3[\3[\3\\\3\\")
        buf.write("\3\\\3\\\3\\\3\\\3\\\3\\\3\\\3\\\3\\\5\\\u0b10\n\\\3\\")
        buf.write("\3\\\3]\3]\3]\3]\3]\3]\3]\3]\3]\3]\5]\u0b1e\n]\3]\3]\3")
        buf.write("]\3]\3]\3]\3]\5]\u0b27\n]\3]\3]\3^\3^\3^\3^\3^\3^\3^\3")
        buf.write("^\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\3^\5^\u0b41\n")
        buf.write("^\3^\3^\3^\3^\3^\3^\3^\5^\u0b4a\n^\3^\3^\3_\3_\5_\u0b50")
        buf.write("\n_\3_\3_\3_\3_\3_\3_\3_\7_\u0b59\n_\f_\16_\u0b5c\13_")
        buf.write("\5_\u0b5e\n_\3_\5_\u0b61\n_\3`\3`\3`\3`\3`\3`\3`\5`\u0b6a")
        buf.write("\n`\3a\3a\3a\3a\5a\u0b70\na\3a\3a\3a\5a\u0b75\na\3b\3")
        buf.write("b\3b\5b\u0b7a\nb\3b\3b\3b\5b\u0b7f\nb\3b\3b\3b\5b\u0b84")
        buf.write("\nb\3c\3c\3c\3c\3c\5c\u0b8b\nc\3c\3c\3c\5c\u0b90\nc\3")
        buf.write("d\3d\3d\3d\3d\3d\3d\5d\u0b99\nd\3d\6d\u0b9c\nd\rd\16d")
        buf.write("\u0b9d\5d\u0ba0\nd\3e\3e\5e\u0ba4\ne\3e\3e\3e\5e\u0ba9")
        buf.write("\ne\3e\3e\3f\3f\3f\3f\5f\u0bb1\nf\3f\3f\3f\3f\3f\3f\3")
        buf.write("f\3f\5f\u0bbb\nf\3f\3f\3f\3f\3f\3f\3f\3f\5f\u0bc5\nf\3")
        buf.write("f\3f\3f\5f\u0bca\nf\3g\3g\3g\3h\3h\3h\3h\3h\3h\3h\3h\5")
        buf.write("h\u0bd7\nh\3i\3i\3i\3i\3j\3j\3j\3j\3j\3j\3j\3j\3j\3j\3")
        buf.write("j\3j\3j\3j\3j\3j\3j\3j\3j\3j\5j\u0bf1\nj\3j\5j\u0bf4\n")
        buf.write("j\3j\5j\u0bf7\nj\3j\5j\u0bfa\nj\3j\3j\3k\3k\3k\3k\3k\3")
        buf.write("k\3k\7k\u0c05\nk\fk\16k\u0c08\13k\3k\3k\3k\3k\3k\3k\3")
        buf.write("k\5k\u0c11\nk\3l\3l\3l\3l\3l\3l\5l\u0c19\nl\3m\3m\3m\3")
        buf.write("m\3n\3n\3n\3n\3n\3n\3o\3o\3o\3o\5o\u0c29\no\3o\3o\3o\3")
        buf.write("o\5o\u0c2f\no\3o\5o\u0c32\no\3o\3o\5o\u0c36\no\3p\3p\3")
        buf.write("p\3p\3q\3q\3q\3q\3q\3q\7q\u0c42\nq\fq\16q\u0c45\13q\3")
        buf.write("q\3q\5q\u0c49\nq\3r\3r\3r\3r\3s\3s\3s\5s\u0c52\ns\3s\3")
        buf.write("s\3s\5s\u0c57\ns\3s\3s\3s\3t\3t\3t\3t\3t\7t\u0c61\nt\f")
        buf.write("t\16t\u0c64\13t\3t\5t\u0c67\nt\3u\3u\5u\u0c6b\nu\3u\3")
        buf.write("u\3u\7u\u0c70\nu\fu\16u\u0c73\13u\3u\5u\u0c76\nu\3v\3")
        buf.write("v\3v\3v\5v\u0c7c\nv\3v\3v\3v\5v\u0c81\nv\3v\3v\3w\3w\5")
        buf.write("w\u0c87\nw\3w\3w\3w\3w\3w\3w\5w\u0c8f\nw\3w\5w\u0c92\n")
        buf.write("w\3x\3x\5x\u0c96\nx\3x\3x\3x\3x\3x\3x\3x\3x\3x\3x\3x\3")
        buf.write("x\3x\3x\3x\3x\3x\3x\3x\3y\3y\3y\3y\3y\3y\3y\3y\3z\3z\3")
        buf.write("z\5z\u0cb6\nz\3z\3z\7z\u0cba\nz\fz\16z\u0cbd\13z\5z\u0cbf")
        buf.write("\nz\3{\3{\3{\5{\u0cc4\n{\3|\3|\5|\u0cc8\n|\3}\3}\3}\3")
        buf.write("}\3}\3}\3}\3}\3}\3}\3}\5}\u0cd5\n}\3}\3}\3}\5}\u0cda\n")
        buf.write("}\3}\3}\3}\5}\u0cdf\n}\3~\3~\3~\3~\3~\3~\3~\5~\u0ce8\n")
        buf.write("~\3\177\3\177\3\177\3\177\3\177\3\177\3\177\3\177\3\177")
        buf.write("\5\177\u0cf3\n\177\3\177\5\177\u0cf6\n\177\3\u0080\3\u0080")
        buf.write("\3\u0080\5\u0080\u0cfb\n\u0080\3\u0080\6\u0080\u0cfe\n")
        buf.write("\u0080\r\u0080\16\u0080\u0cff\5\u0080\u0d02\n\u0080\3")
        buf.write("\u0081\3\u0081\5\u0081\u0d06\n\u0081\3\u0082\3\u0082\3")
        buf.write("\u0082\3\u0082\5\u0082\u0d0c\n\u0082\3\u0082\3\u0082\3")
        buf.write("\u0082\3\u0082\3\u0082\3\u0082\3\u0082\7\u0082\u0d15\n")
        buf.write("\u0082\f\u0082\16\u0082\u0d18\13\u0082\3\u0082\3\u0082")
        buf.write("\5\u0082\u0d1c\n\u0082\3\u0083\3\u0083\5\u0083\u0d20\n")
        buf.write("\u0083\3\u0083\3\u0083\3\u0083\3\u0083\3\u0083\5\u0083")
        buf.write("\u0d27\n\u0083\3\u0083\3\u0083\3\u0083\3\u0083\3\u0083")
        buf.write("\3\u0083\3\u0083\3\u0084\3\u0084\3\u0084\3\u0084\3\u0084")
        buf.write("\3\u0084\3\u0084\3\u0084\5\u0084\u0d38\n\u0084\3\u0084")
        buf.write("\3\u0084\3\u0084\3\u0084\5\u0084\u0d3e\n\u0084\3\u0084")
        buf.write("\3\u0084\3\u0084\3\u0084\3\u0084\7\u0084\u0d45\n\u0084")
        buf.write("\f\u0084\16\u0084\u0d48\13\u0084\3\u0084\3\u0084\5\u0084")
        buf.write("\u0d4c\n\u0084\3\u0085\3\u0085\3\u0085\3\u0086\3\u0086")
        buf.write("\3\u0086\3\u0086\3\u0086\3\u0086\7\u0086\u0d57\n\u0086")
        buf.write("\f\u0086\16\u0086\u0d5a\13\u0086\3\u0086\3\u0086\3\u0087")
        buf.write("\3\u0087\3\u0087\5\u0087\u0d61\n\u0087\3\u0087\3\u0087")
        buf.write("\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088")
        buf.write("\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088\3\u0088")
        buf.write("\3\u0088\3\u0088\3\u0088\5\u0088\u0d76\n\u0088\3\u0089")
        buf.write("\3\u0089\5\u0089\u0d7a\n\u0089\3\u0089\3\u0089\3\u0089")
        buf.write("\5\u0089\u0d7f\n\u0089\3\u0089\3\u0089\3\u0089\3\u0089")
        buf.write("\3\u0089\3\u0089\5\u0089\u0d87\n\u0089\3\u0089\3\u0089")
        buf.write("\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089\3\u0089")
        buf.write("\7\u0089\u0d92\n\u0089\f\u0089\16\u0089\u0d95\13\u0089")
        buf.write("\3\u0089\3\u0089\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a\3\u008a")
        buf.write("\3\u008a\3\u008a\3\u008a\3\u008a\5\u008a\u0dcc\n\u008a")
        buf.write("\3\u008b\3\u008b\3\u008b\3\u008c\3\u008c\3\u008c\5\u008c")
        buf.write("\u0dd4\n\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\7\u008c\u0ddb\n\u008c\f\u008c\16\u008c\u0dde\13\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c\3\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\7\u008c\u0dea\n\u008c\f\u008c")
        buf.write("\16\u008c\u0ded\13\u008c\3\u008c\5\u008c\u0df0\n\u008c")
        buf.write("\3\u008c\3\u008c\3\u008c\3\u008c\5\u008c\u0df6\n\u008c")
        buf.write("\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d\5\u008d\u0dfd")
        buf.write("\n\u008d\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d")
        buf.write("\5\u008d\u0e05\n\u008d\3\u008d\3\u008d\3\u008d\5\u008d")
        buf.write("\u0e0a\n\u008d\3\u008d\3\u008d\3\u008d\3\u008d\3\u008d")
        buf.write("\3\u008d\3\u008d\5\u008d\u0e13\n\u008d\5\u008d\u0e15\n")
        buf.write("\u008d\3\u008e\3\u008e\3\u008e\7\u008e\u0e1a\n\u008e\f")
        buf.write("\u008e\16\u008e\u0e1d\13\u008e\3\u008e\5\u008e\u0e20\n")
        buf.write("\u008e\3\u008f\3\u008f\5\u008f\u0e24\n\u008f\3\u008f\3")
        buf.write("\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f")
        buf.write("\3\u008f\5\u008f\u0e2f\n\u008f\3\u008f\3\u008f\5\u008f")
        buf.write("\u0e33\n\u008f\3\u008f\3\u008f\3\u008f\3\u008f\3\u008f")
        buf.write("\3\u008f\7\u008f\u0e3b\n\u008f\f\u008f\16\u008f\u0e3e")
        buf.write("\13\u008f\3\u008f\3\u008f\5\u008f\u0e42\n\u008f\3\u008f")
        buf.write("\3\u008f\5\u008f\u0e46\n\u008f\3\u0090\3\u0090\3\u0090")
        buf.write("\3\u0090\3\u0090\5\u0090\u0e4d\n\u0090\3\u0091\5\u0091")
        buf.write("\u0e50\n\u0091\3\u0091\3\u0091\3\u0091\3\u0091\3\u0091")
        buf.write("\3\u0091\5\u0091\u0e58\n\u0091\3\u0091\3\u0091\3\u0091")
        buf.write("\5\u0091\u0e5d\n\u0091\3\u0091\3\u0091\3\u0091\5\u0091")
        buf.write("\u0e62\n\u0091\5\u0091\u0e64\n\u0091\3\u0091\5\u0091\u0e67")
        buf.write("\n\u0091\6\u0091\u0e69\n\u0091\r\u0091\16\u0091\u0e6a")
        buf.write("\3\u0091\3\u0091\3\u0091\3\u0091\5\u0091\u0e71\n\u0091")
        buf.write("\3\u0091\5\u0091\u0e74\n\u0091\3\u0091\5\u0091\u0e77\n")
        buf.write("\u0091\3\u0091\3\u0091\3\u0091\5\u0091\u0e7c\n\u0091\5")
        buf.write("\u0091\u0e7e\n\u0091\3\u0091\3\u0091\5\u0091\u0e82\n\u0091")
        buf.write("\3\u0091\5\u0091\u0e85\n\u0091\3\u0091\5\u0091\u0e88\n")
        buf.write("\u0091\3\u0091\3\u0091\3\u0091\3\u0091\3\u0092\3\u0092")
        buf.write("\3\u0092\5\u0092\u0e91\n\u0092\3\u0092\3\u0092\3\u0093")
        buf.write("\3\u0093\3\u0093\3\u0093\3\u0093\3\u0094\3\u0094\3\u0094")
        buf.write("\5\u0094\u0e9d\n\u0094\5\u0094\u0e9f\n\u0094\3\u0094\3")
        buf.write("\u0094\5\u0094\u0ea3\n\u0094\3\u0094\3\u0094\3\u0094\3")
        buf.write("\u0094\3\u0094\3\u0094\3\u0094\3\u0094\5\u0094\u0ead\n")
        buf.write("\u0094\3\u0094\5\u0094\u0eb0\n\u0094\3\u0095\5\u0095\u0eb3")
        buf.write("\n\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\7\u0095\u0ec7")
        buf.write("\n\u0095\f\u0095\16\u0095\u0eca\13\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0095\3\u0095\7\u0095\u0ed1\n\u0095\f\u0095")
        buf.write("\16\u0095\u0ed4\13\u0095\3\u0095\3\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095\3\u0095")
        buf.write("\3\u0095\3\u0095\5\u0095\u0ee3\n\u0095\3\u0096\3\u0096")
        buf.write("\3\u0096\7\u0096\u0ee8\n\u0096\f\u0096\16\u0096\u0eeb")
        buf.write("\13\u0096\3\u0097\3\u0097\3\u0097\3\u0097\3\u0097\3\u0098")
        buf.write("\3\u0098\3\u0098\7\u0098\u0ef5\n\u0098\f\u0098\16\u0098")
        buf.write("\u0ef8\13\u0098\3\u0099\3\u0099\5\u0099\u0efc\n\u0099")
        buf.write("\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099")
        buf.write("\3\u0099\3\u0099\3\u0099\3\u0099\3\u0099\5\u0099\u0f0a")
        buf.write("\n\u0099\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a\3\u009a")
        buf.write("\3\u009a\5\u009a\u0f13\n\u009a\3\u009a\3\u009a\3\u009a")
        buf.write("\3\u009a\5\u009a\u0f19\n\u009a\3\u009a\3\u009a\3\u009a")
        buf.write("\3\u009a\5\u009a\u0f1f\n\u009a\5\u009a\u0f21\n\u009a\3")
        buf.write("\u009b\3\u009b\3\u009b\3\u009b\3\u009b\5\u009b\u0f28\n")
        buf.write("\u009b\3\u009c\3\u009c\3\u009c\5\u009c\u0f2d\n\u009c\3")
        buf.write("\u009d\3\u009d\3\u009d\7\u009d\u0f32\n\u009d\f\u009d\16")
        buf.write("\u009d\u0f35\13\u009d\3\u009e\5\u009e\u0f38\n\u009e\3")
        buf.write("\u009e\3\u009e\3\u009f\3\u009f\3\u009f\3\u009f\3\u009f")
        buf.write("\3\u009f\5\u009f\u0f42\n\u009f\3\u00a0\3\u00a0\3\u00a0")
        buf.write("\3\u00a0\3\u00a0\5\u00a0\u0f49\n\u00a0\5\u00a0\u0f4b\n")
        buf.write("\u00a0\3\u00a0\3\u00a0\3\u00a0\3\u00a0\3\u00a0\5\u00a0")
        buf.write("\u0f52\n\u00a0\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\5\u00a1\u0f6a\n\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\5\u00a1\u0f7e\n\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\5\u00a1\u0f88\n\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\5\u00a1\u0f9a")
        buf.write("\n\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1\3\u00a1")
        buf.write("\3\u00a1\3\u00a1\3\u00a1\3\u00a1\5\u00a1\u0fd0\n\u00a1")
        buf.write("\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\5\u00a2\u0fe0\n\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\3\u00a2\3\u00a2\5\u00a2\u0fe8\n\u00a2\3\u00a2\3\u00a2")
        buf.write("\3\u00a2\5\u00a2\u0fed\n\u00a2\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2")
        buf.write("\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\3\u00a2\5\u00a2")
        buf.write("\u0fff\n\u00a2\3\u00a3\3\u00a3\5\u00a3\u1003\n\u00a3\3")
        buf.write("\u00a3\3\u00a3\3\u00a3\3\u00a3\3\u00a3\5\u00a3\u100a\n")
        buf.write("\u00a3\5\u00a3\u100c\n\u00a3\3\u00a3\3\u00a3\3\u00a4\6")
        buf.write("\u00a4\u1011\n\u00a4\r\u00a4\16\u00a4\u1012\3\u00a4\5")
        buf.write("\u00a4\u1016\n\u00a4\3\u00a5\3\u00a5\3\u00a5\3\u00a5\3")
        buf.write("\u00a6\3\u00a6\3\u00a6\3\u00a6\3\u00a6\7\u00a6\u1021\n")
        buf.write("\u00a6\f\u00a6\16\u00a6\u1024\13\u00a6\3\u00a6\3\u00a6")
        buf.write("\3\u00a7\3\u00a7\3\u00a7\3\u00a8\3\u00a8\3\u00a8\3\u00a9")
        buf.write("\3\u00a9\3\u00a9\3\u00a9\7\u00a9\u1032\n\u00a9\f\u00a9")
        buf.write("\16\u00a9\u1035\13\u00a9\5\u00a9\u1037\n\u00a9\3\u00a9")
        buf.write("\5\u00a9\u103a\n\u00a9\3\u00a9\5\u00a9\u103d\n\u00a9\3")
        buf.write("\u00a9\3\u00a9\3\u00aa\3\u00aa\3\u00aa\3\u00aa\3\u00aa")
        buf.write("\7\u00aa\u1046\n\u00aa\f\u00aa\16\u00aa\u1049\13\u00aa")
        buf.write("\3\u00ab\3\u00ab\7\u00ab\u104d\n\u00ab\f\u00ab\16\u00ab")
        buf.write("\u1050\13\u00ab\3\u00ab\3\u00ab\5\u00ab\u1054\n\u00ab")
        buf.write("\3\u00ac\5\u00ac\u1057\n\u00ac\3\u00ac\5\u00ac\u105a\n")
        buf.write("\u00ac\3\u00ac\3\u00ac\3\u00ac\5\u00ac\u105f\n\u00ac\3")
        buf.write("\u00ad\3\u00ad\3\u00ae\5\u00ae\u1064\n\u00ae\3\u00ae\3")
        buf.write("\u00ae\5\u00ae\u1068\n\u00ae\3\u00ae\3\u00ae\7\u00ae\u106c")
        buf.write("\n\u00ae\f\u00ae\16\u00ae\u106f\13\u00ae\3\u00af\3\u00af")
        buf.write("\3\u00af\3\u00af\3\u00af\3\u00af\3\u00af\5\u00af\u1078")
        buf.write("\n\u00af\3\u00af\3\u00af\3\u00af\3\u00af\3\u00af\5\u00af")
        buf.write("\u107f\n\u00af\3\u00af\3\u00af\3\u00af\3\u00af\5\u00af")
        buf.write("\u1085\n\u00af\3\u00af\3\u00af\5\u00af\u1089\n\u00af\3")
        buf.write("\u00af\3\u00af\3\u00af\3\u00af\5\u00af\u108f\n\u00af\3")
        buf.write("\u00af\3\u00af\3\u00af\3\u00af\5\u00af\u1095\n\u00af\3")
        buf.write("\u00b0\5\u00b0\u1098\n\u00b0\3\u00b0\3\u00b0\3\u00b1\5")
        buf.write("\u00b1\u109d\n\u00b1\3\u00b1\3\u00b1\3\u00b2\3\u00b2\3")
        buf.write("\u00b3\3\u00b3\5\u00b3\u10a5\n\u00b3\3\u00b3\5\u00b3\u10a8")
        buf.write("\n\u00b3\3\u00b3\3\u00b3\5\u00b3\u10ac\n\u00b3\3\u00b4")
        buf.write("\3\u00b4\3\u00b4\3\u00b4\3\u00b4\3\u00b4\5\u00b4\u10b4")
        buf.write("\n\u00b4\3\u00b4\3\u00b4\5\u00b4\u10b8\n\u00b4\3\u00b4")
        buf.write("\3\u00b4\3\u00b4\3\u00b4\7\u00b4\u10be\n\u00b4\f\u00b4")
        buf.write("\16\u00b4\u10c1\13\u00b4\5\u00b4\u10c3\n\u00b4\3\u00b4")
        buf.write("\3\u00b4\5\u00b4\u10c7\n\u00b4\3\u00b4\3\u00b4\3\u00b4")
        buf.write("\5\u00b4\u10cc\n\u00b4\3\u00b5\3\u00b5\3\u00b5\3\u00b5")
        buf.write("\3\u00b5\3\u00b5\3\u00b5\3\u00b5\3\u00b5\3\u00b5\3\u00b5")
        buf.write("\3\u00b5\3\u00b5\3\u00b5\7\u00b5\u10dc\n\u00b5\f\u00b5")
        buf.write("\16\u00b5\u10df\13\u00b5\5\u00b5\u10e1\n\u00b5\3\u00b5")
        buf.write("\3\u00b5\5\u00b5\u10e5\n\u00b5\3\u00b5\3\u00b5\3\u00b5")
        buf.write("\5\u00b5\u10ea\n\u00b5\5\u00b5\u10ec\n\u00b5\3\u00b6\3")
        buf.write("\u00b6\5\u00b6\u10f0\n\u00b6\3\u00b6\3\u00b6\3\u00b6\3")
        buf.write("\u00b6\5\u00b6\u10f6\n\u00b6\3\u00b7\3\u00b7\3\u00b7\3")
        buf.write("\u00b7\3\u00b7\3\u00b7\3\u00b7\5\u00b7\u10ff\n\u00b7\3")
        buf.write("\u00b8\3\u00b8\3\u00b8\3\u00b8\3\u00b9\3\u00b9\3\u00b9")
        buf.write("\3\u00b9\3\u00b9\3\u00b9\5\u00b9\u110b\n\u00b9\3\u00b9")
        buf.write("\3\u00b9\3\u00b9\5\u00b9\u1110\n\u00b9\3\u00b9\3\u00b9")
        buf.write("\3\u00b9\3\u00b9\3\u00b9\3\u00b9\5\u00b9\u1118\n\u00b9")
        buf.write("\3\u00ba\3\u00ba\3\u00ba\3\u00ba\3\u00ba\3\u00ba\3\u00ba")
        buf.write("\3\u00ba\3\u00ba\3\u00ba\3\u00ba\3\u00ba\3\u00ba\3\u00ba")
        buf.write("\3\u00ba\5\u00ba\u1129\n\u00ba\3\u00ba\3\u00ba\3\u00ba")
        buf.write("\3\u00ba\5\u00ba\u112f\n\u00ba\3\u00bb\3\u00bb\5\u00bb")
        buf.write("\u1133\n\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb\3\u00bb")
        buf.write("\3\u00bb\5\u00bb\u113b\n\u00bb\3\u00bc\3\u00bc\3\u00bc")
        buf.write("\3\u00bc\3\u00bc\3\u00bc\3\u00bd\3\u00bd\3\u00bd\3\u00bd")
        buf.write("\3\u00bd\3\u00bd\3\u00bd\3\u00be\3\u00be\3\u00be\3\u00be")
        buf.write("\3\u00be\3\u00be\3\u00be\7\u00be\u1151\n\u00be\f\u00be")
        buf.write("\16\u00be\u1154\13\u00be\3\u00be\3\u00be\3\u00be\3\u00be")
        buf.write("\7\u00be\u115a\n\u00be\f\u00be\16\u00be\u115d\13\u00be")
        buf.write("\5\u00be\u115f\n\u00be\3\u00bf\3\u00bf\3\u00bf\3\u00bf")
        buf.write("\3\u00bf\3\u00bf\3\u00bf\3\u00bf\3\u00bf\5\u00bf\u116a")
        buf.write("\n\u00bf\3\u00bf\3\u00bf\3\u00bf\3\u00bf\3\u00bf\5\u00bf")
        buf.write("\u1171\n\u00bf\3\u00bf\3\u00bf\3\u00bf\5\u00bf\u1176\n")
        buf.write("\u00bf\5\u00bf\u1178\n\u00bf\3\u00bf\5\u00bf\u117b\n\u00bf")
        buf.write("\3\u00bf\3\u00bf\5\u00bf\u117f\n\u00bf\3\u00c0\3\u00c0")
        buf.write("\3\u00c0\3\u00c0\3\u00c0\5\u00c0\u1186\n\u00c0\3\u00c0")
        buf.write("\3\u00c0\3\u00c0\5\u00c0\u118b\n\u00c0\5\u00c0\u118d\n")
        buf.write("\u00c0\3\u00c0\3\u00c0\3\u00c1\3\u00c1\3\u00c1\5\u00c1")
        buf.write("\u1194\n\u00c1\3\u00c1\3\u00c1\3\u00c1\3\u00c1\5\u00c1")
        buf.write("\u119a\n\u00c1\3\u00c2\3\u00c2\3\u00c2\3\u00c2\5\u00c2")
        buf.write("\u11a0\n\u00c2\3\u00c2\3\u00c2\3\u00c2\3\u00c2\3\u00c2")
        buf.write("\3\u00c2\3\u00c2\5\u00c2\u11a9\n\u00c2\3\u00c2\3\u00c2")
        buf.write("\3\u00c2\3\u00c2\7\u00c2\u11af\n\u00c2\f\u00c2\16\u00c2")
        buf.write("\u11b2\13\u00c2\3\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c3")
        buf.write("\3\u00c3\5\u00c3\u11ba\n\u00c3\3\u00c3\3\u00c3\3\u00c3")
        buf.write("\5\u00c3\u11bf\n\u00c3\3\u00c3\5\u00c3\u11c2\n\u00c3\3")
        buf.write("\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c3\5\u00c3")
        buf.write("\u11ca\n\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c3")
        buf.write("\5\u00c3\u11d1\n\u00c3\3\u00c3\3\u00c3\3\u00c3\5\u00c3")
        buf.write("\u11d6\n\u00c3\5\u00c3\u11d8\n\u00c3\3\u00c3\5\u00c3\u11db")
        buf.write("\n\u00c3\3\u00c3\3\u00c3\3\u00c3\3\u00c3\5\u00c3\u11e1")
        buf.write("\n\u00c3\3\u00c4\3\u00c4\3\u00c4\3\u00c4\3\u00c4\3\u00c4")
        buf.write("\3\u00c4\3\u00c4\5\u00c4\u11eb\n\u00c4\3\u00c5\3\u00c5")
        buf.write("\3\u00c5\5\u00c5\u11f0\n\u00c5\3\u00c5\3\u00c5\3\u00c5")
        buf.write("\3\u00c5\5\u00c5\u11f6\n\u00c5\3\u00c6\5\u00c6\u11f9\n")
        buf.write("\u00c6\3\u00c6\3\u00c6\3\u00c6\3\u00c6\3\u00c6\3\u00c6")
        buf.write("\3\u00c6\3\u00c6\3\u00c6\3\u00c7\3\u00c7\3\u00c7\3\u00c7")
        buf.write("\3\u00c7\5\u00c7\u1209\n\u00c7\3\u00c8\3\u00c8\3\u00c8")
        buf.write("\3\u00c8\3\u00c8\3\u00c8\3\u00c8\7\u00c8\u1212\n\u00c8")
        buf.write("\f\u00c8\16\u00c8\u1215\13\u00c8\3\u00c8\3\u00c8\3\u00c8")
        buf.write("\5\u00c8\u121a\n\u00c8\3\u00c8\5\u00c8\u121d\n\u00c8\3")
        buf.write("\u00c9\3\u00c9\3\u00c9\3\u00c9\3\u00ca\3\u00ca\3\u00ca")
        buf.write("\3\u00ca\3\u00ca\3\u00ca\3\u00ca\3\u00ca\3\u00ca\7\u00ca")
        buf.write("\u122c\n\u00ca\f\u00ca\16\u00ca\u122f\13\u00ca\5\u00ca")
        buf.write("\u1231\n\u00ca\3\u00cb\5\u00cb\u1234\n\u00cb\3\u00cb\3")
        buf.write("\u00cb\5\u00cb\u1238\n\u00cb\3\u00cc\3\u00cc\3\u00cc\3")
        buf.write("\u00cc\3\u00cc\3\u00cc\5\u00cc\u1240\n\u00cc\3\u00cc\3")
        buf.write("\u00cc\3\u00cc\3\u00cc\5\u00cc\u1246\n\u00cc\3\u00cd\3")
        buf.write("\u00cd\3\u00cd\3\u00cd\3\u00cd\3\u00cd\3\u00ce\3\u00ce")
        buf.write("\5\u00ce\u1250\n\u00ce\3\u00cf\3\u00cf\3\u00cf\3\u00cf")
        buf.write("\5\u00cf\u1256\n\u00cf\3\u00cf\3\u00cf\5\u00cf\u125a\n")
        buf.write("\u00cf\3\u00cf\5\u00cf\u125d\n\u00cf\3\u00cf\3\u00cf\3")
        buf.write("\u00cf\3\u00cf\3\u00cf\5\u00cf\u1264\n\u00cf\5\u00cf\u1266")
        buf.write("\n\u00cf\3\u00cf\3\u00cf\5\u00cf\u126a\n\u00cf\3\u00d0")
        buf.write("\3\u00d0\3\u00d0\3\u00d0\3\u00d0\3\u00d0\5\u00d0\u1272")
        buf.write("\n\u00d0\3\u00d0\3\u00d0\5\u00d0\u1276\n\u00d0\3\u00d0")
        buf.write("\3\u00d0\5\u00d0\u127a\n\u00d0\3\u00d0\5\u00d0\u127d\n")
        buf.write("\u00d0\3\u00d0\3\u00d0\3\u00d0\3\u00d0\3\u00d0\5\u00d0")
        buf.write("\u1284\n\u00d0\5\u00d0\u1286\n\u00d0\3\u00d1\3\u00d1\5")
        buf.write("\u00d1\u128a\n\u00d1\3\u00d1\7\u00d1\u128d\n\u00d1\f\u00d1")
        buf.write("\16\u00d1\u1290\13\u00d1\3\u00d2\5\u00d2\u1293\n\u00d2")
        buf.write("\3\u00d2\3\u00d2\3\u00d2\5\u00d2\u1298\n\u00d2\3\u00d2")
        buf.write("\3\u00d2\5\u00d2\u129c\n\u00d2\3\u00d2\3\u00d2\5\u00d2")
        buf.write("\u12a0\n\u00d2\3\u00d2\3\u00d2\3\u00d2\5\u00d2\u12a5\n")
        buf.write("\u00d2\3\u00d2\3\u00d2\3\u00d2\5\u00d2\u12aa\n\u00d2\3")
        buf.write("\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2")
        buf.write("\3\u00d2\5\u00d2\u12b4\n\u00d2\3\u00d2\3\u00d2\3\u00d2")
        buf.write("\3\u00d2\3\u00d2\3\u00d2\5\u00d2\u12bc\n\u00d2\3\u00d2")
        buf.write("\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2")
        buf.write("\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2\3\u00d2")
        buf.write("\3\u00d2\5\u00d2\u12ce\n\u00d2\3\u00d3\3\u00d3\5\u00d3")
        buf.write("\u12d2\n\u00d3\3\u00d3\5\u00d3\u12d5\n\u00d3\3\u00d3\5")
        buf.write("\u00d3\u12d8\n\u00d3\3\u00d3\5\u00d3\u12db\n\u00d3\3\u00d3")
        buf.write("\3\u00d3\5\u00d3\u12df\n\u00d3\3\u00d3\3\u00d3\5\u00d3")
        buf.write("\u12e3\n\u00d3\3\u00d3\3\u00d3\5\u00d3\u12e7\n\u00d3\3")
        buf.write("\u00d3\3\u00d3\5\u00d3\u12eb\n\u00d3\3\u00d3\5\u00d3\u12ee")
        buf.write("\n\u00d3\3\u00d3\3\u00d3\3\u00d3\5\u00d3\u12f3\n\u00d3")
        buf.write("\3\u00d3\3\u00d3\5\u00d3\u12f7\n\u00d3\3\u00d3\5\u00d3")
        buf.write("\u12fa\n\u00d3\3\u00d4\3\u00d4\3\u00d4\3\u00d5\3\u00d5")
        buf.write("\3\u00d5\3\u00d5\3\u00d6\3\u00d6\3\u00d6\3\u00d6\7\u00d6")
        buf.write("\u1307\n\u00d6\f\u00d6\16\u00d6\u130a\13\u00d6\3\u00d6")
        buf.write("\3\u00d6\3\u00d7\3\u00d7\5\u00d7\u1310\n\u00d7\3\u00d7")
        buf.write("\3\u00d7\3\u00d7\3\u00d8\3\u00d8\3\u00d8\5\u00d8\u1318")
        buf.write("\n\u00d8\3\u00d8\6\u00d8\u131b\n\u00d8\r\u00d8\16\u00d8")
        buf.write("\u131c\5\u00d8\u131f\n\u00d8\3\u00d9\3\u00d9\5\u00d9\u1323")
        buf.write("\n\u00d9\3\u00d9\3\u00d9\3\u00d9\5\u00d9\u1328\n\u00d9")
        buf.write("\3\u00d9\5\u00d9\u132b\n\u00d9\3\u00da\3\u00da\3\u00da")
        buf.write("\5\u00da\u1330\n\u00da\3\u00db\5\u00db\u1333\n\u00db\3")
        buf.write("\u00db\6\u00db\u1336\n\u00db\r\u00db\16\u00db\u1337\3")
        buf.write("\u00db\5\u00db\u133b\n\u00db\3\u00db\3\u00db\5\u00db\u133f")
        buf.write("\n\u00db\3\u00db\3\u00db\3\u00db\5\u00db\u1344\n\u00db")
        buf.write("\3\u00db\3\u00db\3\u00db\3\u00db\5\u00db\u134a\n\u00db")
        buf.write("\3\u00dc\3\u00dc\5\u00dc\u134e\n\u00dc\3\u00dc\3\u00dc")
        buf.write("\5\u00dc\u1352\n\u00dc\3\u00dc\3\u00dc\3\u00dc\5\u00dc")
        buf.write("\u1357\n\u00dc\3\u00dc\3\u00dc\5\u00dc\u135b\n\u00dc\5")
        buf.write("\u00dc\u135d\n\u00dc\3\u00dd\5\u00dd\u1360\n\u00dd\3\u00dd")
        buf.write("\3\u00dd\5\u00dd\u1364\n\u00dd\3\u00dd\3\u00dd\5\u00dd")
        buf.write("\u1368\n\u00dd\3\u00dd\3\u00dd\3\u00dd\5\u00dd\u136d\n")
        buf.write("\u00dd\3\u00dd\3\u00dd\5\u00dd\u1371\n\u00dd\3\u00dd\5")
        buf.write("\u00dd\u1374\n\u00dd\3\u00dd\5\u00dd\u1377\n\u00dd\3\u00dd")
        buf.write("\5\u00dd\u137a\n\u00dd\3\u00de\5\u00de\u137d\n\u00de\3")
        buf.write("\u00de\3\u00de\5\u00de\u1381\n\u00de\3\u00de\3\u00de\5")
        buf.write("\u00de\u1385\n\u00de\3\u00de\3\u00de\5\u00de\u1389\n\u00de")
        buf.write("\3\u00de\3\u00de\5\u00de\u138d\n\u00de\3\u00de\5\u00de")
        buf.write("\u1390\n\u00de\3\u00de\5\u00de\u1393\n\u00de\3\u00de\5")
        buf.write("\u00de\u1396\n\u00de\3\u00de\3\u00de\3\u00de\3\u00de\5")
        buf.write("\u00de\u139c\n\u00de\3\u00de\3\u00de\5\u00de\u13a0\n\u00de")
        buf.write("\3\u00de\5\u00de\u13a3\n\u00de\3\u00df\3\u00df\3\u00df")
        buf.write("\5\u00df\u13a8\n\u00df\3\u00df\3\u00df\3\u00df\5\u00df")
        buf.write("\u13ad\n\u00df\3\u00df\3\u00df\3\u00e0\3\u00e0\3\u00e0")
        buf.write("\5\u00e0\u13b4\n\u00e0\3\u00e1\3\u00e1\3\u00e1\3\u00e1")
        buf.write("\5\u00e1\u13ba\n\u00e1\3\u00e1\3\u00e1\3\u00e2\3\u00e2")
        buf.write("\3\u00e2\3\u00e2\5\u00e2\u13c2\n\u00e2\3\u00e3\3\u00e3")
        buf.write("\3\u00e3\3\u00e3\3\u00e3\7\u00e3\u13c9\n\u00e3\f\u00e3")
        buf.write("\16\u00e3\u13cc\13\u00e3\3\u00e3\3\u00e3\3\u00e3\3\u00e3")
        buf.write("\3\u00e3\3\u00e3\3\u00e3\3\u00e3\3\u00e3\3\u00e3\3\u00e3")
        buf.write("\3\u00e3\3\u00e3\3\u00e3\3\u00e3\5\u00e3\u13dd\n\u00e3")
        buf.write("\3\u00e4\3\u00e4\3\u00e4\3\u00e4\7\u00e4\u13e3\n\u00e4")
        buf.write("\f\u00e4\16\u00e4\u13e6\13\u00e4\3\u00e4\3\u00e4\3\u00e5")
        buf.write("\3\u00e5\3\u00e5\3\u00e5\7\u00e5\u13ee\n\u00e5\f\u00e5")
        buf.write("\16\u00e5\u13f1\13\u00e5\5\u00e5\u13f3\n\u00e5\3\u00e5")
        buf.write("\3\u00e5\3\u00e5\5\u00e5\u13f8\n\u00e5\3\u00e6\3\u00e6")
        buf.write("\3\u00e6\5\u00e6\u13fd\n\u00e6\3\u00e7\3\u00e7\3\u00e7")
        buf.write("\3\u00e7\3\u00e8\3\u00e8\3\u00e8\3\u00e8\3\u00e8\7\u00e8")
        buf.write("\u1408\n\u00e8\f\u00e8\16\u00e8\u140b\13\u00e8\3\u00e8")
        buf.write("\3\u00e8\3\u00e9\3\u00e9\5\u00e9\u1411\n\u00e9\3\u00ea")
        buf.write("\3\u00ea\3\u00ea\5\u00ea\u1416\n\u00ea\3\u00eb\3\u00eb")
        buf.write("\3\u00eb\3\u00eb\3\u00eb\7\u00eb\u141d\n\u00eb\f\u00eb")
        buf.write("\16\u00eb\u1420\13\u00eb\3\u00eb\3\u00eb\3\u00ec\5\u00ec")
        buf.write("\u1425\n\u00ec\3\u00ec\3\u00ec\5\u00ec\u1429\n\u00ec\3")
        buf.write("\u00ed\3\u00ed\5\u00ed\u142d\n\u00ed\3\u00ee\3\u00ee\3")
        buf.write("\u00ee\3\u00ee\7\u00ee\u1433\n\u00ee\f\u00ee\16\u00ee")
        buf.write("\u1436\13\u00ee\3\u00ee\3\u00ee\3\u00ef\3\u00ef\3\u00ef")
        buf.write("\3\u00ef\3\u00ef\7\u00ef\u143f\n\u00ef\f\u00ef\16\u00ef")
        buf.write("\u1442\13\u00ef\5\u00ef\u1444\n\u00ef\3\u00f0\3\u00f0")
        buf.write("\3\u00f0\5\u00f0\u1449\n\u00f0\3\u00f0\7\u00f0\u144c\n")
        buf.write("\u00f0\f\u00f0\16\u00f0\u144f\13\u00f0\3\u00f0\5\u00f0")
        buf.write("\u1452\n\u00f0\3\u00f1\3\u00f1\3\u00f1\5\u00f1\u1457\n")
        buf.write("\u00f1\3\u00f1\5\u00f1\u145a\n\u00f1\3\u00f1\7\u00f1\u145d")
        buf.write("\n\u00f1\f\u00f1\16\u00f1\u1460\13\u00f1\3\u00f2\3\u00f2")
        buf.write("\3\u00f2\3\u00f3\3\u00f3\5\u00f3\u1467\n\u00f3\3\u00f3")
        buf.write("\3\u00f3\5\u00f3\u146b\n\u00f3\3\u00f3\5\u00f3\u146e\n")
        buf.write("\u00f3\3\u00f4\3\u00f4\3\u00f4\5\u00f4\u1473\n\u00f4\3")
        buf.write("\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4")
        buf.write("\3\u00f4\3\u00f4\7\u00f4\u147e\n\u00f4\f\u00f4\16\u00f4")
        buf.write("\u1481\13\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\5\u00f4")
        buf.write("\u1487\n\u00f4\3\u00f4\3\u00f4\3\u00f4\5\u00f4\u148c\n")
        buf.write("\u00f4\3\u00f4\3\u00f4\3\u00f4\5\u00f4\u1491\n\u00f4\3")
        buf.write("\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\7\u00f4\u1498\n")
        buf.write("\u00f4\f\u00f4\16\u00f4\u149b\13\u00f4\3\u00f4\3\u00f4")
        buf.write("\3\u00f4\3\u00f4\3\u00f4\3\u00f4\5\u00f4\u14a3\n\u00f4")
        buf.write("\3\u00f4\5\u00f4\u14a6\n\u00f4\3\u00f4\3\u00f4\3\u00f4")
        buf.write("\3\u00f4\5\u00f4\u14ac\n\u00f4\3\u00f4\5\u00f4\u14af\n")
        buf.write("\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4")
        buf.write("\3\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\3\u00f4\5\u00f4")
        buf.write("\u14bd\n\u00f4\3\u00f5\3\u00f5\3\u00f5\3\u00f5\3\u00f5")
        buf.write("\3\u00f5\3\u00f5\3\u00f5\3\u00f5\3\u00f5\3\u00f5\3\u00f5")
        buf.write("\3\u00f5\5\u00f5\u14cc\n\u00f5\3\u00f6\3\u00f6\3\u00f6")
        buf.write("\3\u00f6\3\u00f6\3\u00f6\3\u00f6\3\u00f6\3\u00f6\3\u00f6")
        buf.write("\3\u00f6\3\u00f6\3\u00f6\5\u00f6\u14db\n\u00f6\3\u00f7")
        buf.write("\3\u00f7\3\u00f8\5\u00f8\u14e0\n\u00f8\3\u00f8\5\u00f8")
        buf.write("\u14e3\n\u00f8\3\u00f8\3\u00f8\3\u00f8\3\u00f8\5\u00f8")
        buf.write("\u14e9\n\u00f8\5\u00f8\u14eb\n\u00f8\3\u00f9\3\u00f9\3")
        buf.write("\u00f9\3\u00f9\3\u00fa\3\u00fa\3\u00fa\7\u00fa\u14f4\n")
        buf.write("\u00fa\f\u00fa\16\u00fa\u14f7\13\u00fa\3\u00fb\3\u00fb")
        buf.write("\3\u00fb\3\u00fb\7\u00fb\u14fd\n\u00fb\f\u00fb\16\u00fb")
        buf.write("\u1500\13\u00fb\3\u00fb\3\u00fb\3\u00fc\3\u00fc\3\u00fc")
        buf.write("\5\u00fc\u1507\n\u00fc\3\u00fd\3\u00fd\3\u00fd\5\u00fd")
        buf.write("\u150c\n\u00fd\3\u00fe\3\u00fe\3\u00fe\3\u00ff\3\u00ff")
        buf.write("\3\u00ff\3\u00ff\3\u00ff\5\u00ff\u1516\n\u00ff\3\u0100")
        buf.write("\3\u0100\3\u0100\3\u0100\3\u0100\3\u0100\3\u0100\5\u0100")
        buf.write("\u151f\n\u0100\3\u0101\3\u0101\3\u0101\3\u0102\3\u0102")
        buf.write("\3\u0102\3\u0102\5\u0102\u1528\n\u0102\3\u0103\3\u0103")
        buf.write("\3\u0103\3\u0103\3\u0103\5\u0103\u152f\n\u0103\3\u0104")
        buf.write("\3\u0104\3\u0104\3\u0104\3\u0104\5\u0104\u1536\n\u0104")
        buf.write("\3\u0105\3\u0105\3\u0105\3\u0105\3\u0106\3\u0106\3\u0106")
        buf.write("\3\u0106\3\u0107\3\u0107\3\u0107\3\u0107\3\u0107\3\u0107")
        buf.write("\3\u0107\3\u0107\3\u0107\5\u0107\u1549\n\u0107\5\u0107")
        buf.write("\u154b\n\u0107\3\u0108\3\u0108\3\u0109\3\u0109\3\u0109")
        buf.write("\3\u0109\3\u0109\7\u0109\u1554\n\u0109\f\u0109\16\u0109")
        buf.write("\u1557\13\u0109\3\u010a\3\u010a\3\u010b\3\u010b\3\u010b")
        buf.write("\3\u010c\3\u010c\5\u010c\u1560\n\u010c\3\u010c\5\u010c")
        buf.write("\u1563\n\u010c\3\u010d\3\u010d\3\u010e\6\u010e\u1568\n")
        buf.write("\u010e\r\u010e\16\u010e\u1569\3\u010e\7\u010e\u156d\n")
        buf.write("\u010e\f\u010e\16\u010e\u1570\13\u010e\3\u010e\3\u010e")
        buf.write("\5\u010e\u1574\n\u010e\3\u010f\3\u010f\3\u010f\3\u010f")
        buf.write("\3\u010f\3\u010f\3\u010f\3\u010f\5\u010f\u157e\n\u010f")
        buf.write("\3\u010f\3\u010f\5\u010f\u1582\n\u010f\3\u010f\5\u010f")
        buf.write("\u1585\n\u010f\3\u0110\3\u0110\5\u0110\u1589\n\u0110\3")
        buf.write("\u0110\3\u0110\5\u0110\u158d\n\u0110\3\u0110\3\u0110\3")
        buf.write("\u0110\5\u0110\u1592\n\u0110\3\u0111\3\u0111\5\u0111\u1596")
        buf.write("\n\u0111\3\u0111\3\u0111\5\u0111\u159a\n\u0111\3\u0111")
        buf.write("\5\u0111\u159d\n\u0111\3\u0112\3\u0112\5\u0112\u15a1\n")
        buf.write("\u0112\3\u0112\3\u0112\3\u0112\3\u0112\5\u0112\u15a7\n")
        buf.write("\u0112\3\u0113\3\u0113\5\u0113\u15ab\n\u0113\3\u0113\3")
        buf.write("\u0113\3\u0113\3\u0113\5\u0113\u15b1\n\u0113\3\u0114\3")
        buf.write("\u0114\3\u0114\3\u0114\3\u0114\3\u0114\3\u0114\3\u0114")
        buf.write("\3\u0114\3\u0114\5\u0114\u15bd\n\u0114\3\u0114\3\u0114")
        buf.write("\3\u0114\3\u0114\3\u0114\3\u0114\5\u0114\u15c5\n\u0114")
        buf.write("\3\u0114\5\u0114\u15c8\n\u0114\3\u0114\3\u0114\5\u0114")
        buf.write("\u15cc\n\u0114\3\u0114\3\u0114\3\u0114\3\u0114\3\u0114")
        buf.write("\3\u0114\3\u0114\3\u0114\3\u0114\3\u0114\3\u0114\3\u0114")
        buf.write("\3\u0114\3\u0114\5\u0114\u15dc\n\u0114\3\u0114\3\u0114")
        buf.write("\3\u0115\5\u0115\u15e1\n\u0115\3\u0115\3\u0115\5\u0115")
        buf.write("\u15e5\n\u0115\3\u0116\3\u0116\3\u0116\5\u0116\u15ea\n")
        buf.write("\u0116\3\u0117\3\u0117\3\u0117\5\u0117\u15ef\n\u0117\3")
        buf.write("\u0118\3\u0118\3\u0118\5\u0118\u15f4\n\u0118\3\u0119\3")
        buf.write("\u0119\3\u0119\3\u0119\3\u0119\5\u0119\u15fb\n\u0119\3")
        buf.write("\u011a\3\u011a\3\u011b\3\u011b\3\u011c\3\u011c\3\u011d")
        buf.write("\3\u011d\3\u011e\3\u011e\3\u011f\3\u011f\3\u011f\3\u011f")
        buf.write("\3\u011f\5\u011f\u160c\n\u011f\3\u0120\3\u0120\3\u0120")
        buf.write("\7\u0120\u1611\n\u0120\f\u0120\16\u0120\u1614\13\u0120")
        buf.write("\3\u0121\5\u0121\u1617\n\u0121\3\u0121\3\u0121\3\u0121")
        buf.write("\5\u0121\u161c\n\u0121\3\u0121\6\u0121\u161f\n\u0121\r")
        buf.write("\u0121\16\u0121\u1620\5\u0121\u1623\n\u0121\3\u0122\3")
        buf.write("\u0122\5\u0122\u1627\n\u0122\3\u0122\3\u0122\3\u0123\3")
        buf.write("\u0123\3\u0123\5\u0123\u162e\n\u0123\3\u0123\5\u0123\u1631")
        buf.write("\n\u0123\3\u0123\3\u0123\3\u0123\5\u0123\u1636\n\u0123")
        buf.write("\3\u0123\3\u0123\5\u0123\u163a\n\u0123\3\u0123\3\u0123")
        buf.write("\3\u0123\3\u0123\5\u0123\u1640\n\u0123\3\u0123\3\u0123")
        buf.write("\3\u0123\3\u0123\5\u0123\u1646\n\u0123\3\u0123\5\u0123")
        buf.write("\u1649\n\u0123\3\u0123\5\u0123\u164c\n\u0123\3\u0123\3")
        buf.write("\u0123\5\u0123\u1650\n\u0123\3\u0123\5\u0123\u1653\n\u0123")
        buf.write("\3\u0123\3\u0123\5\u0123\u1657\n\u0123\3\u0123\5\u0123")
        buf.write("\u165a\n\u0123\3\u0123\3\u0123\5\u0123\u165e\n\u0123\3")
        buf.write("\u0123\3\u0123\3\u0123\3\u0123\5\u0123\u1664\n\u0123\3")
        buf.write("\u0123\3\u0123\3\u0123\5\u0123\u1669\n\u0123\3\u0123\3")
        buf.write("\u0123\5\u0123\u166d\n\u0123\3\u0123\3\u0123\3\u0123\5")
        buf.write("\u0123\u1672\n\u0123\3\u0123\3\u0123\5\u0123\u1676\n\u0123")
        buf.write("\3\u0123\3\u0123\3\u0123\3\u0123\3\u0123\7\u0123\u167d")
        buf.write("\n\u0123\f\u0123\16\u0123\u1680\13\u0123\3\u0123\3\u0123")
        buf.write("\5\u0123\u1684\n\u0123\5\u0123\u1686\n\u0123\3\u0124\3")
        buf.write("\u0124\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124")
        buf.write("\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124")
        buf.write("\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124")
        buf.write("\3\u0124\3\u0124\3\u0124\3\u0124\3\u0124\5\u0124\u16a3")
        buf.write("\n\u0124\3\u0125\3\u0125\3\u0125\3\u0125\3\u0126\3\u0126")
        buf.write("\3\u0126\3\u0126\5\u0126\u16ad\n\u0126\3\u0126\3\u0126")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\5\u0127\u16b6")
        buf.write("\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127\6\u0127\u16bc")
        buf.write("\n\u0127\r\u0127\16\u0127\u16bd\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u16ca\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\5\u0127\u16e0\n\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u16e4\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\5\u0127\u16ec\n\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\5\u0127\u16f2\n\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\5\u0127\u16f7\n\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\5\u0127\u16fd\n\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u1709\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u171d\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\7\u0127\u1725\n\u0127\f\u0127\16\u0127")
        buf.write("\u1728\13\u0127\5\u0127\u172a\n\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\5\u0127\u1731\n\u0127\3\u0127")
        buf.write("\3\u0127\5\u0127\u1735\n\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u173a\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u1740\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\5\u0127\u1746\n\u0127\3\u0127\3\u0127\3\u0127\3\u0127")
        buf.write("\3\u0127\3\u0127\3\u0127\3\u0127\3\u0127\7\u0127\u1751")
        buf.write("\n\u0127\f\u0127\16\u0127\u1754\13\u0127\3\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\5\u0128\u175b\n\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\6\u0128\u1761\n\u0128\r\u0128")
        buf.write("\16\u0128\u1762\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\5\u0128\u176d\n\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\5\u0128\u1782\n\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\5\u0128\u178f\n\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\5\u0128\u1795\n\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\5\u0128\u179b\n\u0128")
        buf.write("\3\u0128\3\u0128\3\u0128\3\u0128\3\u0128\7\u0128\u17a2")
        buf.write("\n\u0128\f\u0128\16\u0128\u17a5\13\u0128\3\u0129\3\u0129")
        buf.write("\3\u0129\3\u0129\3\u0129\3\u0129\3\u0129\3\u0129\5\u0129")
        buf.write("\u17af\n\u0129\3\u012a\3\u012a\3\u012a\3\u012a\3\u012a")
        buf.write("\3\u012a\3\u012a\3\u012a\5\u012a\u17b9\n\u012a\3\u012b")
        buf.write("\3\u012b\3\u012b\3\u012b\3\u012b\3\u012b\3\u012b\3\u012b")
        buf.write("\3\u012b\3\u012b\3\u012b\3\u012b\3\u012c\3\u012c\3\u012c")
        buf.write("\3\u012c\3\u012c\5\u012c\u17cc\n\u012c\3\u012c\3\u012c")
        buf.write("\3\u012c\3\u012c\3\u012c\3\u012c\3\u012c\3\u012c\3\u012c")
        buf.write("\3\u012c\3\u012c\5\u012c\u17d9\n\u012c\3\u012d\3\u012d")
        buf.write("\3\u012d\5\u012d\u17de\n\u012d\3\u012e\3\u012e\3\u012f")
        buf.write("\3\u012f\3\u0130\3\u0130\5\u0130\u17e6\n\u0130\3\u0130")
        buf.write("\3\u0130\3\u0130\3\u0130\3\u0130\6\u0130\u17ed\n\u0130")
        buf.write("\r\u0130\16\u0130\u17ee\3\u0130\3\u0130\5\u0130\u17f3")
        buf.write("\n\u0130\3\u0130\3\u0130\3\u0131\3\u0131\3\u0131\3\u0131")
        buf.write("\3\u0131\3\u0131\3\u0131\3\u0132\3\u0132\3\u0132\5\u0132")
        buf.write("\u1801\n\u0132\3\u0132\3\u0132\3\u0132\7\u0132\u1806\n")
        buf.write("\u0132\f\u0132\16\u0132\u1809\13\u0132\3\u0132\5\u0132")
        buf.write("\u180c\n\u0132\5\u0132\u180e\n\u0132\3\u0132\3\u0132\3")
        buf.write("\u0132\3\u0132\3\u0132\3\u0132\3\u0132\5\u0132\u1817\n")
        buf.write("\u0132\3\u0132\5\u0132\u181a\n\u0132\3\u0132\3\u0132\3")
        buf.write("\u0132\5\u0132\u181f\n\u0132\5\u0132\u1821\n\u0132\3\u0132")
        buf.write("\3\u0132\3\u0132\3\u0132\3\u0132\3\u0132\5\u0132\u1829")
        buf.write("\n\u0132\3\u0133\5\u0133\u182c\n\u0133\3\u0133\3\u0133")
        buf.write("\3\u0133\5\u0133\u1831\n\u0133\3\u0133\3\u0133\3\u0134")
        buf.write("\3\u0134\3\u0135\3\u0135\3\u0135\3\u0135\3\u0135\7\u0135")
        buf.write("\u183c\n\u0135\f\u0135\16\u0135\u183f\13\u0135\3\u0135")
        buf.write("\3\u0135\3\u0135\3\u0135\3\u0135\3\u0135\3\u0135\7\u0135")
        buf.write("\u1848\n\u0135\f\u0135\16\u0135\u184b\13\u0135\5\u0135")
        buf.write("\u184d\n\u0135\3\u0135\5\u0135\u1850\n\u0135\3\u0136\3")
        buf.write("\u0136\3\u0136\3\u0136\5\u0136\u1856\n\u0136\3\u0136\3")
        buf.write("\u0136\3\u0136\3\u0136\3\u0137\3\u0137\3\u0137\3\u0137")
        buf.write("\3\u0137\3\u0137\5\u0137\u1862\n\u0137\3\u0138\3\u0138")
        buf.write("\3\u0138\5\u0138\u1867\n\u0138\3\u0138\3\u0138\5\u0138")
        buf.write("\u186b\n\u0138\3\u0138\3\u0138\5\u0138\u186f\n\u0138\3")
        buf.write("\u0138\3\u0138\5\u0138\u1873\n\u0138\5\u0138\u1875\n\u0138")
        buf.write("\3\u0139\3\u0139\3\u0139\5\u0139\u187a\n\u0139\3\u0139")
        buf.write("\3\u0139\3\u0139\3\u0139\3\u0139\5\u0139\u1881\n\u0139")
        buf.write("\3\u0139\3\u0139\3\u0139\5\u0139\u1886\n\u0139\5\u0139")
        buf.write("\u1888\n\u0139\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139")
        buf.write("\3\u0139\3\u0139\7\u0139\u1891\n\u0139\f\u0139\16\u0139")
        buf.write("\u1894\13\u0139\3\u0139\3\u0139\5\u0139\u1898\n\u0139")
        buf.write("\3\u0139\3\u0139\5\u0139\u189c\n\u0139\3\u0139\3\u0139")
        buf.write("\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139")
        buf.write("\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139")
        buf.write("\3\u0139\3\u0139\5\u0139\u18b0\n\u0139\3\u0139\3\u0139")
        buf.write("\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139\3\u0139\5\u0139")
        buf.write("\u18ba\n\u0139\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u18c6")
        buf.write("\n\u013a\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u18cc")
        buf.write("\n\u013a\7\u013a\u18ce\n\u013a\f\u013a\16\u013a\u18d1")
        buf.write("\13\u013a\3\u013a\3\u013a\5\u013a\u18d5\n\u013a\3\u013a")
        buf.write("\3\u013a\7\u013a\u18d9\n\u013a\f\u013a\16\u013a\u18dc")
        buf.write("\13\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\5\u013a\u18e5\n\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\5\u013a\u18eb\n\u013a\7\u013a\u18ed\n\u013a\f")
        buf.write("\u013a\16\u013a\u18f0\13\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u18fa")
        buf.write("\n\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u1906\n\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a")
        buf.write("\u190e\n\u013a\5\u013a\u1910\n\u013a\3\u013a\3\u013a\3")
        buf.write("\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a")
        buf.write("\u191a\n\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u191f\n")
        buf.write("\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a\3\u013a")
        buf.write("\3\u013a\7\u013a\u193d\n\u013a\f\u013a\16\u013a\u1940")
        buf.write("\13\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u1945\n\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\3\u013a\5\u013a\u194b\n\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\5\u013a\u1950\n\u013a\3\u013a")
        buf.write("\3\u013a\3\u013a\3\u013a\7\u013a\u1956\n\u013a\f\u013a")
        buf.write("\16\u013a\u1959\13\u013a\3\u013a\3\u013a\5\u013a\u195d")
        buf.write("\n\u013a\3\u013b\3\u013b\3\u013b\3\u013b\5\u013b\u1963")
        buf.write("\n\u013b\3\u013b\3\u013b\5\u013b\u1967\n\u013b\3\u013b")
        buf.write("\5\u013b\u196a\n\u013b\3\u013b\5\u013b\u196d\n\u013b\3")
        buf.write("\u013b\3\u013b\5\u013b\u1971\n\u013b\3\u013c\3\u013c\3")
        buf.write("\u013c\3\u013c\5\u013c\u1977\n\u013c\3\u013c\3\u013c\3")
        buf.write("\u013d\3\u013d\3\u013d\3\u013d\3\u013d\3\u013d\3\u013e")
        buf.write("\3\u013e\5\u013e\u1983\n\u013e\3\u013e\5\u013e\u1986\n")
        buf.write("\u013e\3\u013e\5\u013e\u1989\n\u013e\3\u013e\5\u013e\u198c")
        buf.write("\n\u013e\3\u013e\3\u013e\3\u013f\3\u013f\3\u013f\3\u013f")
        buf.write("\3\u013f\3\u013f\3\u013f\5\u013f\u1997\n\u013f\3\u013f")
        buf.write("\3\u013f\3\u013f\3\u013f\3\u013f\3\u013f\3\u013f\5\u013f")
        buf.write("\u19a0\n\u013f\5\u013f\u19a2\n\u013f\3\u0140\3\u0140\3")
        buf.write("\u0140\3\u0140\3\u0140\5\u0140\u19a9\n\u0140\3\u0141\3")
        buf.write("\u0141\3\u0141\5\u0141\u19ae\n\u0141\3\u0142\3\u0142\3")
        buf.write("\u0142\5\u0142\u19b3\n\u0142\3\u0142\3\u0142\3\u0142\5")
        buf.write("\u0142\u19b8\n\u0142\7\u0142\u19ba\n\u0142\f\u0142\16")
        buf.write("\u0142\u19bd\13\u0142\5\u0142\u19bf\n\u0142\3\u0142\3")
        buf.write("\u0142\3\u0143\3\u0143\3\u0143\3\u0143\3\u0143\3\u0143")
        buf.write("\3\u0143\5\u0143\u19ca\n\u0143\5\u0143\u19cc\n\u0143\3")
        buf.write("\u0144\3\u0144\3\u0144\3\u0144\3\u0144\5\u0144\u19d3\n")
        buf.write("\u0144\5\u0144\u19d5\n\u0144\3\u0145\3\u0145\3\u0146\3")
        buf.write("\u0146\3\u0146\3\u0146\3\u0147\5\u0147\u19de\n\u0147\3")
        buf.write("\u0147\3\u0147\7\u0147\u19e2\n\u0147\f\u0147\16\u0147")
        buf.write("\u19e5\13\u0147\3\u0148\3\u0148\3\u0148\3\u0148\5\u0148")
        buf.write("\u19eb\n\u0148\3\u0148\3\u0148\3\u0148\5\u0148\u19f0\n")
        buf.write("\u0148\3\u0148\3\u0148\3\u0148\5\u0148\u19f5\n\u0148\3")
        buf.write("\u0148\3\u0148\3\u0148\3\u0148\5\u0148\u19fb\n\u0148\3")
        buf.write("\u0148\3\u0148\3\u0148\3\u0148\3\u0148\3\u0148\3\u0148")
        buf.write("\3\u0148\5\u0148\u1a05\n\u0148\3\u0148\3\u0148\3\u0148")
        buf.write("\3\u0148\7\u0148\u1a0b\n\u0148\f\u0148\16\u0148\u1a0e")
        buf.write("\13\u0148\5\u0148\u1a10\n\u0148\3\u0148\3\u0148\3\u0148")
        buf.write("\5\u0148\u1a15\n\u0148\5\u0148\u1a17\n\u0148\3\u0149\5")
        buf.write("\u0149\u1a1a\n\u0149\3\u0149\3\u0149\7\u0149\u1a1e\n\u0149")
        buf.write("\f\u0149\16\u0149\u1a21\13\u0149\3\u014a\3\u014a\5\u014a")
        buf.write("\u1a25\n\u014a\3\u014a\3\u014a\3\u014a\7\u014a\u1a2a\n")
        buf.write("\u014a\f\u014a\16\u014a\u1a2d\13\u014a\3\u014b\3\u014b")
        buf.write("\3\u014b\3\u014b\3\u014b\7\u014b\u1a34\n\u014b\f\u014b")
        buf.write("\16\u014b\u1a37\13\u014b\3\u014b\3\u014b\5\u014b\u1a3b")
        buf.write("\n\u014b\3\u014b\3\u014b\5\u014b\u1a3f\n\u014b\3\u014b")
        buf.write("\5\u014b\u1a42\n\u014b\3\u014b\3\u014b\3\u014b\3\u014b")
        buf.write("\3\u014c\3\u014c\3\u014c\3\u014c\3\u014c\3\u014c\5\u014c")
        buf.write("\u1a4e\n\u014c\3\u014c\3\u014c\3\u014c\5\u014c\u1a53\n")
        buf.write("\u014c\3\u014c\7\u014c\u1a56\n\u014c\f\u014c\16\u014c")
        buf.write("\u1a59\13\u014c\3\u014d\3\u014d\3\u014d\5\u014d\u1a5e")
        buf.write("\n\u014d\3\u014d\3\u014d\3\u014d\3\u014d\3\u014d\5\u014d")
        buf.write("\u1a65\n\u014d\3\u014d\5\u014d\u1a68\n\u014d\3\u014e\3")
        buf.write("\u014e\3\u014e\3\u014e\3\u014e\3\u014e\3\u014e\7\u014e")
        buf.write("\u1a71\n\u014e\f\u014e\16\u014e\u1a74\13\u014e\3\u014e")
        buf.write("\3\u014e\5\u014e\u1a78\n\u014e\5\u014e\u1a7a\n\u014e\3")
        buf.write("\u014e\5\u014e\u1a7d\n\u014e\3\u014e\5\u014e\u1a80\n\u014e")
        buf.write("\3\u014e\3\u014e\3\u014e\3\u014e\7\u014e\u1a86\n\u014e")
        buf.write("\f\u014e\16\u014e\u1a89\13\u014e\5\u014e\u1a8b\n\u014e")
        buf.write("\3\u014e\3\u014e\5\u014e\u1a8f\n\u014e\3\u014e\5\u014e")
        buf.write("\u1a92\n\u014e\3\u014e\3\u014e\5\u014e\u1a96\n\u014e\3")
        buf.write("\u014e\3\u014e\3\u014e\3\u014e\3\u014e\3\u014e\3\u014e")
        buf.write("\3\u014e\3\u014e\7\u014e\u1aa1\n\u014e\f\u014e\16\u014e")
        buf.write("\u1aa4\13\u014e\5\u014e\u1aa6\n\u014e\3\u014e\3\u014e")
        buf.write("\5\u014e\u1aaa\n\u014e\3\u014e\3\u014e\5\u014e\u1aae\n")
        buf.write("\u014e\3\u014e\5\u014e\u1ab1\n\u014e\3\u014f\3\u014f\3")
        buf.write("\u014f\7\u014f\u1ab6\n\u014f\f\u014f\16\u014f\u1ab9\13")
        buf.write("\u014f\3\u0150\3\u0150\3\u0150\3\u0150\5\u0150\u1abf\n")
        buf.write("\u0150\3\u0151\3\u0151\5\u0151\u1ac3\n\u0151\3\u0151\5")
        buf.write("\u0151\u1ac6\n\u0151\3\u0151\3\u0151\3\u0152\3\u0152\3")
        buf.write("\u0152\3\u0152\3\u0152\5\u0152\u1acf\n\u0152\3\u0152\5")
        buf.write("\u0152\u1ad2\n\u0152\3\u0152\3\u0152\3\u0152\3\u0152\3")
        buf.write("\u0152\3\u0152\3\u0152\3\u0152\3\u0152\5\u0152\u1add\n")
        buf.write("\u0152\5\u0152\u1adf\n\u0152\3\u0152\3\u0152\3\u0152\3")
        buf.write("\u0152\3\u0152\3\u0152\5\u0152\u1ae7\n\u0152\5\u0152\u1ae9")
        buf.write("\n\u0152\3\u0152\3\u0152\3\u0152\3\u0152\3\u0152\3\u0152")
        buf.write("\3\u0152\3\u0152\3\u0152\5\u0152\u1af4\n\u0152\5\u0152")
        buf.write("\u1af6\n\u0152\3\u0152\3\u0152\3\u0152\3\u0152\3\u0152")
        buf.write("\7\u0152\u1afd\n\u0152\f\u0152\16\u0152\u1b00\13\u0152")
        buf.write("\3\u0153\5\u0153\u1b03\n\u0153\3\u0153\3\u0153\5\u0153")
        buf.write("\u1b07\n\u0153\3\u0153\5\u0153\u1b0a\n\u0153\3\u0153\3")
        buf.write("\u0153\3\u0153\3\u0153\3\u0153\3\u0153\7\u0153\u1b12\n")
        buf.write("\u0153\f\u0153\16\u0153\u1b15\13\u0153\3\u0153\3\u0153")
        buf.write("\3\u0153\5\u0153\u1b1a\n\u0153\5\u0153\u1b1c\n\u0153\3")
        buf.write("\u0153\5\u0153\u1b1f\n\u0153\3\u0153\3\u0153\3\u0153\3")
        buf.write("\u0153\5\u0153\u1b25\n\u0153\3\u0153\3\u0153\3\u0153\5")
        buf.write("\u0153\u1b2a\n\u0153\3\u0153\3\u0153\3\u0153\5\u0153\u1b2f")
        buf.write("\n\u0153\3\u0153\3\u0153\3\u0153\3\u0153\3\u0153\7\u0153")
        buf.write("\u1b36\n\u0153\f\u0153\16\u0153\u1b39\13\u0153\3\u0153")
        buf.write("\3\u0153\3\u0153\5\u0153\u1b3e\n\u0153\5\u0153\u1b40\n")
        buf.write("\u0153\3\u0153\5\u0153\u1b43\n\u0153\3\u0153\3\u0153\3")
        buf.write("\u0153\3\u0153\3\u0153\3\u0153\5\u0153\u1b4b\n\u0153\3")
        buf.write("\u0153\3\u0153\3\u0153\3\u0153\5\u0153\u1b51\n\u0153\7")
        buf.write("\u0153\u1b53\n\u0153\f\u0153\16\u0153\u1b56\13\u0153\3")
        buf.write("\u0153\3\u0153\3\u0153\5\u0153\u1b5b\n\u0153\3\u0153\5")
        buf.write("\u0153\u1b5e\n\u0153\3\u0153\3\u0153\3\u0153\3\u0153\3")
        buf.write("\u0153\7\u0153\u1b65\n\u0153\f\u0153\16\u0153\u1b68\13")
        buf.write("\u0153\3\u0153\3\u0153\5\u0153\u1b6c\n\u0153\5\u0153\u1b6e")
        buf.write("\n\u0153\5\u0153\u1b70\n\u0153\3\u0154\5\u0154\u1b73\n")
        buf.write("\u0154\3\u0154\3\u0154\3\u0154\3\u0154\3\u0154\7\u0154")
        buf.write("\u1b7a\n\u0154\f\u0154\16\u0154\u1b7d\13\u0154\3\u0154")
        buf.write("\3\u0154\5\u0154\u1b81\n\u0154\3\u0155\3\u0155\3\u0155")
        buf.write("\3\u0155\3\u0155\3\u0155\3\u0155\7\u0155\u1b8a\n\u0155")
        buf.write("\f\u0155\16\u0155\u1b8d\13\u0155\3\u0155\3\u0155\3\u0156")
        buf.write("\3\u0156\3\u0156\3\u0156\3\u0157\3\u0157\3\u0157\7\u0157")
        buf.write("\u1b98\n\u0157\f\u0157\16\u0157\u1b9b\13\u0157\3\u0158")
        buf.write("\3\u0158\3\u0158\3\u0158\3\u0158\3\u0158\3\u0158\5\u0158")
        buf.write("\u1ba4\n\u0158\3\u0158\3\u0158\3\u0158\3\u0158\5\u0158")
        buf.write("\u1baa\n\u0158\3\u0159\3\u0159\3\u0159\3\u0159\7\u0159")
        buf.write("\u1bb0\n\u0159\f\u0159\16\u0159\u1bb3\13\u0159\3\u015a")
        buf.write("\3\u015a\3\u015a\5\u015a\u1bb8\n\u015a\3\u015a\3\u015a")
        buf.write("\3\u015a\5\u015a\u1bbd\n\u015a\7\u015a\u1bbf\n\u015a\f")
        buf.write("\u015a\16\u015a\u1bc2\13\u015a\3\u015a\3\u015a\3\u015b")
        buf.write("\3\u015b\3\u015b\3\u015b\3\u015b\7\u015b\u1bcb\n\u015b")
        buf.write("\f\u015b\16\u015b\u1bce\13\u015b\3\u015c\3\u015c\5\u015c")
        buf.write("\u1bd2\n\u015c\3\u015c\5\u015c\u1bd5\n\u015c\3\u015d\3")
        buf.write("\u015d\3\u015d\3\u015d\5\u015d\u1bdb\n\u015d\3\u015e\3")
        buf.write("\u015e\3\u015e\3\u015f\5\u015f\u1be1\n\u015f\3\u015f\3")
        buf.write("\u015f\3\u015f\3\u015f\3\u015f\5\u015f\u1be8\n\u015f\3")
        buf.write("\u015f\3\u015f\3\u015f\5\u015f\u1bed\n\u015f\3\u015f\5")
        buf.write("\u015f\u1bf0\n\u015f\3\u015f\3\u015f\3\u015f\5\u015f\u1bf5")
        buf.write("\n\u015f\3\u015f\3\u015f\3\u015f\5\u015f\u1bfa\n\u015f")
        buf.write("\3\u015f\5\u015f\u1bfd\n\u015f\3\u015f\3\u015f\5\u015f")
        buf.write("\u1c01\n\u015f\3\u0160\3\u0160\3\u0160\3\u0160\7\u0160")
        buf.write("\u1c07\n\u0160\f\u0160\16\u0160\u1c0a\13\u0160\3\u0160")
        buf.write("\3\u0160\3\u0161\3\u0161\5\u0161\u1c10\n\u0161\3\u0162")
        buf.write("\3\u0162\5\u0162\u1c14\n\u0162\3\u0162\3\u0162\3\u0162")
        buf.write("\5\u0162\u1c19\n\u0162\3\u0163\3\u0163\3\u0163\3\u0163")
        buf.write("\3\u0163\3\u0163\3\u0163\3\u0163\7\u0163\u1c23\n\u0163")
        buf.write("\f\u0163\16\u0163\u1c26\13\u0163\3\u0163\3\u0163\5\u0163")
        buf.write("\u1c2a\n\u0163\5\u0163\u1c2c\n\u0163\3\u0164\5\u0164\u1c2f")
        buf.write("\n\u0164\3\u0164\3\u0164\3\u0164\5\u0164\u1c34\n\u0164")
        buf.write("\3\u0164\3\u0164\5\u0164\u1c38\n\u0164\3\u0164\5\u0164")
        buf.write("\u1c3b\n\u0164\3\u0164\5\u0164\u1c3e\n\u0164\3\u0164\3")
        buf.write("\u0164\3\u0164\3\u0164\7\u0164\u1c44\n\u0164\f\u0164\16")
        buf.write("\u0164\u1c47\13\u0164\5\u0164\u1c49\n\u0164\3\u0164\3")
        buf.write("\u0164\3\u0164\3\u0164\3\u0164\5\u0164\u1c50\n\u0164\5")
        buf.write("\u0164\u1c52\n\u0164\3\u0164\3\u0164\5\u0164\u1c56\n\u0164")
        buf.write("\3\u0165\5\u0165\u1c59\n\u0165\3\u0165\3\u0165\5\u0165")
        buf.write("\u1c5d\n\u0165\3\u0165\3\u0165\5\u0165\u1c61\n\u0165\3")
        buf.write("\u0165\5\u0165\u1c64\n\u0165\3\u0165\5\u0165\u1c67\n\u0165")
        buf.write("\3\u0165\3\u0165\3\u0165\3\u0165\7\u0165\u1c6d\n\u0165")
        buf.write("\f\u0165\16\u0165\u1c70\13\u0165\3\u0165\3\u0165\3\u0165")
        buf.write("\3\u0165\7\u0165\u1c76\n\u0165\f\u0165\16\u0165\u1c79")
        buf.write("\13\u0165\5\u0165\u1c7b\n\u0165\3\u0165\3\u0165\3\u0165")
        buf.write("\3\u0165\3\u0165\5\u0165\u1c82\n\u0165\5\u0165\u1c84\n")
        buf.write("\u0165\3\u0165\3\u0165\5\u0165\u1c88\n\u0165\3\u0166\3")
        buf.write("\u0166\3\u0166\3\u0166\5\u0166\u1c8e\n\u0166\3\u0166\3")
        buf.write("\u0166\3\u0166\3\u0166\7\u0166\u1c94\n\u0166\f\u0166\16")
        buf.write("\u0166\u1c97\13\u0166\3\u0166\3\u0166\3\u0166\5\u0166")
        buf.write("\u1c9c\n\u0166\3\u0166\3\u0166\3\u0166\5\u0166\u1ca1\n")
        buf.write("\u0166\3\u0166\3\u0166\3\u0166\5\u0166\u1ca6\n\u0166\7")
        buf.write("\u0166\u1ca8\n\u0166\f\u0166\16\u0166\u1cab\13\u0166\3")
        buf.write("\u0166\3\u0166\5\u0166\u1caf\n\u0166\5\u0166\u1cb1\n\u0166")
        buf.write("\3\u0167\3\u0167\3\u0167\3\u0167\5\u0167\u1cb7\n\u0167")
        buf.write("\3\u0168\3\u0168\5\u0168\u1cbb\n\u0168\3\u0168\3\u0168")
        buf.write("\3\u0168\7\u0168\u1cc0\n\u0168\f\u0168\16\u0168\u1cc3")
        buf.write("\13\u0168\3\u0168\3\u0168\5\u0168\u1cc7\n\u0168\3\u0168")
        buf.write("\5\u0168\u1cca\n\u0168\3\u0169\3\u0169\3\u0169\7\u0169")
        buf.write("\u1ccf\n\u0169\f\u0169\16\u0169\u1cd2\13\u0169\3\u016a")
        buf.write("\3\u016a\3\u016a\3\u016a\5\u016a\u1cd8\n\u016a\5\u016a")
        buf.write("\u1cda\n\u016a\3\u016a\3\u016a\3\u016a\3\u016a\3\u016a")
        buf.write("\3\u016a\5\u016a\u1ce2\n\u016a\5\u016a\u1ce4\n\u016a\3")
        buf.write("\u016b\3\u016b\3\u016b\3\u016b\5\u016b\u1cea\n\u016b\3")
        buf.write("\u016c\5\u016c\u1ced\n\u016c\3\u016c\5\u016c\u1cf0\n\u016c")
        buf.write("\3\u016c\3\u016c\3\u016c\5\u016c\u1cf5\n\u016c\3\u016c")
        buf.write("\3\u016c\5\u016c\u1cf9\n\u016c\3\u016d\3\u016d\3\u016d")
        buf.write("\3\u016d\3\u016e\3\u016e\7\u016e\u1d01\n\u016e\f\u016e")
        buf.write("\16\u016e\u1d04\13\u016e\3\u016f\7\u016f\u1d07\n\u016f")
        buf.write("\f\u016f\16\u016f\u1d0a\13\u016f\3\u016f\3\u016f\3\u016f")
        buf.write("\3\u016f\3\u0170\5\u0170\u1d11\n\u0170\3\u0170\3\u0170")
        buf.write("\5\u0170\u1d15\n\u0170\3\u0170\3\u0170\5\u0170\u1d19\n")
        buf.write("\u0170\3\u0170\3\u0170\5\u0170\u1d1d\n\u0170\3\u0170\3")
        buf.write("\u0170\3\u0170\3\u0170\5\u0170\u1d23\n\u0170\3\u0170\5")
        buf.write("\u0170\u1d26\n\u0170\3\u0170\5\u0170\u1d29\n\u0170\3\u0170")
        buf.write("\3\u0170\3\u0170\3\u0170\3\u0170\5\u0170\u1d30\n\u0170")
        buf.write("\3\u0170\3\u0170\5\u0170\u1d34\n\u0170\3\u0171\3\u0171")
        buf.write("\3\u0171\3\u0171\3\u0171\3\u0171\7\u0171\u1d3c\n\u0171")
        buf.write("\f\u0171\16\u0171\u1d3f\13\u0171\3\u0172\3\u0172\3\u0172")
        buf.write("\3\u0172\3\u0172\3\u0172\3\u0172\3\u0172\3\u0172\5\u0172")
        buf.write("\u1d4a\n\u0172\3\u0173\3\u0173\3\u0173\3\u0173\3\u0173")
        buf.write("\3\u0173\6\u0173\u1d52\n\u0173\r\u0173\16\u0173\u1d53")
        buf.write("\3\u0174\3\u0174\3\u0174\7\u0174\u1d59\n\u0174\f\u0174")
        buf.write("\16\u0174\u1d5c\13\u0174\3\u0175\3\u0175\3\u0175\3\u0175")
        buf.write("\3\u0175\3\u0175\3\u0175\3\u0175\3\u0175\5\u0175\u1d67")
        buf.write("\n\u0175\3\u0176\3\u0176\3\u0176\3\u0176\3\u0176\5\u0176")
        buf.write("\u1d6e\n\u0176\3\u0176\3\u0176\3\u0176\3\u0176\7\u0176")
        buf.write("\u1d74\n\u0176\f\u0176\16\u0176\u1d77\13\u0176\3\u0176")
        buf.write("\5\u0176\u1d7a\n\u0176\3\u0177\3\u0177\5\u0177\u1d7e\n")
        buf.write("\u0177\3\u0177\3\u0177\3\u0177\3\u0177\7\u0177\u1d84\n")
        buf.write("\u0177\f\u0177\16\u0177\u1d87\13\u0177\3\u0178\3\u0178")
        buf.write("\3\u0178\3\u0178\3\u0179\3\u0179\3\u0179\3\u0179\3\u0179")
        buf.write("\3\u0179\7\u0179\u1d93\n\u0179\f\u0179\16\u0179\u1d96")
        buf.write("\13\u0179\3\u0179\3\u0179\5\u0179\u1d9a\n\u0179\5\u0179")
        buf.write("\u1d9c\n\u0179\3\u0179\3\u0179\3\u0179\3\u0179\3\u0179")
        buf.write("\7\u0179\u1da3\n\u0179\f\u0179\16\u0179\u1da6\13\u0179")
        buf.write("\5\u0179\u1da8\n\u0179\3\u0179\3\u0179\5\u0179\u1dac\n")
        buf.write("\u0179\3\u0179\5\u0179\u1daf\n\u0179\3\u0179\3\u0179\5")
        buf.write("\u0179\u1db3\n\u0179\3\u0179\3\u0179\3\u0179\3\u0179\3")
        buf.write("\u0179\3\u0179\3\u0179\3\u0179\3\u0179\7\u0179\u1dbe\n")
        buf.write("\u0179\f\u0179\16\u0179\u1dc1\13\u0179\5\u0179\u1dc3\n")
        buf.write("\u0179\3\u0179\3\u0179\5\u0179\u1dc7\n\u0179\3\u0179\5")
        buf.write("\u0179\u1dca\n\u0179\3\u0179\7\u0179\u1dcd\n\u0179\f\u0179")
        buf.write("\16\u0179\u1dd0\13\u0179\3\u017a\3\u017a\3\u017a\3\u017a")
        buf.write("\5\u017a\u1dd6\n\u017a\3\u017b\3\u017b\3\u017b\5\u017b")
        buf.write("\u1ddb\n\u017b\3\u017c\3\u017c\3\u017c\3\u017c\3\u017c")
        buf.write("\3\u017c\5\u017c\u1de3\n\u017c\3\u017d\3\u017d\3\u017d")
        buf.write("\5\u017d\u1de8\n\u017d\3\u017d\5\u017d\u1deb\n\u017d\3")
        buf.write("\u017d\3\u017d\3\u017d\3\u017d\3\u017d\3\u017d\3\u017d")
        buf.write("\3\u017d\3\u017d\7\u017d\u1df6\n\u017d\f\u017d\16\u017d")
        buf.write("\u1df9\13\u017d\3\u017d\3\u017d\5\u017d\u1dfd\n\u017d")
        buf.write("\3\u017d\3\u017d\5\u017d\u1e01\n\u017d\3\u017d\5\u017d")
        buf.write("\u1e04\n\u017d\3\u017d\3\u017d\3\u017d\5\u017d\u1e09\n")
        buf.write("\u017d\3\u017d\5\u017d\u1e0c\n\u017d\3\u017d\3\u017d\3")
        buf.write("\u017d\5\u017d\u1e11\n\u017d\3\u017e\3\u017e\3\u017e\5")
        buf.write("\u017e\u1e16\n\u017e\3\u017e\3\u017e\3\u017f\3\u017f\3")
        buf.write("\u017f\5\u017f\u1e1d\n\u017f\3\u017f\5\u017f\u1e20\n\u017f")
        buf.write("\3\u017f\5\u017f\u1e23\n\u017f\3\u0180\3\u0180\5\u0180")
        buf.write("\u1e27\n\u0180\3\u0180\3\u0180\3\u0180\7\u0180\u1e2c\n")
        buf.write("\u0180\f\u0180\16\u0180\u1e2f\13\u0180\5\u0180\u1e31\n")
        buf.write("\u0180\3\u0180\5\u0180\u1e34\n\u0180\3\u0180\3\u0180\5")
        buf.write("\u0180\u1e38\n\u0180\3\u0180\3\u0180\5\u0180\u1e3c\n\u0180")
        buf.write("\3\u0180\3\u0180\5\u0180\u1e40\n\u0180\3\u0180\3\u0180")
        buf.write("\3\u0180\5\u0180\u1e45\n\u0180\3\u0180\3\u0180\3\u0180")
        buf.write("\3\u0180\5\u0180\u1e4b\n\u0180\5\u0180\u1e4d\n\u0180\3")
        buf.write("\u0181\3\u0181\3\u0182\3\u0182\3\u0182\3\u0182\3\u0182")
        buf.write("\3\u0182\3\u0182\3\u0182\3\u0182\7\u0182\u1e5a\n\u0182")
        buf.write("\f\u0182\16\u0182\u1e5d\13\u0182\3\u0183\3\u0183\3\u0184")
        buf.write("\3\u0184\5\u0184\u1e63\n\u0184\3\u0184\3\u0184\3\u0184")
        buf.write("\3\u0184\3\u0184\3\u0184\5\u0184\u1e6b\n\u0184\3\u0185")
        buf.write("\5\u0185\u1e6e\n\u0185\3\u0185\5\u0185\u1e71\n\u0185\3")
        buf.write("\u0185\3\u0185\3\u0185\3\u0185\3\u0185\5\u0185\u1e78\n")
        buf.write("\u0185\3\u0185\3\u0185\5\u0185\u1e7c\n\u0185\3\u0185\3")
        buf.write("\u0185\5\u0185\u1e80\n\u0185\5\u0185\u1e82\n\u0185\3\u0186")
        buf.write("\3\u0186\3\u0186\3\u0186\3\u0186\3\u0186\5\u0186\u1e8a")
        buf.write("\n\u0186\3\u0186\3\u0186\3\u0186\3\u0186\3\u0186\5\u0186")
        buf.write("\u1e91\n\u0186\3\u0186\3\u0186\3\u0186\3\u0186\3\u0186")
        buf.write("\3\u0186\3\u0186\3\u0186\3\u0186\3\u0186\3\u0186\3\u0186")
        buf.write("\3\u0186\7\u0186\u1ea0\n\u0186\f\u0186\16\u0186\u1ea3")
        buf.write("\13\u0186\3\u0186\3\u0186\5\u0186\u1ea7\n\u0186\3\u0186")
        buf.write("\3\u0186\3\u0186\3\u0186\5\u0186\u1ead\n\u0186\3\u0186")
        buf.write("\3\u0186\3\u0186\3\u0186\5\u0186\u1eb3\n\u0186\3\u0187")
        buf.write("\3\u0187\3\u0187\3\u0187\7\u0187\u1eb9\n\u0187\f\u0187")
        buf.write("\16\u0187\u1ebc\13\u0187\3\u0188\3\u0188\3\u0188\3\u0188")
        buf.write("\3\u0188\3\u0188\3\u0188\3\u0188\3\u0188\7\u0188\u1ec7")
        buf.write("\n\u0188\f\u0188\16\u0188\u1eca\13\u0188\3\u0188\3\u0188")
        buf.write("\5\u0188\u1ece\n\u0188\3\u0188\3\u0188\3\u0188\3\u0189")
        buf.write("\3\u0189\5\u0189\u1ed5\n\u0189\3\u0189\3\u0189\3\u0189")
        buf.write("\3\u0189\7\u0189\u1edb\n\u0189\f\u0189\16\u0189\u1ede")
        buf.write("\13\u0189\3\u0189\3\u0189\3\u0189\6\u0189\u1ee3\n\u0189")
        buf.write("\r\u0189\16\u0189\u1ee4\3\u0189\3\u0189\5\u0189\u1ee9")
        buf.write("\n\u0189\3\u0189\3\u0189\3\u0189\3\u018a\3\u018a\3\u018a")
        buf.write("\3\u018a\5\u018a\u1ef2\n\u018a\3\u018a\2\6\u024c\u024e")
        buf.write("\u0296\u02a2\u018b\2\4\6\b\n\f\16\20\22\24\26\30\32\34")
        buf.write("\36 \"$&(*,.\60\62\64\668:<>@BDFHJLNPRTVXZ\\^`bdfhjln")
        buf.write("prtvxz|~\u0080\u0082\u0084\u0086\u0088\u008a\u008c\u008e")
        buf.write("\u0090\u0092\u0094\u0096\u0098\u009a\u009c\u009e\u00a0")
        buf.write("\u00a2\u00a4\u00a6\u00a8\u00aa\u00ac\u00ae\u00b0\u00b2")
        buf.write("\u00b4\u00b6\u00b8\u00ba\u00bc\u00be\u00c0\u00c2\u00c4")
        buf.write("\u00c6\u00c8\u00ca\u00cc\u00ce\u00d0\u00d2\u00d4\u00d6")
        buf.write("\u00d8\u00da\u00dc\u00de\u00e0\u00e2\u00e4\u00e6\u00e8")
        buf.write("\u00ea\u00ec\u00ee\u00f0\u00f2\u00f4\u00f6\u00f8\u00fa")
        buf.write("\u00fc\u00fe\u0100\u0102\u0104\u0106\u0108\u010a\u010c")
        buf.write("\u010e\u0110\u0112\u0114\u0116\u0118\u011a\u011c\u011e")
        buf.write("\u0120\u0122\u0124\u0126\u0128\u012a\u012c\u012e\u0130")
        buf.write("\u0132\u0134\u0136\u0138\u013a\u013c\u013e\u0140\u0142")
        buf.write("\u0144\u0146\u0148\u014a\u014c\u014e\u0150\u0152\u0154")
        buf.write("\u0156\u0158\u015a\u015c\u015e\u0160\u0162\u0164\u0166")
        buf.write("\u0168\u016a\u016c\u016e\u0170\u0172\u0174\u0176\u0178")
        buf.write("\u017a\u017c\u017e\u0180\u0182\u0184\u0186\u0188\u018a")
        buf.write("\u018c\u018e\u0190\u0192\u0194\u0196\u0198\u019a\u019c")
        buf.write("\u019e\u01a0\u01a2\u01a4\u01a6\u01a8\u01aa\u01ac\u01ae")
        buf.write("\u01b0\u01b2\u01b4\u01b6\u01b8\u01ba\u01bc\u01be\u01c0")
        buf.write("\u01c2\u01c4\u01c6\u01c8\u01ca\u01cc\u01ce\u01d0\u01d2")
        buf.write("\u01d4\u01d6\u01d8\u01da\u01dc\u01de\u01e0\u01e2\u01e4")
        buf.write("\u01e6\u01e8\u01ea\u01ec\u01ee\u01f0\u01f2\u01f4\u01f6")
        buf.write("\u01f8\u01fa\u01fc\u01fe\u0200\u0202\u0204\u0206\u0208")
        buf.write("\u020a\u020c\u020e\u0210\u0212\u0214\u0216\u0218\u021a")
        buf.write("\u021c\u021e\u0220\u0222\u0224\u0226\u0228\u022a\u022c")
        buf.write("\u022e\u0230\u0232\u0234\u0236\u0238\u023a\u023c\u023e")
        buf.write("\u0240\u0242\u0244\u0246\u0248\u024a\u024c\u024e\u0250")
        buf.write("\u0252\u0254\u0256\u0258\u025a\u025c\u025e\u0260\u0262")
        buf.write("\u0264\u0266\u0268\u026a\u026c\u026e\u0270\u0272\u0274")
        buf.write("\u0276\u0278\u027a\u027c\u027e\u0280\u0282\u0284\u0286")
        buf.write("\u0288\u028a\u028c\u028e\u0290\u0292\u0294\u0296\u0298")
        buf.write("\u029a\u029c\u029e\u02a0\u02a2\u02a4\u02a6\u02a8\u02aa")
        buf.write("\u02ac\u02ae\u02b0\u02b2\u02b4\u02b6\u02b8\u02ba\u02bc")
        buf.write("\u02be\u02c0\u02c2\u02c4\u02c6\u02c8\u02ca\u02cc\u02ce")
        buf.write("\u02d0\u02d2\u02d4\u02d6\u02d8\u02da\u02dc\u02de\u02e0")
        buf.write("\u02e2\u02e4\u02e6\u02e8\u02ea\u02ec\u02ee\u02f0\u02f2")
        buf.write("\u02f4\u02f6\u02f8\u02fa\u02fc\u02fe\u0300\u0302\u0304")
        buf.write("\u0306\u0308\u030a\u030c\u030e\u0310\u0312\2o\4\2\u010a")
        buf.write("\u010a\u0127\u0127\6\2\3\3&&\u00da\u00da\u0194\u0194\4")
        buf.write("\2\5\5\u014c\u014c\4\2\u0119\u0119\u014c\u014c\4\2\u0094")
        buf.write("\u0094\u0197\u0197\4\2\u019a\u019a\u019e\u019e\7\2\u00b7")
        buf.write("\u00b7\u00e8\u00e8\u0105\u0105\u0107\u0107\u0178\u0178")
        buf.write("\7\2\67\67rr\u00e1\u00e1\u0102\u0102\u01b6\u01b6\4\2\u0126")
        buf.write("\u0126\u01c3\u01c3\n\2\u0177\u0177\u0179\u0179\u01c7\u01c7")
        buf.write("\u01cf\u01cf\u0216\u0216\u0220\u0220\u0222\u0222\u0228")
        buf.write("\u0228\6\2\u0108\u0108\u012a\u012a\u01e8\u01e8\u0229\u0229")
        buf.write("\t\2\u010d\u010d\u0167\u0168\u0177\u0177\u0179\u0179\u01d4")
        buf.write("\u01d4\u01e3\u01e3\u0219\u0219\4\2\u0177\u0177\u0219\u0219")
        buf.write("\4\2\4\4\u00ce\u00ce\4\2\u0178\u0178\u026c\u026c\4\2_")
        buf.write("_\u00c0\u00c0\4\2\7\7II\4\2DDKK\4\2\r\r\u00d3\u00d3\4")
        buf.write("\2\"\"\u00a6\u00a6\4\2\u008a\u008a\u0117\u0117\6\2XX\u01d6")
        buf.write("\u01d6\u01f1\u01f1\u0208\u0208\4\2<<kk\4\2=={{\5\2\u0210")
        buf.write("\u0210\u0213\u0213\u0225\u0225\4\2\u01b8\u01b8\u024c\u024c")
        buf.write("\4\2\u00d9\u00d9\u01bd\u01bd\4\2\t\t\24\24\4\2II\u00ec")
        buf.write("\u00ec\6\2((CC\u00b2\u00b2\u0106\u0106\4\2\7\7\f\f\6\2")
        buf.write("\u0179\u0179\u020d\u020d\u0214\u0214\u0223\u0224\6\2\u0120")
        buf.write("\u0120\u01e9\u01ea\u01ef\u01ef\u020a\u020a\5\2\n\n__\u00c0")
        buf.write("\u00c0\4\2\u00d6\u00d6\u016d\u016d\4\2rr\u01b6\u01b6\4")
        buf.write("\2\u01eb\u01eb\u0212\u0212\4\2\u01cd\u01cd\u01fc\u01fc")
        buf.write("\4\2\u020b\u020c\u0218\u0218\4\2\u0086\u0086\u00eb\u00eb")
        buf.write("\4\2,,FF\6\2>>yy\u0119\u0119\u01b2\u01b2\4\2\13\13zz\4")
        buf.write("\2\u00f7\u00f7\u014c\u014c\4\2\u0097\u0097\u00a7\u00a7")
        buf.write("\4\2\u019a\u019a\u01b8\u01b8\5\2__\u00c0\u00c0\u00dc\u00dc")
        buf.write("\7\2``\u00c1\u00c1\u00dd\u00dd\u00e8\u00e8\u0103\u0103")
        buf.write("\6\2\n\n__\u00c0\u00c0\u00dc\u00dc\4\2  YY\4\2\u018e\u018e")
        buf.write("\u024c\u024c\6\2\u013c\u013c\u0147\u0147\u019e\u019e\u01bf")
        buf.write("\u01bf\4\2\u0105\u0105\u0107\u0107\5\2\u012f\u012f\u013e")
        buf.write("\u013e\u014e\u014e\3\2\u0257\u0258\4\2\u0207\u0207\u0211")
        buf.write("\u0211\7\2>>yy\u0119\u0119\u0178\u0178\u01b2\u01b2\4\2")
        buf.write("__\u00a8\u00a8\5\2\7\7II\u00ec\u00ec\5\2\61\61\u0108\u0108")
        buf.write("\u0162\u0162\4\2\33\33\u0086\u0086\b\2LL\u00b0\u00b0\u0104")
        buf.write("\u0104\u0106\u0106\u01e9\u01ea\u01ef\u01ef\4\2\u01c5\u01c5")
        buf.write("\u01e7\u01e7\4\2bb\u0086\u0086\5\2\u00c5\u00c5\u01df\u01df")
        buf.write("\u01ee\u01ee\4\2RRpp\n\2%%++;;aaiiss\u00fb\u00fb\u0178")
        buf.write("\u0178\5\2\u00b3\u00b3\u00f0\u00f0\u0168\u0168\4\2>>\u0119")
        buf.write("\u0119\5\2\u0265\u0266\u0268\u0268\u026b\u026b\4\2\u018e")
        buf.write("\u018e\u01a8\u01a8\5\2\u0119\u0119\u01b2\u01b2\u0226\u0226")
        buf.write("\4\2\32\32\u00d6\u00d6\3\2\3\u012d\3\2\u012e\u0160\3\2")
        buf.write("\u0161\u0177\3\2\u0178\u01c3\3\2\u01c4\u024a\3\2\u0132")
        buf.write("\u0133\3\2\u0259\u025b\4\2\u017f\u017f\u01b5\u01b5\4\2")
        buf.write("\u024c\u024c\u0250\u0254\3\2\u026c\u026d\5\2\u0196\u0196")
        buf.write("\u01aa\u01aa\u01ba\u01ba\4\2\u0152\u0152\u0182\u0182\3")
        buf.write("\2\u0263\u0264\7\2\u0134\u0134\u013a\u013b\u0140\u0140")
        buf.write("\u0145\u0145\u0157\u0157\5\2\u0180\u0180\u01a3\u01a3\u01b9")
        buf.write("\u01b9\5\2\u0178\u0178\u017b\u017b\u01b4\u01b4\5\2dd\u00c5")
        buf.write("\u00c5\u00de\u00de\4\2\\\\\u00b9\u00b9\4\2\u0178\u0178")
        buf.write("\u0191\u0191\4\2\u00de\u00de\u014c\u014c\4\2[[\u0098\u0098")
        buf.write("\5\2\u0195\u0195\u01a0\u01a0\u01bb\u01bb\5\2\u0105\u0105")
        buf.write("\u0107\u0107\u0117\u0117\5\2\u0168\u0168\u016e\u016e\u0174")
        buf.write("\u0174\4\2[[\u0081\u0081\4\2\u0102\u0102\u01bd\u01bd\4")
        buf.write("\2--\u00d5\u00d5\5\2\u018e\u018e\u024c\u024c\u0264\u0264")
        buf.write("\4\2\u016b\u016b\u0198\u0198\4\2\63\63\u0248\u0248\4\2")
        buf.write("\u024c\u024c\u0264\u0264\4\2&&\u00da\u00da\7\2\u022e\u022e")
        buf.write("\u0235\u0235\u0239\u023a\u023d\u023d\u0249\u0249\n\2\u00e1")
        buf.write("\u00e1\u0185\u0186\u01b6\u01b6\u022d\u022d\u022f\u022f")
        buf.write("\u0233\u0233\u0238\u0238\u023c\u023c\4\2--\u0234\u0234")
        buf.write("\3\2\u0231\u0232\2\u2465\2\u0315\3\2\2\2\4\u032d\3\2\2")
        buf.write("\2\6\u0331\3\2\2\2\b\u0336\3\2\2\2\n\u0341\3\2\2\2\f\u0351")
        buf.write("\3\2\2\2\16\u0359\3\2\2\2\20\u035f\3\2\2\2\22\u0363\3")
        buf.write("\2\2\2\24\u039e\3\2\2\2\26\u03b3\3\2\2\2\30\u03b5\3\2")
        buf.write("\2\2\32\u03d6\3\2\2\2\34\u03f3\3\2\2\2\36\u0473\3\2\2")
        buf.write("\2 \u0475\3\2\2\2\"\u0493\3\2\2\2$\u0495\3\2\2\2&\u04a4")
        buf.write("\3\2\2\2(\u04ba\3\2\2\2*\u04d1\3\2\2\2,\u04d6\3\2\2\2")
        buf.write(".\u04d8\3\2\2\2\60\u04e0\3\2\2\2\62\u0505\3\2\2\2\64\u050d")
        buf.write("\3\2\2\2\66\u050f\3\2\2\28\u0519\3\2\2\2:\u052c\3\2\2")
        buf.write("\2<\u0531\3\2\2\2>\u0562\3\2\2\2@\u0564\3\2\2\2B\u0589")
        buf.write("\3\2\2\2D\u0598\3\2\2\2F\u05af\3\2\2\2H\u05d0\3\2\2\2")
        buf.write("J\u05d6\3\2\2\2L\u05e5\3\2\2\2N\u0641\3\2\2\2P\u0643\3")
        buf.write("\2\2\2R\u0648\3\2\2\2T\u0651\3\2\2\2V\u06ed\3\2\2\2X\u071e")
        buf.write("\3\2\2\2Z\u0720\3\2\2\2\\\u0742\3\2\2\2^\u0744\3\2\2\2")
        buf.write("`\u0746\3\2\2\2b\u074a\3\2\2\2d\u0754\3\2\2\2f\u0758\3")
        buf.write("\2\2\2h\u0793\3\2\2\2j\u0795\3\2\2\2l\u07ad\3\2\2\2n\u07cb")
        buf.write("\3\2\2\2p\u07cd\3\2\2\2r\u07e0\3\2\2\2t\u081f\3\2\2\2")
        buf.write("v\u0823\3\2\2\2x\u0839\3\2\2\2z\u085c\3\2\2\2|\u0873\3")
        buf.write("\2\2\2~\u088e\3\2\2\2\u0080\u08ba\3\2\2\2\u0082\u08bc")
        buf.write("\3\2\2\2\u0084\u08c8\3\2\2\2\u0086\u08ca\3\2\2\2\u0088")
        buf.write("\u08fc\3\2\2\2\u008a\u0915\3\2\2\2\u008c\u0922\3\2\2\2")
        buf.write("\u008e\u0924\3\2\2\2\u0090\u0956\3\2\2\2\u0092\u097a\3")
        buf.write("\2\2\2\u0094\u0982\3\2\2\2\u0096\u0984\3\2\2\2\u0098\u0988")
        buf.write("\3\2\2\2\u009a\u098c\3\2\2\2\u009c\u09a1\3\2\2\2\u009e")
        buf.write("\u09b0\3\2\2\2\u00a0\u09bb\3\2\2\2\u00a2\u09d2\3\2\2\2")
        buf.write("\u00a4\u09de\3\2\2\2\u00a6\u09e1\3\2\2\2\u00a8\u0a00\3")
        buf.write("\2\2\2\u00aa\u0a16\3\2\2\2\u00ac\u0a35\3\2\2\2\u00ae\u0acc")
        buf.write("\3\2\2\2\u00b0\u0adb\3\2\2\2\u00b2\u0aef\3\2\2\2\u00b4")
        buf.write("\u0b00\3\2\2\2\u00b6\u0b04\3\2\2\2\u00b8\u0b13\3\2\2\2")
        buf.write("\u00ba\u0b2a\3\2\2\2\u00bc\u0b4d\3\2\2\2\u00be\u0b62\3")
        buf.write("\2\2\2\u00c0\u0b74\3\2\2\2\u00c2\u0b76\3\2\2\2\u00c4\u0b85")
        buf.write("\3\2\2\2\u00c6\u0b91\3\2\2\2\u00c8\u0ba3\3\2\2\2\u00ca")
        buf.write("\u0bc9\3\2\2\2\u00cc\u0bcb\3\2\2\2\u00ce\u0bd6\3\2\2\2")
        buf.write("\u00d0\u0bd8\3\2\2\2\u00d2\u0bf9\3\2\2\2\u00d4\u0c10\3")
        buf.write("\2\2\2\u00d6\u0c12\3\2\2\2\u00d8\u0c1a\3\2\2\2\u00da\u0c1e")
        buf.write("\3\2\2\2\u00dc\u0c35\3\2\2\2\u00de\u0c37\3\2\2\2\u00e0")
        buf.write("\u0c48\3\2\2\2\u00e2\u0c4a\3\2\2\2\u00e4\u0c4e\3\2\2\2")
        buf.write("\u00e6\u0c5b\3\2\2\2\u00e8\u0c68\3\2\2\2\u00ea\u0c77\3")
        buf.write("\2\2\2\u00ec\u0c86\3\2\2\2\u00ee\u0c95\3\2\2\2\u00f0\u0caa")
        buf.write("\3\2\2\2\u00f2\u0cb2\3\2\2\2\u00f4\u0cc3\3\2\2\2\u00f6")
        buf.write("\u0cc7\3\2\2\2\u00f8\u0cde\3\2\2\2\u00fa\u0ce7\3\2\2\2")
        buf.write("\u00fc\u0cf5\3\2\2\2\u00fe\u0cf7\3\2\2\2\u0100\u0d05\3")
        buf.write("\2\2\2\u0102\u0d07\3\2\2\2\u0104\u0d1d\3\2\2\2\u0106\u0d2f")
        buf.write("\3\2\2\2\u0108\u0d4d\3\2\2\2\u010a\u0d50\3\2\2\2\u010c")
        buf.write("\u0d60\3\2\2\2\u010e\u0d75\3\2\2\2\u0110\u0d79\3\2\2\2")
        buf.write("\u0112\u0dcb\3\2\2\2\u0114\u0dcd\3\2\2\2\u0116\u0df5\3")
        buf.write("\2\2\2\u0118\u0e14\3\2\2\2\u011a\u0e1f\3\2\2\2\u011c\u0e23")
        buf.write("\3\2\2\2\u011e\u0e4c\3\2\2\2\u0120\u0e4f\3\2\2\2\u0122")
        buf.write("\u0e8d\3\2\2\2\u0124\u0e94\3\2\2\2\u0126\u0eaf\3\2\2\2")
        buf.write("\u0128\u0ee2\3\2\2\2\u012a\u0ee4\3\2\2\2\u012c\u0eec\3")
        buf.write("\2\2\2\u012e\u0ef1\3\2\2\2\u0130\u0f09\3\2\2\2\u0132\u0f20")
        buf.write("\3\2\2\2\u0134\u0f22\3\2\2\2\u0136\u0f29\3\2\2\2\u0138")
        buf.write("\u0f2e\3\2\2\2\u013a\u0f37\3\2\2\2\u013c\u0f3b\3\2\2\2")
        buf.write("\u013e\u0f43\3\2\2\2\u0140\u0fcf\3\2\2\2\u0142\u0ffe\3")
        buf.write("\2\2\2\u0144\u1002\3\2\2\2\u0146\u1010\3\2\2\2\u0148\u1017")
        buf.write("\3\2\2\2\u014a\u101b\3\2\2\2\u014c\u1027\3\2\2\2\u014e")
        buf.write("\u102a\3\2\2\2\u0150\u102d\3\2\2\2\u0152\u1040\3\2\2\2")
        buf.write("\u0154\u1053\3\2\2\2\u0156\u1056\3\2\2\2\u0158\u1060\3")
        buf.write("\2\2\2\u015a\u1063\3\2\2\2\u015c\u1094\3\2\2\2\u015e\u1097")
        buf.write("\3\2\2\2\u0160\u109c\3\2\2\2\u0162\u10a0\3\2\2\2\u0164")
        buf.write("\u10a2\3\2\2\2\u0166\u10ad\3\2\2\2\u0168\u10eb\3\2\2\2")
        buf.write("\u016a\u10ed\3\2\2\2\u016c\u10f7\3\2\2\2\u016e\u1100\3")
        buf.write("\2\2\2\u0170\u1117\3\2\2\2\u0172\u1119\3\2\2\2\u0174\u1130")
        buf.write("\3\2\2\2\u0176\u113c\3\2\2\2\u0178\u1142\3\2\2\2\u017a")
        buf.write("\u115e\3\2\2\2\u017c\u117e\3\2\2\2\u017e\u1180\3\2\2\2")
        buf.write("\u0180\u1190\3\2\2\2\u0182\u119b\3\2\2\2\u0184\u11e0\3")
        buf.write("\2\2\2\u0186\u11e2\3\2\2\2\u0188\u11ec\3\2\2\2\u018a\u11f8")
        buf.write("\3\2\2\2\u018c\u1203\3\2\2\2\u018e\u120a\3\2\2\2\u0190")
        buf.write("\u121e\3\2\2\2\u0192\u1230\3\2\2\2\u0194\u1233\3\2\2\2")
        buf.write("\u0196\u1239\3\2\2\2\u0198\u1247\3\2\2\2\u019a\u124f\3")
        buf.write("\2\2\2\u019c\u1251\3\2\2\2\u019e\u126b\3\2\2\2\u01a0\u1287")
        buf.write("\3\2\2\2\u01a2\u12cd\3\2\2\2\u01a4\u12d1\3\2\2\2\u01a6")
        buf.write("\u12fb\3\2\2\2\u01a8\u12fe\3\2\2\2\u01aa\u1302\3\2\2\2")
        buf.write("\u01ac\u130d\3\2\2\2\u01ae\u1314\3\2\2\2\u01b0\u132a\3")
        buf.write("\2\2\2\u01b2\u132c\3\2\2\2\u01b4\u1349\3\2\2\2\u01b6\u135c")
        buf.write("\3\2\2\2\u01b8\u1363\3\2\2\2\u01ba\u1380\3\2\2\2\u01bc")
        buf.write("\u13a4\3\2\2\2\u01be\u13b3\3\2\2\2\u01c0\u13b5\3\2\2\2")
        buf.write("\u01c2\u13c1\3\2\2\2\u01c4\u13dc\3\2\2\2\u01c6\u13de\3")
        buf.write("\2\2\2\u01c8\u13e9\3\2\2\2\u01ca\u13f9\3\2\2\2\u01cc\u13fe")
        buf.write("\3\2\2\2\u01ce\u1402\3\2\2\2\u01d0\u140e\3\2\2\2\u01d2")
        buf.write("\u1412\3\2\2\2\u01d4\u1417\3\2\2\2\u01d6\u1424\3\2\2\2")
        buf.write("\u01d8\u142c\3\2\2\2\u01da\u142e\3\2\2\2\u01dc\u1443\3")
        buf.write("\2\2\2\u01de\u1451\3\2\2\2\u01e0\u1453\3\2\2\2\u01e2\u1461")
        buf.write("\3\2\2\2\u01e4\u1466\3\2\2\2\u01e6\u14bc\3\2\2\2\u01e8")
        buf.write("\u14cb\3\2\2\2\u01ea\u14da\3\2\2\2\u01ec\u14dc\3\2\2\2")
        buf.write("\u01ee\u14df\3\2\2\2\u01f0\u14ec\3\2\2\2\u01f2\u14f0\3")
        buf.write("\2\2\2\u01f4\u14f8\3\2\2\2\u01f6\u1503\3\2\2\2\u01f8\u1508")
        buf.write("\3\2\2\2\u01fa\u150d\3\2\2\2\u01fc\u1515\3\2\2\2\u01fe")
        buf.write("\u1517\3\2\2\2\u0200\u1520\3\2\2\2\u0202\u1523\3\2\2\2")
        buf.write("\u0204\u152e\3\2\2\2\u0206\u1530\3\2\2\2\u0208\u1537\3")
        buf.write("\2\2\2\u020a\u153b\3\2\2\2\u020c\u154a\3\2\2\2\u020e\u154c")
        buf.write("\3\2\2\2\u0210\u154e\3\2\2\2\u0212\u1558\3\2\2\2\u0214")
        buf.write("\u155a\3\2\2\2\u0216\u155f\3\2\2\2\u0218\u1564\3\2\2\2")
        buf.write("\u021a\u1573\3\2\2\2\u021c\u1584\3\2\2\2\u021e\u1586\3")
        buf.write("\2\2\2\u0220\u1593\3\2\2\2\u0222\u159e\3\2\2\2\u0224\u15a8")
        buf.write("\3\2\2\2\u0226\u15db\3\2\2\2\u0228\u15e0\3\2\2\2\u022a")
        buf.write("\u15e9\3\2\2\2\u022c\u15ee\3\2\2\2\u022e\u15f3\3\2\2\2")
        buf.write("\u0230\u15fa\3\2\2\2\u0232\u15fc\3\2\2\2\u0234\u15fe\3")
        buf.write("\2\2\2\u0236\u1600\3\2\2\2\u0238\u1602\3\2\2\2\u023a\u1604")
        buf.write("\3\2\2\2\u023c\u160b\3\2\2\2\u023e\u160d\3\2\2\2\u0240")
        buf.write("\u1616\3\2\2\2\u0242\u1624\3\2\2\2\u0244\u1685\3\2\2\2")
        buf.write("\u0246\u16a2\3\2\2\2\u0248\u16a4\3\2\2\2\u024a\u16a8\3")
        buf.write("\2\2\2\u024c\u16c9\3\2\2\2\u024e\u176c\3\2\2\2\u0250\u17ae")
        buf.write("\3\2\2\2\u0252\u17b8\3\2\2\2\u0254\u17ba\3\2\2\2\u0256")
        buf.write("\u17d8\3\2\2\2\u0258\u17dd\3\2\2\2\u025a\u17df\3\2\2\2")
        buf.write("\u025c\u17e1\3\2\2\2\u025e\u17e3\3\2\2\2\u0260\u17f6\3")
        buf.write("\2\2\2\u0262\u1828\3\2\2\2\u0264\u182b\3\2\2\2\u0266\u1834")
        buf.write("\3\2\2\2\u0268\u184f\3\2\2\2\u026a\u1851\3\2\2\2\u026c")
        buf.write("\u1861\3\2\2\2\u026e\u1874\3\2\2\2\u0270\u18b9\3\2\2\2")
        buf.write("\u0272\u195c\3\2\2\2\u0274\u195e\3\2\2\2\u0276\u1972\3")
        buf.write("\2\2\2\u0278\u197a\3\2\2\2\u027a\u1980\3\2\2\2\u027c\u198f")
        buf.write("\3\2\2\2\u027e\u19a8\3\2\2\2\u0280\u19aa\3\2\2\2\u0282")
        buf.write("\u19af\3\2\2\2\u0284\u19cb\3\2\2\2\u0286\u19cd\3\2\2\2")
        buf.write("\u0288\u19d6\3\2\2\2\u028a\u19d8\3\2\2\2\u028c\u19dd\3")
        buf.write("\2\2\2\u028e\u1a16\3\2\2\2\u0290\u1a19\3\2\2\2\u0292\u1a22")
        buf.write("\3\2\2\2\u0294\u1a2e\3\2\2\2\u0296\u1a4d\3\2\2\2\u0298")
        buf.write("\u1a67\3\2\2\2\u029a\u1ab0\3\2\2\2\u029c\u1ab2\3\2\2\2")
        buf.write("\u029e\u1aba\3\2\2\2\u02a0\u1ac0\3\2\2\2\u02a2\u1ad1\3")
        buf.write("\2\2\2\u02a4\u1b6f\3\2\2\2\u02a6\u1b72\3\2\2\2\u02a8\u1b82")
        buf.write("\3\2\2\2\u02aa\u1b90\3\2\2\2\u02ac\u1b94\3\2\2\2\u02ae")
        buf.write("\u1ba9\3\2\2\2\u02b0\u1bab\3\2\2\2\u02b2\u1bb4\3\2\2\2")
        buf.write("\u02b4\u1bc5\3\2\2\2\u02b6\u1bcf\3\2\2\2\u02b8\u1bda\3")
        buf.write("\2\2\2\u02ba\u1bdc\3\2\2\2\u02bc\u1be0\3\2\2\2\u02be\u1c02")
        buf.write("\3\2\2\2\u02c0\u1c0d\3\2\2\2\u02c2\u1c18\3\2\2\2\u02c4")
        buf.write("\u1c2b\3\2\2\2\u02c6\u1c2e\3\2\2\2\u02c8\u1c58\3\2\2\2")
        buf.write("\u02ca\u1cb0\3\2\2\2\u02cc\u1cb2\3\2\2\2\u02ce\u1cb8\3")
        buf.write("\2\2\2\u02d0\u1ccb\3\2\2\2\u02d2\u1ce3\3\2\2\2\u02d4\u1ce5")
        buf.write("\3\2\2\2\u02d6\u1cec\3\2\2\2\u02d8\u1cfa\3\2\2\2\u02da")
        buf.write("\u1cfe\3\2\2\2\u02dc\u1d08\3\2\2\2\u02de\u1d33\3\2\2\2")
        buf.write("\u02e0\u1d35\3\2\2\2\u02e2\u1d49\3\2\2\2\u02e4\u1d4b\3")
        buf.write("\2\2\2\u02e6\u1d5a\3\2\2\2\u02e8\u1d66\3\2\2\2\u02ea\u1d79")
        buf.write("\3\2\2\2\u02ec\u1d7d\3\2\2\2\u02ee\u1d88\3\2\2\2\u02f0")
        buf.write("\u1d9b\3\2\2\2\u02f2\u1dd1\3\2\2\2\u02f4\u1dd7\3\2\2\2")
        buf.write("\u02f6\u1de2\3\2\2\2\u02f8\u1e10\3\2\2\2\u02fa\u1e15\3")
        buf.write("\2\2\2\u02fc\u1e22\3\2\2\2\u02fe\u1e4c\3\2\2\2\u0300\u1e4e")
        buf.write("\3\2\2\2\u0302\u1e50\3\2\2\2\u0304\u1e5e\3\2\2\2\u0306")
        buf.write("\u1e6a\3\2\2\2\u0308\u1e81\3\2\2\2\u030a\u1eb2\3\2\2\2")
        buf.write("\u030c\u1eb4\3\2\2\2\u030e\u1ebd\3\2\2\2\u0310\u1ed2\3")
        buf.write("\2\2\2\u0312\u1ef1\3\2\2\2\u0314\u0316\7\u0277\2\2\u0315")
        buf.write("\u0314\3\2\2\2\u0315\u0316\3\2\2\2\u0316\u031a\3\2\2\2")
        buf.write("\u0317\u0319\7\u024e\2\2\u0318\u0317\3\2\2\2\u0319\u031c")
        buf.write("\3\2\2\2\u031a\u0318\3\2\2\2\u031a\u031b\3\2\2\2\u031b")
        buf.write("\u0328\3\2\2\2\u031c\u031a\3\2\2\2\u031d\u0324\5\16\b")
        buf.write("\2\u031e\u0320\7\u024e\2\2\u031f\u031e\3\2\2\2\u0320\u0321")
        buf.write("\3\2\2\2\u0321\u031f\3\2\2\2\u0321\u0322\3\2\2\2\u0322")
        buf.write("\u0325\3\2\2\2\u0323\u0325\7\2\2\3\u0324\u031f\3\2\2\2")
        buf.write("\u0324\u0323\3\2\2\2\u0325\u0327\3\2\2\2\u0326\u031d\3")
        buf.write("\2\2\2\u0327\u032a\3\2\2\2\u0328\u0326\3\2\2\2\u0328\u0329")
        buf.write("\3\2\2\2\u0329\u032b\3\2\2\2\u032a\u0328\3\2\2\2\u032b")
        buf.write("\u032c\7\2\2\3\u032c\3\3\2\2\2\u032d\u032e\5\u0286\u0144")
        buf.write("\2\u032e\u032f\7\2\2\3\u032f\5\3\2\2\2\u0330\u0332\5\u0286")
        buf.write("\u0144\2\u0331\u0330\3\2\2\2\u0331\u0332\3\2\2\2\u0332")
        buf.write("\u0333\3\2\2\2\u0333\u0334\5\u0150\u00a9\2\u0334\u0335")
        buf.write("\7\2\2\3\u0335\7\3\2\2\2\u0336\u033b\5\u024c\u0127\2\u0337")
        buf.write("\u0338\7\u024f\2\2\u0338\u033a\5\u024c\u0127\2\u0339\u0337")
        buf.write("\3\2\2\2\u033a\u033d\3\2\2\2\u033b\u0339\3\2\2\2\u033b")
        buf.write("\u033c\3\2\2\2\u033c\u033e\3\2\2\2\u033d\u033b\3\2\2\2")
        buf.write("\u033e\u033f\7\2\2\3\u033f\t\3\2\2\2\u0340\u0342\5\u02d4")
        buf.write("\u016b\2\u0341\u0340\3\2\2\2\u0341\u0342\3\2\2\2\u0342")
        buf.write("\u0343\3\2\2\2\u0343\u0345\5\u02d6\u016c\2\u0344\u0346")
        buf.write("\7\u024e\2\2\u0345\u0344\3\2\2\2\u0345\u0346\3\2\2\2\u0346")
        buf.write("\u0347\3\2\2\2\u0347\u0348\7\2\2\3\u0348\13\3\2\2\2\u0349")
        buf.write("\u034b\5\u02d4\u016b\2\u034a\u0349\3\2\2\2\u034a\u034b")
        buf.write("\3\2\2\2\u034b\u034c\3\2\2\2\u034c\u034d\5\u02d6\u016c")
        buf.write("\2\u034d\u034e\7\u024e\2\2\u034e\u0350\3\2\2\2\u034f\u034a")
        buf.write("\3\2\2\2\u0350\u0353\3\2\2\2\u0351\u034f\3\2\2\2\u0351")
        buf.write("\u0352\3\2\2\2\u0352\u0354\3\2\2\2\u0353\u0351\3\2\2\2")
        buf.write("\u0354\u0355\7\2\2\3\u0355\r\3\2\2\2\u0356\u035a\5\20")
        buf.write("\t\2\u0357\u035a\5<\37\2\u0358\u035a\5\22\n\2\u0359\u0356")
        buf.write("\3\2\2\2\u0359\u0357\3\2\2\2\u0359\u0358\3\2\2\2\u035a")
        buf.write("\17\3\2\2\2\u035b\u0360\5\u028c\u0147\2\u035c\u0360\5")
        buf.write("\u02bc\u015f\2\u035d\u0360\5\u02c8\u0165\2\u035e\u0360")
        buf.write("\5\u02c6\u0164\2\u035f\u035b\3\2\2\2\u035f\u035c\3\2\2")
        buf.write("\2\u035f\u035d\3\2\2\2\u035f\u035e\3\2\2\2\u0360\21\3")
        buf.write("\2\2\2\u0361\u0364\5\24\13\2\u0362\u0364\5\34\17\2\u0363")
        buf.write("\u0361\3\2\2\2\u0363\u0362\3\2\2\2\u0364\23\3\2\2\2\u0365")
        buf.write("\u0366\7\u00f6\2\2\u0366\u036c\7\u010a\2\2\u0367\u0369")
        buf.write("\7\25\2\2\u0368\u036a\t\2\2\2\u0369\u0368\3\2\2\2\u0369")
        buf.write("\u036a\3\2\2\2\u036a\u036c\3\2\2\2\u036b\u0365\3\2\2\2")
        buf.write("\u036b\u0367\3\2\2\2\u036c\u0375\3\2\2\2\u036d\u0372\5")
        buf.write("\26\f\2\u036e\u036f\7\u024f\2\2\u036f\u0371\5\26\f\2\u0370")
        buf.write("\u036e\3\2\2\2\u0371\u0374\3\2\2\2\u0372\u0370\3\2\2\2")
        buf.write("\u0372\u0373\3\2\2\2\u0373\u0376\3\2\2\2\u0374\u0372\3")
        buf.write("\2\2\2\u0375\u036d\3\2\2\2\u0375\u0376\3\2\2\2\u0376\u039f")
        buf.write("\3\2\2\2\u0377\u0379\t\3\2\2\u0378\u037a\t\2\2\2\u0379")
        buf.write("\u0378\3\2\2\2\u0379\u037a\3\2\2\2\u037a\u0380\3\2\2\2")
        buf.write("\u037b\u037d\7\u017a\2\2\u037c\u037e\7\u009d\2\2\u037d")
        buf.write("\u037c\3\2\2\2\u037d\u037e\3\2\2\2\u037e\u037f\3\2\2\2")
        buf.write("\u037f\u0381\7\35\2\2\u0380\u037b\3\2\2\2\u0380\u0381")
        buf.write("\3\2\2\2\u0381\u039f\3\2\2\2\u0382\u0383\7&\2\2\u0383")
        buf.write("\u0387\7\u00bb\2\2\u0384\u0385\7\u00ba\2\2\u0385\u0387")
        buf.write("\7\u010a\2\2\u0386\u0382\3\2\2\2\u0386\u0384\3\2\2\2\u0387")
        buf.write("\u0388\3\2\2\2\u0388\u039f\7\u0271\2\2\u0389\u038f\7\u00e0")
        buf.write("\2\2\u038a\u038c\7\u00cf\2\2\u038b\u038d\7\u00e0\2\2\u038c")
        buf.write("\u038b\3\2\2\2\u038c\u038d\3\2\2\2\u038d\u038f\3\2\2\2")
        buf.write("\u038e\u0389\3\2\2\2\u038e\u038a\3\2\2\2\u038f\u0390\3")
        buf.write("\2\2\2\u0390\u039f\5\u022c\u0117\2\u0391\u0392\7\u00da")
        buf.write("\2\2\u0392\u0393\7\u00bb\2\2\u0393\u039f\7\u0271\2\2\u0394")
        buf.write("\u0396\7\u00da\2\2\u0395\u0397\t\2\2\2\u0396\u0395\3\2")
        buf.write("\2\2\u0396\u0397\3\2\2\2\u0397\u0398\3\2\2\2\u0398\u039a")
        buf.write("\7\u01b8\2\2\u0399\u039b\7\u00e0\2\2\u039a\u0399\3\2\2")
        buf.write("\2\u039a\u039b\3\2\2\2\u039b\u039c\3\2\2\2\u039c\u039f")
        buf.write("\5\u022c\u0117\2\u039d\u039f\5\30\r\2\u039e\u036b\3\2")
        buf.write("\2\2\u039e\u0377\3\2\2\2\u039e\u0386\3\2\2\2\u039e\u038e")
        buf.write("\3\2\2\2\u039e\u0391\3\2\2\2\u039e\u0394\3\2\2\2\u039e")
        buf.write("\u039d\3\2\2\2\u039f\25\3\2\2\2\u03a0\u03a1\7|\2\2\u03a1")
        buf.write("\u03a9\7\u0083\2\2\u03a2\u03aa\7\u00e9\2\2\u03a3\u03a4")
        buf.write("\7\u00d1\2\2\u03a4\u03aa\7\u00c6\2\2\u03a5\u03a6\7\u00c6")
        buf.write("\2\2\u03a6\u03aa\7\'\2\2\u03a7\u03a8\7\u00c6\2\2\u03a8")
        buf.write("\u03aa\7\u0113\2\2\u03a9\u03a2\3\2\2\2\u03a9\u03a3\3\2")
        buf.write("\2\2\u03a9\u03a5\3\2\2\2\u03a9\u03a7\3\2\2\2\u03aa\u03b4")
        buf.write("\3\2\2\2\u03ab\u03ac\7\u00c6\2\2\u03ac\u03b4\7\u0129\2")
        buf.write("\2\u03ad\u03ae\7\u00c6\2\2\u03ae\u03b4\7\u01ab\2\2\u03af")
        buf.write("\u03b1\7\u01a7\2\2\u03b0\u03af\3\2\2\2\u03b0\u03b1\3\2")
        buf.write("\2\2\u03b1\u03b2\3\2\2\2\u03b2\u03b4\7\u018f\2\2\u03b3")
        buf.write("\u03a0\3\2\2\2\u03b3\u03ab\3\2\2\2\u03b3\u03ad\3\2\2\2")
        buf.write("\u03b3\u03b0\3\2\2\2\u03b4\27\3\2\2\2\u03b5\u03b7\7\u0088")
        buf.write("\2\2\u03b6\u03b8\7\u01b6\2\2\u03b7\u03b6\3\2\2\2\u03b7")
        buf.write("\u03b8\3\2\2\2\u03b8\u03b9\3\2\2\2\u03b9\u03be\5\u0194")
        buf.write("\u00cb\2\u03ba\u03bb\7\u024f\2\2\u03bb\u03bd\5\u0194\u00cb")
        buf.write("\2\u03bc\u03ba\3\2\2\2\u03bd\u03c0\3\2\2\2\u03be\u03bc")
        buf.write("\3\2\2\2\u03be\u03bf\3\2\2\2\u03bf\u03c5\3\2\2\2\u03c0")
        buf.write("\u03be\3\2\2\2\u03c1\u03c2\7\u019e\2\2\u03c2\u03c3\5\32")
        buf.write("\16\2\u03c3\u03c4\7\u0092\2\2\u03c4\u03c6\3\2\2\2\u03c5")
        buf.write("\u03c1\3\2\2\2\u03c5\u03c6\3\2\2\2\u03c6\u03c8\3\2\2\2")
        buf.write("\u03c7\u03c9\7\u00a1\2\2\u03c8\u03c7\3\2\2\2\u03c8\u03c9")
        buf.write("\3\2\2\2\u03c9\31\3\2\2\2\u03ca\u03cb\t\4\2\2\u03cb\u03d7")
        buf.write("\7\u00ee\2\2\u03cc\u03cd\7\u014c\2\2\u03cd\u03d7\7S\2")
        buf.write("\2\u03ce\u03cf\7\u00ee\2\2\u03cf\u03d0\t\5\2\2\u03d0\u03d7")
        buf.write("\7S\2\2\u03d1\u03d7\7\u00ee\2\2\u03d2\u03d4\7\5\2\2\u03d3")
        buf.write("\u03d2\3\2\2\2\u03d3\u03d4\3\2\2\2\u03d4\u03d5\3\2\2\2")
        buf.write("\u03d5\u03d7\7S\2\2\u03d6\u03ca\3\2\2\2\u03d6\u03cc\3")
        buf.write("\2\2\2\u03d6\u03ce\3\2\2\2\u03d6\u03d1\3\2\2\2\u03d6\u03d3")
        buf.write("\3\2\2\2\u03d7\33\3\2\2\2\u03d8\u03f4\5\36\20\2\u03d9")
        buf.write("\u03da\7\u011a\2\2\u03da\u03dc\5\62\32\2\u03db\u03dd\5")
        buf.write(".\30\2\u03dc\u03db\3\2\2\2\u03dc\u03dd\3\2\2\2\u03dd\u03f4")
        buf.write("\3\2\2\2\u03de\u03e0\t\6\2\2\u03df\u03e1\5:\36\2\u03e0")
        buf.write("\u03df\3\2\2\2\u03e0\u03e1\3\2\2\2\u03e1\u03e3\3\2\2\2")
        buf.write("\u03e2\u03e4\t\7\2\2\u03e3\u03e2\3\2\2\2\u03e3\u03e4\3")
        buf.write("\2\2\2\u03e4\u03e5\3\2\2\2\u03e5\u03f4\5\u022c\u0117\2")
        buf.write("\u03e6\u03e9\7!\2\2\u03e7\u03ea\5\u022c\u0117\2\u03e8")
        buf.write("\u03ea\7\u0178\2\2\u03e9\u03e7\3\2\2\2\u03e9\u03e8\3\2")
        buf.write("\2\2\u03ea\u03f4\3\2\2\2\u03eb\u03ec\7\30\2\2\u03ec\u03f4")
        buf.write("\5\u0262\u0132\2\u03ed\u03ee\7E\2\2\u03ee\u03f4\t\b\2")
        buf.write("\2\u03ef\u03f4\5&\24\2\u03f0\u03f4\5$\23\2\u03f1\u03f4")
        buf.write("\5 \21\2\u03f2\u03f4\5(\25\2\u03f3\u03d8\3\2\2\2\u03f3")
        buf.write("\u03d9\3\2\2\2\u03f3\u03de\3\2\2\2\u03f3\u03e6\3\2\2\2")
        buf.write("\u03f3\u03eb\3\2\2\2\u03f3\u03ed\3\2\2\2\u03f3\u03ef\3")
        buf.write("\2\2\2\u03f3\u03f0\3\2\2\2\u03f3\u03f1\3\2\2\2\u03f3\u03f2")
        buf.write("\3\2\2\2\u03f4\35\3\2\2\2\u03f5\u0474\5\u02d2\u016a\2")
        buf.write("\u03f6\u03f7\7\u0084\2\2\u03f7\u0474\5\u022c\u0117\2\u03f8")
        buf.write("\u03fb\7\u0116\2\2\u03f9\u03fc\5\u022c\u0117\2\u03fa\u03fc")
        buf.write("\7\u0259\2\2\u03fb\u03f9\3\2\2\2\u03fb\u03fa\3\2\2\2\u03fc")
        buf.write("\u0474\3\2\2\2\u03fd\u040a\7\u0179\2\2\u03fe\u03ff\7\u0255")
        buf.write("\2\2\u03ff\u0404\5\66\34\2\u0400\u0401\7\u024f\2\2\u0401")
        buf.write("\u0403\5\66\34\2\u0402\u0400\3\2\2\2\u0403\u0406\3\2\2")
        buf.write("\2\u0404\u0402\3\2\2\2\u0404\u0405\3\2\2\2\u0405\u0407")
        buf.write("\3\2\2\2\u0406\u0404\3\2\2\2\u0407\u0408\7\u0256\2\2\u0408")
        buf.write("\u040b\3\2\2\2\u0409\u040b\7\u0177\2\2\u040a\u03fe\3\2")
        buf.write("\2\2\u040a\u0409\3\2\2\2\u040a\u040b\3\2\2\2\u040b\u040d")
        buf.write("\3\2\2\2\u040c\u040e\5.\30\2\u040d\u040c\3\2\2\2\u040d")
        buf.write("\u040e\3\2\2\2\u040e\u0474\3\2\2\2\u040f\u0411\7\"\2\2")
        buf.write("\u0410\u0412\7\u0177\2\2\u0411\u0410\3\2\2\2\u0411\u0412")
        buf.write("\3\2\2\2\u0412\u041c\3\2\2\2\u0413\u0414\5\u022c\u0117")
        buf.write("\2\u0414\u0415\7\u01aa\2\2\u0415\u0416\5\u0286\u0144\2")
        buf.write("\u0416\u041d\3\2\2\2\u0417\u041a\5\u0286\u0144\2\u0418")
        buf.write("\u0419\7\u01be\2\2\u0419\u041b\5\u022c\u0117\2\u041a\u0418")
        buf.write("\3\2\2\2\u041a\u041b\3\2\2\2\u041b\u041d\3\2\2\2\u041c")
        buf.write("\u0413\3\2\2\2\u041c\u0417\3\2\2\2\u041c\u041d\3\2\2\2")
        buf.write("\u041d\u0474\3\2\2\2\u041e\u0474\7\37\2\2\u041f\u0420")
        buf.write("\7\u0085\2\2\u0420\u0474\7\u0271\2\2\u0421\u0423\79\2")
        buf.write("\2\u0422\u0424\7\u00ba\2\2\u0423\u0422\3\2\2\2\u0423\u0424")
        buf.write("\3\2\2\2\u0424\u0427\3\2\2\2\u0425\u0428\5\u022c\u0117")
        buf.write("\2\u0426\u0428\7\u0178\2\2\u0427\u0425\3\2\2\2\u0427\u0426")
        buf.write("\3\2\2\2\u0428\u0474\3\2\2\2\u0429\u042d\7\u00cd\2\2\u042a")
        buf.write("\u042b\7\u0255\2\2\u042b\u042c\7\u0177\2\2\u042c\u042e")
        buf.write("\7\u0256\2\2\u042d\u042a\3\2\2\2\u042d\u042e\3\2\2\2\u042e")
        buf.write("\u042f\3\2\2\2\u042f\u0431\t\t\2\2\u0430\u0432\7\u0164")
        buf.write("\2\2\u0431\u0430\3\2\2\2\u0431\u0432\3\2\2\2\u0432\u0433")
        buf.write("\3\2\2\2\u0433\u0474\5\u0286\u0144\2\u0434\u0440\7\u00d4")
        buf.write("\2\2\u0435\u0436\5\u022c\u0117\2\u0436\u0437\7\u025d\2")
        buf.write("\2\u0437\u0439\3\2\2\2\u0438\u0435\3\2\2\2\u0438\u0439")
        buf.write("\3\2\2\2\u0439\u043a\3\2\2\2\u043a\u0441\5\u022c\u0117")
        buf.write("\2\u043b\u043c\7\u0150\2\2\u043c\u0441\7\u012d\2\2\u043d")
        buf.write("\u043e\7\u00eb\2\2\u043e\u0441\7\u0161\2\2\u043f\u0441")
        buf.write("\7\u0178\2\2\u0440\u0438\3\2\2\2\u0440\u043b\3\2\2\2\u0440")
        buf.write("\u043d\3\2\2\2\u0440\u043f\3\2\2\2\u0441\u0474\3\2\2\2")
        buf.write("\u0442\u0443\7\u00cc\2\2\u0443\u0444\7\u008d\2\2\u0444")
        buf.write("\u0446\7\u0121\2\2\u0445\u0447\7\u0164\2\2\u0446\u0445")
        buf.write("\3\2\2\2\u0446\u0447\3\2\2\2\u0447\u0448\3\2\2\2\u0448")
        buf.write("\u044e\5\u0286\u0144\2\u0449\u044b\7\u01c3\2\2\u044a\u044c")
        buf.write("\7\u009d\2\2\u044b\u044a\3\2\2\2\u044b\u044c\3\2\2\2\u044c")
        buf.write("\u044d\3\2\2\2\u044d\u044f\7\66\2\2\u044e\u0449\3\2\2")
        buf.write("\2\u044e\u044f\3\2\2\2\u044f\u0474\3\2\2\2\u0450\u0451")
        buf.write("\7\u00ba\2\2\u0451\u045d\5\u022c\u0117\2\u0452\u0453\7")
        buf.write("\u0255\2\2\u0453\u0458\5\u0240\u0121\2\u0454\u0455\7\u024f")
        buf.write("\2\2\u0455\u0457\5\u0240\u0121\2\u0456\u0454\3\2\2\2\u0457")
        buf.write("\u045a\3\2\2\2\u0458\u0456\3\2\2\2\u0458\u0459\3\2\2\2")
        buf.write("\u0459\u045b\3\2\2\2\u045a\u0458\3\2\2\2\u045b\u045c\7")
        buf.write("\u0256\2\2\u045c\u045e\3\2\2\2\u045d\u0452\3\2\2\2\u045d")
        buf.write("\u045e\3\2\2\2\u045e\u045f\3\2\2\2\u045f\u0460\7\u017d")
        buf.write("\2\2\u0460\u0461\5\20\t\2\u0461\u0474\3\2\2\2\u0462\u0463")
        buf.write("\7\u00c7\2\2\u0463\u0464\7\u00af\2\2\u0464\u0465\7\26")
        buf.write("\2\2\u0465\u046a\5,\27\2\u0466\u0467\7\u024f\2\2\u0467")
        buf.write("\u0469\5,\27\2\u0468\u0466\3\2\2\2\u0469\u046c\3\2\2\2")
        buf.write("\u046a\u0468\3\2\2\2\u046a\u046b\3\2\2\2\u046b\u046d\3")
        buf.write("\2\2\2\u046c\u046a\3\2\2\2\u046d\u046e\7\u01b8\2\2\u046e")
        buf.write("\u046f\5,\27\2\u046f\u0474\3\2\2\2\u0470\u0474\5\u019a")
        buf.write("\u00ce\2\u0471\u0474\5\u02ce\u0168\2\u0472\u0474\5\u02cc")
        buf.write("\u0167\2\u0473\u03f5\3\2\2\2\u0473\u03f6\3\2\2\2\u0473")
        buf.write("\u03f8\3\2\2\2\u0473\u03fd\3\2\2\2\u0473\u040f\3\2\2\2")
        buf.write("\u0473\u041e\3\2\2\2\u0473\u041f\3\2\2\2\u0473\u0421\3")
        buf.write("\2\2\2\u0473\u0429\3\2\2\2\u0473\u0434\3\2\2\2\u0473\u0442")
        buf.write("\3\2\2\2\u0473\u0450\3\2\2\2\u0473\u0462\3\2\2\2\u0473")
        buf.write("\u0470\3\2\2\2\u0473\u0471\3\2\2\2\u0473\u0472\3\2\2\2")
        buf.write("\u0474\37\3\2\2\2\u0475\u0487\7U\2\2\u0476\u0478\7\u0179")
        buf.write("\2\2\u0477\u0476\3\2\2\2\u0477\u0478\3\2\2\2\u0478\u047a")
        buf.write("\3\2\2\2\u0479\u047b\7\u0177\2\2\u047a\u0479\3\2\2\2\u047a")
        buf.write("\u047b\3\2\2\2\u047b\u0488\3\2\2\2\u047c\u047d\7\u0255")
        buf.write("\2\2\u047d\u0482\5*\26\2\u047e\u047f\7\u024f\2\2\u047f")
        buf.write("\u0481\5*\26\2\u0480\u047e\3\2\2\2\u0481\u0484\3\2\2\2")
        buf.write("\u0482\u0480\3\2\2\2\u0482\u0483\3\2\2\2\u0483\u0485\3")
        buf.write("\2\2\2\u0484\u0482\3\2\2\2\u0485\u0486\7\u0256\2\2\u0486")
        buf.write("\u0488\3\2\2\2\u0487\u0477\3\2\2\2\u0487\u047c\3\2\2\2")
        buf.write("\u0488\u0489\3\2\2\2\u0489\u048a\5\"\22\2\u048a!\3\2\2")
        buf.write("\2\u048b\u0494\5\20\t\2\u048c\u0494\5$\23\2\u048d\u0494")
        buf.write("\5&\24\2\u048e\u0491\7\u0187\2\2\u048f\u0492\5\u01ba\u00de")
        buf.write("\2\u0490\u0492\5\u01a4\u00d3\2\u0491\u048f\3\2\2\2\u0491")
        buf.write("\u0490\3\2\2\2\u0492\u0494\3\2\2\2\u0493\u048b\3\2\2\2")
        buf.write("\u0493\u048c\3\2\2\2\u0493\u048d\3\2\2\2\u0493\u048e\3")
        buf.write("\2\2\2\u0494#\3\2\2\2\u0495\u0496\7T\2\2\u0496\u04a2\5")
        buf.write("\u022c\u0117\2\u0497\u0498\7\u0255\2\2\u0498\u049d\5\u024c")
        buf.write("\u0127\2\u0499\u049a\7\u024f\2\2\u049a\u049c\5\u024c\u0127")
        buf.write("\2\u049b\u0499\3\2\2\2\u049c\u049f\3\2\2\2\u049d\u049b")
        buf.write("\3\2\2\2\u049d\u049e\3\2\2\2\u049e\u04a0\3\2\2\2\u049f")
        buf.write("\u049d\3\2\2\2\u04a0\u04a1\7\u0256\2\2\u04a1\u04a3\3\2")
        buf.write("\2\2\u04a2\u0497\3\2\2\2\u04a2\u04a3\3\2\2\2\u04a3%\3")
        buf.write("\2\2\2\u04a4\u04a5\7:\2\2\u04a5\u04a7\5\u022c\u0117\2")
        buf.write("\u04a6\u04a8\7\u0162\2\2\u04a7\u04a6\3\2\2\2\u04a7\u04a8")
        buf.write("\3\2\2\2\u04a8\u04aa\3\2\2\2\u04a9\u04ab\7x\2\2\u04aa")
        buf.write("\u04a9\3\2\2\2\u04aa\u04ab\3\2\2\2\u04ab\u04b0\3\2\2\2")
        buf.write("\u04ac\u04ae\7\u009d\2\2\u04ad\u04ac\3\2\2\2\u04ad\u04ae")
        buf.write("\3\2\2\2\u04ae\u04af\3\2\2\2\u04af\u04b1\7\u00e3\2\2\u04b0")
        buf.write("\u04ad\3\2\2\2\u04b0\u04b1\3\2\2\2\u04b1\u04b2\3\2\2\2")
        buf.write("\u04b2\u04b5\7\64\2\2\u04b3\u04b4\t\n\2\2\u04b4\u04b6")
        buf.write("\7g\2\2\u04b5\u04b3\3\2\2\2\u04b5\u04b6\3\2\2\2\u04b6")
        buf.write("\u04b7\3\2\2\2\u04b7\u04b8\7\u0198\2\2\u04b8\u04b9\5\u028c")
        buf.write("\u0147\2\u04b9\'\3\2\2\2\u04ba\u04c9\7\u00ef\2\2\u04bb")
        buf.write("\u04bc\5\u022c\u0117\2\u04bc\u04bd\7\u025d\2\2\u04bd\u04bf")
        buf.write("\3\2\2\2\u04be\u04bb\3\2\2\2\u04be\u04bf\3\2\2\2\u04bf")
        buf.write("\u04c0\3\2\2\2\u04c0\u04ca\5\u022c\u0117\2\u04c1\u04ca")
        buf.write("\7\u0178\2\2\u04c2\u04c3\7\u0150\2\2\u04c3\u04ca\7\u012d")
        buf.write("\2\2\u04c4\u04c5\7\u010a\2\2\u04c5\u04c6\7|\2\2\u04c6")
        buf.write("\u04ca\7\u0083\2\2\u04c7\u04c8\7\u00eb\2\2\u04c8\u04ca")
        buf.write("\7\u0161\2\2\u04c9\u04be\3\2\2\2\u04c9\u04c1\3\2\2\2\u04c9")
        buf.write("\u04c2\3\2\2\2\u04c9\u04c4\3\2\2\2\u04c9\u04c7\3\2\2\2")
        buf.write("\u04ca)\3\2\2\2\u04cb\u04cd\t\13\2\2\u04cc\u04ce\58\35")
        buf.write("\2\u04cd\u04cc\3\2\2\2\u04cd\u04ce\3\2\2\2\u04ce\u04d2")
        buf.write("\3\2\2\2\u04cf\u04d0\7\u01dd\2\2\u04d0\u04d2\t\f\2\2\u04d1")
        buf.write("\u04cb\3\2\2\2\u04d1\u04cf\3\2\2\2\u04d2+\3\2\2\2\u04d3")
        buf.write("\u04d7\5\u022c\u0117\2\u04d4\u04d7\7\u018d\2\2\u04d5\u04d7")
        buf.write("\7\u01b3\2\2\u04d6\u04d3\3\2\2\2\u04d6\u04d4\3\2\2\2\u04d6")
        buf.write("\u04d5\3\2\2\2\u04d7-\3\2\2\2\u04d8\u04dd\5\60\31\2\u04d9")
        buf.write("\u04da\7\u024f\2\2\u04da\u04dc\5\60\31\2\u04db\u04d9\3")
        buf.write("\2\2\2\u04dc\u04df\3\2\2\2\u04dd\u04db\3\2\2\2\u04dd\u04de")
        buf.write("\3\2\2\2\u04de/\3\2\2\2\u04df\u04dd\3\2\2\2\u04e0\u04ec")
        buf.write("\5\u0286\u0144\2\u04e1\u04e2\7\u0255\2\2\u04e2\u04e7\5")
        buf.write("\u022c\u0117\2\u04e3\u04e4\7\u024f\2\2\u04e4\u04e6\5\u022c")
        buf.write("\u0117\2\u04e5\u04e3\3\2\2\2\u04e6\u04e9\3\2\2\2\u04e7")
        buf.write("\u04e5\3\2\2\2\u04e7\u04e8\3\2\2\2\u04e8\u04ea\3\2\2\2")
        buf.write("\u04e9\u04e7\3\2\2\2\u04ea\u04eb\7\u0256\2\2\u04eb\u04ed")
        buf.write("\3\2\2\2\u04ec\u04e1\3\2\2\2\u04ec\u04ed\3\2\2\2\u04ed")
        buf.write("\61\3\2\2\2\u04ee\u04ef\7\u0255\2\2\u04ef\u04f4\5\64\33")
        buf.write("\2\u04f0\u04f1\7\u024f\2\2\u04f1\u04f3\5\64\33\2\u04f2")
        buf.write("\u04f0\3\2\2\2\u04f3\u04f6\3\2\2\2\u04f4\u04f2\3\2\2\2")
        buf.write("\u04f4\u04f5\3\2\2\2\u04f5\u04f7\3\2\2\2\u04f6\u04f4\3")
        buf.write("\2\2\2\u04f7\u04f8\7\u0256\2\2\u04f8\u0506\3\2\2\2\u04f9")
        buf.write("\u04fb\7\u0168\2\2\u04fa\u04f9\3\2\2\2\u04fa\u04fb\3\2")
        buf.write("\2\2\u04fb\u04fd\3\2\2\2\u04fc\u04fe\7\u0167\2\2\u04fd")
        buf.write("\u04fc\3\2\2\2\u04fd\u04fe\3\2\2\2\u04fe\u0500\3\2\2\2")
        buf.write("\u04ff\u0501\7\u0177\2\2\u0500\u04ff\3\2\2\2\u0500\u0501")
        buf.write("\3\2\2\2\u0501\u0503\3\2\2\2\u0502\u0504\7\u0179\2\2\u0503")
        buf.write("\u0502\3\2\2\2\u0503\u0504\3\2\2\2\u0504\u0506\3\2\2\2")
        buf.write("\u0505\u04ee\3\2\2\2\u0505\u04fa\3\2\2\2\u0506\63\3\2")
        buf.write("\2\2\u0507\u0509\t\r\2\2\u0508\u050a\58\35\2\u0509\u0508")
        buf.write("\3\2\2\2\u0509\u050a\3\2\2\2\u050a\u050e\3\2\2\2\u050b")
        buf.write("\u050c\7\u00b1\2\2\u050c\u050e\7\u026c\2\2\u050d\u0507")
        buf.write("\3\2\2\2\u050d\u050b\3\2\2\2\u050e\65\3\2\2\2\u050f\u0511")
        buf.write("\t\16\2\2\u0510\u0512\58\35\2\u0511\u0510\3\2\2\2\u0511")
        buf.write("\u0512\3\2\2\2\u0512\67\3\2\2\2\u0513\u051a\7\u01ba\2")
        buf.write("\2\u0514\u051a\7\u0196\2\2\u0515\u051a\7\u00a5\2\2\u0516")
        buf.write("\u051a\7\u01aa\2\2\u0517\u051a\7\u026c\2\2\u0518\u051a")
        buf.write("\5\u0154\u00ab\2\u0519\u0513\3\2\2\2\u0519\u0514\3\2\2")
        buf.write("\2\u0519\u0515\3\2\2\2\u0519\u0516\3\2\2\2\u0519\u0517")
        buf.write("\3\2\2\2\u0519\u0518\3\2\2\2\u051a9\3\2\2\2\u051b\u052d")
        buf.write("\7\u0098\2\2\u051c\u052d\7\u00bd\2\2\u051d\u052d\7[\2")
        buf.write("\2\u051e\u052d\7\u0081\2\2\u051f\u0521\t\17\2\2\u0520")
        buf.write("\u051f\3\2\2\2\u0520\u0521\3\2\2\2\u0521\u0522\3\2\2\2")
        buf.write("\u0522\u052d\5\u015e\u00b0\2\u0523\u052d\7\u0178\2\2\u0524")
        buf.write("\u0526\7^\2\2\u0525\u0527\t\20\2\2\u0526\u0525\3\2\2\2")
        buf.write("\u0526\u0527\3\2\2\2\u0527\u052d\3\2\2\2\u0528\u052a\7")
        buf.write("\23\2\2\u0529\u052b\t\20\2\2\u052a\u0529\3\2\2\2\u052a")
        buf.write("\u052b\3\2\2\2\u052b\u052d\3\2\2\2\u052c\u051b\3\2\2\2")
        buf.write("\u052c\u051c\3\2\2\2\u052c\u051d\3\2\2\2\u052c\u051e\3")
        buf.write("\2\2\2\u052c\u0520\3\2\2\2\u052c\u0523\3\2\2\2\u052c\u0524")
        buf.write("\3\2\2\2\u052c\u0528\3\2\2\2\u052d;\3\2\2\2\u052e\u0532")
        buf.write("\5> \2\u052f\u0532\5@!\2\u0530\u0532\5B\"\2\u0531\u052e")
        buf.write("\3\2\2\2\u0531\u052f\3\2\2\2\u0531\u0530\3\2\2\2\u0532")
        buf.write("=\3\2\2\2\u0533\u055b\7\u0187\2\2\u0534\u055c\5\u00f0")
        buf.write("y\2\u0535\u055c\5\u0110\u0089\2\u0536\u055c\5\u0172\u00ba")
        buf.write("\2\u0537\u055c\5\u00bc_\2\u0538\u055c\5\u018a\u00c6\2")
        buf.write("\u0539\u055c\5\u01ae\u00d8\2\u053a\u055c\5\u00aeX\2\u053b")
        buf.write("\u055c\5\u00aaV\2\u053c\u055c\5\u00a6T\2\u053d\u055c\5")
        buf.write("\u0106\u0084\2\u053e\u055c\5\u01bc\u00df\2\u053f\u055c")
        buf.write("\5\u00b6\\\2\u0540\u055c\5\u00b2Z\2\u0541\u055c\5\u00ba")
        buf.write("^\2\u0542\u055c\5\u00b8]\2\u0543\u055c\5\u0144\u00a3\2")
        buf.write("\u0544\u055c\5\u00fe\u0080\2\u0545\u055c\5\u009aN\2\u0546")
        buf.write("\u055c\5\u00a8U\2\u0547\u055c\5\u0182\u00c2\2\u0548\u055c")
        buf.write("\5\u0176\u00bc\2\u0549\u055c\5\u010a\u0086\2\u054a\u055c")
        buf.write("\5\u0166\u00b4\2\u054b\u055c\5\u018e\u00c8\2\u054c\u055c")
        buf.write("\5\u011c\u008f\2\u054d\u055c\5\u0164\u00b3\2\u054e\u055c")
        buf.write("\5\u015a\u00ae\2\u054f\u055c\5\u00b0Y\2\u0550\u055c\5")
        buf.write("\u0104\u0083\2\u0551\u055c\5\u016c\u00b7\2\u0552\u055c")
        buf.write("\5\u01ba\u00de\2\u0553\u055c\5\u01b8\u00dd\2\u0554\u055c")
        buf.write("\5\u0102\u0082\2\u0555\u055c\5\u00eex\2\u0556\u055c\5")
        buf.write("\u0120\u0091\2\u0557\u055c\5\u00acW\2\u0558\u055c\5\u00c2")
        buf.write("b\2\u0559\u055c\5\u00f2z\2\u055a\u055c\5\u01a4\u00d3\2")
        buf.write("\u055b\u0534\3\2\2\2\u055b\u0535\3\2\2\2\u055b\u0536\3")
        buf.write("\2\2\2\u055b\u0537\3\2\2\2\u055b\u0538\3\2\2\2\u055b\u0539")
        buf.write("\3\2\2\2\u055b\u053a\3\2\2\2\u055b\u053b\3\2\2\2\u055b")
        buf.write("\u053c\3\2\2\2\u055b\u053d\3\2\2\2\u055b\u053e\3\2\2\2")
        buf.write("\u055b\u053f\3\2\2\2\u055b\u0540\3\2\2\2\u055b\u0541\3")
        buf.write("\2\2\2\u055b\u0542\3\2\2\2\u055b\u0543\3\2\2\2\u055b\u0544")
        buf.write("\3\2\2\2\u055b\u0545\3\2\2\2\u055b\u0546\3\2\2\2\u055b")
        buf.write("\u0547\3\2\2\2\u055b\u0548\3\2\2\2\u055b\u0549\3\2\2\2")
        buf.write("\u055b\u054a\3\2\2\2\u055b\u054b\3\2\2\2\u055b\u054c\3")
        buf.write("\2\2\2\u055b\u054d\3\2\2\2\u055b\u054e\3\2\2\2\u055b\u054f")
        buf.write("\3\2\2\2\u055b\u0550\3\2\2\2\u055b\u0551\3\2\2\2\u055b")
        buf.write("\u0552\3\2\2\2\u055b\u0553\3\2\2\2\u055b\u0554\3\2\2\2")
        buf.write("\u055b\u0555\3\2\2\2\u055b\u0556\3\2\2\2\u055b\u0557\3")
        buf.write("\2\2\2\u055b\u0558\3\2\2\2\u055b\u0559\3\2\2\2\u055b\u055a")
        buf.write("\3\2\2\2\u055c\u0563\3\2\2\2\u055d\u0563\5\u013c\u009f")
        buf.write("\2\u055e\u0563\5\u0126\u0094\2\u055f\u0563\5D#\2\u0560")
        buf.write("\u0563\5\u013e\u00a0\2\u0561\u0563\5\u0114\u008b\2\u0562")
        buf.write("\u0533\3\2\2\2\u0562\u055d\3\2\2\2\u0562\u055e\3\2\2\2")
        buf.write("\u0562\u055f\3\2\2\2\u0562\u0560\3\2\2\2\u0562\u0561\3")
        buf.write("\2\2\2\u0563?\3\2\2\2\u0564\u0587\7\f\2\2\u0565\u0588")
        buf.write("\5H%\2\u0566\u0588\5\u00be`\2\u0567\u0588\5\u018c\u00c7")
        buf.write("\2\u0568\u0588\5p9\2\u0569\u0588\5\u01b2\u00da\2\u056a")
        buf.write("\u0588\5\u0088E\2\u056b\u0588\5\u0082B\2\u056c\u0588\5")
        buf.write("J&\2\u056d\u0588\5\u00dan\2\u056e\u0588\5\u008eH\2\u056f")
        buf.write("\u0588\5F$\2\u0570\u0588\5\u00ccg\2\u0571\u0588\5l\67")
        buf.write("\2\u0572\u0588\5R*\2\u0573\u0588\5|?\2\u0574\u0588\5\u0186")
        buf.write("\u00c4\2\u0575\u0588\5\u0178\u00bd\2\u0576\u0588\5\u00de")
        buf.write("p\2\u0577\u0588\5\u00d2j\2\u0578\u0588\5\u0168\u00b5\2")
        buf.write("\u0579\u0588\5\u0190\u00c9\2\u057a\u0588\5\u0198\u00cd")
        buf.write("\2\u057b\u0588\5P)\2\u057c\u0588\5v<\2\u057d\u0588\5\u008a")
        buf.write("F\2\u057e\u0588\5\u00d6l\2\u057f\u0588\5\u016e\u00b8\2")
        buf.write("\u0580\u0588\5T+\2\u0581\u0588\5\u00d0i\2\u0582\u0588")
        buf.write("\5\u0196\u00cc\2\u0583\u0588\5\u0086D\2\u0584\u0588\5")
        buf.write("\u00c4c\2\u0585\u0588\5\u00c6d\2\u0586\u0588\5x=\2\u0587")
        buf.write("\u0565\3\2\2\2\u0587\u0566\3\2\2\2\u0587\u0567\3\2\2\2")
        buf.write("\u0587\u0568\3\2\2\2\u0587\u0569\3\2\2\2\u0587\u056a\3")
        buf.write("\2\2\2\u0587\u056b\3\2\2\2\u0587\u056c\3\2\2\2\u0587\u056d")
        buf.write("\3\2\2\2\u0587\u056e\3\2\2\2\u0587\u056f\3\2\2\2\u0587")
        buf.write("\u0570\3\2\2\2\u0587\u0571\3\2\2\2\u0587\u0572\3\2\2\2")
        buf.write("\u0587\u0573\3\2\2\2\u0587\u0574\3\2\2\2\u0587\u0575\3")
        buf.write("\2\2\2\u0587\u0576\3\2\2\2\u0587\u0577\3\2\2\2\u0587\u0578")
        buf.write("\3\2\2\2\u0587\u0579\3\2\2\2\u0587\u057a\3\2\2\2\u0587")
        buf.write("\u057b\3\2\2\2\u0587\u057c\3\2\2\2\u0587\u057d\3\2\2\2")
        buf.write("\u0587\u057e\3\2\2\2\u0587\u057f\3\2\2\2\u0587\u0580\3")
        buf.write("\2\2\2\u0587\u0581\3\2\2\2\u0587\u0582\3\2\2\2\u0587\u0583")
        buf.write("\3\2\2\2\u0587\u0584\3\2\2\2\u0587\u0585\3\2\2\2\u0587")
        buf.write("\u0586\3\2\2\2\u0588A\3\2\2\2\u0589\u0596\7I\2\2\u058a")
        buf.write("\u0597\5\u0174\u00bb\2\u058b\u0597\5\u021e\u0110\2\u058c")
        buf.write("\u0597\5\u0220\u0111\2\u058d\u0597\5\u0188\u00c5\2\u058e")
        buf.write("\u0597\5\u0180\u00c1\2\u058f\u0597\5\u00e8u\2\u0590\u0597")
        buf.write("\5\u00e6t\2\u0591\u0597\5\u016a\u00b6\2\u0592\u0597\5")
        buf.write("\u0224\u0113\2\u0593\u0597\5\u0226\u0114\2\u0594\u0597")
        buf.write("\5\u0222\u0112\2\u0595\u0597\5\u00e4s\2\u0596\u058a\3")
        buf.write("\2\2\2\u0596\u058b\3\2\2\2\u0596\u058c\3\2\2\2\u0596\u058d")
        buf.write("\3\2\2\2\u0596\u058e\3\2\2\2\u0596\u058f\3\2\2\2\u0596")
        buf.write("\u0590\3\2\2\2\u0596\u0591\3\2\2\2\u0596\u0592\3\2\2\2")
        buf.write("\u0596\u0593\3\2\2\2\u0596\u0594\3\2\2\2\u0596\u0595\3")
        buf.write("\2\2\2\u0597C\3\2\2\2\u0598\u0599\7n\2\2\u0599\u059a\7")
        buf.write("\u0199\2\2\u059a\u059b\7\u00e1\2\2\u059b\u05a5\5\u022c")
        buf.write("\u0117\2\u059c\u059d\7\u01a4\2\2\u059d\u05a0\7\u01b8\2")
        buf.write("\2\u059e\u05a0\7\u0195\2\2\u059f\u059c\3\2\2\2\u059f\u059e")
        buf.write("\3\2\2\2\u05a0\u05a1\3\2\2\2\u05a1\u05a2\7\u0255\2\2\u05a2")
        buf.write("\u05a3\5\u02d0\u0169\2\u05a3\u05a4\7\u0256\2\2\u05a4\u05a6")
        buf.write("\3\2\2\2\u05a5\u059f\3\2\2\2\u05a5\u05a6\3\2\2\2\u05a6")
        buf.write("\u05a7\3\2\2\2\u05a7\u05a8\7\u019a\2\2\u05a8\u05a9\7\u00ea")
        buf.write("\2\2\u05a9\u05aa\5\u022c\u0117\2\u05aa\u05ab\7\u01a1\2")
        buf.write("\2\u05ab\u05ad\5\u022c\u0117\2\u05ac\u05ae\5\u01d4\u00eb")
        buf.write("\2\u05ad\u05ac\3\2\2\2\u05ad\u05ae\3\2\2\2\u05aeE\3\2")
        buf.write("\2\2\u05af\u05b1\t\21\2\2\u05b0\u05b2\5\u014e\u00a8\2")
        buf.write("\u05b1\u05b0\3\2\2\2\u05b1\u05b2\3\2\2\2\u05b2\u05ce\3")
        buf.write("\2\2\2\u05b3\u05bf\5h\65\2\u05b4\u05bc\7\u00d4\2\2\u05b5")
        buf.write("\u05b6\5\u022c\u0117\2\u05b6\u05b7\7\u025d\2\2\u05b7\u05b9")
        buf.write("\3\2\2\2\u05b8\u05b5\3\2\2\2\u05b8\u05b9\3\2\2\2\u05b9")
        buf.write("\u05ba\3\2\2\2\u05ba\u05bd\5\u022c\u0117\2\u05bb\u05bd")
        buf.write("\7\u0178\2\2\u05bc\u05b8\3\2\2\2\u05bc\u05bb\3\2\2\2\u05bd")
        buf.write("\u05bf\3\2\2\2\u05be\u05b3\3\2\2\2\u05be\u05b4\3\2\2\2")
        buf.write("\u05bf\u05c0\3\2\2\2\u05c0\u05be\3\2\2\2\u05c0\u05c1\3")
        buf.write("\2\2\2\u05c1\u05c3\3\2\2\2\u05c2\u05c4\7\u00d6\2\2\u05c3")
        buf.write("\u05c2\3\2\2\2\u05c3\u05c4\3\2\2\2\u05c4\u05cf\3\2\2\2")
        buf.write("\u05c5\u05cf\5\u0208\u0105\2\u05c6\u05cf\5\u020a\u0106")
        buf.write("\2\u05c7\u05c9\7\u009d\2\2\u05c8\u05c7\3\2\2\2\u05c8\u05c9")
        buf.write("\3\2\2\2\u05c9\u05ca\3\2\2\2\u05ca\u05cb\7A\2\2\u05cb")
        buf.write("\u05cc\7\u01aa\2\2\u05cc\u05cd\7W\2\2\u05cd\u05cf\5\u022c")
        buf.write("\u0117\2\u05ce\u05be\3\2\2\2\u05ce\u05c5\3\2\2\2\u05ce")
        buf.write("\u05c6\3\2\2\2\u05ce\u05c8\3\2\2\2\u05cfG\3\2\2\2\u05d0")
        buf.write("\u05d1\7\n\2\2\u05d1\u05d4\5\u014e\u00a8\2\u05d2\u05d5")
        buf.write("\5\u0208\u0105\2\u05d3\u05d5\5\u020a\u0106\2\u05d4\u05d2")
        buf.write("\3\2\2\2\u05d4\u05d3\3\2\2\2\u05d5I\3\2\2\2\u05d6\u05d7")
        buf.write("\7W\2\2\u05d7\u05d8\5\u022c\u0117\2\u05d8\u05d9\5L\'\2")
        buf.write("\u05d9K\3\2\2\2\u05da\u05e6\5\u020a\u0106\2\u05db\u05e1")
        buf.write("\7\u0119\2\2\u05dc\u05df\7\u01b8\2\2\u05dd\u05e0\5\u022c")
        buf.write("\u0117\2\u05de\u05e0\5\u0154\u00ab\2\u05df\u05dd\3\2\2")
        buf.write("\2\u05df\u05de\3\2\2\2\u05e0\u05e2\3\2\2\2\u05e1\u05dc")
        buf.write("\3\2\2\2\u05e1\u05e2\3\2\2\2\u05e2\u05e6\3\2\2\2\u05e3")
        buf.write("\u05e4\t\22\2\2\u05e4\u05e6\5N(\2\u05e5\u05da\3\2\2\2")
        buf.write("\u05e5\u05db\3\2\2\2\u05e5\u05e3\3\2\2\2\u05e6M\3\2\2")
        buf.write("\2\u05e7\u05e8\7\5\2\2\u05e8\u05e9\7\u008f\2\2\u05e9\u0642")
        buf.write("\5\u0286\u0144\2\u05ea\u05eb\7\n\2\2\u05eb\u0642\5\u014e")
        buf.write("\u00a8\2\u05ec\u05ed\7\u0182\2\2\u05ed\u05ee\7\u0255\2")
        buf.write("\2\u05ee\u05ef\5\u0286\u0144\2\u05ef\u05f0\7\u017d\2\2")
        buf.write("\u05f0\u05f1\5\u0286\u0144\2\u05f1\u05f2\7\u0256\2\2\u05f2")
        buf.write("\u0642\3\2\2\2\u05f3\u05f4\7\u0163\2\2\u05f4\u0642\5\u022c")
        buf.write("\u0117\2\u05f5\u05f6\7.\2\2\u05f6\u0642\5\u022c\u0117")
        buf.write("\2\u05f7\u05f8\7G\2\2\u05f8\u0642\5\u0286\u0144\2\u05f9")
        buf.write("\u05fa\7P\2\2\u05fa\u05fb\7\u010c\2\2\u05fb\u0642\5\u022c")
        buf.write("\u0117\2\u05fc\u05fd\7\u0199\2\2\u05fd\u05fe\7\66\2\2")
        buf.write("\u05fe\u05ff\7\u0128\2\2\u05ff\u0642\5\u022c\u0117\2\u0600")
        buf.write("\u0601\7\u0199\2\2\u0601\u0602\7\u01b6\2\2\u0602\u0642")
        buf.write("\5\u0286\u0144\2\u0603\u0604\7_\2\2\u0604\u0642\5\u014e")
        buf.write("\u00a8\2\u0605\u0607\7\u008d\2\2\u0606\u0605\3\2\2\2\u0606")
        buf.write("\u0607\3\2\2\2\u0607\u0608\3\2\2\2\u0608\u0609\7\u0121")
        buf.write("\2\2\u0609\u0642\5\u0286\u0144\2\u060a\u060b\7\u00a8\2")
        buf.write("\2\u060b\u0642\5\u010c\u0087\2\u060c\u060d\7\u00a8\2\2")
        buf.write("\u060d\u060e\7 \2\2\u060e\u060f\5\u0286\u0144\2\u060f")
        buf.write("\u0610\7\u01be\2\2\u0610\u0611\5\u022c\u0117\2\u0611\u0642")
        buf.write("\3\2\2\2\u0612\u0613\7\u00a8\2\2\u0613\u0614\7Y\2\2\u0614")
        buf.write("\u0615\5\u0286\u0144\2\u0615\u0616\7\u01be\2\2\u0616\u0617")
        buf.write("\5\u022c\u0117\2\u0617\u0642\3\2\2\2\u0618\u061a\7\u00bf")
        buf.write("\2\2\u0619\u0618\3\2\2\2\u0619\u061a\3\2\2\2\u061a\u061b")
        buf.write("\3\2\2\2\u061b\u061c\7\177\2\2\u061c\u0642\5\u022c\u0117")
        buf.write("\2\u061d\u061e\7\u00c0\2\2\u061e\u0642\5\u014e\u00a8\2")
        buf.write("\u061f\u0620\7\u00dc\2\2\u0620\u0642\5\u014e\u00a8\2\u0621")
        buf.write("\u0622\7\u00e1\2\2\u0622\u0642\5\u022c\u0117\2\u0623\u0624")
        buf.write("\7\u00e7\2\2\u0624\u0642\5\u0286\u0144\2\u0625\u0626\7")
        buf.write("\u00ea\2\2\u0626\u0642\5\u022c\u0117\2\u0627\u0628\7\u01b6")
        buf.write("\2\2\u0628\u0642\5\u0286\u0144\2\u0629\u062a\7\u0108\2")
        buf.write("\2\u062a\u062b\7\u00e4\2\2\u062b\u062c\7(\2\2\u062c\u0642")
        buf.write("\5\u0286\u0144\2\u062d\u062e\7\u0108\2\2\u062e\u062f\7")
        buf.write("\u00e4\2\2\u062f\u0630\7C\2\2\u0630\u0642\5\u0286\u0144")
        buf.write("\2\u0631\u0632\7\u0108\2\2\u0632\u0633\7\u00e4\2\2\u0633")
        buf.write("\u0634\7\u00b2\2\2\u0634\u0642\5\u0286\u0144\2\u0635\u0636")
        buf.write("\7\u0108\2\2\u0636\u0637\7\u00e4\2\2\u0637\u0638\7\u0106")
        buf.write("\2\2\u0638\u0642\5\u0286\u0144\2\u0639\u063a\7\u010b\2")
        buf.write("\2\u063a\u063b\7\u0198\2\2\u063b\u063c\5\u022c\u0117\2")
        buf.write("\u063c\u063d\7\177\2\2\u063d\u063e\5\u022c\u0117\2\u063e")
        buf.write("\u0642\3\2\2\2\u063f\u0640\7\u010f\2\2\u0640\u0642\5\u0286")
        buf.write("\u0144\2\u0641\u05e7\3\2\2\2\u0641\u05ea\3\2\2\2\u0641")
        buf.write("\u05ec\3\2\2\2\u0641\u05f3\3\2\2\2\u0641\u05f5\3\2\2\2")
        buf.write("\u0641\u05f7\3\2\2\2\u0641\u05f9\3\2\2\2\u0641\u05fc\3")
        buf.write("\2\2\2\u0641\u0600\3\2\2\2\u0641\u0603\3\2\2\2\u0641\u0606")
        buf.write("\3\2\2\2\u0641\u060a\3\2\2\2\u0641\u060c\3\2\2\2\u0641")
        buf.write("\u0612\3\2\2\2\u0641\u0619\3\2\2\2\u0641\u061d\3\2\2\2")
        buf.write("\u0641\u061f\3\2\2\2\u0641\u0621\3\2\2\2\u0641\u0623\3")
        buf.write("\2\2\2\u0641\u0625\3\2\2\2\u0641\u0627\3\2\2\2\u0641\u0629")
        buf.write("\3\2\2\2\u0641\u062d\3\2\2\2\u0641\u0631\3\2\2\2\u0641")
        buf.write("\u0635\3\2\2\2\u0641\u0639\3\2\2\2\u0641\u063f\3\2\2\2")
        buf.write("\u0642O\3\2\2\2\u0643\u0644\7\u00e1\2\2\u0644\u0645\5")
        buf.write("\u022c\u0117\2\u0645\u0646\5\u0208\u0105\2\u0646Q\3\2")
        buf.write("\2\2\u0647\u0649\7\u00bf\2\2\u0648\u0647\3\2\2\2\u0648")
        buf.write("\u0649\3\2\2\2\u0649\u064a\3\2\2\2\u064a\u064b\7\177\2")
        buf.write("\2\u064b\u064e\5\u022c\u0117\2\u064c\u064f\5\u0208\u0105")
        buf.write("\2\u064d\u064f\5\u0206\u0104\2\u064e\u064c\3\2\2\2\u064e")
        buf.write("\u064d\3\2\2\2\u064fS\3\2\2\2\u0650\u0652\7\u0199\2\2")
        buf.write("\u0651\u0650\3\2\2\2\u0651\u0652\3\2\2\2\u0652\u0653\3")
        buf.write("\2\2\2\u0653\u0655\7\u01b6\2\2\u0654\u0656\5\u01a6\u00d4")
        buf.write("\2\u0655\u0654\3\2\2\2\u0655\u0656\3\2\2\2\u0656\u0658")
        buf.write("\3\2\2\2\u0657\u0659\7\u01ab\2\2\u0658\u0657\3\2\2\2\u0658")
        buf.write("\u0659\3\2\2\2\u0659\u065a\3\2\2\2\u065a\u065c\5\u0286")
        buf.write("\u0144\2\u065b\u065d\7\u0259\2\2\u065c\u065b\3\2\2\2\u065c")
        buf.write("\u065d\3\2\2\2\u065d\u067e\3\2\2\2\u065e\u0663\5V,\2\u065f")
        buf.write("\u0660\7\u024f\2\2\u0660\u0662\5V,\2\u0661\u065f\3\2\2")
        buf.write("\2\u0662\u0665\3\2\2\2\u0663\u0661\3\2\2\2\u0663\u0664")
        buf.write("\3\2\2\2\u0664\u067f\3\2\2\2\u0665\u0663\3\2\2\2\u0666")
        buf.write("\u0668\7\u00d0\2\2\u0667\u0669\7\u0185\2\2\u0668\u0667")
        buf.write("\3\2\2\2\u0668\u0669\3\2\2\2\u0669\u066a\3\2\2\2\u066a")
        buf.write("\u066b\5\u022c\u0117\2\u066b\u066c\7\u01b8\2\2\u066c\u066d")
        buf.write("\5\u022c\u0117\2\u066d\u067f\3\2\2\2\u066e\u067f\5\u020a")
        buf.write("\u0106\2\u066f\u067f\5\u0208\u0105\2\u0670\u0671\7\u00d0")
        buf.write("\2\2\u0671\u0672\7\u0186\2\2\u0672\u0673\5\u022c\u0117")
        buf.write("\2\u0673\u0674\7\u01b8\2\2\u0674\u0675\5\u022c\u0117\2")
        buf.write("\u0675\u067f\3\2\2\2\u0676\u0677\7\21\2\2\u0677\u0678")
        buf.write("\7\u00b4\2\2\u0678\u0679\5\u0286\u0144\2\u0679\u067a\5")
        buf.write("\u01c2\u00e2\2\u067a\u067f\3\2\2\2\u067b\u067c\7B\2\2")
        buf.write("\u067c\u067d\7\u00b4\2\2\u067d\u067f\5\u0286\u0144\2\u067e")
        buf.write("\u065e\3\2\2\2\u067e\u0666\3\2\2\2\u067e\u066e\3\2\2\2")
        buf.write("\u067e\u066f\3\2\2\2\u067e\u0670\3\2\2\2\u067e\u0676\3")
        buf.write("\2\2\2\u067e\u067b\3\2\2\2\u067fU\3\2\2\2\u0680\u0682")
        buf.write("\7\7\2\2\u0681\u0683\7\u0185\2\2\u0682\u0681\3\2\2\2\u0682")
        buf.write("\u0683\3\2\2\2\u0683\u0685\3\2\2\2\u0684\u0686\5\u01a8")
        buf.write("\u00d5\2\u0685\u0684\3\2\2\2\u0685\u0686\3\2\2\2\u0686")
        buf.write("\u0687\3\2\2\2\u0687\u06ee\5\u01e0\u00f1\2\u0688\u068a")
        buf.write("\7I\2\2\u0689\u068b\7\u0185\2\2\u068a\u0689\3\2\2\2\u068a")
        buf.write("\u068b\3\2\2\2\u068b\u068d\3\2\2\2\u068c\u068e\5\u01a6")
        buf.write("\u00d4\2\u068d\u068c\3\2\2\2\u068d\u068e\3\2\2\2\u068e")
        buf.write("\u068f\3\2\2\2\u068f\u0691\5\u022c\u0117\2\u0690\u0692")
        buf.write("\5\u0212\u010a\2\u0691\u0690\3\2\2\2\u0691\u0692\3\2\2")
        buf.write("\2\u0692\u06ee\3\2\2\2\u0693\u0695\7\f\2\2\u0694\u0696")
        buf.write("\7\u0185\2\2\u0695\u0694\3\2\2\2\u0695\u0696\3\2\2\2\u0696")
        buf.write("\u0697\3\2\2\2\u0697\u0698\5\u022c\u0117\2\u0698\u0699")
        buf.write("\5X-\2\u0699\u06ee\3\2\2\2\u069a\u069b\7\7\2\2\u069b\u069e")
        buf.write("\5\u01e4\u00f3\2\u069c\u069d\7\u01a7\2\2\u069d\u069f\7")
        buf.write("\u011b\2\2\u069e\u069c\3\2\2\2\u069e\u069f\3\2\2\2\u069f")
        buf.write("\u06ee\3\2\2\2\u06a0\u06ee\5`\61\2\u06a1\u06ee\5b\62\2")
        buf.write("\u06a2\u06a3\t\23\2\2\u06a3\u06a7\7\u010c\2\2\u06a4\u06a8")
        buf.write("\5\u0286\u0144\2\u06a5\u06a8\7\u0178\2\2\u06a6\u06a8\7")
        buf.write("\u01bd\2\2\u06a7\u06a4\3\2\2\2\u06a7\u06a5\3\2\2\2\u06a7")
        buf.write("\u06a6\3\2\2\2\u06a7\u06a8\3\2\2\2\u06a8\u06ee\3\2\2\2")
        buf.write("\u06a9\u06aa\7K\2\2\u06aa\u06ab\t\24\2\2\u06ab\u06ac\7")
        buf.write("\u010c\2\2\u06ac\u06ee\5\u0286\u0144\2\u06ad\u06ae\t\23")
        buf.write("\2\2\u06ae\u06af\7\u00df\2\2\u06af\u06ee\5\u0286\u0144")
        buf.write("\2\u06b0\u06b1\7K\2\2\u06b1\u06b2\t\24\2\2\u06b2\u06b3")
        buf.write("\7\u00df\2\2\u06b3\u06ee\5\u0286\u0144\2\u06b4\u06b5\t")
        buf.write("\23\2\2\u06b5\u06b6\7\u014c\2\2\u06b6\u06b7\7\u0083\2")
        buf.write("\2\u06b7\u06ee\7\u00e6\2\2\u06b8\u06ba\7\u009d\2\2\u06b9")
        buf.write("\u06b8\3\2\2\2\u06b9\u06ba\3\2\2\2\u06ba\u06bb\3\2\2\2")
        buf.write("\u06bb\u06bc\7]\2\2\u06bc\u06bd\7\u014c\2\2\u06bd\u06be")
        buf.write("\7\u0083\2\2\u06be\u06ee\7\u00e6\2\2\u06bf\u06c0\7\"\2")
        buf.write("\2\u06c0\u06c1\7\u01aa\2\2\u06c1\u06ee\5\u0286\u0144\2")
        buf.write("\u06c2\u06c3\7\u00ec\2\2\u06c3\u06c4\7\u0126\2\2\u06c4")
        buf.write("\u06ee\t\25\2\2\u06c5\u06c6\7\u00ec\2\2\u06c6\u06c7\7")
        buf.write("\u01c3\2\2\u06c7\u06ee\7\u00a6\2\2\u06c8\u06c9\7\u00ec")
        buf.write("\2\2\u06c9\u06ee\t\26\2\2\u06ca\u06cb\7\u00ec\2\2\u06cb")
        buf.write("\u06ee\5\u01f4\u00fb\2\u06cc\u06cd\7\u00d4\2\2\u06cd\u06ee")
        buf.write("\5\u01f0\u00f9\2\u06ce\u06ee\5\u01d4\u00eb\2\u06cf\u06d0")
        buf.write("\7t\2\2\u06d0\u06ee\5\u0286\u0144\2\u06d1\u06d2\7\u009d")
        buf.write("\2\2\u06d2\u06d3\7t\2\2\u06d3\u06ee\5\u0286\u0144\2\u06d4")
        buf.write("\u06d5\7\u00a4\2\2\u06d5\u06ee\5\u0286\u0144\2\u06d6\u06d7")
        buf.write("\7\u01a7\2\2\u06d7\u06ee\7\u00a4\2\2\u06d8\u06ee\5\u0206")
        buf.write("\u0104\2\u06d9\u06ee\5\u0202\u0102\2\u06da\u06db\7\u00d3")
        buf.write("\2\2\u06db\u06e2\7i\2\2\u06dc\u06e3\7\u018e\2\2\u06dd")
        buf.write("\u06e3\7\u0168\2\2\u06de\u06e3\7\u009f\2\2\u06df\u06e0")
        buf.write("\7\u01be\2\2\u06e0\u06e1\7r\2\2\u06e1\u06e3\5\u022c\u0117")
        buf.write("\2\u06e2\u06dc\3\2\2\2\u06e2\u06dd\3\2\2\2\u06e2\u06de")
        buf.write("\3\2\2\2\u06e2\u06df\3\2\2\2\u06e3\u06ee\3\2\2\2\u06e4")
        buf.write("\u06e5\7\f\2\2\u06e5\u06e6\7\u0186\2\2\u06e6\u06e8\5\u022c")
        buf.write("\u0117\2\u06e7\u06e9\5d\63\2\u06e8\u06e7\3\2\2\2\u06e8")
        buf.write("\u06e9\3\2\2\2\u06e9\u06eb\3\2\2\2\u06ea\u06ec\5f\64\2")
        buf.write("\u06eb\u06ea\3\2\2\2\u06eb\u06ec\3\2\2\2\u06ec\u06ee\3")
        buf.write("\2\2\2\u06ed\u0680\3\2\2\2\u06ed\u0688\3\2\2\2\u06ed\u0693")
        buf.write("\3\2\2\2\u06ed\u069a\3\2\2\2\u06ed\u06a0\3\2\2\2\u06ed")
        buf.write("\u06a1\3\2\2\2\u06ed\u06a2\3\2\2\2\u06ed\u06a9\3\2\2\2")
        buf.write("\u06ed\u06ad\3\2\2\2\u06ed\u06b0\3\2\2\2\u06ed\u06b4\3")
        buf.write("\2\2\2\u06ed\u06b9\3\2\2\2\u06ed\u06bf\3\2\2\2\u06ed\u06c2")
        buf.write("\3\2\2\2\u06ed\u06c5\3\2\2\2\u06ed\u06c8\3\2\2\2\u06ed")
        buf.write("\u06ca\3\2\2\2\u06ed\u06cc\3\2\2\2\u06ed\u06ce\3\2\2\2")
        buf.write("\u06ed\u06cf\3\2\2\2\u06ed\u06d1\3\2\2\2\u06ed\u06d4\3")
        buf.write("\2\2\2\u06ed\u06d6\3\2\2\2\u06ed\u06d8\3\2\2\2\u06ed\u06d9")
        buf.write("\3\2\2\2\u06ed\u06da\3\2\2\2\u06ed\u06e4\3\2\2\2\u06ee")
        buf.write("W\3\2\2\2\u06ef\u06f0\7\u00ec\2\2\u06f0\u06f2\7\66\2\2")
        buf.write("\u06f1\u06ef\3\2\2\2\u06f1\u06f2\3\2\2\2\u06f2\u06f3\3")
        buf.write("\2\2\2\u06f3\u06f4\7\u010f\2\2\u06f4\u06f6\5\u0240\u0121")
        buf.write("\2\u06f5\u06f7\5\u0214\u010b\2\u06f6\u06f5\3\2\2\2\u06f6")
        buf.write("\u06f7\3\2\2\2\u06f7\u06fa\3\2\2\2\u06f8\u06f9\7\u01be")
        buf.write("\2\2\u06f9\u06fb\5\u024c\u0127\2\u06fa\u06f8\3\2\2\2\u06fa")
        buf.write("\u06fb\3\2\2\2\u06fb\u071f\3\2\2\2\u06fc\u06fd\7\7\2\2")
        buf.write("\u06fd\u071f\5Z.\2\u06fe\u071f\5\u0096L\2\u06ff\u071f")
        buf.write("\5\u0098M\2\u0700\u0703\7\u00ec\2\2\u0701\u0703\7I\2\2")
        buf.write("\u0702\u0700\3\2\2\2\u0702\u0701\3\2\2\2\u0703\u0704\3")
        buf.write("\2\2\2\u0704\u0705\7\u01a7\2\2\u0705\u071f\7\u01a8\2\2")
        buf.write("\u0706\u0707\7I\2\2\u0707\u0709\7i\2\2\u0708\u070a\5\u01a6")
        buf.write("\u00d4\2\u0709\u0708\3\2\2\2\u0709\u070a\3\2\2\2\u070a")
        buf.write("\u071f\3\2\2\2\u070b\u070c\7I\2\2\u070c\u070e\7V\2\2\u070d")
        buf.write("\u070f\5\u01a6\u00d4\2\u070e\u070d\3\2\2\2\u070e\u070f")
        buf.write("\3\2\2\2\u070f\u071f\3\2\2\2\u0710\u0711\7\u00ec\2\2\u0711")
        buf.write("\u071f\5\u01f4\u00fb\2\u0712\u071f\5\u00d8m\2\u0713\u0714")
        buf.write("\7\u00ec\2\2\u0714\u0715\7\u00fb\2\2\u0715\u071f\5^\60")
        buf.write("\2\u0716\u0717\7\u00d4\2\2\u0717\u071f\5\u01f0\u00f9\2")
        buf.write("\u0718\u071f\5\u01d4\u00eb\2\u0719\u071b\5\\/\2\u071a")
        buf.write("\u0719\3\2\2\2\u071b\u071c\3\2\2\2\u071c\u071a\3\2\2\2")
        buf.write("\u071c\u071d\3\2\2\2\u071d\u071f\3\2\2\2\u071e\u06f1\3")
        buf.write("\2\2\2\u071e\u06fc\3\2\2\2\u071e\u06fe\3\2\2\2\u071e\u06ff")
        buf.write("\3\2\2\2\u071e\u0702\3\2\2\2\u071e\u0706\3\2\2\2\u071e")
        buf.write("\u070b\3\2\2\2\u071e\u0710\3\2\2\2\u071e\u0712\3\2\2\2")
        buf.write("\u071e\u0713\3\2\2\2\u071e\u0716\3\2\2\2\u071e\u0718\3")
        buf.write("\2\2\2\u071e\u071a\3\2\2\2\u071fY\3\2\2\2\u0720\u0724")
        buf.write("\7a\2\2\u0721\u0725\7\r\2\2\u0722\u0723\7\26\2\2\u0723")
        buf.write("\u0725\7\u018e\2\2\u0724\u0721\3\2\2\2\u0724\u0722\3\2")
        buf.write("\2\2\u0725\u0726\3\2\2\2\u0726\u0727\7\u017d\2\2\u0727")
        buf.write("\u0730\7i\2\2\u0728\u072a\7\u0255\2\2\u0729\u072b\5\u015c")
        buf.write("\u00af\2\u072a\u0729\3\2\2\2\u072b\u072c\3\2\2\2\u072c")
        buf.write("\u072a\3\2\2\2\u072c\u072d\3\2\2\2\u072d\u072e\3\2\2\2")
        buf.write("\u072e\u072f\7\u0256\2\2\u072f\u0731\3\2\2\2\u0730\u0728")
        buf.write("\3\2\2\2\u0730\u0731\3\2\2\2\u0731[\3\2\2\2\u0732\u0733")
        buf.write("\7\u00ec\2\2\u0733\u0737\7a\2\2\u0734\u0738\7\r\2\2\u0735")
        buf.write("\u0736\7\26\2\2\u0736\u0738\7\u018e\2\2\u0737\u0734\3")
        buf.write("\2\2\2\u0737\u0735\3\2\2\2\u0738\u0743\3\2\2\2\u0739\u073a")
        buf.write("\7\u00ec\2\2\u073a\u0743\5\u015c\u00af\2\u073b\u0740\7")
        buf.write("\u00d5\2\2\u073c\u073e\7\u01c3\2\2\u073d\u073c\3\2\2\2")
        buf.write("\u073d\u073e\3\2\2\2\u073e\u073f\3\2\2\2\u073f\u0741\7")
        buf.write("\u026c\2\2\u0740\u073d\3\2\2\2\u0740\u0741\3\2\2\2\u0741")
        buf.write("\u0743\3\2\2\2\u0742\u0732\3\2\2\2\u0742\u0739\3\2\2\2")
        buf.write("\u0742\u073b\3\2\2\2\u0743]\3\2\2\2\u0744\u0745\t\27\2")
        buf.write("\2\u0745_\3\2\2\2\u0746\u0747\7\u011c\2\2\u0747\u0748")
        buf.write("\7\u0186\2\2\u0748\u0749\5\u0286\u0144\2\u0749a\3\2\2")
        buf.write("\2\u074a\u074b\7I\2\2\u074b\u074d\7\u0186\2\2\u074c\u074e")
        buf.write("\5\u01a6\u00d4\2\u074d\u074c\3\2\2\2\u074d\u074e\3\2\2")
        buf.write("\2\u074e\u074f\3\2\2\2\u074f\u0751\5\u022c\u0117\2\u0750")
        buf.write("\u0752\5\u0212\u010a\2\u0751\u0750\3\2\2\2\u0751\u0752")
        buf.write("\3\2\2\2\u0752c\3\2\2\2\u0753\u0755\7\u01a7\2\2\u0754")
        buf.write("\u0753\3\2\2\2\u0754\u0755\3\2\2\2\u0755\u0756\3\2\2\2")
        buf.write("\u0756\u0757\7\u018f\2\2\u0757e\3\2\2\2\u0758\u0759\7")
        buf.write("\u019f\2\2\u0759\u075a\t\30\2\2\u075ag\3\2\2\2\u075b\u075f")
        buf.write("\7\31\2\2\u075c\u075d\7\u00d7\2\2\u075d\u075f\7\u01a8")
        buf.write("\2\2\u075e\u075b\3\2\2\2\u075e\u075c\3\2\2\2\u075f\u0760")
        buf.write("\3\2\2\2\u0760\u0761\7\u01aa\2\2\u0761\u0762\7\u01a8\2")
        buf.write("\2\u0762\u0794\7w\2\2\u0763\u0764\7\u010b\2\2\u0764\u0769")
        buf.write("\5\u0148\u00a5\2\u0765\u0766\7\u024f\2\2\u0766\u0768\5")
        buf.write("\u0148\u00a5\2\u0767\u0765\3\2\2\2\u0768\u076b\3\2\2\2")
        buf.write("\u0769\u0767\3\2\2\2\u0769\u076a\3\2\2\2\u076a\u0794\3")
        buf.write("\2\2\2\u076b\u0769\3\2\2\2\u076c\u0794\7\u00fd\2\2\u076d")
        buf.write("\u0794\7l\2\2\u076e\u0794\7\u0123\2\2\u076f\u0794\7\u00f4")
        buf.write("\2\2\u0770\u0772\7\u01a7\2\2\u0771\u0770\3\2\2\2\u0771")
        buf.write("\u0772\3\2\2\2\u0772\u0773\3\2\2\2\u0773\u0794\7\u0082")
        buf.write("\2\2\u0774\u0776\7X\2\2\u0775\u0774\3\2\2\2\u0775\u0776")
        buf.write("\3\2\2\2\u0776\u0777\3\2\2\2\u0777\u0778\7\u00e6\2\2\u0778")
        buf.write("\u0794\t\31\2\2\u0779\u077a\7\u00b1\2\2\u077a\u0794\t")
        buf.write("\32\2\2\u077b\u077c\7\60\2\2\u077c\u0794\5\u025a\u012e")
        buf.write("\2\u077d\u077e\7\u00de\2\2\u077e\u0794\5\u025a\u012e\2")
        buf.write("\u077f\u0780\7\u0100\2\2\u0780\u0794\5\u0286\u0144\2\u0781")
        buf.write("\u0785\7\u00ec\2\2\u0782\u0783\5\u022c\u0117\2\u0783\u0784")
        buf.write("\7\u025d\2\2\u0784\u0786\3\2\2\2\u0785\u0782\3\2\2\2\u0785")
        buf.write("\u0786\3\2\2\2\u0786\u0787\3\2\2\2\u0787\u078c\5\u022c")
        buf.write("\u0117\2\u0788\u0789\t\33\2\2\u0789\u078d\5\u011a\u008e")
        buf.write("\2\u078a\u078b\7\u019a\2\2\u078b\u078d\7\63\2\2\u078c")
        buf.write("\u0788\3\2\2\2\u078c\u078a\3\2\2\2\u078d\u0794\3\2\2\2")
        buf.write("\u078e\u078f\7\177\2\2\u078f\u0794\5\u022c\u0117\2\u0790")
        buf.write("\u0794\7\u01c2\2\2\u0791\u0792\7\u017d\2\2\u0792\u0794")
        buf.write("\5j\66\2\u0793\u075e\3\2\2\2\u0793\u0763\3\2\2\2\u0793")
        buf.write("\u076c\3\2\2\2\u0793\u076d\3\2\2\2\u0793\u076e\3\2\2\2")
        buf.write("\u0793\u076f\3\2\2\2\u0793\u0771\3\2\2\2\u0793\u0775\3")
        buf.write("\2\2\2\u0793\u0779\3\2\2\2\u0793\u077b\3\2\2\2\u0793\u077d")
        buf.write("\3\2\2\2\u0793\u077f\3\2\2\2\u0793\u0781\3\2\2\2\u0793")
        buf.write("\u078e\3\2\2\2\u0793\u0790\3\2\2\2\u0793\u0791\3\2\2\2")
        buf.write("\u0794i\3\2\2\2\u0795\u0798\5\u0154\u00ab\2\u0796\u0797")
        buf.write("\7\u024f\2\2\u0797\u0799\5\u0154\u00ab\2\u0798\u0796\3")
        buf.write("\2\2\2\u0798\u0799\3\2\2\2\u0799k\3\2\2\2\u079a\u079c")
        buf.write("\7r\2\2\u079b\u079d\5\u01a6\u00d4\2\u079c\u079b\3\2\2")
        buf.write("\2\u079c\u079d\3\2\2\2\u079d\u079e\3\2\2\2\u079e\u079f")
        buf.write("\5\u0286\u0144\2\u079f\u07a0\5n8\2\u07a0\u07ae\3\2\2\2")
        buf.write("\u07a1\u07a2\7r\2\2\u07a2\u07a3\7\u0178\2\2\u07a3\u07a4")
        buf.write("\7\u019e\2\2\u07a4\u07a5\7\u0104\2\2\u07a5\u07a9\5\u022c")
        buf.write("\u0117\2\u07a6\u07a7\7\u00af\2\2\u07a7\u07a8\7\26\2\2")
        buf.write("\u07a8\u07aa\5\u02d0\u0169\2\u07a9\u07a6\3\2\2\2\u07a9")
        buf.write("\u07aa\3\2\2\2\u07aa\u07ab\3\2\2\2\u07ab\u07ac\5\u0202")
        buf.write("\u0102\2\u07ac\u07ae\3\2\2\2\u07ad\u079a\3\2\2\2\u07ad")
        buf.write("\u07a1\3\2\2\2\u07aem\3\2\2\2\u07af\u07cc\5\u0208\u0105")
        buf.write("\2\u07b0\u07b1\7\21\2\2\u07b1\u07b2\7\u00b4\2\2\u07b2")
        buf.write("\u07cc\5\u0286\u0144\2\u07b3\u07b5\7\u009d\2\2\u07b4\u07b3")
        buf.write("\3\2\2\2\u07b4\u07b5\3\2\2\2\u07b5\u07b6\3\2\2\2\u07b6")
        buf.write("\u07b7\7A\2\2\u07b7\u07b8\7\u01aa\2\2\u07b8\u07b9\7W\2")
        buf.write("\2\u07b9\u07cc\5\u0286\u0144\2\u07ba\u07bc\7\f\2\2\u07bb")
        buf.write("\u07bd\7\u0185\2\2\u07bc\u07bb\3\2\2\2\u07bc\u07bd\3\2")
        buf.write("\2\2\u07bd\u07c0\3\2\2\2\u07be\u07c1\7\u026c\2\2\u07bf")
        buf.write("\u07c1\5\u022c\u0117\2\u07c0\u07be\3\2\2\2\u07c0\u07bf")
        buf.write("\3\2\2\2\u07c1\u07c2\3\2\2\2\u07c2\u07cc\5\u00d8m\2\u07c3")
        buf.write("\u07c4\7\u00d4\2\2\u07c4\u07c5\7\u0255\2\2\u07c5\u07c6")
        buf.write("\5\u02d0\u0169\2\u07c6\u07c7\7\u0256\2\2\u07c7\u07cc\3")
        buf.write("\2\2\2\u07c8\u07cc\5\u0202\u0102\2\u07c9\u07ca\7\u00ec")
        buf.write("\2\2\u07ca\u07cc\5\u01f4\u00fb\2\u07cb\u07af\3\2\2\2\u07cb")
        buf.write("\u07b0\3\2\2\2\u07cb\u07b4\3\2\2\2\u07cb\u07ba\3\2\2\2")
        buf.write("\u07cb\u07c3\3\2\2\2\u07cb\u07c8\3\2\2\2\u07cb\u07c9\3")
        buf.write("\2\2\2\u07cco\3\2\2\2\u07cd\u07ce\7\u018e\2\2\u07ce\u07d2")
        buf.write("\7\u00be\2\2\u07cf\u07d0\7\u0198\2\2\u07d0\u07d1\t\34")
        buf.write("\2\2\u07d1\u07d3\5\u02d0\u0169\2\u07d2\u07cf\3\2\2\2\u07d2")
        buf.write("\u07d3\3\2\2\2\u07d3\u07d7\3\2\2\2\u07d4\u07d5\7\u019e")
        buf.write("\2\2\u07d5\u07d6\7\u00e1\2\2\u07d6\u07d8\5\u02d0\u0169")
        buf.write("\2\u07d7\u07d4\3\2\2\2\u07d7\u07d8\3\2\2\2\u07d8\u07d9")
        buf.write("\3\2\2\2\u07d9\u07da\5r:\2\u07daq\3\2\2\2\u07db\u07e1")
        buf.write("\7\u019b\2\2\u07dc\u07de\7\u00d8\2\2\u07dd\u07df\5t;\2")
        buf.write("\u07de\u07dd\3\2\2\2\u07de\u07df\3\2\2\2\u07df\u07e1\3")
        buf.write("\2\2\2\u07e0\u07db\3\2\2\2\u07e0\u07dc\3\2\2\2\u07e1\u0819")
        buf.write("\3\2\2\2\u07e2\u07e7\5\u020c\u0107\2\u07e3\u07e4\7\u024f")
        buf.write("\2\2\u07e4\u07e6\5\u020c\u0107\2\u07e5\u07e3\3\2\2\2\u07e6")
        buf.write("\u07e9\3\2\2\2\u07e7\u07e5\3\2\2\2\u07e7\u07e8\3\2\2\2")
        buf.write("\u07e8\u07ea\3\2\2\2\u07e9\u07e7\3\2\2\2\u07ea\u07eb\7")
        buf.write("\u01aa\2\2\u07eb\u07ec\7\u0103\2\2\u07ec\u081a\3\2\2\2")
        buf.write("\u07ed\u07f2\5\u020e\u0108\2\u07ee\u07ef\7\u024f\2\2\u07ef")
        buf.write("\u07f1\5\u020e\u0108\2\u07f0\u07ee\3\2\2\2\u07f1\u07f4")
        buf.write("\3\2\2\2\u07f2\u07f0\3\2\2\2\u07f2\u07f3\3\2\2\2\u07f3")
        buf.write("\u07fa\3\2\2\2\u07f4\u07f2\3\2\2\2\u07f5\u07f7\7\u0178")
        buf.write("\2\2\u07f6\u07f8\7\u00be\2\2\u07f7\u07f6\3\2\2\2\u07f7")
        buf.write("\u07f8\3\2\2\2\u07f8\u07fa\3\2\2\2\u07f9\u07ed\3\2\2\2")
        buf.write("\u07f9\u07f5\3\2\2\2\u07fa\u07fb\3\2\2\2\u07fb\u07fc\7")
        buf.write("\u01aa\2\2\u07fc\u081a\7\u00e8\2\2\u07fd\u0803\7T\2\2")
        buf.write("\u07fe\u0800\7\u0178\2\2\u07ff\u0801\7\u00be\2\2\u0800")
        buf.write("\u07ff\3\2\2\2\u0800\u0801\3\2\2\2\u0801\u0803\3\2\2\2")
        buf.write("\u0802\u07fd\3\2\2\2\u0802\u07fe\3\2\2\2\u0803\u0804\3")
        buf.write("\2\2\2\u0804\u0805\7\u01aa\2\2\u0805\u081a\7`\2\2\u0806")
        buf.write("\u080d\7\u0226\2\2\u0807\u080d\7\u0187\2\2\u0808\u080a")
        buf.write("\7\u0178\2\2\u0809\u080b\7\u00be\2\2\u080a\u0809\3\2\2")
        buf.write("\2\u080a\u080b\3\2\2\2\u080b\u080d\3\2\2\2\u080c\u0806")
        buf.write("\3\2\2\2\u080c\u0807\3\2\2\2\u080c\u0808\3\2\2\2\u080d")
        buf.write("\u080e\3\2\2\2\u080e\u080f\7\u01aa\2\2\u080f\u081a\7\u00e2")
        buf.write("\2\2\u0810\u0816\7\u0226\2\2\u0811\u0813\7\u0178\2\2\u0812")
        buf.write("\u0814\7\u00be\2\2\u0813\u0812\3\2\2\2\u0813\u0814\3\2")
        buf.write("\2\2\u0814\u0816\3\2\2\2\u0815\u0810\3\2\2\2\u0815\u0811")
        buf.write("\3\2\2\2\u0816\u0817\3\2\2\2\u0817\u0818\7\u01aa\2\2\u0818")
        buf.write("\u081a\7\u0110\2\2\u0819\u07e2\3\2\2\2\u0819\u07f9\3\2")
        buf.write("\2\2\u0819\u0802\3\2\2\2\u0819\u080c\3\2\2\2\u0819\u0815")
        buf.write("\3\2\2\2\u081a\u081d\3\2\2\2\u081b\u081e\5\u0134\u009b")
        buf.write("\2\u081c\u081e\5\u0136\u009c\2\u081d\u081b\3\2\2\2\u081d")
        buf.write("\u081c\3\2\2\2\u081es\3\2\2\2\u081f\u0820\7\u019b\2\2")
        buf.write("\u0820\u0821\7\u00a9\2\2\u0821\u0822\7\u0198\2\2\u0822")
        buf.write("u\3\2\2\2\u0823\u0825\7\u00e7\2\2\u0824\u0826\5\u01a6")
        buf.write("\u00d4\2\u0825\u0824\3\2\2\2\u0825\u0826\3\2\2\2\u0826")
        buf.write("\u0827\3\2\2\2\u0827\u0837\5\u0286\u0144\2\u0828\u0831")
        buf.write("\5\u015c\u00af\2\u0829\u082e\7\u00d5\2\2\u082a\u082c\7")
        buf.write("\u01c3\2\2\u082b\u082a\3\2\2\2\u082b\u082c\3\2\2\2\u082c")
        buf.write("\u082d\3\2\2\2\u082d\u082f\5\u015e\u00b0\2\u082e\u082b")
        buf.write("\3\2\2\2\u082e\u082f\3\2\2\2\u082f\u0831\3\2\2\2\u0830")
        buf.write("\u0828\3\2\2\2\u0830\u0829\3\2\2\2\u0831\u0834\3\2\2\2")
        buf.write("\u0832\u0830\3\2\2\2\u0832\u0833\3\2\2\2\u0833\u0838\3")
        buf.write("\2\2\2\u0834\u0832\3\2\2\2\u0835\u0838\5\u020a\u0106\2")
        buf.write("\u0836\u0838\5\u0208\u0105\2\u0837\u0832\3\2\2\2\u0837")
        buf.write("\u0835\3\2\2\2\u0837\u0836\3\2\2\2\u0838w\3\2\2\2\u0839")
        buf.write("\u083b\7\u0121\2\2\u083a\u083c\5\u01a6\u00d4\2\u083b\u083a")
        buf.write("\3\2\2\2\u083b\u083c\3\2\2\2\u083c\u083d\3\2\2\2\u083d")
        buf.write("\u083e\5\u0286\u0144\2\u083e\u083f\5z>\2\u083fy\3\2\2")
        buf.write("\2\u0840\u0842\7\f\2\2\u0841\u0843\7\u0185\2\2\u0842\u0841")
        buf.write("\3\2\2\2\u0842\u0843\3\2\2\2\u0843\u0844\3\2\2\2\u0844")
        buf.write("\u0845\5\u022c\u0117\2\u0845\u0846\5\u0096L\2\u0846\u085d")
        buf.write("\3\2\2\2\u0847\u0849\7\f\2\2\u0848\u084a\7\u0185\2\2\u0849")
        buf.write("\u0848\3\2\2\2\u0849\u084a\3\2\2\2\u084a\u084b\3\2\2\2")
        buf.write("\u084b\u084c\5\u022c\u0117\2\u084c\u084d\5\u0098M\2\u084d")
        buf.write("\u085d\3\2\2\2\u084e\u0850\7\u00d0\2\2\u084f\u0851\7\u0185")
        buf.write("\2\2\u0850\u084f\3\2\2\2\u0850\u0851\3\2\2\2\u0851\u0852")
        buf.write("\3\2\2\2\u0852\u0853\5\u022c\u0117\2\u0853\u0854\7\u01b8")
        buf.write("\2\2\u0854\u0855\5\u022c\u0117\2\u0855\u085d\3\2\2\2\u0856")
        buf.write("\u085d\5\u0208\u0105\2\u0857\u085d\5\u020a\u0106\2\u0858")
        buf.write("\u0859\7\u00ec\2\2\u0859\u085d\5\u01f4\u00fb\2\u085a\u085b")
        buf.write("\7\u00d4\2\2\u085b\u085d\5\u01f0\u00f9\2\u085c\u0840\3")
        buf.write("\2\2\2\u085c\u0847\3\2\2\2\u085c\u084e\3\2\2\2\u085c\u0856")
        buf.write("\3\2\2\2\u085c\u0857\3\2\2\2\u085c\u0858\3\2\2\2\u085c")
        buf.write("\u085a\3\2\2\2\u085d{\3\2\2\2\u085e\u085f\7\u008d\2\2")
        buf.write("\u085f\u0861\7\u0121\2\2\u0860\u0862\5\u01a6\u00d4\2\u0861")
        buf.write("\u0860\3\2\2\2\u0861\u0862\3\2\2\2\u0862\u0863\3\2\2\2")
        buf.write("\u0863\u0864\5\u0286\u0144\2\u0864\u0865\5~@\2\u0865\u0874")
        buf.write("\3\2\2\2\u0866\u0867\7\u008d\2\2\u0867\u0868\7\u0121\2")
        buf.write("\2\u0868\u0869\7\u0178\2\2\u0869\u086a\7\u019e\2\2\u086a")
        buf.write("\u086b\7\u0104\2\2\u086b\u086f\5\u022c\u0117\2\u086c\u086d")
        buf.write("\7\u00af\2\2\u086d\u086e\7\26\2\2\u086e\u0870\5\u02d0")
        buf.write("\u0169\2\u086f\u086c\3\2\2\2\u086f\u0870\3\2\2\2\u0870")
        buf.write("\u0871\3\2\2\2\u0871\u0872\5\u0202\u0102\2\u0872\u0874")
        buf.write("\3\2\2\2\u0873\u085e\3\2\2\2\u0873\u0866\3\2\2\2\u0874")
        buf.write("}\3\2\2\2\u0875\u088f\5\u0208\u0105\2\u0876\u088f\5\u020a")
        buf.write("\u0106\2\u0877\u0879\7\u00d0\2\2\u0878\u087a\7\u0185\2")
        buf.write("\2\u0879\u0878\3\2\2\2\u0879\u087a\3\2\2\2\u087a\u087b")
        buf.write("\3\2\2\2\u087b\u087c\5\u022c\u0117\2\u087c\u087d\7\u01b8")
        buf.write("\2\2\u087d\u087e\5\u022c\u0117\2\u087e\u088f\3\2\2\2\u087f")
        buf.write("\u0881\7\u009d\2\2\u0880\u087f\3\2\2\2\u0880\u0881\3\2")
        buf.write("\2\2\u0881\u0882\3\2\2\2\u0882\u0883\7A\2\2\u0883\u0884")
        buf.write("\7\u01aa\2\2\u0884\u0885\7W\2\2\u0885\u088f\5\u022c\u0117")
        buf.write("\2\u0886\u088b\5\u0080A\2\u0887\u0888\7\u024f\2\2\u0888")
        buf.write("\u088a\5\u0080A\2\u0889\u0887\3\2\2\2\u088a\u088d\3\2")
        buf.write("\2\2\u088b\u0889\3\2\2\2\u088b\u088c\3\2\2\2\u088c\u088f")
        buf.write("\3\2\2\2\u088d\u088b\3\2\2\2\u088e\u0875\3\2\2\2\u088e")
        buf.write("\u0876\3\2\2\2\u088e\u0877\3\2\2\2\u088e\u0880\3\2\2\2")
        buf.write("\u088e\u0886\3\2\2\2\u088f\177\3\2\2\2\u0890\u0892\7\f")
        buf.write("\2\2\u0891\u0893\7\u0185\2\2\u0892\u0891\3\2\2\2\u0892")
        buf.write("\u0893\3\2\2\2\u0893\u0894\3\2\2\2\u0894\u0895\5\u022c")
        buf.write("\u0117\2\u0895\u0896\5\u00d8m\2\u0896\u08bb\3\2\2\2\u0897")
        buf.write("\u0899\7\f\2\2\u0898\u089a\7\u0185\2\2\u0899\u0898\3\2")
        buf.write("\2\2\u0899\u089a\3\2\2\2\u089a\u089b\3\2\2\2\u089b\u089c")
        buf.write("\5\u022c\u0117\2\u089c\u089d\7\u00ec\2\2\u089d\u089e\5")
        buf.write("\u01f4\u00fb\2\u089e\u08bb\3\2\2\2\u089f\u08a1\7\f\2\2")
        buf.write("\u08a0\u08a2\7\u0185\2\2\u08a1\u08a0\3\2\2\2\u08a1\u08a2")
        buf.write("\3\2\2\2\u08a2\u08a3\3\2\2\2\u08a3\u08a4\5\u022c\u0117")
        buf.write("\2\u08a4\u08a5\7\u00d4\2\2\u08a5\u08a6\5\u01f0\u00f9\2")
        buf.write("\u08a6\u08bb\3\2\2\2\u08a7\u08a9\7\f\2\2\u08a8\u08aa\7")
        buf.write("\u0185\2\2\u08a9\u08a8\3\2\2\2\u08a9\u08aa\3\2\2\2\u08aa")
        buf.write("\u08ab\3\2\2\2\u08ab\u08ac\5\u022c\u0117\2\u08ac\u08ad")
        buf.write("\7\u00ec\2\2\u08ad\u08ae\7\u00fb\2\2\u08ae\u08af\5^\60")
        buf.write("\2\u08af\u08bb\3\2\2\2\u08b0\u08b1\7\"\2\2\u08b1\u08b2")
        buf.write("\7\u01aa\2\2\u08b2\u08bb\5\u0286\u0144\2\u08b3\u08b4\7")
        buf.write("\u00ec\2\2\u08b4\u08b5\7\u0126\2\2\u08b5\u08bb\7\"\2\2")
        buf.write("\u08b6\u08b7\7\u00ec\2\2\u08b7\u08bb\5\u01f4\u00fb\2\u08b8")
        buf.write("\u08b9\7\u00d4\2\2\u08b9\u08bb\5\u01f0\u00f9\2\u08ba\u0890")
        buf.write("\3\2\2\2\u08ba\u0897\3\2\2\2\u08ba\u089f\3\2\2\2\u08ba")
        buf.write("\u08a7\3\2\2\2\u08ba\u08b0\3\2\2\2\u08ba\u08b3\3\2\2\2")
        buf.write("\u08ba\u08b6\3\2\2\2\u08ba\u08b8\3\2\2\2\u08bb\u0081\3")
        buf.write("\2\2\2\u08bc\u08bd\7P\2\2\u08bd\u08be\7\u010c\2\2\u08be")
        buf.write("\u08bf\5\u022c\u0117\2\u08bf\u08c0\5\u0084C\2\u08c0\u0083")
        buf.write("\3\2\2\2\u08c1\u08c9\7D\2\2\u08c2\u08c4\7K\2\2\u08c3\u08c5")
        buf.write("\t\24\2\2\u08c4\u08c3\3\2\2\2\u08c4\u08c5\3\2\2\2\u08c5")
        buf.write("\u08c9\3\2\2\2\u08c6\u08c9\5\u0206\u0104\2\u08c7\u08c9")
        buf.write("\5\u0208\u0105\2\u08c8\u08c1\3\2\2\2\u08c8\u08c2\3\2\2")
        buf.write("\2\u08c8\u08c6\3\2\2\2\u08c8\u08c7\3\2\2\2\u08c9\u0085")
        buf.write("\3\2\2\2\u08ca\u08cb\7\u010f\2\2\u08cb\u08fa\5\u0286\u0144")
        buf.write("\2\u08cc\u08fb\5\u020a\u0106\2\u08cd\u08fb\5\u0208\u0105")
        buf.write("\2\u08ce\u08cf\7\7\2\2\u08cf\u08d1\7\u011e\2\2\u08d0\u08d2")
        buf.write("\5\u01a8\u00d5\2\u08d1\u08d0\3\2\2\2\u08d1\u08d2\3\2\2")
        buf.write("\2\u08d2\u08d3\3\2\2\2\u08d3\u08d6\5\u0154\u00ab\2\u08d4")
        buf.write("\u08d5\t\35\2\2\u08d5\u08d7\5\u0154\u00ab\2\u08d6\u08d4")
        buf.write("\3\2\2\2\u08d6\u08d7\3\2\2\2\u08d7\u08fb\3\2\2\2\u08d8")
        buf.write("\u08d9\7\u00d0\2\2\u08d9\u08da\7\22\2\2\u08da\u08db\5")
        buf.write("\u022c\u0117\2\u08db\u08dc\7\u01b8\2\2\u08dc\u08de\5\u022c")
        buf.write("\u0117\2\u08dd\u08df\5\u0212\u010a\2\u08de\u08dd\3\2\2")
        buf.write("\2\u08de\u08df\3\2\2\2\u08df\u08fb\3\2\2\2\u08e0\u08e1")
        buf.write("\7\u00d0\2\2\u08e1\u08e2\7\u011e\2\2\u08e2\u08e3\5\u0154")
        buf.write("\u00ab\2\u08e3\u08e4\7\u01b8\2\2\u08e4\u08e5\5\u0154\u00ab")
        buf.write("\2\u08e5\u08fb\3\2\2\2\u08e6\u08eb\5\u0092J\2\u08e7\u08e8")
        buf.write("\7\u024f\2\2\u08e8\u08ea\5\u0092J\2\u08e9\u08e7\3\2\2")
        buf.write("\2\u08ea\u08ed\3\2\2\2\u08eb\u08e9\3\2\2\2\u08eb\u08ec")
        buf.write("\3\2\2\2\u08ec\u08fb\3\2\2\2\u08ed\u08eb\3\2\2\2\u08ee")
        buf.write("\u08ef\7\u00ec\2\2\u08ef\u08f0\7\u0255\2\2\u08f0\u08f5")
        buf.write("\5\u0094K\2\u08f1\u08f2\7\u024f\2\2\u08f2\u08f4\5\u0094")
        buf.write("K\2\u08f3\u08f1\3\2\2\2\u08f4\u08f7\3\2\2\2\u08f5\u08f3")
        buf.write("\3\2\2\2\u08f5\u08f6\3\2\2\2\u08f6\u08f8\3\2\2\2\u08f7")
        buf.write("\u08f5\3\2\2\2\u08f8\u08f9\7\u0256\2\2\u08f9\u08fb\3\2")
        buf.write("\2\2\u08fa\u08cc\3\2\2\2\u08fa\u08cd\3\2\2\2\u08fa\u08ce")
        buf.write("\3\2\2\2\u08fa\u08d8\3\2\2\2\u08fa\u08e0\3\2\2\2\u08fa")
        buf.write("\u08e6\3\2\2\2\u08fa\u08ee\3\2\2\2\u08fb\u0087\3\2\2\2")
        buf.write("\u08fc\u08fd\7G\2\2\u08fd\u0913\5\u0286\u0144\2\u08fe")
        buf.write("\u0914\5\u0096L\2\u08ff\u0914\5\u0098M\2\u0900\u0901\t")
        buf.write("\36\2\2\u0901\u0902\7\u01a7\2\2\u0902\u0914\7\u01a8\2")
        buf.write("\2\u0903\u0904\7\7\2\2\u0904\u0907\5\u00ecw\2\u0905\u0906")
        buf.write("\7\u01a7\2\2\u0906\u0908\7\u011b\2\2\u0907\u0905\3\2\2")
        buf.write("\2\u0907\u0908\3\2\2\2\u0908\u0914\3\2\2\2\u0909\u0914")
        buf.write("\5b\62\2\u090a\u090b\7\u00d0\2\2\u090b\u090c\7\u0186\2")
        buf.write("\2\u090c\u090d\5\u0286\u0144\2\u090d\u090e\7\u01b8\2\2")
        buf.write("\u090e\u090f\5\u0286\u0144\2\u090f\u0914\3\2\2\2\u0910")
        buf.write("\u0914\5`\61\2\u0911\u0914\5\u0208\u0105\2\u0912\u0914")
        buf.write("\5\u020a\u0106\2\u0913\u08fe\3\2\2\2\u0913\u08ff\3\2\2")
        buf.write("\2\u0913\u0900\3\2\2\2\u0913\u0903\3\2\2\2\u0913\u0909")
        buf.write("\3\2\2\2\u0913\u090a\3\2\2\2\u0913\u0910\3\2\2\2\u0913")
        buf.write("\u0911\3\2\2\2\u0913\u0912\3\2\2\2\u0914\u0089\3\2\2\2")
        buf.write("\u0915\u0916\7\u00ea\2\2\u0916\u0917\5\u022c\u0117\2\u0917")
        buf.write("\u0918\5\u008cG\2\u0918\u008b\3\2\2\2\u0919\u091a\7\u0120")
        buf.write("\2\2\u091a\u091c\5\u0154\u00ab\2\u091b\u0919\3\2\2\2\u091b")
        buf.write("\u091c\3\2\2\2\u091c\u091d\3\2\2\2\u091d\u0923\5\u01d4")
        buf.write("\u00eb\2\u091e\u091f\7\u0120\2\2\u091f\u0923\5\u0154\u00ab")
        buf.write("\2\u0920\u0923\5\u0206\u0104\2\u0921\u0923\5\u0208\u0105")
        buf.write("\2\u0922\u091b\3\2\2\2\u0922\u091e\3\2\2\2\u0922\u0920")
        buf.write("\3\2\2\2\u0922\u0921\3\2\2\2\u0923\u008d\3\2\2\2\u0924")
        buf.write("\u0925\7\u0108\2\2\u0925\u0934\7\u00e4\2\2\u0926\u0927")
        buf.write("\t\37\2\2\u0927\u092a\5\u0286\u0144\2\u0928\u092b\5\u0208")
        buf.write("\u0105\2\u0929\u092b\5\u020a\u0106\2\u092a\u0928\3\2\2")
        buf.write("\2\u092a\u0929\3\2\2\2\u092b\u0935\3\2\2\2\u092c\u092d")
        buf.write("\7C\2\2\u092d\u092e\5\u0286\u0144\2\u092e\u092f\5\u01f4")
        buf.write("\u00fb\2\u092f\u0935\3\2\2\2\u0930\u0931\7(\2\2\u0931")
        buf.write("\u0932\5\u0286\u0144\2\u0932\u0933\5\u0090I\2\u0933\u0935")
        buf.write("\3\2\2\2\u0934\u0926\3\2\2\2\u0934\u092c\3\2\2\2\u0934")
        buf.write("\u0930\3\2\2\2\u0935\u008f\3\2\2\2\u0936\u0937\t \2\2")
        buf.write("\u0937\u0938\7\u008b\2\2\u0938\u0939\7\u0198\2\2\u0939")
        buf.write("\u093a\5\u02d0\u0169\2\u093a\u093b\7\u01c3\2\2\u093b\u0940")
        buf.write("\5\u0286\u0144\2\u093c\u093d\7\u024f\2\2\u093d\u093f\5")
        buf.write("\u0286\u0144\2\u093e\u093c\3\2\2\2\u093f\u0942\3\2\2\2")
        buf.write("\u0940\u093e\3\2\2\2\u0940\u0941\3\2\2\2\u0941\u0957\3")
        buf.write("\2\2\2\u0942\u0940\3\2\2\2\u0943\u0944\7\f\2\2\u0944\u0947")
        buf.write("\7\u008b\2\2\u0945\u0946\7\u0198\2\2\u0946\u0948\5\u02d0")
        buf.write("\u0169\2\u0947\u0945\3\2\2\2\u0947\u0948\3\2\2\2\u0948")
        buf.write("\u0949\3\2\2\2\u0949\u094a\7\u00d2\2\2\u094a\u094b\5\u0286")
        buf.write("\u0144\2\u094b\u094c\7\u01c3\2\2\u094c\u094d\5\u0286\u0144")
        buf.write("\2\u094d\u0957\3\2\2\2\u094e\u094f\7I\2\2\u094f\u0952")
        buf.write("\7\u008b\2\2\u0950\u0951\7j\2\2\u0951\u0953\7\u0137\2")
        buf.write("\2\u0952\u0950\3\2\2\2\u0952\u0953\3\2\2\2\u0953\u0954")
        buf.write("\3\2\2\2\u0954\u0955\7\u0198\2\2\u0955\u0957\5\u02d0\u0169")
        buf.write("\2\u0956\u0936\3\2\2\2\u0956\u0943\3\2\2\2\u0956\u094e")
        buf.write("\3\2\2\2\u0957\u0091\3\2\2\2\u0958\u0959\7\7\2\2\u0959")
        buf.write("\u095a\7\22\2\2\u095a\u095b\5\u022c\u0117\2\u095b\u095d")
        buf.write("\5\u0240\u0121\2\u095c\u095e\5\u0214\u010b\2\u095d\u095c")
        buf.write("\3\2\2\2\u095d\u095e\3\2\2\2\u095e\u0960\3\2\2\2\u095f")
        buf.write("\u0961\5\u0212\u010a\2\u0960\u095f\3\2\2\2\u0960\u0961")
        buf.write("\3\2\2\2\u0961\u097b\3\2\2\2\u0962\u0963\7I\2\2\u0963")
        buf.write("\u0965\7\22\2\2\u0964\u0966\5\u01a6\u00d4\2\u0965\u0964")
        buf.write("\3\2\2\2\u0965\u0966\3\2\2\2\u0966\u0967\3\2\2\2\u0967")
        buf.write("\u0969\5\u022c\u0117\2\u0968\u096a\5\u0212\u010a\2\u0969")
        buf.write("\u0968\3\2\2\2\u0969\u096a\3\2\2\2\u096a\u097b\3\2\2\2")
        buf.write("\u096b\u096c\7\f\2\2\u096c\u096d\7\22\2\2\u096d\u0970")
        buf.write("\5\u022c\u0117\2\u096e\u096f\7\u00ec\2\2\u096f\u0971\7")
        buf.write("\66\2\2\u0970\u096e\3\2\2\2\u0970\u0971\3\2\2\2\u0971")
        buf.write("\u0972\3\2\2\2\u0972\u0973\7\u010f\2\2\u0973\u0975\5\u0240")
        buf.write("\u0121\2\u0974\u0976\5\u0214\u010b\2\u0975\u0974\3\2\2")
        buf.write("\2\u0975\u0976\3\2\2\2\u0976\u0978\3\2\2\2\u0977\u0979")
        buf.write("\5\u0212\u010a\2\u0978\u0977\3\2\2\2\u0978\u0979\3\2\2")
        buf.write("\2\u0979\u097b\3\2\2\2\u097a\u0958\3\2\2\2\u097a\u0962")
        buf.write("\3\2\2\2\u097a\u096b\3\2\2\2\u097b\u0093\3\2\2\2\u097c")
        buf.write("\u097d\t!\2\2\u097d\u097e\7\u024c\2\2\u097e\u0983\5\u0286")
        buf.write("\u0144\2\u097f\u0980\7\u00fb\2\2\u0980\u0981\7\u024c\2")
        buf.write("\2\u0981\u0983\5^\60\2\u0982\u097c\3\2\2\2\u0982\u097f")
        buf.write("\3\2\2\2\u0983\u0095\3\2\2\2\u0984\u0985\7\u00ec\2\2\u0985")
        buf.write("\u0986\7\u018e\2\2\u0986\u0987\5\u024c\u0127\2\u0987\u0097")
        buf.write("\3\2\2\2\u0988\u0989\7I\2\2\u0989\u098a\7\u018e\2\2\u098a")
        buf.write("\u0099\3\2\2\2\u098b\u098d\7\u01bc\2\2\u098c\u098b\3\2")
        buf.write("\2\2\u098c\u098d\3\2\2\2\u098d\u098e\3\2\2\2\u098e\u0990")
        buf.write("\7r\2\2\u098f\u0991\7\u0164\2\2\u0990\u098f\3\2\2\2\u0990")
        buf.write("\u0991\3\2\2\2\u0991\u0993\3\2\2\2\u0992\u0994\5\u01a8")
        buf.write("\u00d5\2\u0993\u0992\3\2\2\2\u0993\u0994\3\2\2\2\u0994")
        buf.write("\u0996\3\2\2\2\u0995\u0997\5\u022c\u0117\2\u0996\u0995")
        buf.write("\3\2\2\2\u0996\u0997\3\2\2\2\u0997\u0998\3\2\2\2\u0998")
        buf.write("\u099a\7\u01aa\2\2\u0999\u099b\7\u01ab\2\2\u099a\u0999")
        buf.write("\3\2\2\2\u099a\u099b\3\2\2\2\u099b\u099c\3\2\2\2\u099c")
        buf.write("\u099d\5\u0286\u0144\2\u099d\u099e\5\u009cO\2\u099e\u009b")
        buf.write("\3\2\2\2\u099f\u09a0\7\u01be\2\2\u09a0\u09a2\5\u022c\u0117")
        buf.write("\2\u09a1\u099f\3\2\2\2\u09a1\u09a2\3\2\2\2\u09a2\u09a3")
        buf.write("\3\2\2\2\u09a3\u09a5\5\u009eP\2\u09a4\u09a6\5\u00a2R\2")
        buf.write("\u09a5\u09a4\3\2\2\2\u09a5\u09a6\3\2\2\2\u09a6\u09a8\3")
        buf.write("\2\2\2\u09a7\u09a9\5\u01fa\u00fe\2\u09a8\u09a7\3\2\2\2")
        buf.write("\u09a8\u09a9\3\2\2\2\u09a9\u09ab\3\2\2\2\u09aa\u09ac\5")
        buf.write("\u0200\u0101\2\u09ab\u09aa\3\2\2\2\u09ab\u09ac\3\2\2\2")
        buf.write("\u09ac\u09ae\3\2\2\2\u09ad\u09af\5\u00a4S\2\u09ae\u09ad")
        buf.write("\3\2\2\2\u09ae\u09af\3\2\2\2\u09af\u009d\3\2\2\2\u09b0")
        buf.write("\u09b1\7\u0255\2\2\u09b1\u09b6\5\u00a0Q\2\u09b2\u09b3")
        buf.write("\7\u024f\2\2\u09b3\u09b5\5\u00a0Q\2\u09b4\u09b2\3\2\2")
        buf.write("\2\u09b5\u09b8\3\2\2\2\u09b6\u09b4\3\2\2\2\u09b6\u09b7")
        buf.write("\3\2\2\2\u09b7\u09b9\3\2\2\2\u09b8\u09b6\3\2\2\2\u09b9")
        buf.write("\u09ba\7\u0256\2\2\u09ba\u009f\3\2\2\2\u09bb\u09bd\5\u024c")
        buf.write("\u0127\2\u09bc\u09be\5\u0286\u0144\2\u09bd\u09bc\3\2\2")
        buf.write("\2\u09bd\u09be\3\2\2\2\u09be\u09ca\3\2\2\2\u09bf\u09c0")
        buf.write("\7\u0255\2\2\u09c0\u09c5\5\u00b4[\2\u09c1\u09c2\7\u024f")
        buf.write("\2\2\u09c2\u09c4\5\u00b4[\2\u09c3\u09c1\3\2\2\2\u09c4")
        buf.write("\u09c7\3\2\2\2\u09c5\u09c3\3\2\2\2\u09c5\u09c6\3\2\2\2")
        buf.write("\u09c6\u09c8\3\2\2\2\u09c7\u09c5\3\2\2\2\u09c8\u09c9\7")
        buf.write("\u0256\2\2\u09c9\u09cb\3\2\2\2\u09ca\u09bf\3\2\2\2\u09ca")
        buf.write("\u09cb\3\2\2\2\u09cb\u09cd\3\2\2\2\u09cc\u09ce\5\u02b8")
        buf.write("\u015d\2\u09cd\u09cc\3\2\2\2\u09cd\u09ce\3\2\2\2\u09ce")
        buf.write("\u09d0\3\2\2\2\u09cf\u09d1\5\u02ba\u015e\2\u09d0\u09cf")
        buf.write("\3\2\2\2\u09d0\u09d1\3\2\2\2\u09d1\u00a1\3\2\2\2\u09d2")
        buf.write("\u09d3\7o\2\2\u09d3\u09d4\7\u0255\2\2\u09d4\u09d9\5\u022c")
        buf.write("\u0117\2\u09d5\u09d6\7\u024f\2\2\u09d6\u09d8\5\u022c\u0117")
        buf.write("\2\u09d7\u09d5\3\2\2\2\u09d8\u09db\3\2\2\2\u09d9\u09d7")
        buf.write("\3\2\2\2\u09d9\u09da\3\2\2\2\u09da\u09dc\3\2\2\2\u09db")
        buf.write("\u09d9\3\2\2\2\u09dc\u09dd\7\u0256\2\2\u09dd\u00a3\3\2")
        buf.write("\2\2\u09de\u09df\7\u01c1\2\2\u09df\u09e0\5\u024c\u0127")
        buf.write("\2\u09e0\u00a5\3\2\2\2\u09e1\u09e3\7W\2\2\u09e2\u09e4")
        buf.write("\5\u01a8\u00d5\2\u09e3\u09e2\3\2\2\2\u09e3\u09e4\3\2\2")
        buf.write("\2\u09e4\u09e5\3\2\2\2\u09e5\u09e7\5\u022c\u0117\2\u09e6")
        buf.write("\u09e8\7\u01c3\2\2\u09e7\u09e6\3\2\2\2\u09e7\u09e8\3\2")
        buf.write("\2\2\u09e8\u09eb\3\2\2\2\u09e9\u09ea\7\u00e1\2\2\u09ea")
        buf.write("\u09ec\5\u022c\u0117\2\u09eb\u09e9\3\2\2\2\u09eb\u09ec")
        buf.write("\3\2\2\2\u09ec\u09f2\3\2\2\2\u09ed\u09f0\7\u0120\2\2\u09ee")
        buf.write("\u09f1\5\u022c\u0117\2\u09ef\u09f1\5\u0154\u00ab\2\u09f0")
        buf.write("\u09ee\3\2\2\2\u09f0\u09ef\3\2\2\2\u09f1\u09f3\3\2\2\2")
        buf.write("\u09f2\u09ed\3\2\2\2\u09f2\u09f3\3\2\2\2\u09f3\u09f9\3")
        buf.write("\2\2\2\u09f4\u09f7\7\u019a\2\2\u09f5\u09f8\5\u022c\u0117")
        buf.write("\2\u09f6\u09f8\5\u0154\u00ab\2\u09f7\u09f5\3\2\2\2\u09f7")
        buf.write("\u09f6\3\2\2\2\u09f8\u09fa\3\2\2\2\u09f9\u09f4\3\2\2\2")
        buf.write("\u09f9\u09fa\3\2\2\2\u09fa\u09fc\3\2\2\2\u09fb\u09fd\7")
        buf.write("\32\2\2\u09fc\u09fb\3\2\2\2\u09fc\u09fd\3\2\2\2\u09fd")
        buf.write("\u00a7\3\2\2\2\u09fe\u09ff\7\u01ac\2\2\u09ff\u0a01\7\u00d2")
        buf.write("\2\2\u0a00\u09fe\3\2\2\2\u0a00\u0a01\3\2\2\2\u0a01\u0a03")
        buf.write("\3\2\2\2\u0a02\u0a04\7\u010e\2\2\u0a03\u0a02\3\2\2\2\u0a03")
        buf.write("\u0a04\3\2\2\2\u0a04\u0a06\3\2\2\2\u0a05\u0a07\7\u00bf")
        buf.write("\2\2\u0a06\u0a05\3\2\2\2\u0a06\u0a07\3\2\2\2\u0a07\u0a08")
        buf.write("\3\2\2\2\u0a08\u0a09\7\177\2\2\u0a09\u0a14\5\u022c\u0117")
        buf.write("\2\u0a0a\u0a0b\7e\2\2\u0a0b\u0a0e\5\u0286\u0144\2\u0a0c")
        buf.write("\u0a0d\7v\2\2\u0a0d\u0a0f\5\u0286\u0144\2\u0a0e\u0a0c")
        buf.write("\3\2\2\2\u0a0e\u0a0f\3\2\2\2\u0a0f\u0a12\3\2\2\2\u0a10")
        buf.write("\u0a11\7\u011d\2\2\u0a11\u0a13\5\u0286\u0144\2\u0a12\u0a10")
        buf.write("\3\2\2\2\u0a12\u0a13\3\2\2\2\u0a13\u0a15\3\2\2\2\u0a14")
        buf.write("\u0a0a\3\2\2\2\u0a14\u0a15\3\2\2\2\u0a15\u00a9\3\2\2\2")
        buf.write("\u0a16\u0a17\7P\2\2\u0a17\u0a18\7\u010c\2\2\u0a18\u0a19")
        buf.write("\5\u022c\u0117\2\u0a19\u0a1a\7\u01aa\2\2\u0a1a\u0a2f\5")
        buf.write("\u022c\u0117\2\u0a1b\u0a2b\7\u01c0\2\2\u0a1c\u0a1d\5\u0286")
        buf.write("\u0144\2\u0a1d\u0a1e\7\u019e\2\2\u0a1e\u0a1f\7\u0255\2")
        buf.write("\2\u0a1f\u0a24\5\u0154\u00ab\2\u0a20\u0a21\7\u024f\2\2")
        buf.write("\u0a21\u0a23\5\u0154\u00ab\2\u0a22\u0a20\3\2\2\2\u0a23")
        buf.write("\u0a26\3\2\2\2\u0a24\u0a22\3\2\2\2\u0a24\u0a25\3\2\2\2")
        buf.write("\u0a25\u0a27\3\2\2\2\u0a26\u0a24\3\2\2\2\u0a27\u0a29\7")
        buf.write("\u0256\2\2\u0a28\u0a2a\7\u017a\2\2\u0a29\u0a28\3\2\2\2")
        buf.write("\u0a29\u0a2a\3\2\2\2\u0a2a\u0a2c\3\2\2\2\u0a2b\u0a1c\3")
        buf.write("\2\2\2\u0a2c\u0a2d\3\2\2\2\u0a2d\u0a2b\3\2\2\2\u0a2d\u0a2e")
        buf.write("\3\2\2\2\u0a2e\u0a30\3\2\2\2\u0a2f\u0a1b\3\2\2\2\u0a2f")
        buf.write("\u0a30\3\2\2\2\u0a30\u0a31\3\2\2\2\u0a31\u0a32\7T\2\2")
        buf.write("\u0a32\u0a33\t\21\2\2\u0a33\u0a34\5\u024c\u0127\2\u0a34")
        buf.write("\u00ab\3\2\2\2\u0a35\u0a36\7\u010f\2\2\u0a36\u0aca\5\u0286")
        buf.write("\u0144\2\u0a37\u0a7c\7\u017d\2\2\u0a38\u0a41\7\u0255\2")
        buf.write("\2\u0a39\u0a3e\5\u01e0\u00f1\2\u0a3a\u0a3b\7\u024f\2\2")
        buf.write("\u0a3b\u0a3d\5\u01e0\u00f1\2\u0a3c\u0a3a\3\2\2\2\u0a3d")
        buf.write("\u0a40\3\2\2\2\u0a3e\u0a3c\3\2\2\2\u0a3e\u0a3f\3\2\2\2")
        buf.write("\u0a3f\u0a42\3\2\2\2\u0a40\u0a3e\3\2\2\2\u0a41\u0a39\3")
        buf.write("\2\2\2\u0a41\u0a42\3\2\2\2\u0a42\u0a43\3\2\2\2\u0a43\u0a7d")
        buf.write("\7\u0256\2\2\u0a44\u0a45\7N\2\2\u0a45\u0a4e\7\u0255\2")
        buf.write("\2\u0a46\u0a4b\5\u0154\u00ab\2\u0a47\u0a48\7\u024f\2\2")
        buf.write("\u0a48\u0a4a\5\u0154\u00ab\2\u0a49\u0a47\3\2\2\2\u0a4a")
        buf.write("\u0a4d\3\2\2\2\u0a4b\u0a49\3\2\2\2\u0a4b\u0a4c\3\2\2\2")
        buf.write("\u0a4c\u0a4f\3\2\2\2\u0a4d\u0a4b\3\2\2\2\u0a4e\u0a46\3")
        buf.write("\2\2\2\u0a4e\u0a4f\3\2\2\2\u0a4f\u0a50\3\2\2\2\u0a50\u0a7d")
        buf.write("\7\u0256\2\2\u0a51\u0a52\7\u00c5\2\2\u0a52\u0a62\7\u0255")
        buf.write("\2\2\u0a53\u0a54\7\u021f\2\2\u0a54\u0a55\7\u024c\2\2\u0a55")
        buf.write("\u0a63\5\u0240\u0121\2\u0a56\u0a57\7\u021e\2\2\u0a57\u0a58")
        buf.write("\7\u024c\2\2\u0a58\u0a63\5\u022c\u0117\2\u0a59\u0a5a\7")
        buf.write("\u0163\2\2\u0a5a\u0a5b\7\u024c\2\2\u0a5b\u0a63\5\u0286")
        buf.write("\u0144\2\u0a5c\u0a5d\7\u01c9\2\2\u0a5d\u0a5e\7\u024c\2")
        buf.write("\2\u0a5e\u0a63\5\u0286\u0144\2\u0a5f\u0a60\7\u021d\2\2")
        buf.write("\u0a60\u0a61\7\u024c\2\2\u0a61\u0a63\5\u0286\u0144\2\u0a62")
        buf.write("\u0a53\3\2\2\2\u0a62\u0a56\3\2\2\2\u0a62\u0a59\3\2\2\2")
        buf.write("\u0a62\u0a5c\3\2\2\2\u0a62\u0a5f\3\2\2\2\u0a62\u0a63\3")
        buf.write("\2\2\2\u0a63\u0a78\3\2\2\2\u0a64\u0a74\7\u024f\2\2\u0a65")
        buf.write("\u0a66\7\u021f\2\2\u0a66\u0a67\7\u024c\2\2\u0a67\u0a75")
        buf.write("\5\u0240\u0121\2\u0a68\u0a69\7\u021e\2\2\u0a69\u0a6a\7")
        buf.write("\u024c\2\2\u0a6a\u0a75\5\u022c\u0117\2\u0a6b\u0a6c\7\u0163")
        buf.write("\2\2\u0a6c\u0a6d\7\u024c\2\2\u0a6d\u0a75\5\u0286\u0144")
        buf.write("\2\u0a6e\u0a6f\7\u01c9\2\2\u0a6f\u0a70\7\u024c\2\2\u0a70")
        buf.write("\u0a75\5\u0286\u0144\2\u0a71\u0a72\7\u021d\2\2\u0a72\u0a73")
        buf.write("\7\u024c\2\2\u0a73\u0a75\5\u0286\u0144\2\u0a74\u0a65\3")
        buf.write("\2\2\2\u0a74\u0a68\3\2\2\2\u0a74\u0a6b\3\2\2\2\u0a74\u0a6e")
        buf.write("\3\2\2\2\u0a74\u0a71\3\2\2\2\u0a75\u0a77\3\2\2\2\u0a76")
        buf.write("\u0a64\3\2\2\2\u0a77\u0a7a\3\2\2\2\u0a78\u0a76\3\2\2\2")
        buf.write("\u0a78\u0a79\3\2\2\2\u0a79\u0a7b\3\2\2\2\u0a7a\u0a78\3")
        buf.write("\2\2\2\u0a7b\u0a7d\7\u0256\2\2\u0a7c\u0a38\3\2\2\2\u0a7c")
        buf.write("\u0a44\3\2\2\2\u0a7c\u0a51\3\2\2\2\u0a7d\u0acb\3\2\2\2")
        buf.write("\u0a7e\u0a86\7\u0255\2\2\u0a7f\u0a80\7\u01e6\2\2\u0a80")
        buf.write("\u0a83\7\u024c\2\2\u0a81\u0a84\5\u0160\u00b1\2\u0a82\u0a84")
        buf.write("\7\u0227\2\2\u0a83\u0a81\3\2\2\2\u0a83\u0a82\3\2\2\2\u0a84")
        buf.write("\u0a85\3\2\2\2\u0a85\u0a87\7\u024f\2\2\u0a86\u0a7f\3\2")
        buf.write("\2\2\u0a86\u0a87\3\2\2\2\u0a87\u0a88\3\2\2\2\u0a88\u0a89")
        buf.write("\7w\2\2\u0a89\u0a8a\7\u024c\2\2\u0a8a\u0a8b\5\u0286\u0144")
        buf.write("\2\u0a8b\u0a8c\7\u024f\2\2\u0a8c\u0a8d\7\u0204\2\2\u0a8d")
        buf.write("\u0a8e\7\u024c\2\2\u0a8e\u0ac5\5\u0286\u0144\2\u0a8f\u0ac1")
        buf.write("\7\u024f\2\2\u0a90\u0a91\7\u020d\2\2\u0a91\u0a92\7\u024c")
        buf.write("\2\2\u0a92\u0ac2\5\u0286\u0144\2\u0a93\u0a94\7\u0214\2")
        buf.write("\2\u0a94\u0a95\7\u024c\2\2\u0a95\u0ac2\5\u0286\u0144\2")
        buf.write("\u0a96\u0a97\7\u0223\2\2\u0a97\u0a98\7\u024c\2\2\u0a98")
        buf.write("\u0ac2\5\u0286\u0144\2\u0a99\u0a9a\7\u0224\2\2\u0a9a\u0a9b")
        buf.write("\7\u024c\2\2\u0a9b\u0ac2\5\u0286\u0144\2\u0a9c\u0a9d\7")
        buf.write("\u0179\2\2\u0a9d\u0a9e\7\u024c\2\2\u0a9e\u0ac2\5\u0286")
        buf.write("\u0144\2\u0a9f\u0aa0\7\u01e6\2\2\u0aa0\u0aa3\7\u024c\2")
        buf.write("\2\u0aa1\u0aa4\5\u0160\u00b1\2\u0aa2\u0aa4\7\u0227\2\2")
        buf.write("\u0aa3\u0aa1\3\2\2\2\u0aa3\u0aa2\3\2\2\2\u0aa4\u0ac2\3")
        buf.write("\2\2\2\u0aa5\u0ac2\7\u0205\2\2\u0aa6\u0aa7\7\u01c4\2\2")
        buf.write("\u0aa7\u0aa8\7\u024c\2\2\u0aa8\u0ac2\5\u0240\u0121\2\u0aa9")
        buf.write("\u0aaa\7\u00fb\2\2\u0aaa\u0aab\7\u024c\2\2\u0aab\u0ac2")
        buf.write("\5^\60\2\u0aac\u0aad\7\u016f\2\2\u0aad\u0aae\7\u024c\2")
        buf.write("\2\u0aae\u0ac2\5\u0240\u0121\2\u0aaf\u0ab0\7\u01ca\2\2")
        buf.write("\u0ab0\u0ab1\7\u024c\2\2\u0ab1\u0ac2\5\u0154\u00ab\2\u0ab2")
        buf.write("\u0ab3\7\u0209\2\2\u0ab3\u0ab4\7\u024c\2\2\u0ab4\u0ac2")
        buf.write("\5\u025c\u012f\2\u0ab5\u0ab6\7\u018e\2\2\u0ab6\u0ab7\7")
        buf.write("\u024c\2\2\u0ab7\u0ac2\5\u024c\u0127\2\u0ab8\u0ab9\7\u01d5")
        buf.write("\2\2\u0ab9\u0aba\7\u024c\2\2\u0aba\u0ac2\5\u0240\u0121")
        buf.write("\2\u0abb\u0abc\7?\2\2\u0abc\u0abd\7\u024c\2\2\u0abd\u0ac2")
        buf.write("\5\u0154\u00ab\2\u0abe\u0abf\7\u01cb\2\2\u0abf\u0ac0\7")
        buf.write("\u024c\2\2\u0ac0\u0ac2\5\u025c\u012f\2\u0ac1\u0a90\3\2")
        buf.write("\2\2\u0ac1\u0a93\3\2\2\2\u0ac1\u0a96\3\2\2\2\u0ac1\u0a99")
        buf.write("\3\2\2\2\u0ac1\u0a9c\3\2\2\2\u0ac1\u0a9f\3\2\2\2\u0ac1")
        buf.write("\u0aa5\3\2\2\2\u0ac1\u0aa6\3\2\2\2\u0ac1\u0aa9\3\2\2\2")
        buf.write("\u0ac1\u0aac\3\2\2\2\u0ac1\u0aaf\3\2\2\2\u0ac1\u0ab2\3")
        buf.write("\2\2\2\u0ac1\u0ab5\3\2\2\2\u0ac1\u0ab8\3\2\2\2\u0ac1\u0abb")
        buf.write("\3\2\2\2\u0ac1\u0abe\3\2\2\2\u0ac2\u0ac4\3\2\2\2\u0ac3")
        buf.write("\u0a8f\3\2\2\2\u0ac4\u0ac7\3\2\2\2\u0ac5\u0ac3\3\2\2\2")
        buf.write("\u0ac5\u0ac6\3\2\2\2\u0ac6\u0ac8\3\2\2\2\u0ac7\u0ac5\3")
        buf.write("\2\2\2\u0ac8\u0ac9\7\u0256\2\2\u0ac9\u0acb\3\2\2\2\u0aca")
        buf.write("\u0a37\3\2\2\2\u0aca\u0a7e\3\2\2\2\u0aca\u0acb\3\2\2\2")
        buf.write("\u0acb\u00ad\3\2\2\2\u0acc\u0acd\7G\2\2\u0acd\u0acf\5")
        buf.write("\u0286\u0144\2\u0ace\u0ad0\7\u017d\2\2\u0acf\u0ace\3\2")
        buf.write("\2\2\u0acf\u0ad0\3\2\2\2\u0ad0\u0ad1\3\2\2\2\u0ad1\u0ad8")
        buf.write("\5\u0240\u0121\2\u0ad2\u0ad7\5\u0214\u010b\2\u0ad3\u0ad4")
        buf.write("\7\u018e\2\2\u0ad4\u0ad7\5\u024c\u0127\2\u0ad5\u0ad7\5")
        buf.write("\u00ecw\2\u0ad6\u0ad2\3\2\2\2\u0ad6\u0ad3\3\2\2\2\u0ad6")
        buf.write("\u0ad5\3\2\2\2\u0ad7\u0ada\3\2\2\2\u0ad8\u0ad6\3\2\2\2")
        buf.write("\u0ad8\u0ad9\3\2\2\2\u0ad9\u00af\3\2\2\2\u0ada\u0ad8\3")
        buf.write("\2\2\2\u0adb\u0add\7\u00ea\2\2\u0adc\u0ade\5\u01a8\u00d5")
        buf.write("\2\u0add\u0adc\3\2\2\2\u0add\u0ade\3\2\2\2\u0ade\u0adf")
        buf.write("\3\2\2\2\u0adf\u0ae2\5\u022c\u0117\2\u0ae0\u0ae1\7\u010f")
        buf.write("\2\2\u0ae1\u0ae3\5\u0154\u00ab\2\u0ae2\u0ae0\3\2\2\2\u0ae2")
        buf.write("\u0ae3\3\2\2\2\u0ae3\u0ae6\3\2\2\2\u0ae4\u0ae5\7\u0120")
        buf.write("\2\2\u0ae5\u0ae7\5\u0154\u00ab\2\u0ae6\u0ae4\3\2\2\2\u0ae6")
        buf.write("\u0ae7\3\2\2\2\u0ae7\u0ae8\3\2\2\2\u0ae8\u0ae9\7\u0199")
        buf.write("\2\2\u0ae9\u0aea\7\66\2\2\u0aea\u0aeb\7\u0128\2\2\u0aeb")
        buf.write("\u0aed\5\u022c\u0117\2\u0aec\u0aee\5\u01d4\u00eb\2\u0aed")
        buf.write("\u0aec\3\2\2\2\u0aed\u0aee\3\2\2\2\u0aee\u00b1\3\2\2\2")
        buf.write("\u0aef\u0af0\7\u0108\2\2\u0af0\u0af1\7\u00e4\2\2\u0af1")
        buf.write("\u0af2\7C\2\2\u0af2\u0af3\5\u0286\u0144\2\u0af3\u0af4")
        buf.write("\7\u0255\2\2\u0af4\u0af5\7\u0106\2\2\u0af5\u0af6\7\u024c")
        buf.write("\2\2\u0af6\u0afb\5\u0286\u0144\2\u0af7\u0af8\7\u024f\2")
        buf.write("\2\u0af8\u0afa\5\u00b4[\2\u0af9\u0af7\3\2\2\2\u0afa\u0afd")
        buf.write("\3\2\2\2\u0afb\u0af9\3\2\2\2\u0afb\u0afc\3\2\2\2\u0afc")
        buf.write("\u0afe\3\2\2\2\u0afd\u0afb\3\2\2\2\u0afe\u0aff\7\u0256")
        buf.write("\2\2\u0aff\u00b3\3\2\2\2\u0b00\u0b01\5\u022c\u0117\2\u0b01")
        buf.write("\u0b02\7\u024c\2\2\u0b02\u0b03\5\u024c\u0127\2\u0b03\u00b5")
        buf.write("\3\2\2\2\u0b04\u0b05\7\u0108\2\2\u0b05\u0b06\7\u00e4\2")
        buf.write("\2\u0b06\u0b07\7(\2\2\u0b07\u0b08\5\u0286\u0144\2\u0b08")
        buf.write("\u0b0f\7\u0255\2\2\u0b09\u0b0a\7\u00b2\2\2\u0b0a\u0b0b")
        buf.write("\7\u024c\2\2\u0b0b\u0b10\5\u0286\u0144\2\u0b0c\u0b0d\7")
        buf.write("/\2\2\u0b0d\u0b0e\7\u024c\2\2\u0b0e\u0b10\5\u0286\u0144")
        buf.write("\2\u0b0f\u0b09\3\2\2\2\u0b0f\u0b0c\3\2\2\2\u0b10\u0b11")
        buf.write("\3\2\2\2\u0b11\u0b12\7\u0256\2\2\u0b12\u00b7\3\2\2\2\u0b13")
        buf.write("\u0b14\7\u0108\2\2\u0b14\u0b15\7\u00e4\2\2\u0b15\u0b16")
        buf.write("\7\u0106\2\2\u0b16\u0b17\5\u0286\u0144\2\u0b17\u0b1d\7")
        buf.write("\u0255\2\2\u0b18\u0b19\7\u01e4\2\2\u0b19\u0b1a\7\u024c")
        buf.write("\2\2\u0b1a\u0b1b\5\u0286\u0144\2\u0b1b\u0b1c\7\u024f\2")
        buf.write("\2\u0b1c\u0b1e\3\2\2\2\u0b1d\u0b18\3\2\2\2\u0b1d\u0b1e")
        buf.write("\3\2\2\2\u0b1e\u0b1f\3\2\2\2\u0b1f\u0b20\7\u01ec\2\2\u0b20")
        buf.write("\u0b21\7\u024c\2\2\u0b21\u0b26\5\u0286\u0144\2\u0b22\u0b23")
        buf.write("\7\u024f\2\2\u0b23\u0b24\7\u01e4\2\2\u0b24\u0b25\7\u024c")
        buf.write("\2\2\u0b25\u0b27\5\u0286\u0144\2\u0b26\u0b22\3\2\2\2\u0b26")
        buf.write("\u0b27\3\2\2\2\u0b27\u0b28\3\2\2\2\u0b28\u0b29\7\u0256")
        buf.write("\2\2\u0b29\u00b9\3\2\2\2\u0b2a\u0b2b\7\u0108\2\2\u0b2b")
        buf.write("\u0b2c\7\u00e4\2\2\u0b2c\u0b2d\7\u00b2\2\2\u0b2d\u0b2e")
        buf.write("\5\u0286\u0144\2\u0b2e\u0b2f\7\u0255\2\2\u0b2f\u0b30\7")
        buf.write("\u00f6\2\2\u0b30\u0b31\7\u024c\2\2\u0b31\u0b32\5\u0286")
        buf.write("\u0144\2\u0b32\u0b33\7\u024f\2\2\u0b33\u0b34\7\u01de\2")
        buf.write("\2\u0b34\u0b35\7\u024c\2\2\u0b35\u0b36\5\u0286\u0144\2")
        buf.write("\u0b36\u0b37\7\u024f\2\2\u0b37\u0b38\7\u0194\2\2\u0b38")
        buf.write("\u0b39\7\u024c\2\2\u0b39\u0b3a\5\u0286\u0144\2\u0b3a\u0b40")
        buf.write("\7\u024f\2\2\u0b3b\u0b3c\7\u01e1\2\2\u0b3c\u0b3d\7\u024c")
        buf.write("\2\2\u0b3d\u0b3e\5\u0286\u0144\2\u0b3e\u0b3f\7\u024f\2")
        buf.write("\2\u0b3f\u0b41\3\2\2\2\u0b40\u0b3b\3\2\2\2\u0b40\u0b41")
        buf.write("\3\2\2\2\u0b41\u0b42\3\2\2\2\u0b42\u0b43\7\u01ed\2\2\u0b43")
        buf.write("\u0b44\7\u024c\2\2\u0b44\u0b49\5\u0286\u0144\2\u0b45\u0b46")
        buf.write("\7\u024f\2\2\u0b46\u0b47\7\u01e1\2\2\u0b47\u0b48\7\u024c")
        buf.write("\2\2\u0b48\u0b4a\5\u0286\u0144\2\u0b49\u0b45\3\2\2\2\u0b49")
        buf.write("\u0b4a\3\2\2\2\u0b4a\u0b4b\3\2\2\2\u0b4b\u0b4c\7\u0256")
        buf.write("\2\2\u0b4c\u00bb\3\2\2\2\u0b4d\u0b4f\7\u0163\2\2\u0b4e")
        buf.write("\u0b50\5\u01a8\u00d5\2\u0b4f\u0b4e\3\2\2\2\u0b4f\u0b50")
        buf.write("\3\2\2\2\u0b50\u0b51\3\2\2\2\u0b51\u0b60\5\u0286\u0144")
        buf.write("\2\u0b52\u0b53\7\u019a\2\2\u0b53\u0b61\5\u0286\u0144\2")
        buf.write("\u0b54\u0b5d\7\u0255\2\2\u0b55\u0b5a\5\u00c0a\2\u0b56")
        buf.write("\u0b57\7\u024f\2\2\u0b57\u0b59\5\u00c0a\2\u0b58\u0b56")
        buf.write("\3\2\2\2\u0b59\u0b5c\3\2\2\2\u0b5a\u0b58\3\2\2\2\u0b5a")
        buf.write("\u0b5b\3\2\2\2\u0b5b\u0b5e\3\2\2\2\u0b5c\u0b5a\3\2\2\2")
        buf.write("\u0b5d\u0b55\3\2\2\2\u0b5d\u0b5e\3\2\2\2\u0b5e\u0b5f\3")
        buf.write("\2\2\2\u0b5f\u0b61\7\u0256\2\2\u0b60\u0b52\3\2\2\2\u0b60")
        buf.write("\u0b54\3\2\2\2\u0b61\u00bd\3\2\2\2\u0b62\u0b63\7\u0163")
        buf.write("\2\2\u0b63\u0b69\5\u0286\u0144\2\u0b64\u0b65\7\u00cc\2")
        buf.write("\2\u0b65\u0b6a\7\u0120\2\2\u0b66\u0b6a\5\u0208\u0105\2")
        buf.write("\u0b67\u0b6a\5\u0206\u0104\2\u0b68\u0b6a\5\u020a\u0106")
        buf.write("\2\u0b69\u0b64\3\2\2\2\u0b69\u0b66\3\2\2\2\u0b69\u0b67")
        buf.write("\3\2\2\2\u0b69\u0b68\3\2\2\2\u0b6a\u00bf\3\2\2\2\u0b6b")
        buf.write("\u0b6c\t\"\2\2\u0b6c\u0b6f\7\u024c\2\2\u0b6d\u0b70\5\u0154")
        buf.write("\u00ab\2\u0b6e\u0b70\5\u022c\u0117\2\u0b6f\u0b6d\3\2\2")
        buf.write("\2\u0b6f\u0b6e\3\2\2\2\u0b70\u0b75\3\2\2\2\u0b71\u0b72")
        buf.write("\7\u01d3\2\2\u0b72\u0b73\7\u024c\2\2\u0b73\u0b75\58\35")
        buf.write("\2\u0b74\u0b6b\3\2\2\2\u0b74\u0b71\3\2\2\2\u0b75\u00c1")
        buf.write("\3\2\2\2\u0b76\u0b77\7\u01bd\2\2\u0b77\u0b79\7\u008b\2")
        buf.write("\2\u0b78\u0b7a\5\u01a8\u00d5\2\u0b79\u0b78\3\2\2\2\u0b79")
        buf.write("\u0b7a\3\2\2\2\u0b7a\u0b7b\3\2\2\2\u0b7b\u0b7e\7\u0198")
        buf.write("\2\2\u0b7c\u0b7f\5,\27\2\u0b7d\u0b7f\7\u01bd\2\2\u0b7e")
        buf.write("\u0b7c\3\2\2\2\u0b7e\u0b7d\3\2\2\2\u0b7f\u0b80\3\2\2\2")
        buf.write("\u0b80\u0b81\7\u00ea\2\2\u0b81\u0b83\5\u022c\u0117\2\u0b82")
        buf.write("\u0b84\5\u01d4\u00eb\2\u0b83\u0b82\3\2\2\2\u0b83\u0b84")
        buf.write("\3\2\2\2\u0b84\u00c3\3\2\2\2\u0b85\u0b86\7\u01bd\2\2\u0b86")
        buf.write("\u0b87\7\u008b\2\2\u0b87\u0b8a\7\u0198\2\2\u0b88\u0b8b")
        buf.write("\5,\27\2\u0b89\u0b8b\7\u01bd\2\2\u0b8a\u0b88\3\2\2\2\u0b8a")
        buf.write("\u0b89\3\2\2\2\u0b8b\u0b8c\3\2\2\2\u0b8c\u0b8d\7\u00ea")
        buf.write("\2\2\u0b8d\u0b8f\5\u022c\u0117\2\u0b8e\u0b90\5\u01d4\u00eb")
        buf.write("\2\u0b8f\u0b8e\3\2\2\2\u0b8f\u0b90\3\2\2\2\u0b90\u00c5")
        buf.write("\3\2\2\2\u0b91\u0b9f\t\34\2\2\u0b92\u0ba0\5\u00c8e\2\u0b93")
        buf.write("\u0b94\5\u022c\u0117\2\u0b94\u0b95\5\u0208\u0105\2\u0b95")
        buf.write("\u0ba0\3\2\2\2\u0b96\u0b98\5,\27\2\u0b97\u0b99\7\u01c3")
        buf.write("\2\2\u0b98\u0b97\3\2\2\2\u0b98\u0b99\3\2\2\2\u0b99\u0b9b")
        buf.write("\3\2\2\2\u0b9a\u0b9c\5\u00f6|\2\u0b9b\u0b9a\3\2\2\2\u0b9c")
        buf.write("\u0b9d\3\2\2\2\u0b9d\u0b9b\3\2\2\2\u0b9d\u0b9e\3\2\2\2")
        buf.write("\u0b9e\u0ba0\3\2\2\2\u0b9f\u0b92\3\2\2\2\u0b9f\u0b93\3")
        buf.write("\2\2\2\u0b9f\u0b96\3\2\2\2\u0ba0\u00c7\3\2\2\2\u0ba1\u0ba4")
        buf.write("\5,\27\2\u0ba2\u0ba4\7\u0178\2\2\u0ba3\u0ba1\3\2\2\2\u0ba3")
        buf.write("\u0ba2\3\2\2\2\u0ba4\u0ba8\3\2\2\2\u0ba5\u0ba6\7\u019e")
        buf.write("\2\2\u0ba6\u0ba7\7\67\2\2\u0ba7\u0ba9\5\u022c\u0117\2")
        buf.write("\u0ba8\u0ba5\3\2\2\2\u0ba8\u0ba9\3\2\2\2\u0ba9\u0baa\3")
        buf.write("\2\2\2\u0baa\u0bab\5\u00caf\2\u0bab\u00c9\3\2\2\2\u0bac")
        buf.write("\u0bb0\7\u00ec\2\2\u0bad\u0bae\5\u022c\u0117\2\u0bae\u0baf")
        buf.write("\7\u025d\2\2\u0baf\u0bb1\3\2\2\2\u0bb0\u0bad\3\2\2\2\u0bb0")
        buf.write("\u0bb1\3\2\2\2\u0bb1\u0bb2\3\2\2\2\u0bb2\u0bb3\5\u022c")
        buf.write("\u0117\2\u0bb3\u0bb4\t\33\2\2\u0bb4\u0bb5\5\u011a\u008e")
        buf.write("\2\u0bb5\u0bca\3\2\2\2\u0bb6\u0bba\7\u00ec\2\2\u0bb7\u0bb8")
        buf.write("\5\u022c\u0117\2\u0bb8\u0bb9\7\u025d\2\2\u0bb9\u0bbb\3")
        buf.write("\2\2\2\u0bba\u0bb7\3\2\2\2\u0bba\u0bbb\3\2\2\2\u0bbb\u0bbc")
        buf.write("\3\2\2\2\u0bbc\u0bbd\5\u022c\u0117\2\u0bbd\u0bbe\7\u019a")
        buf.write("\2\2\u0bbe\u0bbf\7\63\2\2\u0bbf\u0bca\3\2\2\2\u0bc0\u0bc4")
        buf.write("\7\u00d4\2\2\u0bc1\u0bc2\5\u022c\u0117\2\u0bc2\u0bc3\7")
        buf.write("\u025d\2\2\u0bc3\u0bc5\3\2\2\2\u0bc4\u0bc1\3\2\2\2\u0bc4")
        buf.write("\u0bc5\3\2\2\2\u0bc5\u0bc6\3\2\2\2\u0bc6\u0bca\5\u022c")
        buf.write("\u0117\2\u0bc7\u0bc8\7\u00d4\2\2\u0bc8\u0bca\7\u0178\2")
        buf.write("\2\u0bc9\u0bac\3\2\2\2\u0bc9\u0bb6\3\2\2\2\u0bc9\u0bc0")
        buf.write("\3\2\2\2\u0bc9\u0bc7\3\2\2\2\u0bca\u00cb\3\2\2\2\u0bcb")
        buf.write("\u0bcc\7\u019c\2\2\u0bcc\u0bcd\5\u00ceh\2\u0bcd\u00cd")
        buf.write("\3\2\2\2\u0bce\u0bcf\5\u022c\u0117\2\u0bcf\u0bd0\5\u0208")
        buf.write("\u0105\2\u0bd0\u0bd7\3\2\2\2\u0bd1\u0bd2\5,\27\2\u0bd2")
        buf.write("\u0bd3\t\22\2\2\u0bd3\u0bd4\7\u01bd\2\2\u0bd4\u0bd5\5")
        buf.write("\u02d0\u0169\2\u0bd5\u0bd7\3\2\2\2\u0bd6\u0bce\3\2\2\2")
        buf.write("\u0bd6\u0bd1\3\2\2\2\u0bd7\u00cf\3\2\2\2\u0bd8\u0bd9\7")
        buf.write("\u0104\2\2\u0bd9\u0bda\5\u022c\u0117\2\u0bda\u0bdb\5\u00d4")
        buf.write("k\2\u0bdb\u00d1\3\2\2\2\u0bdc\u0bdd\7\u00a8\2\2\u0bdd")
        buf.write("\u0bfa\5\u00eav\2\u0bde\u0bdf\7\u0080\2\2\u0bdf\u0be0")
        buf.write("\7\u00a3\2\2\u0be0\u0bfa\7\u026c\2\2\u0be1\u0be2\t#\2")
        buf.write("\2\u0be2\u0be3\5\u0286\u0144\2\u0be3\u0be4\5\u0150\u00a9")
        buf.write("\2\u0be4\u0bfa\3\2\2\2\u0be5\u0be6\7\u0108\2\2\u0be6\u0be7")
        buf.write("\7\u00e4\2\2\u0be7\u0bf4\7C\2\2\u0be8\u0be9\7\u0108\2")
        buf.write("\2\u0be9\u0bea\7\u00e4\2\2\u0bea\u0bf4\7(\2\2\u0beb\u0bf4")
        buf.write("\7G\2\2\u0bec\u0bf4\7\u00e1\2\2\u0bed\u0bf4\7\u00e7\2")
        buf.write("\2\u0bee\u0bf4\7\u010f\2\2\u0bef\u0bf1\7\u008d\2\2\u0bf0")
        buf.write("\u0bef\3\2\2\2\u0bf0\u0bf1\3\2\2\2\u0bf1\u0bf2\3\2\2\2")
        buf.write("\u0bf2\u0bf4\7\u0121\2\2\u0bf3\u0be5\3\2\2\2\u0bf3\u0be8")
        buf.write("\3\2\2\2\u0bf3\u0beb\3\2\2\2\u0bf3\u0bec\3\2\2\2\u0bf3")
        buf.write("\u0bed\3\2\2\2\u0bf3\u0bee\3\2\2\2\u0bf3\u0bf0\3\2\2\2")
        buf.write("\u0bf4\u0bf6\3\2\2\2\u0bf5\u0bf7\5\u01a6\u00d4\2\u0bf6")
        buf.write("\u0bf5\3\2\2\2\u0bf6\u0bf7\3\2\2\2\u0bf7\u0bf8\3\2\2\2")
        buf.write("\u0bf8\u0bfa\5\u0286\u0144\2\u0bf9\u0bdc\3\2\2\2\u0bf9")
        buf.write("\u0bde\3\2\2\2\u0bf9\u0be1\3\2\2\2\u0bf9\u0bf3\3\2\2\2")
        buf.write("\u0bfa\u0bfb\3\2\2\2\u0bfb\u0bfc\5\u0206\u0104\2\u0bfc")
        buf.write("\u00d3\3\2\2\2\u0bfd\u0c11\5\u0208\u0105\2\u0bfe\u0c11")
        buf.write("\5\u0206\u0104\2\u0bff\u0c00\7\u00ec\2\2\u0c00\u0c01\7")
        buf.write("\u0255\2\2\u0c01\u0c06\5\u00b4[\2\u0c02\u0c03\7\u024f")
        buf.write("\2\2\u0c03\u0c05\5\u00b4[\2\u0c04\u0c02\3\2\2\2\u0c05")
        buf.write("\u0c08\3\2\2\2\u0c06\u0c04\3\2\2\2\u0c06\u0c07\3\2\2\2")
        buf.write("\u0c07\u0c09\3\2\2\2\u0c08\u0c06\3\2\2\2\u0c09\u0c0a\7")
        buf.write("\u0256\2\2\u0c0a\u0c11\3\2\2\2\u0c0b\u0c0c\7\u00d4\2\2")
        buf.write("\u0c0c\u0c0d\7\u0255\2\2\u0c0d\u0c0e\5\u02d0\u0169\2\u0c0e")
        buf.write("\u0c0f\7\u0256\2\2\u0c0f\u0c11\3\2\2\2\u0c10\u0bfd\3\2")
        buf.write("\2\2\u0c10\u0bfe\3\2\2\2\u0c10\u0bff\3\2\2\2\u0c10\u0c0b")
        buf.write("\3\2\2\2\u0c11\u00d5\3\2\2\2\u0c12\u0c13\7\u00f8\2\2\u0c13")
        buf.write("\u0c18\5\u0286\u0144\2\u0c14\u0c19\5\u0208\u0105\2\u0c15")
        buf.write("\u0c19\5\u020a\u0106\2\u0c16\u0c19\5\u0206\u0104\2\u0c17")
        buf.write("\u0c19\5\u00d8m\2\u0c18\u0c14\3\2\2\2\u0c18\u0c15\3\2")
        buf.write("\2\2\u0c18\u0c16\3\2\2\2\u0c18\u0c17\3\2\2\2\u0c19\u00d7")
        buf.write("\3\2\2\2\u0c1a\u0c1b\7\u00ec\2\2\u0c1b\u0c1c\7\u00f8\2")
        buf.write("\2\u0c1c\u0c1d\5\u015e\u00b0\2\u0c1d\u00d9\3\2\2\2\u0c1e")
        buf.write("\u0c1f\7\u0199\2\2\u0c1f\u0c20\7\66\2\2\u0c20\u0c21\7")
        buf.write("\u0128\2\2\u0c21\u0c22\5\u022c\u0117\2\u0c22\u0c23\5\u00dc")
        buf.write("o\2\u0c23\u00db\3\2\2\2\u0c24\u0c25\7e\2\2\u0c25\u0c29")
        buf.write("\5\u023c\u011f\2\u0c26\u0c27\7\u009d\2\2\u0c27\u0c29\7")
        buf.write("e\2\2\u0c28\u0c24\3\2\2\2\u0c28\u0c26\3\2\2\2\u0c28\u0c29")
        buf.write("\3\2\2\2\u0c29\u0c2e\3\2\2\2\u0c2a\u0c2b\7\u011d\2\2\u0c2b")
        buf.write("\u0c2f\5\u023c\u011f\2\u0c2c\u0c2d\7\u009d\2\2\u0c2d\u0c2f")
        buf.write("\7\u011d\2\2\u0c2e\u0c2a\3\2\2\2\u0c2e\u0c2c\3\2\2\2\u0c2e")
        buf.write("\u0c2f\3\2\2\2\u0c2f\u0c31\3\2\2\2\u0c30\u0c32\5\u01d4")
        buf.write("\u00eb\2\u0c31\u0c30\3\2\2\2\u0c31\u0c32\3\2\2\2\u0c32")
        buf.write("\u0c36\3\2\2\2\u0c33\u0c36\5\u0206\u0104\2\u0c34\u0c36")
        buf.write("\5\u0208\u0105\2\u0c35\u0c28\3\2\2\2\u0c35\u0c33\3\2\2")
        buf.write("\2\u0c35\u0c34\3\2\2\2\u0c36\u00dd\3\2\2\2\u0c37\u0c38")
        buf.write("\7\u00a8\2\2\u0c38\u0c39\5\u00eav\2\u0c39\u0c3a\5\u00e0")
        buf.write("q\2\u0c3a\u00df\3\2\2\2\u0c3b\u0c49\5\u020a\u0106\2\u0c3c")
        buf.write("\u0c3d\7\u00ec\2\2\u0c3d\u0c3e\7\u0255\2\2\u0c3e\u0c43")
        buf.write("\5\u00e2r\2\u0c3f\u0c40\7\u024f\2\2\u0c40\u0c42\5\u00e2")
        buf.write("r\2\u0c41\u0c3f\3\2\2\2\u0c42\u0c45\3\2\2\2\u0c43\u0c41")
        buf.write("\3\2\2\2\u0c43\u0c44\3\2\2\2\u0c44\u0c46\3\2\2\2\u0c45")
        buf.write("\u0c43\3\2\2\2\u0c46\u0c47\7\u0256\2\2\u0c47\u0c49\3\2")
        buf.write("\2\2\u0c48\u0c3b\3\2\2\2\u0c48\u0c3c\3\2\2\2\u0c49\u00e1")
        buf.write("\3\2\2\2\u0c4a\u0c4b\t$\2\2\u0c4b\u0c4c\7\u024c\2\2\u0c4c")
        buf.write("\u0c4d\5\u0286\u0144\2\u0c4d\u00e3\3\2\2\2\u0c4e\u0c4f")
        buf.write("\7\u01bd\2\2\u0c4f\u0c51\7\u008b\2\2\u0c50\u0c52\5\u01a6")
        buf.write("\u00d4\2\u0c51\u0c50\3\2\2\2\u0c51\u0c52\3\2\2\2\u0c52")
        buf.write("\u0c53\3\2\2\2\u0c53\u0c56\7\u0198\2\2\u0c54\u0c57\5,")
        buf.write("\27\2\u0c55\u0c57\7\u01bd\2\2\u0c56\u0c54\3\2\2\2\u0c56")
        buf.write("\u0c55\3\2\2\2\u0c57\u0c58\3\2\2\2\u0c58\u0c59\7\u00ea")
        buf.write("\2\2\u0c59\u0c5a\5\u022c\u0117\2\u0c5a\u00e5\3\2\2\2\u0c5b")
        buf.write("\u0c5c\7\u00af\2\2\u0c5c\u0c5d\7\26\2\2\u0c5d\u0c62\5")
        buf.write(",\27\2\u0c5e\u0c5f\7\u024f\2\2\u0c5f\u0c61\5,\27\2\u0c60")
        buf.write("\u0c5e\3\2\2\2\u0c61\u0c64\3\2\2\2\u0c62\u0c60\3\2\2\2")
        buf.write("\u0c62\u0c63\3\2\2\2\u0c63\u0c66\3\2\2\2\u0c64\u0c62\3")
        buf.write("\2\2\2\u0c65\u0c67\5\u0212\u010a\2\u0c66\u0c65\3\2\2\2")
        buf.write("\u0c66\u0c67\3\2\2\2\u0c67\u00e7\3\2\2\2\u0c68\u0c6a\7")
        buf.write("\u00a8\2\2\u0c69\u0c6b\5\u01a6\u00d4\2\u0c6a\u0c69\3\2")
        buf.write("\2\2\u0c6a\u0c6b\3\2\2\2\u0c6b\u0c6c\3\2\2\2\u0c6c\u0c71")
        buf.write("\5\u00eav\2\u0c6d\u0c6e\7\u024f\2\2\u0c6e\u0c70\5\u00ea")
        buf.write("v\2\u0c6f\u0c6d\3\2\2\2\u0c70\u0c73\3\2\2\2\u0c71\u0c6f")
        buf.write("\3\2\2\2\u0c71\u0c72\3\2\2\2\u0c72\u0c75\3\2\2\2\u0c73")
        buf.write("\u0c71\3\2\2\2\u0c74\u0c76\5\u0212\u010a\2\u0c75\u0c74")
        buf.write("\3\2\2\2\u0c75\u0c76\3\2\2\2\u0c76\u00e9\3\2\2\2\u0c77")
        buf.write("\u0c78\5\u010c\u0087\2\u0c78\u0c7b\7\u0255\2\2\u0c79\u0c7c")
        buf.write("\5\u0240\u0121\2\u0c7a\u0c7c\7\u0143\2\2\u0c7b\u0c79\3")
        buf.write("\2\2\2\u0c7b\u0c7a\3\2\2\2\u0c7c\u0c7d\3\2\2\2\u0c7d\u0c80")
        buf.write("\7\u024f\2\2\u0c7e\u0c81\5\u0240\u0121\2\u0c7f\u0c81\7")
        buf.write("\u0143\2\2\u0c80\u0c7e\3\2\2\2\u0c80\u0c7f\3\2\2\2\u0c81")
        buf.write("\u0c82\3\2\2\2\u0c82\u0c83\7\u0256\2\2\u0c83\u00eb\3\2")
        buf.write("\2\2\u0c84\u0c85\7\u0186\2\2\u0c85\u0c87\5\u022c\u0117")
        buf.write("\2\u0c86\u0c84\3\2\2\2\u0c86\u0c87\3\2\2\2\u0c87\u0c91")
        buf.write("\3\2\2\2\u0c88\u0c89\7\u0183\2\2\u0c89\u0c8a\7\u0255\2")
        buf.write("\2\u0c8a\u0c8b\5\u024c\u0127\2\u0c8b\u0c8c\7\u0256\2\2")
        buf.write("\u0c8c\u0c92\3\2\2\2\u0c8d\u0c8f\7\u01a7\2\2\u0c8e\u0c8d")
        buf.write("\3\2\2\2\u0c8e\u0c8f\3\2\2\2\u0c8f\u0c90\3\2\2\2\u0c90")
        buf.write("\u0c92\7\u01a8\2\2\u0c91\u0c88\3\2\2\2\u0c91\u0c8e\3\2")
        buf.write("\2\2\u0c92\u00ed\3\2\2\2\u0c93\u0c94\7\u01ac\2\2\u0c94")
        buf.write("\u0c96\7\u00d2\2\2\u0c95\u0c93\3\2\2\2\u0c95\u0c96\3\2")
        buf.write("\2\2\u0c96\u0c97\3\2\2\2\u0c97\u0c98\7\u010b\2\2\u0c98")
        buf.write("\u0c99\7\u0198\2\2\u0c99\u0c9a\5\u0240\u0121\2\u0c9a\u0c9b")
        buf.write("\7\177\2\2\u0c9b\u0c9c\5\u022c\u0117\2\u0c9c\u0c9d\7\u0255")
        buf.write("\2\2\u0c9d\u0c9e\7\u019a\2\2\u0c9e\u0c9f\7\u00f3\2\2\u0c9f")
        buf.write("\u0ca0\7\u01c3\2\2\u0ca0\u0ca1\7_\2\2\u0ca1\u0ca2\5\u014e")
        buf.write("\u00a8\2\u0ca2\u0ca3\7\u024f\2\2\u0ca3\u0ca4\7\u01b8\2")
        buf.write("\2\u0ca4\u0ca5\7\u00f3\2\2\u0ca5\u0ca6\7\u01c3\2\2\u0ca6")
        buf.write("\u0ca7\7_\2\2\u0ca7\u0ca8\5\u014e\u00a8\2\u0ca8\u0ca9")
        buf.write("\7\u0256\2\2\u0ca9\u00ef\3\2\2\2\u0caa\u0cab\7\5\2\2\u0cab")
        buf.write("\u0cac\7\u008f\2\2\u0cac\u0cad\5\u022c\u0117\2\u0cad\u0cae")
        buf.write("\7\u010f\2\2\u0cae\u0caf\t%\2\2\u0caf\u0cb0\7e\2\2\u0cb0")
        buf.write("\u0cb1\5\u0286\u0144\2\u0cb1\u00f1\3\2\2\2\u0cb2\u0cb3")
        buf.write("\t\34\2\2\u0cb3\u0cbe\5\u022c\u0117\2\u0cb4\u0cb6\7\u01c3")
        buf.write("\2\2\u0cb5\u0cb4\3\2\2\2\u0cb5\u0cb6\3\2\2\2\u0cb6\u0cb7")
        buf.write("\3\2\2\2\u0cb7\u0cbb\5\u00f4{\2\u0cb8\u0cba\5\u00f4{\2")
        buf.write("\u0cb9\u0cb8\3\2\2\2\u0cba\u0cbd\3\2\2\2\u0cbb\u0cb9\3")
        buf.write("\2\2\2\u0cbb\u0cbc\3\2\2\2\u0cbc\u0cbf\3\2\2\2\u0cbd\u0cbb")
        buf.write("\3\2\2\2\u0cbe\u0cb5\3\2\2\2\u0cbe\u0cbf\3\2\2\2\u0cbf")
        buf.write("\u00f3\3\2\2\2\u0cc0\u0cc4\5\u00f8}\2\u0cc1\u0cc4\5\u00fa")
        buf.write("~\2\u0cc2\u0cc4\5\u00fc\177\2\u0cc3\u0cc0\3\2\2\2\u0cc3")
        buf.write("\u0cc1\3\2\2\2\u0cc3\u0cc2\3\2\2\2\u0cc4\u00f5\3\2\2\2")
        buf.write("\u0cc5\u0cc8\5\u00f8}\2\u0cc6\u0cc8\5\u00fa~\2\u0cc7\u0cc5")
        buf.write("\3\2\2\2\u0cc7\u0cc6\3\2\2\2\u0cc8\u00f7\3\2\2\2\u0cc9")
        buf.write("\u0cdf\7\u0221\2\2\u0cca\u0cdf\7\u0203\2\2\u0ccb\u0cdf")
        buf.write("\7\u01d0\2\2\u0ccc\u0cdf\7\u01fe\2\2\u0ccd\u0cdf\7\u01d1")
        buf.write("\2\2\u0cce\u0cdf\7\u01ff\2\2\u0ccf\u0cdf\7t\2\2\u0cd0")
        buf.write("\u0cdf\7\u0200\2\2\u0cd1\u0cdf\7\u01f0\2\2\u0cd2\u0cdf")
        buf.write("\7\u0201\2\2\u0cd3\u0cd5\7M\2\2\u0cd4\u0cd3\3\2\2\2\u0cd4")
        buf.write("\u0cd5\3\2\2\2\u0cd5\u0cd6\3\2\2\2\u0cd6\u0cd9\7\u00b6")
        buf.write("\2\2\u0cd7\u0cda\7\u0271\2\2\u0cd8\u0cda\7\u01a8\2\2\u0cd9")
        buf.write("\u0cd7\3\2\2\2\u0cd9\u0cd8\3\2\2\2\u0cda\u0cdf\3\2\2\2")
        buf.write("\u0cdb\u0cdc\7\u011b\2\2\u0cdc\u0cdd\7\u0118\2\2\u0cdd")
        buf.write("\u0cdf\7\u0271\2\2\u0cde\u0cc9\3\2\2\2\u0cde\u0cca\3\2")
        buf.write("\2\2\u0cde\u0ccb\3\2\2\2\u0cde\u0ccc\3\2\2\2\u0cde\u0ccd")
        buf.write("\3\2\2\2\u0cde\u0cce\3\2\2\2\u0cde\u0ccf\3\2\2\2\u0cde")
        buf.write("\u0cd0\3\2\2\2\u0cde\u0cd1\3\2\2\2\u0cde\u0cd2\3\2\2\2")
        buf.write("\u0cde\u0cd4\3\2\2\2\u0cde\u0cdb\3\2\2\2\u0cdf\u00f9\3")
        buf.write("\2\2\2\u0ce0\u0ce8\7\u020f\2\2\u0ce1\u0ce8\7\u0202\2\2")
        buf.write("\u0ce2\u0ce8\7\u01c8\2\2\u0ce3\u0ce8\7\u01fd\2\2\u0ce4")
        buf.write("\u0ce5\7*\2\2\u0ce5\u0ce6\7\u01a4\2\2\u0ce6\u0ce8\5\u015e")
        buf.write("\u00b0\2\u0ce7\u0ce0\3\2\2\2\u0ce7\u0ce1\3\2\2\2\u0ce7")
        buf.write("\u0ce2\3\2\2\2\u0ce7\u0ce3\3\2\2\2\u0ce7\u0ce4\3\2\2\2")
        buf.write("\u0ce8\u00fb\3\2\2\2\u0ce9\u0cea\7\u0101\2\2\u0cea\u0cf6")
        buf.write("\5\u024c\u0127\2\u0ceb\u0cec\7\u019e\2\2\u0cec\u0cf3\7")
        buf.write("\u00d9\2\2\u0ced\u0cee\7\u019e\2\2\u0cee\u0cf3\7\u019c")
        buf.write("\2\2\u0cef\u0cf3\7\u00d9\2\2\u0cf0\u0cf3\7\b\2\2\u0cf1")
        buf.write("\u0cf3\7\u01bd\2\2\u0cf2\u0ceb\3\2\2\2\u0cf2\u0ced\3\2")
        buf.write("\2\2\u0cf2\u0cef\3\2\2\2\u0cf2\u0cf0\3\2\2\2\u0cf2\u0cf1")
        buf.write("\3\2\2\2\u0cf3\u0cf4\3\2\2\2\u0cf4\u0cf6\5\u02d0\u0169")
        buf.write("\2\u0cf5\u0ce9\3\2\2\2\u0cf5\u0cf2\3\2\2\2\u0cf6\u00fd")
        buf.write("\3\2\2\2\u0cf7\u0cf8\7\u019c\2\2\u0cf8\u0d01\5\u022c\u0117")
        buf.write("\2\u0cf9\u0cfb\7\u01c3\2\2\u0cfa\u0cf9\3\2\2\2\u0cfa\u0cfb")
        buf.write("\3\2\2\2\u0cfb\u0cfd\3\2\2\2\u0cfc\u0cfe\5\u0100\u0081")
        buf.write("\2\u0cfd\u0cfc\3\2\2\2\u0cfe\u0cff\3\2\2\2\u0cff\u0cfd")
        buf.write("\3\2\2\2\u0cff\u0d00\3\2\2\2\u0d00\u0d02\3\2\2\2\u0d01")
        buf.write("\u0cfa\3\2\2\2\u0d01\u0d02\3\2\2\2\u0d02\u00ff\3\2\2\2")
        buf.write("\u0d03\u0d06\5\u00f8}\2\u0d04\u0d06\5\u00fc\177\2\u0d05")
        buf.write("\u0d03\3\2\2\2\u0d05\u0d04\3\2\2\2\u0d06\u0101\3\2\2\2")
        buf.write("\u0d07\u0d08\7\u0104\2\2\u0d08\u0d0b\5\u022c\u0117\2\u0d09")
        buf.write("\u0d0a\7\u00b0\2\2\u0d0a\u0d0c\5,\27\2\u0d0b\u0d09\3\2")
        buf.write("\2\2\u0d0b\u0d0c\3\2\2\2\u0d0c\u0d0d\3\2\2\2\u0d0d\u0d0e")
        buf.write("\7\u0087\2\2\u0d0e\u0d1b\7\u0271\2\2\u0d0f\u0d10\7\u01c3")
        buf.write("\2\2\u0d10\u0d11\7\u0255\2\2\u0d11\u0d16\5\u00b4[\2\u0d12")
        buf.write("\u0d13\7\u024f\2\2\u0d13\u0d15\5\u00b4[\2\u0d14\u0d12")
        buf.write("\3\2\2\2\u0d15\u0d18\3\2\2\2\u0d16\u0d14\3\2\2\2\u0d16")
        buf.write("\u0d17\3\2\2\2\u0d17\u0d19\3\2\2\2\u0d18\u0d16\3\2\2\2")
        buf.write("\u0d19\u0d1a\7\u0256\2\2\u0d1a\u0d1c\3\2\2\2\u0d1b\u0d0f")
        buf.write("\3\2\2\2\u0d1b\u0d1c\3\2\2\2\u0d1c\u0103\3\2\2\2\u0d1d")
        buf.write("\u0d1f\7\u00f8\2\2\u0d1e\u0d20\5\u01a8\u00d5\2\u0d1f\u0d1e")
        buf.write("\3\2\2\2\u0d1f\u0d20\3\2\2\2\u0d20\u0d21\3\2\2\2\u0d21")
        buf.write("\u0d26\5\u0286\u0144\2\u0d22\u0d23\7\u0255\2\2\u0d23\u0d24")
        buf.write("\5\u02d0\u0169\2\u0d24\u0d25\7\u0256\2\2\u0d25\u0d27\3")
        buf.write("\2\2\2\u0d26\u0d22\3\2\2\2\u0d26\u0d27\3\2\2\2\u0d27\u0d28")
        buf.write("\3\2\2\2\u0d28\u0d29\7\u01aa\2\2\u0d29\u0d2a\5\u022c\u0117")
        buf.write("\2\u0d2a\u0d2b\7\u024f\2\2\u0d2b\u0d2c\5\u02d0\u0169\2")
        buf.write("\u0d2c\u0d2d\7\u019a\2\2\u0d2d\u0d2e\5\u0286\u0144\2\u0d2e")
        buf.write("\u0105\3\2\2\2\u0d2f\u0d30\7\u0199\2\2\u0d30\u0d31\7\66")
        buf.write("\2\2\u0d31\u0d32\7\u0128\2\2\u0d32\u0d37\5\u022c\u0117")
        buf.write("\2\u0d33\u0d34\7e\2\2\u0d34\u0d38\5\u023c\u011f\2\u0d35")
        buf.write("\u0d36\7\u009d\2\2\u0d36\u0d38\7e\2\2\u0d37\u0d33\3\2")
        buf.write("\2\2\u0d37\u0d35\3\2\2\2\u0d37\u0d38\3\2\2\2\u0d38\u0d3d")
        buf.write("\3\2\2\2\u0d39\u0d3a\7\u011d\2\2\u0d3a\u0d3e\5\u023c\u011f")
        buf.write("\2\u0d3b\u0d3c\7\u009d\2\2\u0d3c\u0d3e\7\u011d\2\2\u0d3d")
        buf.write("\u0d39\3\2\2\2\u0d3d\u0d3b\3\2\2\2\u0d3d\u0d3e\3\2\2\2")
        buf.write("\u0d3e\u0d4b\3\2\2\2\u0d3f\u0d40\7\u00aa\2\2\u0d40\u0d41")
        buf.write("\7\u0255\2\2\u0d41\u0d46\5\u0108\u0085\2\u0d42\u0d43\7")
        buf.write("\u024f\2\2\u0d43\u0d45\5\u0108\u0085\2\u0d44\u0d42\3\2")
        buf.write("\2\2\u0d45\u0d48\3\2\2\2\u0d46\u0d44\3\2\2\2\u0d46\u0d47")
        buf.write("\3\2\2\2\u0d47\u0d49\3\2\2\2\u0d48\u0d46\3\2\2\2\u0d49")
        buf.write("\u0d4a\7\u0256\2\2\u0d4a\u0d4c\3\2\2\2\u0d4b\u0d3f\3\2")
        buf.write("\2\2\u0d4b\u0d4c\3\2\2\2\u0d4c\u0107\3\2\2\2\u0d4d\u0d4e")
        buf.write("\5\u022c\u0117\2\u0d4e\u0d4f\7\u0271\2\2\u0d4f\u0109\3")
        buf.write("\2\2\2\u0d50\u0d51\7\u00a8\2\2\u0d51\u0d52\5\u010c\u0087")
        buf.write("\2\u0d52\u0d53\7\u0255\2\2\u0d53\u0d58\5\u010e\u0088\2")
        buf.write("\u0d54\u0d55\7\u024f\2\2\u0d55\u0d57\5\u010e\u0088\2\u0d56")
        buf.write("\u0d54\3\2\2\2\u0d57\u0d5a\3\2\2\2\u0d58\u0d56\3\2\2\2")
        buf.write("\u0d58\u0d59\3\2\2\2\u0d59\u0d5b\3\2\2\2\u0d5a\u0d58\3")
        buf.write("\2\2\2\u0d5b\u0d5c\7\u0256\2\2\u0d5c\u010b\3\2\2\2\u0d5d")
        buf.write("\u0d5e\5\u022c\u0117\2\u0d5e\u0d5f\7\u025d\2\2\u0d5f\u0d61")
        buf.write("\3\2\2\2\u0d60\u0d5d\3\2\2\2\u0d60\u0d61\3\2\2\2\u0d61")
        buf.write("\u0d62\3\2\2\2\u0d62\u0d63\5\u01ea\u00f6\2\u0d63\u010d")
        buf.write("\3\2\2\2\u0d64\u0d65\t\21\2\2\u0d65\u0d66\7\u024c\2\2")
        buf.write("\u0d66\u0d76\5\u0286\u0144\2\u0d67\u0d68\7\u00d6\2\2\u0d68")
        buf.write("\u0d69\7\u024c\2\2\u0d69\u0d76\5\u0286\u0144\2\u0d6a\u0d6b")
        buf.write("\7\u016d\2\2\u0d6b\u0d6c\7\u024c\2\2\u0d6c\u0d76\5\u0286")
        buf.write("\u0144\2\u0d6d\u0d6e\t&\2\2\u0d6e\u0d6f\7\u024c\2\2\u0d6f")
        buf.write("\u0d76\5\u0240\u0121\2\u0d70\u0d71\t\'\2\2\u0d71\u0d72")
        buf.write("\7\u024c\2\2\u0d72\u0d76\5\u0252\u012a\2\u0d73\u0d76\7")
        buf.write("\u01e0\2\2\u0d74\u0d76\7\u01f2\2\2\u0d75\u0d64\3\2\2\2")
        buf.write("\u0d75\u0d67\3\2\2\2\u0d75\u0d6a\3\2\2\2\u0d75\u0d6d\3")
        buf.write("\2\2\2\u0d75\u0d70\3\2\2\2\u0d75\u0d73\3\2\2\2\u0d75\u0d74")
        buf.write("\3\2\2\2\u0d76\u010f\3\2\2\2\u0d77\u0d78\7\u01ac\2\2\u0d78")
        buf.write("\u0d7a\7\u00d2\2\2\u0d79\u0d77\3\2\2\2\u0d79\u0d7a\3\2")
        buf.write("\2\2\u0d7a\u0d7b\3\2\2\2\u0d7b\u0d7c\7\n\2\2\u0d7c\u0d7e")
        buf.write("\5\u0286\u0144\2\u0d7d\u0d7f\5\u0150\u00a9\2\u0d7e\u0d7d")
        buf.write("\3\2\2\2\u0d7e\u0d7f\3\2\2\2\u0d7f\u0d80\3\2\2\2\u0d80")
        buf.write("\u0d86\7\u0255\2\2\u0d81\u0d82\7\u01c6\2\2\u0d82\u0d83")
        buf.write("\7\u024c\2\2\u0d83\u0d84\5\u0240\u0121\2\u0d84\u0d85\7")
        buf.write("\u024f\2\2\u0d85\u0d87\3\2\2\2\u0d86\u0d81\3\2\2\2\u0d86")
        buf.write("\u0d87\3\2\2\2\u0d87\u0d88\3\2\2\2\u0d88\u0d89\7\u0217")
        buf.write("\2\2\u0d89\u0d8a\7\u024c\2\2\u0d8a\u0d8b\5\u0286\u0144")
        buf.write("\2\u0d8b\u0d8c\7\u024f\2\2\u0d8c\u0d8d\7\u021c\2\2\u0d8d")
        buf.write("\u0d8e\7\u024c\2\2\u0d8e\u0d93\5\u0240\u0121\2\u0d8f\u0d90")
        buf.write("\7\u024f\2\2\u0d90\u0d92\5\u0112\u008a\2\u0d91\u0d8f\3")
        buf.write("\2\2\2\u0d92\u0d95\3\2\2\2\u0d93\u0d91\3\2\2\2\u0d93\u0d94")
        buf.write("\3\2\2\2\u0d94\u0d96\3\2\2\2\u0d95\u0d93\3\2\2\2\u0d96")
        buf.write("\u0d97\7\u0256\2\2\u0d97\u0111\3\2\2\2\u0d98\u0d99\7\u021b")
        buf.write("\2\2\u0d99\u0d9a\7\u024c\2\2\u0d9a\u0dcc\7\u026c\2\2\u0d9b")
        buf.write("\u0d9c\7\u01d7\2\2\u0d9c\u0d9d\7\u024c\2\2\u0d9d\u0dcc")
        buf.write("\5\u0286\u0144\2\u0d9e\u0dcc\7\u01d8\2\2\u0d9f\u0da0\7")
        buf.write("\u01d9\2\2\u0da0\u0da1\7\u024c\2\2\u0da1\u0dcc\t(\2\2")
        buf.write("\u0da2\u0da3\7\u01cc\2\2\u0da3\u0da4\7\u024c\2\2\u0da4")
        buf.write("\u0dcc\5\u0286\u0144\2\u0da5\u0da6\7\u0215\2\2\u0da6\u0da7")
        buf.write("\7\u024c\2\2\u0da7\u0dcc\5\u0286\u0144\2\u0da8\u0da9\7")
        buf.write("\u01d2\2\2\u0da9\u0daa\7\u024c\2\2\u0daa\u0dcc\5\u0286")
        buf.write("\u0144\2\u0dab\u0dac\7\u01e5\2\2\u0dac\u0dad\7\u024c\2")
        buf.write("\2\u0dad\u0dcc\5\u024c\u0127\2\u0dae\u0daf\7\u01f9\2\2")
        buf.write("\u0daf\u0db0\7\u024c\2\2\u0db0\u0dcc\5\u0286\u0144\2\u0db1")
        buf.write("\u0db2\7\u01f7\2\2\u0db2\u0db3\7\u024c\2\2\u0db3\u0dcc")
        buf.write("\5\u0286\u0144\2\u0db4\u0db5\7\u01fb\2\2\u0db5\u0db6\7")
        buf.write("\u024c\2\2\u0db6\u0dcc\5\u0240\u0121\2\u0db7\u0db8\7\u01fa")
        buf.write("\2\2\u0db8\u0db9\7\u024c\2\2\u0db9\u0dcc\7\u026c\2\2\u0dba")
        buf.write("\u0dbb\7\u01f3\2\2\u0dbb\u0dbc\7\u024c\2\2\u0dbc\u0dcc")
        buf.write("\5\u0286\u0144\2\u0dbd\u0dcc\7\u01f4\2\2\u0dbe\u0dbf\7")
        buf.write("\u01f5\2\2\u0dbf\u0dc0\7\u024c\2\2\u0dc0\u0dcc\t(\2\2")
        buf.write("\u0dc1\u0dc2\7\u01f6\2\2\u0dc2\u0dc3\7\u024c\2\2\u0dc3")
        buf.write("\u0dcc\5\u024c\u0127\2\u0dc4\u0dc5\7\u021a\2\2\u0dc5\u0dc6")
        buf.write("\7\u024c\2\2\u0dc6\u0dcc\5\u0252\u012a\2\u0dc7\u0dc8\7")
        buf.write("\u00b1\2\2\u0dc8\u0dc9\7\u024c\2\2\u0dc9\u0dcc\t\32\2")
        buf.write("\2\u0dca\u0dcc\7\u01e2\2\2\u0dcb\u0d98\3\2\2\2\u0dcb\u0d9b")
        buf.write("\3\2\2\2\u0dcb\u0d9e\3\2\2\2\u0dcb\u0d9f\3\2\2\2\u0dcb")
        buf.write("\u0da2\3\2\2\2\u0dcb\u0da5\3\2\2\2\u0dcb\u0da8\3\2\2\2")
        buf.write("\u0dcb\u0dab\3\2\2\2\u0dcb\u0dae\3\2\2\2\u0dcb\u0db1\3")
        buf.write("\2\2\2\u0dcb\u0db4\3\2\2\2\u0dcb\u0db7\3\2\2\2\u0dcb\u0dba")
        buf.write("\3\2\2\2\u0dcb\u0dbd\3\2\2\2\u0dcb\u0dbe\3\2\2\2\u0dcb")
        buf.write("\u0dc1\3\2\2\2\u0dcb\u0dc4\3\2\2\2\u0dcb\u0dc7\3\2\2\2")
        buf.write("\u0dcb\u0dca\3\2\2\2\u0dcc\u0113\3\2\2\2\u0dcd\u0dce\7")
        buf.write("\u00ec\2\2\u0dce\u0dcf\5\u0116\u008c\2\u0dcf\u0115\3\2")
        buf.write("\2\2\u0dd0\u0dd3\7+\2\2\u0dd1\u0dd4\7\u0178\2\2\u0dd2")
        buf.write("\u0dd4\5\u01f2\u00fa\2\u0dd3\u0dd1\3\2\2\2\u0dd3\u0dd2")
        buf.write("\3\2\2\2\u0dd4\u0dd5\3\2\2\2\u0dd5\u0df6\t\30\2\2\u0dd6")
        buf.write("\u0dd7\7\u010a\2\2\u0dd7\u0ddc\5\26\f\2\u0dd8\u0dd9\7")
        buf.write("\u024f\2\2\u0dd9\u0ddb\5\26\f\2\u0dda\u0dd8\3\2\2\2\u0ddb")
        buf.write("\u0dde\3\2\2\2\u0ddc\u0dda\3\2\2\2\u0ddc\u0ddd\3\2\2\2")
        buf.write("\u0ddd\u0df6\3\2\2\2\u0dde\u0ddc\3\2\2\2\u0ddf\u0de0\7")
        buf.write("\u010a\2\2\u0de0\u0de1\7\u00f2\2\2\u0de1\u0df6\7\u0271")
        buf.write("\2\2\u0de2\u0de3\7\u00eb\2\2\u0de3\u0de4\7\36\2\2\u0de4")
        buf.write("\u0de5\7\u017d\2\2\u0de5\u0de6\7\u010a\2\2\u0de6\u0deb")
        buf.write("\5\26\f\2\u0de7\u0de8\7\u024f\2\2\u0de8\u0dea\5\26\f\2")
        buf.write("\u0de9\u0de7\3\2\2\2\u0dea\u0ded\3\2\2\2\u0deb\u0de9\3")
        buf.write("\2\2\2\u0deb\u0dec\3\2\2\2\u0dec\u0df6\3\2\2\2\u0ded\u0deb")
        buf.write("\3\2\2\2\u0dee\u0df0\t)\2\2\u0def\u0dee\3\2\2\2\u0def")
        buf.write("\u0df0\3\2\2\2\u0df0\u0df1\3\2\2\2\u0df1\u0df6\5\u0118")
        buf.write("\u008d\2\u0df2\u0df3\7\u012a\2\2\u0df3\u0df4\7\u00a9\2")
        buf.write("\2\u0df4\u0df6\t*\2\2\u0df5\u0dd0\3\2\2\2\u0df5\u0dd6")
        buf.write("\3\2\2\2\u0df5\u0ddf\3\2\2\2\u0df5\u0de2\3\2\2\2\u0df5")
        buf.write("\u0def\3\2\2\2\u0df5\u0df2\3\2\2\2\u0df6\u0117\3\2\2\2")
        buf.write("\u0df7\u0df8\7\u00eb\2\2\u0df8\u0dfc\7\u0161\2\2\u0df9")
        buf.write("\u0dfd\7\u0271\2\2\u0dfa\u0dfd\5\u022c\u0117\2\u0dfb\u0dfd")
        buf.write("\7\u018e\2\2\u0dfc\u0df9\3\2\2\2\u0dfc\u0dfa\3\2\2\2\u0dfc")
        buf.write("\u0dfb\3\2\2\2\u0dfd\u0e15\3\2\2\2\u0dfe\u0dff\7\u0150")
        buf.write("\2\2\u0dff\u0e04\7\u012d\2\2\u0e00\u0e05\7\u0271\2\2\u0e01")
        buf.write("\u0e05\5\u0160\u00b1\2\u0e02\u0e05\7\u0086\2\2\u0e03\u0e05")
        buf.write("\7\u018e\2\2\u0e04\u0e00\3\2\2\2\u0e04\u0e01\3\2\2\2\u0e04")
        buf.write("\u0e02\3\2\2\2\u0e04\u0e03\3\2\2\2\u0e05\u0e15\3\2\2\2")
        buf.write("\u0e06\u0e07\5\u022c\u0117\2\u0e07\u0e08\7\u025d\2\2\u0e08")
        buf.write("\u0e0a\3\2\2\2\u0e09\u0e06\3\2\2\2\u0e09\u0e0a\3\2\2\2")
        buf.write("\u0e0a\u0e0b\3\2\2\2\u0e0b\u0e0c\5\u022c\u0117\2\u0e0c")
        buf.write("\u0e0d\t\33\2\2\u0e0d\u0e0e\5\u011a\u008e\2\u0e0e\u0e15")
        buf.write("\3\2\2\2\u0e0f\u0e12\7\u00d9\2\2\u0e10\u0e13\5\u022c\u0117")
        buf.write("\2\u0e11\u0e13\7\u0143\2\2\u0e12\u0e10\3\2\2\2\u0e12\u0e11")
        buf.write("\3\2\2\2\u0e13\u0e15\3\2\2\2\u0e14\u0df7\3\2\2\2\u0e14")
        buf.write("\u0dfe\3\2\2\2\u0e14\u0e09\3\2\2\2\u0e14\u0e0f\3\2\2\2")
        buf.write("\u0e15\u0119\3\2\2\2\u0e16\u0e1b\5\u024c\u0127\2\u0e17")
        buf.write("\u0e18\7\u024f\2\2\u0e18\u0e1a\5\u024c\u0127\2\u0e19\u0e17")
        buf.write("\3\2\2\2\u0e1a\u0e1d\3\2\2\2\u0e1b\u0e19\3\2\2\2\u0e1b")
        buf.write("\u0e1c\3\2\2\2\u0e1c\u0e20\3\2\2\2\u0e1d\u0e1b\3\2\2\2")
        buf.write("\u0e1e\u0e20\7\u018e\2\2\u0e1f\u0e16\3\2\2\2\u0e1f\u0e1e")
        buf.write("\3\2\2\2\u0e20\u011b\3\2\2\2\u0e21\u0e22\7\u01ac\2\2\u0e22")
        buf.write("\u0e24\7\u00d2\2\2\u0e23\u0e21\3\2\2\2\u0e23\u0e24\3\2")
        buf.write("\2\2\u0e24\u0e25\3\2\2\2\u0e25\u0e26\7\u00df\2\2\u0e26")
        buf.write("\u0e27\5\u022c\u0117\2\u0e27\u0e28\7\u017d\2\2\u0e28\u0e29")
        buf.write("\7\u01aa\2\2\u0e29\u0e2a\t+\2\2\u0e2a\u0e2b\7\u01b8\2")
        buf.write("\2\u0e2b\u0e2e\5\u0286\u0144\2\u0e2c\u0e2d\7\u01c1\2\2")
        buf.write("\u0e2d\u0e2f\5\u024c\u0127\2\u0e2e\u0e2c\3\2\2\2\u0e2e")
        buf.write("\u0e2f\3\2\2\2\u0e2f\u0e30\3\2\2\2\u0e30\u0e32\7\u0192")
        buf.write("\2\2\u0e31\u0e33\t,\2\2\u0e32\u0e31\3\2\2\2\u0e32\u0e33")
        buf.write("\3\2\2\2\u0e33\u0e45\3\2\2\2\u0e34\u0e46\7\u009f\2\2\u0e35")
        buf.write("\u0e46\5\u011e\u0090\2\u0e36\u0e3c\7\u0255\2\2\u0e37\u0e38")
        buf.write("\5\u011e\u0090\2\u0e38\u0e39\7\u024e\2\2\u0e39\u0e3b\3")
        buf.write("\2\2\2\u0e3a\u0e37\3\2\2\2\u0e3b\u0e3e\3\2\2\2\u0e3c\u0e3a")
        buf.write("\3\2\2\2\u0e3c\u0e3d\3\2\2\2\u0e3d\u0e3f\3\2\2\2\u0e3e")
        buf.write("\u0e3c\3\2\2\2\u0e3f\u0e41\5\u011e\u0090\2\u0e40\u0e42")
        buf.write("\7\u024e\2\2\u0e41\u0e40\3\2\2\2\u0e41\u0e42\3\2\2\2\u0e42")
        buf.write("\u0e43\3\2\2\2\u0e43\u0e44\7\u0256\2\2\u0e44\u0e46\3\2")
        buf.write("\2\2\u0e45\u0e34\3\2\2\2\u0e45\u0e35\3\2\2\2\u0e45\u0e36")
        buf.write("\3\2\2\2\u0e46\u011d\3\2\2\2\u0e47\u0e4d\5\u028c\u0147")
        buf.write("\2\u0e48\u0e4d\5\u02bc\u015f\2\u0e49\u0e4d\5\u02c8\u0165")
        buf.write("\2\u0e4a\u0e4d\5\u02c6\u0164\2\u0e4b\u0e4d\5\u02cc\u0167")
        buf.write("\2\u0e4c\u0e47\3\2\2\2\u0e4c\u0e48\3\2\2\2\u0e4c\u0e49")
        buf.write("\3\2\2\2\u0e4c\u0e4a\3\2\2\2\u0e4c\u0e4b\3\2\2\2\u0e4d")
        buf.write("\u011f\3\2\2\2\u0e4e\u0e50\7\u0186\2\2\u0e4f\u0e4e\3\2")
        buf.write("\2\2\u0e4f\u0e50\3\2\2\2\u0e50\u0e51\3\2\2\2\u0e51\u0e52")
        buf.write("\7\u010c\2\2\u0e52\u0e57\5\u022c\u0117\2\u0e53\u0e58\7")
        buf.write("\24\2\2\u0e54\u0e55\7z\2\2\u0e55\u0e58\7\u00a4\2\2\u0e56")
        buf.write("\u0e58\7\t\2\2\u0e57\u0e53\3\2\2\2\u0e57\u0e54\3\2\2\2")
        buf.write("\u0e57\u0e56\3\2\2\2\u0e58\u0e68\3\2\2\2\u0e59\u0e5d\7")
        buf.write("y\2\2\u0e5a\u0e5d\7>\2\2\u0e5b\u0e5d\7\u010d\2\2\u0e5c")
        buf.write("\u0e59\3\2\2\2\u0e5c\u0e5a\3\2\2\2\u0e5c\u0e5b\3\2\2\2")
        buf.write("\u0e5d\u0e64\3\2\2\2\u0e5e\u0e61\7\u0119\2\2\u0e5f\u0e60")
        buf.write("\7\u00a4\2\2\u0e60\u0e62\5\u02d0\u0169\2\u0e61\u0e5f\3")
        buf.write("\2\2\2\u0e61\u0e62\3\2\2\2\u0e62\u0e64\3\2\2\2\u0e63\u0e5c")
        buf.write("\3\2\2\2\u0e63\u0e5e\3\2\2\2\u0e64\u0e66\3\2\2\2\u0e65")
        buf.write("\u0e67\7\u01ac\2\2\u0e66\u0e65\3\2\2\2\u0e66\u0e67\3\2")
        buf.write("\2\2\u0e67\u0e69\3\2\2\2\u0e68\u0e63\3\2\2\2\u0e69\u0e6a")
        buf.write("\3\2\2\2\u0e6a\u0e68\3\2\2\2\u0e6a\u0e6b\3\2\2\2\u0e6b")
        buf.write("\u0e6c\3\2\2\2\u0e6c\u0e6d\7\u01aa\2\2\u0e6d\u0e70\5\u0286")
        buf.write("\u0144\2\u0e6e\u0e6f\7\u019a\2\2\u0e6f\u0e71\5\u0286\u0144")
        buf.write("\2\u0e70\u0e6e\3\2\2\2\u0e70\u0e71\3\2\2\2\u0e71\u0e73")
        buf.write("\3\2\2\2\u0e72\u0e74\5d\63\2\u0e73\u0e72\3\2\2\2\u0e73")
        buf.write("\u0e74\3\2\2\2\u0e74\u0e76\3\2\2\2\u0e75\u0e77\5f\64\2")
        buf.write("\u0e76\u0e75\3\2\2\2\u0e76\u0e77\3\2\2\2\u0e77\u0e7d\3")
        buf.write("\2\2\2\u0e78\u0e79\7\u00cb\2\2\u0e79\u0e7b\5\u0122\u0092")
        buf.write("\2\u0e7a\u0e7c\5\u0122\u0092\2\u0e7b\u0e7a\3\2\2\2\u0e7b")
        buf.write("\u0e7c\3\2\2\2\u0e7c\u0e7e\3\2\2\2\u0e7d\u0e78\3\2\2\2")
        buf.write("\u0e7d\u0e7e\3\2\2\2\u0e7e\u0e84\3\2\2\2\u0e7f\u0e81\7")
        buf.write("\u0198\2\2\u0e80\u0e82\7J\2\2\u0e81\u0e80\3\2\2\2\u0e81")
        buf.write("\u0e82\3\2\2\2\u0e82\u0e83\3\2\2\2\u0e83\u0e85\t-\2\2")
        buf.write("\u0e84\u0e7f\3\2\2\2\u0e84\u0e85\3\2\2\2\u0e85\u0e87\3")
        buf.write("\2\2\2\u0e86\u0e88\5\u0124\u0093\2\u0e87\u0e86\3\2\2\2")
        buf.write("\u0e87\u0e88\3\2\2\2\u0e88\u0e89\3\2\2\2\u0e89\u0e8a\7")
        buf.write("T\2\2\u0e8a\u0e8b\t\21\2\2\u0e8b\u0e8c\5\u0262\u0132\2")
        buf.write("\u0e8c\u0121\3\2\2\2\u0e8d\u0e8e\t.\2\2\u0e8e\u0e90\7")
        buf.write("\u01b6\2\2\u0e8f\u0e91\7\u017d\2\2\u0e90\u0e8f\3\2\2\2")
        buf.write("\u0e90\u0e91\3\2\2\2\u0e91\u0e92\3\2\2\2\u0e92\u0e93\5")
        buf.write("\u022c\u0117\2\u0e93\u0123\3\2\2\2\u0e94\u0e95\7\u01c0")
        buf.write("\2\2\u0e95\u0e96\7\u0255\2\2\u0e96\u0e97\5\u024c\u0127")
        buf.write("\2\u0e97\u0e98\7\u0256\2\2\u0e98\u0125\3\2\2\2\u0e99\u0e9f")
        buf.write("\7\u019b\2\2\u0e9a\u0e9c\7\u00d8\2\2\u0e9b\u0e9d\5t;\2")
        buf.write("\u0e9c\u0e9b\3\2\2\2\u0e9c\u0e9d\3\2\2\2\u0e9d\u0e9f\3")
        buf.write("\2\2\2\u0e9e\u0e99\3\2\2\2\u0e9e\u0e9a\3\2\2\2\u0e9f\u0ea2")
        buf.write("\3\2\2\2\u0ea0\u0ea3\5\u012e\u0098\2\u0ea1\u0ea3\5\u012a")
        buf.write("\u0096\2\u0ea2\u0ea0\3\2\2\2\u0ea2\u0ea1\3\2\2\2\u0ea3")
        buf.write("\u0ea4\3\2\2\2\u0ea4\u0ea5\7\u01aa\2\2\u0ea5\u0ea6\5\u0128")
        buf.write("\u0095\2\u0ea6\u0ea7\t/\2\2\u0ea7\u0eac\5\u0138\u009d")
        buf.write("\2\u0ea8\u0ea9\7\u01c3\2\2\u0ea9\u0eaa\7\u019b\2\2\u0eaa")
        buf.write("\u0ead\7\u00a9\2\2\u0eab\u0ead\5\u0212\u010a\2\u0eac\u0ea8")
        buf.write("\3\2\2\2\u0eac\u0eab\3\2\2\2\u0eac\u0ead\3\2\2\2\u0ead")
        buf.write("\u0eb0\3\2\2\2\u0eae\u0eb0\5\u0132\u009a\2\u0eaf\u0e9e")
        buf.write("\3\2\2\2\u0eaf\u0eae\3\2\2\2\u0eb0\u0127\3\2\2\2\u0eb1")
        buf.write("\u0eb3\7\u01b6\2\2\u0eb2\u0eb1\3\2\2\2\u0eb2\u0eb3\3\2")
        buf.write("\2\2\u0eb3\u0eb4\3\2\2\2\u0eb4\u0ee3\5\u01f2\u00fa\2\u0eb5")
        buf.write("\u0eb6\7\u00e7\2\2\u0eb6\u0ee3\5\u01f2\u00fa\2\u0eb7\u0eb8")
        buf.write("\7\67\2\2\u0eb8\u0ee3\5\u01f2\u00fa\2\u0eb9\u0eba\7G\2")
        buf.write("\2\u0eba\u0ee3\5\u01f2\u00fa\2\u0ebb\u0ebc\7\u0199\2\2")
        buf.write("\u0ebc\u0ebd\7\66\2\2\u0ebd\u0ebe\7\u0128\2\2\u0ebe\u0ee3")
        buf.write("\5\u01f2\u00fa\2\u0ebf\u0ec0\7\u0199\2\2\u0ec0\u0ec1\7")
        buf.write("\u00ea\2\2\u0ec1\u0ee3\5\u01f2\u00fa\2\u0ec2\u0ec3\t\60")
        buf.write("\2\2\u0ec3\u0ec8\5\u014e\u00a8\2\u0ec4\u0ec5\7\u024f\2")
        buf.write("\2\u0ec5\u0ec7\5\u014e\u00a8\2\u0ec6\u0ec4\3\2\2\2\u0ec7")
        buf.write("\u0eca\3\2\2\2\u0ec8\u0ec6\3\2\2\2\u0ec8\u0ec9\3\2\2\2")
        buf.write("\u0ec9\u0ee3\3\2\2\2\u0eca\u0ec8\3\2\2\2\u0ecb\u0ecc\7")
        buf.write("\u0080\2\2\u0ecc\u0ecd\7\u00a3\2\2\u0ecd\u0ed2\7\u026c")
        buf.write("\2\2\u0ece\u0ecf\7\u024f\2\2\u0ecf\u0ed1\7\u026c\2\2\u0ed0")
        buf.write("\u0ece\3\2\2\2\u0ed1\u0ed4\3\2\2\2\u0ed2\u0ed0\3\2\2\2")
        buf.write("\u0ed2\u0ed3\3\2\2\2\u0ed3\u0ee3\3\2\2\2\u0ed4\u0ed2\3")
        buf.write("\2\2\2\u0ed5\u0ed6\7\177\2\2\u0ed6\u0ee3\5\u01f2\u00fa")
        buf.write("\2\u0ed7\u0ed8\7\u00e1\2\2\u0ed8\u0ee3\5\u01f2\u00fa\2")
        buf.write("\u0ed9\u0eda\7\u0104\2\2\u0eda\u0ee3\5\u01f2\u00fa\2\u0edb")
        buf.write("\u0edc\7\u010f\2\2\u0edc\u0ee3\5\u01f2\u00fa\2\u0edd\u0ede")
        buf.write("\7\u0178\2\2\u0ede\u0edf\t\61\2\2\u0edf\u0ee0\7\u019e")
        buf.write("\2\2\u0ee0\u0ee1\7\u00e1\2\2\u0ee1\u0ee3\5\u01f2\u00fa")
        buf.write("\2\u0ee2\u0eb2\3\2\2\2\u0ee2\u0eb5\3\2\2\2\u0ee2\u0eb7")
        buf.write("\3\2\2\2\u0ee2\u0eb9\3\2\2\2\u0ee2\u0ebb\3\2\2\2\u0ee2")
        buf.write("\u0ebf\3\2\2\2\u0ee2\u0ec2\3\2\2\2\u0ee2\u0ecb\3\2\2\2")
        buf.write("\u0ee2\u0ed5\3\2\2\2\u0ee2\u0ed7\3\2\2\2\u0ee2\u0ed9\3")
        buf.write("\2\2\2\u0ee2\u0edb\3\2\2\2\u0ee2\u0edd\3\2\2\2\u0ee3\u0129")
        buf.write("\3\2\2\2\u0ee4\u0ee9\5\u012c\u0097\2\u0ee5\u0ee6\7\u024f")
        buf.write("\2\2\u0ee6\u0ee8\5\u012c\u0097\2\u0ee7\u0ee5\3\2\2\2\u0ee8")
        buf.write("\u0eeb\3\2\2\2\u0ee9\u0ee7\3\2\2\2\u0ee9\u0eea\3\2\2\2")
        buf.write("\u0eea\u012b\3\2\2\2\u0eeb\u0ee9\3\2\2\2\u0eec\u0eed\5")
        buf.write("\u020c\u0107\2\u0eed\u0eee\7\u0255\2\2\u0eee\u0eef\5\u02d0")
        buf.write("\u0169\2\u0eef\u0ef0\7\u0256\2\2\u0ef0\u012d\3\2\2\2\u0ef1")
        buf.write("\u0ef6\5\u0130\u0099\2\u0ef2\u0ef3\7\u024f\2\2\u0ef3\u0ef5")
        buf.write("\5\u0130\u0099\2\u0ef4\u0ef2\3\2\2\2\u0ef5\u0ef8\3\2\2")
        buf.write("\2\u0ef6\u0ef4\3\2\2\2\u0ef6\u0ef7\3\2\2\2\u0ef7\u012f")
        buf.write("\3\2\2\2\u0ef8\u0ef6\3\2\2\2\u0ef9\u0efb\7\u0178\2\2\u0efa")
        buf.write("\u0efc\7\u00be\2\2\u0efb\u0efa\3\2\2\2\u0efb\u0efc\3\2")
        buf.write("\2\2\u0efc\u0f0a\3\2\2\2\u0efd\u0f0a\7\u01ce\2\2\u0efe")
        buf.write("\u0f0a\7\u0187\2\2\u0eff\u0f0a\7>\2\2\u0f00\u0f0a\7T\2")
        buf.write("\2\u0f01\u0f0a\7y\2\2\u0f02\u0f0a\7\u0119\2\2\u0f03\u0f0a")
        buf.write("\7\u01b0\2\2\u0f04\u0f0a\7\u01b2\2\2\u0f05\u0f0a\7\u0105")
        buf.write("\2\2\u0f06\u0f0a\7\u010c\2\2\u0f07\u0f0a\7\u010d\2\2\u0f08")
        buf.write("\u0f0a\7\u0226\2\2\u0f09\u0ef9\3\2\2\2\u0f09\u0efd\3\2")
        buf.write("\2\2\u0f09\u0efe\3\2\2\2\u0f09\u0eff\3\2\2\2\u0f09\u0f00")
        buf.write("\3\2\2\2\u0f09\u0f01\3\2\2\2\u0f09\u0f02\3\2\2\2\u0f09")
        buf.write("\u0f03\3\2\2\2\u0f09\u0f04\3\2\2\2\u0f09\u0f05\3\2\2\2")
        buf.write("\u0f09\u0f06\3\2\2\2\u0f09\u0f07\3\2\2\2\u0f09\u0f08\3")
        buf.write("\2\2\2\u0f0a\u0131\3\2\2\2\u0f0b\u0f0c\7\u019b\2\2\u0f0c")
        buf.write("\u0f0d\5\u01f2\u00fa\2\u0f0d\u0f0e\7\u01b8\2\2\u0f0e\u0f12")
        buf.write("\5\u01f2\u00fa\2\u0f0f\u0f10\7\u01c3\2\2\u0f10\u0f11\7")
        buf.write("\b\2\2\u0f11\u0f13\7\u00a9\2\2\u0f12\u0f0f\3\2\2\2\u0f12")
        buf.write("\u0f13\3\2\2\2\u0f13\u0f21\3\2\2\2\u0f14\u0f18\7\u00d8")
        buf.write("\2\2\u0f15\u0f16\7\b\2\2\u0f16\u0f17\7\u00a9\2\2\u0f17")
        buf.write("\u0f19\7\u0198\2\2\u0f18\u0f15\3\2\2\2\u0f18\u0f19\3\2")
        buf.write("\2\2\u0f19\u0f1a\3\2\2\2\u0f1a\u0f1b\5\u01f2\u00fa\2\u0f1b")
        buf.write("\u0f1c\7\u019a\2\2\u0f1c\u0f1e\5\u01f2\u00fa\2\u0f1d\u0f1f")
        buf.write("\5\u0212\u010a\2\u0f1e\u0f1d\3\2\2\2\u0f1e\u0f1f\3\2\2")
        buf.write("\2\u0f1f\u0f21\3\2\2\2\u0f20\u0f0b\3\2\2\2\u0f20\u0f14")
        buf.write("\3\2\2\2\u0f21\u0133\3\2\2\2\u0f22\u0f23\7\u01b8\2\2\u0f23")
        buf.write("\u0f27\5\u0138\u009d\2\u0f24\u0f25\7\u01c3\2\2\u0f25\u0f26")
        buf.write("\7\u019b\2\2\u0f26\u0f28\7\u00a9\2\2\u0f27\u0f24\3\2\2")
        buf.write("\2\u0f27\u0f28\3\2\2\2\u0f28\u0135\3\2\2\2\u0f29\u0f2a")
        buf.write("\7\u019a\2\2\u0f2a\u0f2c\5\u0138\u009d\2\u0f2b\u0f2d\5")
        buf.write("\u0212\u010a\2\u0f2c\u0f2b\3\2\2\2\u0f2c\u0f2d\3\2\2\2")
        buf.write("\u0f2d\u0137\3\2\2\2\u0f2e\u0f33\5\u013a\u009e\2\u0f2f")
        buf.write("\u0f30\7\u024f\2\2\u0f30\u0f32\5\u013a\u009e\2\u0f31\u0f2f")
        buf.write("\3\2\2\2\u0f32\u0f35\3\2\2\2\u0f33\u0f31\3\2\2\2\u0f33")
        buf.write("\u0f34\3\2\2\2\u0f34\u0139\3\2\2\2\u0f35\u0f33\3\2\2\2")
        buf.write("\u0f36\u0f38\7\u019c\2\2\u0f37\u0f36\3\2\2\2\u0f37\u0f38")
        buf.write("\3\2\2\2\u0f38\u0f39\3\2\2\2\u0f39\u0f3a\5,\27\2\u0f3a")
        buf.write("\u013b\3\2\2\2\u0f3b\u0f3c\7$\2\2\u0f3c\u0f3d\7\u01aa")
        buf.write("\2\2\u0f3d\u0f3e\5\u0140\u00a1\2\u0f3e\u0f41\7\u016b\2")
        buf.write("\2\u0f3f\u0f42\5\u0154\u00ab\2\u0f40\u0f42\7\u01a8\2\2")
        buf.write("\u0f41\u0f3f\3\2\2\2\u0f41\u0f40\3\2\2\2\u0f42\u013d\3")
        buf.write("\2\2\2\u0f43\u0f44\7\u00e6\2\2\u0f44\u0f4a\7~\2\2\u0f45")
        buf.write("\u0f48\7\u0198\2\2\u0f46\u0f49\5\u022c\u0117\2\u0f47\u0f49")
        buf.write("\5\u0154\u00ab\2\u0f48\u0f46\3\2\2\2\u0f48\u0f47\3\2\2")
        buf.write("\2\u0f49\u0f4b\3\2\2\2\u0f4a\u0f45\3\2\2\2\u0f4a\u0f4b")
        buf.write("\3\2\2\2\u0f4b\u0f4c\3\2\2\2\u0f4c\u0f4d\7\u01aa\2\2\u0f4d")
        buf.write("\u0f4e\5\u0142\u00a2\2\u0f4e\u0f51\7\u016b\2\2\u0f4f\u0f52")
        buf.write("\5\u0154\u00ab\2\u0f50\u0f52\7\u01a8\2\2\u0f51\u0f4f\3")
        buf.write("\2\2\2\u0f51\u0f50\3\2\2\2\u0f52\u013f\3\2\2\2\u0f53\u0f54")
        buf.write("\7\5\2\2\u0f54\u0f55\7\u008f\2\2\u0f55\u0fd0\5\u022c\u0117")
        buf.write("\2\u0f56\u0f57\t\62\2\2\u0f57\u0f58\5\u0286\u0144\2\u0f58")
        buf.write("\u0f59\5\u0150\u00a9\2\u0f59\u0fd0\3\2\2\2\u0f5a\u0f5b")
        buf.write("\7\u0182\2\2\u0f5b\u0f5c\7\u0255\2\2\u0f5c\u0f5d\5\u0240")
        buf.write("\u0121\2\u0f5d\u0f5e\7\u017d\2\2\u0f5e\u0f5f\5\u0240\u0121")
        buf.write("\2\u0f5f\u0f60\7\u0256\2\2\u0f60\u0fd0\3\2\2\2\u0f61\u0f62")
        buf.write("\7\u0163\2\2\u0f62\u0fd0\5\u022c\u0117\2\u0f63\u0f64\7")
        buf.write("\u0185\2\2\u0f64\u0fd0\5\u0286\u0144\2\u0f65\u0f66\7\u0186")
        buf.write("\2\2\u0f66\u0f67\5\u022c\u0117\2\u0f67\u0f69\7\u01aa\2")
        buf.write("\2\u0f68\u0f6a\7G\2\2\u0f69\u0f68\3\2\2\2\u0f69\u0f6a")
        buf.write("\3\2\2\2\u0f6a\u0f6b\3\2\2\2\u0f6b\u0f6c\5\u0286\u0144")
        buf.write("\2\u0f6c\u0fd0\3\2\2\2\u0f6d\u0f6e\7.\2\2\u0f6e\u0fd0")
        buf.write("\5\u0286\u0144\2\u0f6f\u0f70\7\67\2\2\u0f70\u0fd0\5\u022c")
        buf.write("\u0117\2\u0f71\u0f72\7G\2\2\u0f72\u0fd0\5\u0286\u0144")
        buf.write("\2\u0f73\u0f74\7W\2\2\u0f74\u0fd0\5\u022c\u0117\2\u0f75")
        buf.write("\u0f76\7P\2\2\u0f76\u0f77\7\u010c\2\2\u0f77\u0fd0\5\u022c")
        buf.write("\u0117\2\u0f78\u0f79\7\u0199\2\2\u0f79\u0f7a\7\66\2\2")
        buf.write("\u0f7a\u0f7b\7\u0128\2\2\u0f7b\u0fd0\5\u022c\u0117\2\u0f7c")
        buf.write("\u0f7e\7\u0199\2\2\u0f7d\u0f7c\3\2\2\2\u0f7d\u0f7e\3\2")
        buf.write("\2\2\u0f7e\u0f7f\3\2\2\2\u0f7f\u0f80\7\u01b6\2\2\u0f80")
        buf.write("\u0fd0\5\u0286\u0144\2\u0f81\u0f82\7r\2\2\u0f82\u0fd0")
        buf.write("\5\u0286\u0144\2\u0f83\u0f84\7\u0080\2\2\u0f84\u0f85\7")
        buf.write("\u00a3\2\2\u0f85\u0fd0\7\u026c\2\2\u0f86\u0f88\7\u008d")
        buf.write("\2\2\u0f87\u0f86\3\2\2\2\u0f87\u0f88\3\2\2\2\u0f88\u0f89")
        buf.write("\3\2\2\2\u0f89\u0f8a\7\u0121\2\2\u0f8a\u0fd0\5\u0286\u0144")
        buf.write("\2\u0f8b\u0f8c\7\u00a8\2\2\u0f8c\u0fd0\5\u00eav\2\u0f8d")
        buf.write("\u0f8e\7\u00a8\2\2\u0f8e\u0f8f\t\63\2\2\u0f8f\u0f90\5")
        buf.write("\u0286\u0144\2\u0f90\u0f91\7\u01be\2\2\u0f91\u0f92\5\u022c")
        buf.write("\u0117\2\u0f92\u0fd0\3\2\2\2\u0f93\u0f94\7\u00b8\2\2\u0f94")
        buf.write("\u0f95\5\u022c\u0117\2\u0f95\u0f96\7\u01aa\2\2\u0f96\u0f97")
        buf.write("\5\u0286\u0144\2\u0f97\u0fd0\3\2\2\2\u0f98\u0f9a\7\u00bf")
        buf.write("\2\2\u0f99\u0f98\3\2\2\2\u0f99\u0f9a\3\2\2\2\u0f9a\u0f9b")
        buf.write("\3\2\2\2\u0f9b\u0f9c\7\177\2\2\u0f9c\u0fd0\5\u0286\u0144")
        buf.write("\2\u0f9d\u0f9e\7\u00c3\2\2\u0f9e\u0fd0\5\u022c\u0117\2")
        buf.write("\u0f9f\u0fa0\7\u00d9\2\2\u0fa0\u0fd0\5\u022c\u0117\2\u0fa1")
        buf.write("\u0fa2\7\u00df\2\2\u0fa2\u0fa3\5\u022c\u0117\2\u0fa3\u0fa4")
        buf.write("\7\u01aa\2\2\u0fa4\u0fa5\5\u0286\u0144\2\u0fa5\u0fd0\3")
        buf.write("\2\2\2\u0fa6\u0fa7\7\u00e1\2\2\u0fa7\u0fd0\5\u022c\u0117")
        buf.write("\2\u0fa8\u0fa9\7\u00e7\2\2\u0fa9\u0fd0\5\u0286\u0144\2")
        buf.write("\u0faa\u0fab\7\u00ea\2\2\u0fab\u0fd0\5\u022c\u0117\2\u0fac")
        buf.write("\u0fad\7\u00f8\2\2\u0fad\u0fd0\5\u0286\u0144\2\u0fae\u0faf")
        buf.write("\7\u00ff\2\2\u0faf\u0fd0\5\u022c\u0117\2\u0fb0\u0fb1\7")
        buf.write("\u0104\2\2\u0fb1\u0fd0\5\u022c\u0117\2\u0fb2\u0fb3\7\u0108")
        buf.write("\2\2\u0fb3\u0fb4\7\u00e4\2\2\u0fb4\u0fb5\7(\2\2\u0fb5")
        buf.write("\u0fd0\5\u0286\u0144\2\u0fb6\u0fb7\7\u0108\2\2\u0fb7\u0fb8")
        buf.write("\7\u00e4\2\2\u0fb8\u0fb9\7C\2\2\u0fb9\u0fd0\5\u0286\u0144")
        buf.write("\2\u0fba\u0fbb\7\u0108\2\2\u0fbb\u0fbc\7\u00e4\2\2\u0fbc")
        buf.write("\u0fbd\7\u00b2\2\2\u0fbd\u0fd0\5\u0286\u0144\2\u0fbe\u0fbf")
        buf.write("\7\u0108\2\2\u0fbf\u0fc0\7\u00e4\2\2\u0fc0\u0fc1\7\u0106")
        buf.write("\2\2\u0fc1\u0fd0\5\u0286\u0144\2\u0fc2\u0fc3\7\u010b\2")
        buf.write("\2\u0fc3\u0fc4\7\u0198\2\2\u0fc4\u0fc5\5\u0286\u0144\2")
        buf.write("\u0fc5\u0fc6\7\177\2\2\u0fc6\u0fc7\5\u022c\u0117\2\u0fc7")
        buf.write("\u0fd0\3\2\2\2\u0fc8\u0fc9\7\u010c\2\2\u0fc9\u0fca\5\u022c")
        buf.write("\u0117\2\u0fca\u0fcb\7\u01aa\2\2\u0fcb\u0fcc\5\u0286\u0144")
        buf.write("\2\u0fcc\u0fd0\3\2\2\2\u0fcd\u0fce\7\u010f\2\2\u0fce\u0fd0")
        buf.write("\5\u0286\u0144\2\u0fcf\u0f53\3\2\2\2\u0fcf\u0f56\3\2\2")
        buf.write("\2\u0fcf\u0f5a\3\2\2\2\u0fcf\u0f61\3\2\2\2\u0fcf\u0f63")
        buf.write("\3\2\2\2\u0fcf\u0f65\3\2\2\2\u0fcf\u0f6d\3\2\2\2\u0fcf")
        buf.write("\u0f6f\3\2\2\2\u0fcf\u0f71\3\2\2\2\u0fcf\u0f73\3\2\2\2")
        buf.write("\u0fcf\u0f75\3\2\2\2\u0fcf\u0f78\3\2\2\2\u0fcf\u0f7d\3")
        buf.write("\2\2\2\u0fcf\u0f81\3\2\2\2\u0fcf\u0f83\3\2\2\2\u0fcf\u0f87")
        buf.write("\3\2\2\2\u0fcf\u0f8b\3\2\2\2\u0fcf\u0f8d\3\2\2\2\u0fcf")
        buf.write("\u0f93\3\2\2\2\u0fcf\u0f99\3\2\2\2\u0fcf\u0f9d\3\2\2\2")
        buf.write("\u0fcf\u0f9f\3\2\2\2\u0fcf\u0fa1\3\2\2\2\u0fcf\u0fa6\3")
        buf.write("\2\2\2\u0fcf\u0fa8\3\2\2\2\u0fcf\u0faa\3\2\2\2\u0fcf\u0fac")
        buf.write("\3\2\2\2\u0fcf\u0fae\3\2\2\2\u0fcf\u0fb0\3\2\2\2\u0fcf")
        buf.write("\u0fb2\3\2\2\2\u0fcf\u0fb6\3\2\2\2\u0fcf\u0fba\3\2\2\2")
        buf.write("\u0fcf\u0fbe\3\2\2\2\u0fcf\u0fc2\3\2\2\2\u0fcf\u0fc8\3")
        buf.write("\2\2\2\u0fcf\u0fcd\3\2\2\2\u0fd0\u0141\3\2\2\2\u0fd1\u0fd2")
        buf.write("\t\62\2\2\u0fd2\u0fd3\5\u0286\u0144\2\u0fd3\u0fd4\5\u0150")
        buf.write("\u00a9\2\u0fd4\u0fff\3\2\2\2\u0fd5\u0fd6\7\u0185\2\2\u0fd6")
        buf.write("\u0fff\5\u0286\u0144\2\u0fd7\u0fd8\7\67\2\2\u0fd8\u0fff")
        buf.write("\5\u022c\u0117\2\u0fd9\u0fda\7G\2\2\u0fda\u0fff\5\u0286")
        buf.write("\u0144\2\u0fdb\u0fdc\7P\2\2\u0fdc\u0fdd\7\u010c\2\2\u0fdd")
        buf.write("\u0fff\5\u022c\u0117\2\u0fde\u0fe0\7\u0199\2\2\u0fdf\u0fde")
        buf.write("\3\2\2\2\u0fdf\u0fe0\3\2\2\2\u0fe0\u0fe1\3\2\2\2\u0fe1")
        buf.write("\u0fe2\7\u01b6\2\2\u0fe2\u0fff\5\u0286\u0144\2\u0fe3\u0fe4")
        buf.write("\7\u0080\2\2\u0fe4\u0fe5\7\u00a3\2\2\u0fe5\u0fff\7\u026c")
        buf.write("\2\2\u0fe6\u0fe8\7\u008d\2\2\u0fe7\u0fe6\3\2\2\2\u0fe7")
        buf.write("\u0fe8\3\2\2\2\u0fe8\u0fe9\3\2\2\2\u0fe9\u0fea\7\u0121")
        buf.write("\2\2\u0fea\u0fff\5\u0286\u0144\2\u0feb\u0fed\7\u00bf\2")
        buf.write("\2\u0fec\u0feb\3\2\2\2\u0fec\u0fed\3\2\2\2\u0fed\u0fee")
        buf.write("\3\2\2\2\u0fee\u0fef\7\177\2\2\u0fef\u0fff\5\u0286\u0144")
        buf.write("\2\u0ff0\u0ff1\7\u00c3\2\2\u0ff1\u0fff\5\u022c\u0117\2")
        buf.write("\u0ff2\u0ff3\7\u00d9\2\2\u0ff3\u0fff\5\u022c\u0117\2\u0ff4")
        buf.write("\u0ff5\7\u00e1\2\2\u0ff5\u0fff\5\u022c\u0117\2\u0ff6\u0ff7")
        buf.write("\7\u00e7\2\2\u0ff7\u0fff\5\u0286\u0144\2\u0ff8\u0ff9\7")
        buf.write("\u00ff\2\2\u0ff9\u0fff\5\u022c\u0117\2\u0ffa\u0ffb\7\u0104")
        buf.write("\2\2\u0ffb\u0fff\5\u022c\u0117\2\u0ffc\u0ffd\7\u010f\2")
        buf.write("\2\u0ffd\u0fff\5\u0286\u0144\2\u0ffe\u0fd1\3\2\2\2\u0ffe")
        buf.write("\u0fd5\3\2\2\2\u0ffe\u0fd7\3\2\2\2\u0ffe\u0fd9\3\2\2\2")
        buf.write("\u0ffe\u0fdb\3\2\2\2\u0ffe\u0fdf\3\2\2\2\u0ffe\u0fe3\3")
        buf.write("\2\2\2\u0ffe\u0fe7\3\2\2\2\u0ffe\u0fec\3\2\2\2\u0ffe\u0ff0")
        buf.write("\3\2\2\2\u0ffe\u0ff2\3\2\2\2\u0ffe\u0ff4\3\2\2\2\u0ffe")
        buf.write("\u0ff6\3\2\2\2\u0ffe\u0ff8\3\2\2\2\u0ffe\u0ffa\3\2\2\2")
        buf.write("\u0ffe\u0ffc\3\2\2\2\u0fff\u0143\3\2\2\2\u1000\u1001\7")
        buf.write("\u01ac\2\2\u1001\u1003\7\u00d2\2\2\u1002\u1000\3\2\2\2")
        buf.write("\u1002\u1003\3\2\2\2\u1003\u1004\3\2\2\2\u1004\u1005\t")
        buf.write("\21\2\2\u1005\u100b\5\u014e\u00a8\2\u1006\u1009\7\u00d7")
        buf.write("\2\2\u1007\u100a\5\u0240\u0121\2\u1008\u100a\5\u014a\u00a6")
        buf.write("\2\u1009\u1007\3\2\2\2\u1009\u1008\3\2\2\2\u100a\u100c")
        buf.write("\3\2\2\2\u100b\u1006\3\2\2\2\u100b\u100c\3\2\2\2\u100c")
        buf.write("\u100d\3\2\2\2\u100d\u100e\5\u0146\u00a4\2\u100e\u0145")
        buf.write("\3\2\2\2\u100f\u1011\5h\65\2\u1010\u100f\3\2\2\2\u1011")
        buf.write("\u1012\3\2\2\2\u1012\u1010\3\2\2\2\u1012\u1013\3\2\2\2")
        buf.write("\u1013\u1015\3\2\2\2\u1014\u1016\5\u01fa\u00fe\2\u1015")
        buf.write("\u1014\3\2\2\2\u1015\u1016\3\2\2\2\u1016\u0147\3\2\2\2")
        buf.write("\u1017\u1018\7\u0198\2\2\u1018\u1019\7\u010f\2\2\u1019")
        buf.write("\u101a\5\u0240\u0121\2\u101a\u0149\3\2\2\2\u101b\u101c")
        buf.write("\7\u01b6\2\2\u101c\u101d\7\u0255\2\2\u101d\u1022\5\u014c")
        buf.write("\u00a7\2\u101e\u101f\7\u024f\2\2\u101f\u1021\5\u014c\u00a7")
        buf.write("\2\u1020\u101e\3\2\2\2\u1021\u1024\3\2\2\2\u1022\u1020")
        buf.write("\3\2\2\2\u1022\u1023\3\2\2\2\u1023\u1025\3\2\2\2\u1024")
        buf.write("\u1022\3\2\2\2\u1025\u1026\7\u0256\2\2\u1026\u014b\3\2")
        buf.write("\2\2\u1027\u1028\5\u022c\u0117\2\u1028\u1029\5\u0240\u0121")
        buf.write("\2\u1029\u014d\3\2\2\2\u102a\u102b\5\u0286\u0144\2\u102b")
        buf.write("\u102c\5\u0150\u00a9\2\u102c\u014f\3\2\2\2\u102d\u103c")
        buf.write("\7\u0255\2\2\u102e\u1033\5\u0156\u00ac\2\u102f\u1030\7")
        buf.write("\u024f\2\2\u1030\u1032\5\u0156\u00ac\2\u1031\u102f\3\2")
        buf.write("\2\2\u1032\u1035\3\2\2\2\u1033\u1031\3\2\2\2\u1033\u1034")
        buf.write("\3\2\2\2\u1034\u1037\3\2\2\2\u1035\u1033\3\2\2\2\u1036")
        buf.write("\u102e\3\2\2\2\u1036\u1037\3\2\2\2\u1037\u1039\3\2\2\2")
        buf.write("\u1038\u103a\5\u0152\u00aa\2\u1039\u1038\3\2\2\2\u1039")
        buf.write("\u103a\3\2\2\2\u103a\u103d\3\2\2\2\u103b\u103d\7\u0259")
        buf.write("\2\2\u103c\u1036\3\2\2\2\u103c\u103b\3\2\2\2\u103d\u103e")
        buf.write("\3\2\2\2\u103e\u103f\7\u0256\2\2\u103f\u0151\3\2\2\2\u1040")
        buf.write("\u1041\7\u01ad\2\2\u1041\u1042\7\26\2\2\u1042\u1047\5")
        buf.write("\u0156\u00ac\2\u1043\u1044\7\u024f\2\2\u1044\u1046\5\u0156")
        buf.write("\u00ac\2\u1045\u1043\3\2\2\2\u1046\u1049\3\2\2\2\u1047")
        buf.write("\u1045\3\2\2\2\u1047\u1048\3\2\2\2\u1048\u0153\3\2\2\2")
        buf.write("\u1049\u1047\3\2\2\2\u104a\u104e\7\u0272\2\2\u104b\u104d")
        buf.write("\7\u0279\2\2\u104c\u104b\3\2\2\2\u104d\u1050\3\2\2\2\u104e")
        buf.write("\u104c\3\2\2\2\u104e\u104f\3\2\2\2\u104f\u1051\3\2\2\2")
        buf.write("\u1050\u104e\3\2\2\2\u1051\u1054\7\u027a\2\2\u1052\u1054")
        buf.write("\7\u0271\2\2\u1053\u104a\3\2\2\2\u1053\u1052\3\2\2\2\u1054")
        buf.write("\u0155\3\2\2\2\u1055\u1057\5\u0158\u00ad\2\u1056\u1055")
        buf.write("\3\2\2\2\u1056\u1057\3\2\2\2\u1057\u1059\3\2\2\2\u1058")
        buf.write("\u105a\5\u022e\u0118\2\u1059\u1058\3\2\2\2\u1059\u105a")
        buf.write("\3\2\2\2\u105a\u105b\3\2\2\2\u105b\u105e\5\u0240\u0121")
        buf.write("\2\u105c\u105d\t\64\2\2\u105d\u105f\5\u024c\u0127\2\u105e")
        buf.write("\u105c\3\2\2\2\u105e\u105f\3\2\2\2\u105f\u0157\3\2\2\2")
        buf.write("\u1060\u1061\t\65\2\2\u1061\u0159\3\2\2\2\u1062\u1064")
        buf.write("\t\66\2\2\u1063\u1062\3\2\2\2\u1063\u1064\3\2\2\2\u1064")
        buf.write("\u1065\3\2\2\2\u1065\u1067\7\u00e7\2\2\u1066\u1068\5\u01a8")
        buf.write("\u00d5\2\u1067\u1066\3\2\2\2\u1067\u1068\3\2\2\2\u1068")
        buf.write("\u1069\3\2\2\2\u1069\u106d\5\u0286\u0144\2\u106a\u106c")
        buf.write("\5\u015c\u00af\2\u106b\u106a\3\2\2\2\u106c\u106f\3\2\2")
        buf.write("\2\u106d\u106b\3\2\2\2\u106d\u106e\3\2\2\2\u106e\u015b")
        buf.write("\3\2\2\2\u106f\u106d\3\2\2\2\u1070\u1071\7\u017d\2\2\u1071")
        buf.write("\u1095\t\67\2\2\u1072\u1073\7\u00e7\2\2\u1073\u1074\7")
        buf.write("\u0095\2\2\u1074\u1095\5\u0286\u0144\2\u1075\u1077\7q")
        buf.write("\2\2\u1076\u1078\7\26\2\2\u1077\u1076\3\2\2\2\u1077\u1078")
        buf.write("\3\2\2\2\u1078\u1079\3\2\2\2\u1079\u1095\5\u0160\u00b1")
        buf.write("\2\u107a\u107b\7\u0091\2\2\u107b\u107f\5\u0160\u00b1\2")
        buf.write("\u107c\u107d\7\u009d\2\2\u107d\u107f\7\u0091\2\2\u107e")
        buf.write("\u107a\3\2\2\2\u107e\u107c\3\2\2\2\u107f\u1095\3\2\2\2")
        buf.write("\u1080\u1081\7\u008e\2\2\u1081\u1085\5\u0160\u00b1\2\u1082")
        buf.write("\u1083\7\u009d\2\2\u1083\u1085\7\u008e\2\2\u1084\u1080")
        buf.write("\3\2\2\2\u1084\u1082\3\2\2\2\u1085\u1095\3\2\2\2\u1086")
        buf.write("\u1088\7\u00f6\2\2\u1087\u1089\7\u01c3\2\2\u1088\u1087")
        buf.write("\3\2\2\2\u1088\u1089\3\2\2\2\u1089\u108a\3\2\2\2\u108a")
        buf.write("\u1095\5\u0160\u00b1\2\u108b\u108c\7\27\2\2\u108c\u1095")
        buf.write("\5\u0160\u00b1\2\u108d\u108f\7\u009d\2\2\u108e\u108d\3")
        buf.write("\2\2\2\u108e\u108f\3\2\2\2\u108f\u1090\3\2\2\2\u1090\u1095")
        buf.write("\7\65\2\2\u1091\u1092\7\u00af\2\2\u1092\u1093\7\26\2\2")
        buf.write("\u1093\u1095\5\u0286\u0144\2\u1094\u1070\3\2\2\2\u1094")
        buf.write("\u1072\3\2\2\2\u1094\u1075\3\2\2\2\u1094\u107e\3\2\2\2")
        buf.write("\u1094\u1084\3\2\2\2\u1094\u1086\3\2\2\2\u1094\u108b\3")
        buf.write("\2\2\2\u1094\u108e\3\2\2\2\u1094\u1091\3\2\2\2\u1095\u015d")
        buf.write("\3\2\2\2\u1096\u1098\5\u0162\u00b2\2\u1097\u1096\3\2\2")
        buf.write("\2\u1097\u1098\3\2\2\2\u1098\u1099\3\2\2\2\u1099\u109a")
        buf.write("\7\u026c\2\2\u109a\u015f\3\2\2\2\u109b\u109d\5\u0162\u00b2")
        buf.write("\2\u109c\u109b\3\2\2\2\u109c\u109d\3\2\2\2\u109d\u109e")
        buf.write("\3\2\2\2\u109e\u109f\5\u025a\u012e\2\u109f\u0161\3\2\2")
        buf.write("\2\u10a0\u10a1\t8\2\2\u10a1\u0163\3\2\2\2\u10a2\u10a4")
        buf.write("\7\u00e1\2\2\u10a3\u10a5\5\u01a8\u00d5\2\u10a4\u10a3\3")
        buf.write("\2\2\2\u10a4\u10a5\3\2\2\2\u10a5\u10a7\3\2\2\2\u10a6\u10a8")
        buf.write("\5\u022c\u0117\2\u10a7\u10a6\3\2\2\2\u10a7\u10a8\3\2\2")
        buf.write("\2\u10a8\u10ab\3\2\2\2\u10a9\u10aa\7\u0161\2\2\u10aa\u10ac")
        buf.write("\5,\27\2\u10ab\u10a9\3\2\2\2\u10ab\u10ac\3\2\2\2\u10ac")
        buf.write("\u0165\3\2\2\2\u10ad\u10ae\7\u00b8\2\2\u10ae\u10af\5\u022c")
        buf.write("\u0117\2\u10af\u10b0\7\u01aa\2\2\u10b0\u10b3\5\u0286\u0144")
        buf.write("\2\u10b1\u10b2\7\u017d\2\2\u10b2\u10b4\t9\2\2\u10b3\u10b1")
        buf.write("\3\2\2\2\u10b3\u10b4\3\2\2\2\u10b4\u10b7\3\2\2\2\u10b5")
        buf.write("\u10b6\7\u0198\2\2\u10b6\u10b8\t:\2\2\u10b7\u10b5\3\2")
        buf.write("\2\2\u10b7\u10b8\3\2\2\2\u10b8\u10c2\3\2\2\2\u10b9\u10ba")
        buf.write("\7\u01b8\2\2\u10ba\u10bf\5,\27\2\u10bb\u10bc\7\u024f\2")
        buf.write("\2\u10bc\u10be\5,\27\2\u10bd\u10bb\3\2\2\2\u10be\u10c1")
        buf.write("\3\2\2\2\u10bf\u10bd\3\2\2\2\u10bf\u10c0\3\2\2\2\u10c0")
        buf.write("\u10c3\3\2\2\2\u10c1\u10bf\3\2\2\2\u10c2\u10b9\3\2\2\2")
        buf.write("\u10c2\u10c3\3\2\2\2\u10c3\u10c6\3\2\2\2\u10c4\u10c5\7")
        buf.write("\u01be\2\2\u10c5\u10c7\5\u024c\u0127\2\u10c6\u10c4\3\2")
        buf.write("\2\2\u10c6\u10c7\3\2\2\2\u10c7\u10cb\3\2\2\2\u10c8\u10c9")
        buf.write("\7\u01c3\2\2\u10c9\u10ca\7\u0183\2\2\u10ca\u10cc\5\u024c")
        buf.write("\u0127\2\u10cb\u10c8\3\2\2\2\u10cb\u10cc\3\2\2\2\u10cc")
        buf.write("\u0167\3\2\2\2\u10cd\u10ce\7\u00b8\2\2\u10ce\u10cf\5\u022c")
        buf.write("\u0117\2\u10cf\u10d0\7\u01aa\2\2\u10d0\u10d1\5\u0286\u0144")
        buf.write("\2\u10d1\u10d2\5\u0208\u0105\2\u10d2\u10ec\3\2\2\2\u10d3")
        buf.write("\u10d4\7\u00b8\2\2\u10d4\u10d5\5\u022c\u0117\2\u10d5\u10d6")
        buf.write("\7\u01aa\2\2\u10d6\u10e0\5\u0286\u0144\2\u10d7\u10d8\7")
        buf.write("\u01b8\2\2\u10d8\u10dd\5,\27\2\u10d9\u10da\7\u024f\2\2")
        buf.write("\u10da\u10dc\5,\27\2\u10db\u10d9\3\2\2\2\u10dc\u10df\3")
        buf.write("\2\2\2\u10dd\u10db\3\2\2\2\u10dd\u10de\3\2\2\2\u10de\u10e1")
        buf.write("\3\2\2\2\u10df\u10dd\3\2\2\2\u10e0\u10d7\3\2\2\2\u10e0")
        buf.write("\u10e1\3\2\2\2\u10e1\u10e4\3\2\2\2\u10e2\u10e3\7\u01be")
        buf.write("\2\2\u10e3\u10e5\5\u024c\u0127\2\u10e4\u10e2\3\2\2\2\u10e4")
        buf.write("\u10e5\3\2\2\2\u10e5\u10e9\3\2\2\2\u10e6\u10e7\7\u01c3")
        buf.write("\2\2\u10e7\u10e8\7\u0183\2\2\u10e8\u10ea\5\u024c\u0127")
        buf.write("\2\u10e9\u10e6\3\2\2\2\u10e9\u10ea\3\2\2\2\u10ea\u10ec")
        buf.write("\3\2\2\2\u10eb\u10cd\3\2\2\2\u10eb\u10d3\3\2\2\2\u10ec")
        buf.write("\u0169\3\2\2\2\u10ed\u10ef\7\u00b8\2\2\u10ee\u10f0\5\u01a6")
        buf.write("\u00d4\2\u10ef\u10ee\3\2\2\2\u10ef\u10f0\3\2\2\2\u10f0")
        buf.write("\u10f1\3\2\2\2\u10f1\u10f2\5\u022c\u0117\2\u10f2\u10f3")
        buf.write("\7\u01aa\2\2\u10f3\u10f5\5\u0286\u0144\2\u10f4\u10f6\5")
        buf.write("\u0212\u010a\2\u10f5\u10f4\3\2\2\2\u10f5\u10f6\3\2\2\2")
        buf.write("\u10f6\u016b\3\2\2\2\u10f7\u10f8\7\u00ff\2\2\u10f8\u10f9")
        buf.write("\5\u022c\u0117\2\u10f9\u10fa\7*\2\2\u10fa\u10fb\7\u0271")
        buf.write("\2\2\u10fb\u10fc\7\u00c3\2\2\u10fc\u10fe\5\u02d0\u0169")
        buf.write("\2\u10fd\u10ff\5\u01fa\u00fe\2\u10fe\u10fd\3\2\2\2\u10fe")
        buf.write("\u10ff\3\2\2\2\u10ff\u016d\3\2\2\2\u1100\u1101\7\u00ff")
        buf.write("\2\2\u1101\u1102\5\u022c\u0117\2\u1102\u1103\5\u0170\u00b9")
        buf.write("\2\u1103\u016f\3\2\2\2\u1104\u1105\7*\2\2\u1105\u1118")
        buf.write("\5\u0154\u00ab\2\u1106\u1107\7\u00ec\2\2\u1107\u1108\7")
        buf.write("\u00c3\2\2\u1108\u110a\5\u02d0\u0169\2\u1109\u110b\5\u01fa")
        buf.write("\u00fe\2\u110a\u1109\3\2\2\2\u110a\u110b\3\2\2\2\u110b")
        buf.write("\u1118\3\2\2\2\u110c\u110d\7\u00cc\2\2\u110d\u110f\7\u00c3")
        buf.write("\2\2\u110e\u1110\5\u01fa\u00fe\2\u110f\u110e\3\2\2\2\u110f")
        buf.write("\u1110\3\2\2\2\u1110\u1118\3\2\2\2\u1111\u1118\7K\2\2")
        buf.write("\u1112\u1118\7D\2\2\u1113\u1114\7\u00ec\2\2\u1114\u1118")
        buf.write("\5\u01f4\u00fb\2\u1115\u1118\5\u0206\u0104\2\u1116\u1118")
        buf.write("\5\u0208\u0105\2\u1117\u1104\3\2\2\2\u1117\u1106\3\2\2")
        buf.write("\2\u1117\u110c\3\2\2\2\u1117\u1111\3\2\2\2\u1117\u1112")
        buf.write("\3\2\2\2\u1117\u1113\3\2\2\2\u1117\u1115\3\2\2\2\u1117")
        buf.write("\u1116\3\2\2\2\u1118\u0171\3\2\2\2\u1119\u111a\7\u0182")
        buf.write("\2\2\u111a\u111b\7\u0255\2\2\u111b\u111c\5\u0240\u0121")
        buf.write("\2\u111c\u111d\7\u017d\2\2\u111d\u111e\5\u0240\u0121\2")
        buf.write("\u111e\u1128\7\u0256\2\2\u111f\u1120\7\u01c3\2\2\u1120")
        buf.write("\u1121\7_\2\2\u1121\u1122\5\u0286\u0144\2\u1122\u1123")
        buf.write("\5\u0150\u00a9\2\u1123\u1129\3\2\2\2\u1124\u1125\7\u0126")
        buf.write("\2\2\u1125\u1129\7_\2\2\u1126\u1127\7\u01c3\2\2\u1127")
        buf.write("\u1129\7\u013c\2\2\u1128\u111f\3\2\2\2\u1128\u1124\3\2")
        buf.write("\2\2\u1128\u1126\3\2\2\2\u1129\u112e\3\2\2\2\u112a\u112b")
        buf.write("\7\u017d\2\2\u112b\u112f\7\17\2\2\u112c\u112d\7\u017d")
        buf.write("\2\2\u112d\u112f\7m\2\2\u112e\u112a\3\2\2\2\u112e\u112c")
        buf.write("\3\2\2\2\u112e\u112f\3\2\2\2\u112f\u0173\3\2\2\2\u1130")
        buf.write("\u1132\7\u0182\2\2\u1131\u1133\5\u01a6\u00d4\2\u1132\u1131")
        buf.write("\3\2\2\2\u1132\u1133\3\2\2\2\u1133\u1134\3\2\2\2\u1134")
        buf.write("\u1135\7\u0255\2\2\u1135\u1136\5\u0240\u0121\2\u1136\u1137")
        buf.write("\7\u017d\2\2\u1137\u1138\5\u0240\u0121\2\u1138\u113a\7")
        buf.write("\u0256\2\2\u1139\u113b\5\u0212\u010a\2\u113a\u1139\3\2")
        buf.write("\2\2\u113a\u113b\3\2\2\2\u113b\u0175\3\2\2\2\u113c\u113d")
        buf.write("\7\u00a8\2\2\u113d\u113e\7Y\2\2\u113e\u113f\5\u0286\u0144")
        buf.write("\2\u113f\u1140\7\u01be\2\2\u1140\u1141\5\u022c\u0117\2")
        buf.write("\u1141\u0177\3\2\2\2\u1142\u1143\7\u00a8\2\2\u1143\u1144")
        buf.write("\7Y\2\2\u1144\u1145\5\u0286\u0144\2\u1145\u1146\7\u01be")
        buf.write("\2\2\u1146\u1147\5\u022c\u0117\2\u1147\u1148\5\u017a\u00be")
        buf.write("\2\u1148\u0179\3\2\2\2\u1149\u115f\5\u0208\u0105\2\u114a")
        buf.write("\u115f\5\u0206\u0104\2\u114b\u115f\5\u020a\u0106\2\u114c")
        buf.write("\u114d\7\7\2\2\u114d\u1152\5\u017c\u00bf\2\u114e\u114f")
        buf.write("\7\u024f\2\2\u114f\u1151\5\u017c\u00bf\2\u1150\u114e\3")
        buf.write("\2\2\2\u1151\u1154\3\2\2\2\u1152\u1150\3\2\2\2\u1152\u1153")
        buf.write("\3\2\2\2\u1153\u115f\3\2\2\2\u1154\u1152\3\2\2\2\u1155")
        buf.write("\u1156\7I\2\2\u1156\u115b\5\u017e\u00c0\2\u1157\u1158")
        buf.write("\7\u024f\2\2\u1158\u115a\5\u017e\u00c0\2\u1159\u1157\3")
        buf.write("\2\2\2\u115a\u115d\3\2\2\2\u115b\u1159\3\2\2\2\u115b\u115c")
        buf.write("\3\2\2\2\u115c\u115f\3\2\2\2\u115d\u115b\3\2\2\2\u115e")
        buf.write("\u1149\3\2\2\2\u115e\u114a\3\2\2\2\u115e\u114b\3\2\2\2")
        buf.write("\u115e\u114c\3\2\2\2\u115e\u1155\3\2\2\2\u115f\u017b\3")
        buf.write("\2\2\2\u1160\u1161\7\u00a8\2\2\u1161\u1162\5\u025a\u012e")
        buf.write("\2\u1162\u1169\5\u00eav\2\u1163\u1164\7\u0198\2\2\u1164")
        buf.write("\u116a\7\u00e4\2\2\u1165\u1166\7\u0198\2\2\u1166\u1167")
        buf.write("\7\u01ad\2\2\u1167\u1168\7\26\2\2\u1168\u116a\5\u0286")
        buf.write("\u0144\2\u1169\u1163\3\2\2\2\u1169\u1165\3\2\2\2\u1169")
        buf.write("\u116a\3\2\2\2\u116a\u117f\3\2\2\2\u116b\u116c\7_\2\2")
        buf.write("\u116c\u117a\5\u025a\u012e\2\u116d\u1170\7\u0255\2\2\u116e")
        buf.write("\u1171\5\u0240\u0121\2\u116f\u1171\7\u0143\2\2\u1170\u116e")
        buf.write("\3\2\2\2\u1170\u116f\3\2\2\2\u1171\u1177\3\2\2\2\u1172")
        buf.write("\u1175\7\u024f\2\2\u1173\u1176\5\u0240\u0121\2\u1174\u1176")
        buf.write("\7\u0143\2\2\u1175\u1173\3\2\2\2\u1175\u1174\3\2\2\2\u1176")
        buf.write("\u1178\3\2\2\2\u1177\u1172\3\2\2\2\u1177\u1178\3\2\2\2")
        buf.write("\u1178\u1179\3\2\2\2\u1179\u117b\7\u0256\2\2\u117a\u116d")
        buf.write("\3\2\2\2\u117a\u117b\3\2\2\2\u117b\u117c\3\2\2\2\u117c")
        buf.write("\u117d\5\u0262\u0132\2\u117d\u117f\3\2\2\2\u117e\u1160")
        buf.write("\3\2\2\2\u117e\u116b\3\2\2\2\u117f\u017d\3\2\2\2\u1180")
        buf.write("\u1181\t;\2\2\u1181\u1182\5\u025a\u012e\2\u1182\u1185")
        buf.write("\7\u0255\2\2\u1183\u1186\5\u0240\u0121\2\u1184\u1186\7")
        buf.write("\u0143\2\2\u1185\u1183\3\2\2\2\u1185\u1184\3\2\2\2\u1186")
        buf.write("\u118c\3\2\2\2\u1187\u118a\7\u024f\2\2\u1188\u118b\5\u0240")
        buf.write("\u0121\2\u1189\u118b\7\u0143\2\2\u118a\u1188\3\2\2\2\u118a")
        buf.write("\u1189\3\2\2\2\u118b\u118d\3\2\2\2\u118c\u1187\3\2\2\2")
        buf.write("\u118c\u118d\3\2\2\2\u118d\u118e\3\2\2\2\u118e\u118f\7")
        buf.write("\u0256\2\2\u118f\u017f\3\2\2\2\u1190\u1191\7\u00a8\2\2")
        buf.write("\u1191\u1193\7Y\2\2\u1192\u1194\5\u01a6\u00d4\2\u1193")
        buf.write("\u1192\3\2\2\2\u1193\u1194\3\2\2\2\u1194\u1195\3\2\2\2")
        buf.write("\u1195\u1196\5\u0286\u0144\2\u1196\u1197\7\u01be\2\2\u1197")
        buf.write("\u1199\5\u022c\u0117\2\u1198\u119a\5\u0212\u010a\2\u1199")
        buf.write("\u1198\3\2\2\2\u1199\u119a\3\2\2\2\u119a\u0181\3\2\2\2")
        buf.write("\u119b\u119c\7\u00a8\2\2\u119c\u119d\7 \2\2\u119d\u119f")
        buf.write("\5\u0286\u0144\2\u119e\u11a0\7\u018e\2\2\u119f\u119e\3")
        buf.write("\2\2\2\u119f\u11a0\3\2\2\2\u11a0\u11a1\3\2\2\2\u11a1\u11a2")
        buf.write("\7\u0198\2\2\u11a2\u11a3\7\u010f\2\2\u11a3\u11a4\5\u0240")
        buf.write("\u0121\2\u11a4\u11a5\7\u01be\2\2\u11a5\u11a8\5\u022c\u0117")
        buf.write("\2\u11a6\u11a7\7Y\2\2\u11a7\u11a9\5\u0286\u0144\2\u11a8")
        buf.write("\u11a6\3\2\2\2\u11a8\u11a9\3\2\2\2\u11a9\u11aa\3\2\2\2")
        buf.write("\u11aa\u11ab\7\u017d\2\2\u11ab\u11b0\5\u0184\u00c3\2\u11ac")
        buf.write("\u11ad\7\u024f\2\2\u11ad\u11af\5\u0184\u00c3\2\u11ae\u11ac")
        buf.write("\3\2\2\2\u11af\u11b2\3\2\2\2\u11b0\u11ae\3\2\2\2\u11b0")
        buf.write("\u11b1\3\2\2\2\u11b1\u0183\3\2\2\2\u11b2\u11b0\3\2\2\2")
        buf.write("\u11b3\u11b4\7\u00a8\2\2\u11b4\u11b5\5\u025a\u012e\2\u11b5")
        buf.write("\u11c1\5\u010c\u0087\2\u11b6\u11b9\7\u0255\2\2\u11b7\u11ba")
        buf.write("\5\u0240\u0121\2\u11b8\u11ba\7\u0143\2\2\u11b9\u11b7\3")
        buf.write("\2\2\2\u11b9\u11b8\3\2\2\2\u11ba\u11bb\3\2\2\2\u11bb\u11be")
        buf.write("\7\u024f\2\2\u11bc\u11bf\5\u0240\u0121\2\u11bd\u11bf\7")
        buf.write("\u0143\2\2\u11be\u11bc\3\2\2\2\u11be\u11bd\3\2\2\2\u11bf")
        buf.write("\u11c0\3\2\2\2\u11c0\u11c2\7\u0256\2\2\u11c1\u11b6\3\2")
        buf.write("\2\2\u11c1\u11c2\3\2\2\2\u11c2\u11c9\3\2\2\2\u11c3\u11c4")
        buf.write("\7\u0198\2\2\u11c4\u11ca\7\u00e4\2\2\u11c5\u11c6\7\u0198")
        buf.write("\2\2\u11c6\u11c7\7\u01ad\2\2\u11c7\u11c8\7\26\2\2\u11c8")
        buf.write("\u11ca\5\u0286\u0144\2\u11c9\u11c3\3\2\2\2\u11c9\u11c5")
        buf.write("\3\2\2\2\u11c9\u11ca\3\2\2\2\u11ca\u11e1\3\2\2\2\u11cb")
        buf.write("\u11cc\7_\2\2\u11cc\u11da\5\u025a\u012e\2\u11cd\u11d0")
        buf.write("\7\u0255\2\2\u11ce\u11d1\5\u0240\u0121\2\u11cf\u11d1\7")
        buf.write("\u0143\2\2\u11d0\u11ce\3\2\2\2\u11d0\u11cf\3\2\2\2\u11d1")
        buf.write("\u11d7\3\2\2\2\u11d2\u11d5\7\u024f\2\2\u11d3\u11d6\5\u0240")
        buf.write("\u0121\2\u11d4\u11d6\7\u0143\2\2\u11d5\u11d3\3\2\2\2\u11d5")
        buf.write("\u11d4\3\2\2\2\u11d6\u11d8\3\2\2\2\u11d7\u11d2\3\2\2\2")
        buf.write("\u11d7\u11d8\3\2\2\2\u11d8\u11d9\3\2\2\2\u11d9\u11db\7")
        buf.write("\u0256\2\2\u11da\u11cd\3\2\2\2\u11da\u11db\3\2\2\2\u11db")
        buf.write("\u11dc\3\2\2\2\u11dc\u11dd\5\u0262\u0132\2\u11dd\u11e1")
        buf.write("\3\2\2\2\u11de\u11df\7\u00fb\2\2\u11df\u11e1\5\u0240\u0121")
        buf.write("\2\u11e0\u11b3\3\2\2\2\u11e0\u11cb\3\2\2\2\u11e0\u11de")
        buf.write("\3\2\2\2\u11e1\u0185\3\2\2\2\u11e2\u11e3\7\u00a8\2\2\u11e3")
        buf.write("\u11e4\7 \2\2\u11e4\u11e5\5\u0286\u0144\2\u11e5\u11e6")
        buf.write("\7\u01be\2\2\u11e6\u11ea\5\u022c\u0117\2\u11e7\u11eb\5")
        buf.write("\u0208\u0105\2\u11e8\u11eb\5\u0206\u0104\2\u11e9\u11eb")
        buf.write("\5\u020a\u0106\2\u11ea\u11e7\3\2\2\2\u11ea\u11e8\3\2\2")
        buf.write("\2\u11ea\u11e9\3\2\2\2\u11eb\u0187\3\2\2\2\u11ec\u11ed")
        buf.write("\7\u00a8\2\2\u11ed\u11ef\7 \2\2\u11ee\u11f0\5\u01a6\u00d4")
        buf.write("\2\u11ef\u11ee\3\2\2\2\u11ef\u11f0\3\2\2\2\u11f0\u11f1")
        buf.write("\3\2\2\2\u11f1\u11f2\5\u0286\u0144\2\u11f2\u11f3\7\u01be")
        buf.write("\2\2\u11f3\u11f5\5\u022c\u0117\2\u11f4\u11f6\5\u0212\u010a")
        buf.write("\2\u11f5\u11f4\3\2\2\2\u11f5\u11f6\3\2\2\2\u11f6\u0189")
        buf.write("\3\2\2\2\u11f7\u11f9\7\u018e\2\2\u11f8\u11f7\3\2\2\2\u11f8")
        buf.write("\u11f9\3\2\2\2\u11f9\u11fa\3\2\2\2\u11fa\u11fb\7.\2\2")
        buf.write("\u11fb\u11fc\5\u0286\u0144\2\u11fc\u11fd\7\u0198\2\2\u11fd")
        buf.write("\u11fe\7\u0271\2\2\u11fe\u11ff\7\u01b8\2\2\u11ff\u1200")
        buf.write("\7\u0271\2\2\u1200\u1201\7\u019a\2\2\u1201\u1202\5\u0286")
        buf.write("\u0144\2\u1202\u018b\3\2\2\2\u1203\u1204\7.\2\2\u1204")
        buf.write("\u1208\5\u0286\u0144\2\u1205\u1209\5\u0208\u0105\2\u1206")
        buf.write("\u1209\5\u0206\u0104\2\u1207\u1209\5\u020a\u0106\2\u1208")
        buf.write("\u1205\3\2\2\2\u1208\u1206\3\2\2\2\u1208\u1207\3\2\2\2")
        buf.write("\u1209\u018d\3\2\2\2\u120a\u120b\7\u00c3\2\2\u120b\u1219")
        buf.write("\5\u022c\u0117\2\u120c\u120d\7\u0198\2\2\u120d\u120e\7")
        buf.write("\u01b6\2\2\u120e\u1213\5\u0194\u00cb\2\u120f\u1210\7\u024f")
        buf.write("\2\2\u1210\u1212\5\u0194\u00cb\2\u1211\u120f\3\2\2\2\u1212")
        buf.write("\u1215\3\2\2\2\u1213\u1211\3\2\2\2\u1213\u1214\3\2\2\2")
        buf.write("\u1214\u121a\3\2\2\2\u1215\u1213\3\2\2\2\u1216\u1217\7")
        buf.write("\u0198\2\2\u1217\u1218\7\u0178\2\2\u1218\u121a\7\u0103")
        buf.write("\2\2\u1219\u120c\3\2\2\2\u1219\u1216\3\2\2\2\u1219\u121a")
        buf.write("\3\2\2\2\u121a\u121c\3\2\2\2\u121b\u121d\5\u01fa\u00fe")
        buf.write("\2\u121c\u121b\3\2\2\2\u121c\u121d\3\2\2\2\u121d\u018f")
        buf.write("\3\2\2\2\u121e\u121f\7\u00c3\2\2\u121f\u1220\5\u022c\u0117")
        buf.write("\2\u1220\u1221\5\u0192\u00ca\2\u1221\u0191\3\2\2\2\u1222")
        buf.write("\u1231\5\u0208\u0105\2\u1223\u1231\5\u0206\u0104\2\u1224")
        buf.write("\u1225\7\u00ec\2\2\u1225\u1231\5\u01f4\u00fb\2\u1226\u1227")
        buf.write("\t<\2\2\u1227\u1228\7\u01b6\2\2\u1228\u122d\5\u0194\u00cb")
        buf.write("\2\u1229\u122a\7\u024f\2\2\u122a\u122c\5\u0194\u00cb\2")
        buf.write("\u122b\u1229\3\2\2\2\u122c\u122f\3\2\2\2\u122d\u122b\3")
        buf.write("\2\2\2\u122d\u122e\3\2\2\2\u122e\u1231\3\2\2\2\u122f\u122d")
        buf.write("\3\2\2\2\u1230\u1222\3\2\2\2\u1230\u1223\3\2\2\2\u1230")
        buf.write("\u1224\3\2\2\2\u1230\u1226\3\2\2\2\u1231\u0193\3\2\2\2")
        buf.write("\u1232\u1234\7\u01ab\2\2\u1233\u1232\3\2\2\2\u1233\u1234")
        buf.write("\3\2\2\2\u1234\u1235\3\2\2\2\u1235\u1237\5\u0286\u0144")
        buf.write("\2\u1236\u1238\7\u0259\2\2\u1237\u1236\3\2\2\2\u1237\u1238")
        buf.write("\3\2\2\2\u1238\u0195\3\2\2\2\u1239\u123a\7\u010c\2\2\u123a")
        buf.write("\u123b\5\u022c\u0117\2\u123b\u123c\7\u01aa\2\2\u123c\u1245")
        buf.write("\5\u0286\u0144\2\u123d\u1246\5\u0208\u0105\2\u123e\u1240")
        buf.write("\7\u009d\2\2\u123f\u123e\3\2\2\2\u123f\u1240\3\2\2\2\u1240")
        buf.write("\u1241\3\2\2\2\u1241\u1242\7A\2\2\u1242\u1243\7\u01aa")
        buf.write("\2\2\u1243\u1244\7W\2\2\u1244\u1246\5\u022c\u0117\2\u1245")
        buf.write("\u123d\3\2\2\2\u1245\u123f\3\2\2\2\u1246\u0197\3\2\2\2")
        buf.write("\u1247\u1248\7\u00df\2\2\u1248\u1249\5\u022c\u0117\2\u1249")
        buf.write("\u124a\7\u01aa\2\2\u124a\u124b\5\u0286\u0144\2\u124b\u124c")
        buf.write("\5\u0208\u0105\2\u124c\u0199\3\2\2\2\u124d\u1250\5\u019e")
        buf.write("\u00d0\2\u124e\u1250\5\u019c\u00cf\2\u124f\u124d\3\2\2")
        buf.write("\2\u124f\u124e\3\2\2\2\u1250\u019b\3\2\2\2\u1251\u1252")
        buf.write("\7/\2\2\u1252\u1253\5\60\31\2\u1253\u1259\7\u019a\2\2")
        buf.write("\u1254\u1256\7\u00c2\2\2\u1255\u1254\3\2\2\2\u1255\u1256")
        buf.write("\3\2\2\2\u1256\u1257\3\2\2\2\u1257\u125a\7\u0271\2\2\u1258")
        buf.write("\u125a\7\u00f9\2\2\u1259\u1255\3\2\2\2\u1259\u1258\3\2")
        buf.write("\2\2\u125a\u1265\3\2\2\2\u125b\u125d\7\u01c3\2\2\u125c")
        buf.write("\u125b\3\2\2\2\u125c\u125d\3\2\2\2\u125d\u1263\3\2\2\2")
        buf.write("\u125e\u125f\7\u0255\2\2\u125f\u1260\5\u01a0\u00d1\2\u1260")
        buf.write("\u1261\7\u0256\2\2\u1261\u1264\3\2\2\2\u1262\u1264\5\u01a0")
        buf.write("\u00d1\2\u1263\u125e\3\2\2\2\u1263\u1262\3\2\2\2\u1264")
        buf.write("\u1266\3\2\2\2\u1265\u125c\3\2\2\2\u1265\u1266\3\2\2\2")
        buf.write("\u1266\u1269\3\2\2\2\u1267\u1268\7\u01c1\2\2\u1268\u126a")
        buf.write("\5\u024c\u0127\2\u1269\u1267\3\2\2\2\u1269\u126a\3\2\2")
        buf.write("\2\u126a\u019d\3\2\2\2\u126b\u1271\7/\2\2\u126c\u1272")
        buf.write("\5\60\31\2\u126d\u126e\7\u0255\2\2\u126e\u126f\5\20\t")
        buf.write("\2\u126f\u1270\7\u0256\2\2\u1270\u1272\3\2\2\2\u1271\u126c")
        buf.write("\3\2\2\2\u1271\u126d\3\2\2\2\u1272\u1273\3\2\2\2\u1273")
        buf.write("\u1279\7\u01b8\2\2\u1274\u1276\7\u00c2\2\2\u1275\u1274")
        buf.write("\3\2\2\2\u1275\u1276\3\2\2\2\u1276\u1277\3\2\2\2\u1277")
        buf.write("\u127a\7\u0271\2\2\u1278\u127a\7\u00fa\2\2\u1279\u1275")
        buf.write("\3\2\2\2\u1279\u1278\3\2\2\2\u127a\u1285\3\2\2\2\u127b")
        buf.write("\u127d\7\u01c3\2\2\u127c\u127b\3\2\2\2\u127c\u127d\3\2")
        buf.write("\2\2\u127d\u1283\3\2\2\2\u127e\u127f\7\u0255\2\2\u127f")
        buf.write("\u1280\5\u01a0\u00d1\2\u1280\u1281\7\u0256\2\2\u1281\u1284")
        buf.write("\3\2\2\2\u1282\u1284\5\u01a0\u00d1\2\u1283\u127e\3\2\2")
        buf.write("\2\u1283\u1282\3\2\2\2\u1284\u1286\3\2\2\2\u1285\u127c")
        buf.write("\3\2\2\2\u1285\u1286\3\2\2\2\u1286\u019f\3\2\2\2\u1287")
        buf.write("\u128e\5\u01a2\u00d2\2\u1288\u128a\7\u024f\2\2\u1289\u1288")
        buf.write("\3\2\2\2\u1289\u128a\3\2\2\2\u128a\u128b\3\2\2\2\u128b")
        buf.write("\u128d\5\u01a2\u00d2\2\u128c\u1289\3\2\2\2\u128d\u1290")
        buf.write("\3\2\2\2\u128e\u128c\3\2\2\2\u128e\u128f\3\2\2\2\u128f")
        buf.write("\u01a1\3\2\2\2\u1290\u128e\3\2\2\2\u1291\u1293\7\u01dd")
        buf.write("\2\2\u1292\u1291\3\2\2\2\u1292\u1293\3\2\2\2\u1293\u1294")
        buf.write("\3\2\2\2\u1294\u12ce\t=\2\2\u1295\u1297\7\u00a6\2\2\u1296")
        buf.write("\u1298\5\u025c\u012f\2\u1297\u1296\3\2\2\2\u1297\u1298")
        buf.write("\3\2\2\2\u1298\u12ce\3\2\2\2\u1299\u129b\7\u0167\2\2\u129a")
        buf.write("\u129c\5\u025c\u012f\2\u129b\u129a\3\2\2\2\u129b\u129c")
        buf.write("\3\2\2\2\u129c\u12ce\3\2\2\2\u129d\u129f\7?\2\2\u129e")
        buf.write("\u12a0\7\u017d\2\2\u129f\u129e\3\2\2\2\u129f\u12a0\3\2")
        buf.write("\2\2\u12a0\u12a1\3\2\2\2\u12a1\u12ce\7\u0271\2\2\u12a2")
        buf.write("\u12a4\7\u01a8\2\2\u12a3\u12a5\7\u017d\2\2\u12a4\u12a3")
        buf.write("\3\2\2\2\u12a4\u12a5\3\2\2\2\u12a5\u12a6\3\2\2\2\u12a6")
        buf.write("\u12ce\7\u0271\2\2\u12a7\u12a9\7f\2\2\u12a8\u12aa\5\u025c")
        buf.write("\u012f\2\u12a9\u12a8\3\2\2\2\u12a9\u12aa\3\2\2\2\u12aa")
        buf.write("\u12ce\3\2\2\2\u12ab\u12ac\7\u00c4\2\2\u12ac\u12ce\7\u0271")
        buf.write("\2\2\u12ad\u12ae\7O\2\2\u12ae\u12ce\7\u0271\2\2\u12af")
        buf.write("\u12b0\7]\2\2\u12b0\u12b3\7\u00c4\2\2\u12b1\u12b4\7\u0259")
        buf.write("\2\2\u12b2\u12b4\5\u02d0\u0169\2\u12b3\u12b1\3\2\2\2\u12b3")
        buf.write("\u12b2\3\2\2\2\u12b4\u12ce\3\2\2\2\u12b5\u12bb\7\u01dc")
        buf.write("\2\2\u12b6\u12bc\7\u0259\2\2\u12b7\u12b8\7\u0255\2\2\u12b8")
        buf.write("\u12b9\5\u02d0\u0169\2\u12b9\u12ba\7\u0256\2\2\u12ba\u12bc")
        buf.write("\3\2\2\2\u12bb\u12b6\3\2\2\2\u12bb\u12b7\3\2\2\2\u12bc")
        buf.write("\u12ce\3\2\2\2\u12bd\u12be\7]\2\2\u12be\u12bf\7\u01a7")
        buf.write("\2\2\u12bf\u12c0\7\u01a8\2\2\u12c0\u12ce\5\u02d0\u0169")
        buf.write("\2\u12c1\u12c2\7\u01da\2\2\u12c2\u12c3\7\u0255\2\2\u12c3")
        buf.write("\u12c4\5\u02d0\u0169\2\u12c4\u12c5\7\u0256\2\2\u12c5\u12ce")
        buf.write("\3\2\2\2\u12c6\u12c7\7\u01db\2\2\u12c7\u12c8\7\u0255\2")
        buf.write("\2\u12c8\u12c9\5\u02d0\u0169\2\u12c9\u12ca\7\u0256\2\2")
        buf.write("\u12ca\u12ce\3\2\2\2\u12cb\u12cc\7L\2\2\u12cc\u12ce\7")
        buf.write("\u0271\2\2\u12cd\u1292\3\2\2\2\u12cd\u1295\3\2\2\2\u12cd")
        buf.write("\u1299\3\2\2\2\u12cd\u129d\3\2\2\2\u12cd\u12a2\3\2\2\2")
        buf.write("\u12cd\u12a7\3\2\2\2\u12cd\u12ab\3\2\2\2\u12cd\u12ad\3")
        buf.write("\2\2\2\u12cd\u12af\3\2\2\2\u12cd\u12b5\3\2\2\2\u12cd\u12bd")
        buf.write("\3\2\2\2\u12cd\u12c1\3\2\2\2\u12cd\u12c6\3\2\2\2\u12cd")
        buf.write("\u12cb\3\2\2\2\u12ce\u01a3\3\2\2\2\u12cf\u12d0\7\u01ac")
        buf.write("\2\2\u12d0\u12d2\7\u00d2\2\2\u12d1\u12cf\3\2\2\2\u12d1")
        buf.write("\u12d2\3\2\2\2\u12d2\u12d4\3\2\2\2\u12d3\u12d5\t\66\2")
        buf.write("\2\u12d4\u12d3\3\2\2\2\u12d4\u12d5\3\2\2\2\u12d5\u12d7")
        buf.write("\3\2\2\2\u12d6\u12d8\7\u00c9\2\2\u12d7\u12d6\3\2\2\2\u12d7")
        buf.write("\u12d8\3\2\2\2\u12d8\u12da\3\2\2\2\u12d9\u12db\7\u008d")
        buf.write("\2\2\u12da\u12d9\3\2\2\2\u12da\u12db\3\2\2\2\u12db\u12dc")
        buf.write("\3\2\2\2\u12dc\u12de\7\u0121\2\2\u12dd\u12df\5\u01a8\u00d5")
        buf.write("\2\u12de\u12dd\3\2\2\2\u12de\u12df\3\2\2\2\u12df\u12e0")
        buf.write("\3\2\2\2\u12e0\u12e2\5\u0286\u0144\2\u12e1\u12e3\5\u01aa")
        buf.write("\u00d6\2\u12e2\u12e1\3\2\2\2\u12e2\u12e3\3\2\2\2\u12e3")
        buf.write("\u12e6\3\2\2\2\u12e4\u12e5\7\u01be\2\2\u12e5\u12e7\5\u022c")
        buf.write("\u0117\2\u12e6\u12e4\3\2\2\2\u12e6\u12e7\3\2\2\2\u12e7")
        buf.write("\u12ea\3\2\2\2\u12e8\u12e9\7\u01c3\2\2\u12e9\u12eb\5\u01f4")
        buf.write("\u00fb\2\u12ea\u12e8\3\2\2\2\u12ea\u12eb\3\2\2\2\u12eb")
        buf.write("\u12ed\3\2\2\2\u12ec\u12ee\5\u0200\u0101\2\u12ed\u12ec")
        buf.write("\3\2\2\2\u12ed\u12ee\3\2\2\2\u12ee\u12ef\3\2\2\2\u12ef")
        buf.write("\u12f0\7\u017d\2\2\u12f0\u12f2\5\u028c\u0147\2\u12f1\u12f3")
        buf.write("\5\u01ac\u00d7\2\u12f2\u12f1\3\2\2\2\u12f2\u12f3\3\2\2")
        buf.write("\2\u12f3\u12f9\3\2\2\2\u12f4\u12f6\7\u01c3\2\2\u12f5\u12f7")
        buf.write("\7\u009d\2\2\u12f6\u12f5\3\2\2\2\u12f6\u12f7\3\2\2\2\u12f7")
        buf.write("\u12f8\3\2\2\2\u12f8\u12fa\7\66\2\2\u12f9\u12f4\3\2\2")
        buf.write("\2\u12f9\u12fa\3\2\2\2\u12fa\u01a5\3\2\2\2\u12fb\u12fc")
        buf.write("\7j\2\2\u12fc\u12fd\7\u0137\2\2\u12fd\u01a7\3\2\2\2\u12fe")
        buf.write("\u12ff\7j\2\2\u12ff\u1300\7\u01a7\2\2\u1300\u1301\7\u0137")
        buf.write("\2\2\u1301\u01a9\3\2\2\2\u1302\u1303\7\u0255\2\2\u1303")
        buf.write("\u1308\5\u022c\u0117\2\u1304\u1305\7\u024f\2\2\u1305\u1307")
        buf.write("\5\u022c\u0117\2\u1306\u1304\3\2\2\2\u1307\u130a\3\2\2")
        buf.write("\2\u1308\u1306\3\2\2\2\u1308\u1309\3\2\2\2\u1309\u130b")
        buf.write("\3\2\2\2\u130a\u1308\3\2\2\2\u130b\u130c\7\u0256\2\2\u130c")
        buf.write("\u01ab\3\2\2\2\u130d\u130f\7\u01c3\2\2\u130e\u1310\t>")
        buf.write("\2\2\u130f\u130e\3\2\2\2\u130f\u1310\3\2\2\2\u1310\u1311")
        buf.write("\3\2\2\2\u1311\u1312\7\u0183\2\2\u1312\u1313\7\u00a9\2")
        buf.write("\2\u1313\u01ad\3\2\2\2\u1314\u1315\7\67\2\2\u1315\u131e")
        buf.write("\5\u022c\u0117\2\u1316\u1318\7\u01c3\2\2\u1317\u1316\3")
        buf.write("\2\2\2\u1317\u1318\3\2\2\2\u1318\u131a\3\2\2\2\u1319\u131b")
        buf.write("\5\u01b0\u00d9\2\u131a\u1319\3\2\2\2\u131b\u131c\3\2\2")
        buf.write("\2\u131c\u131a\3\2\2\2\u131c\u131d\3\2\2\2\u131d\u131f")
        buf.write("\3\2\2\2\u131e\u1317\3\2\2\2\u131e\u131f\3\2\2\2\u131f")
        buf.write("\u01af\3\2\2\2\u1320\u1322\t?\2\2\u1321\u1323\7\u024c")
        buf.write("\2\2\u1322\u1321\3\2\2\2\u1322\u1323\3\2\2\2\u1323\u1327")
        buf.write("\3\2\2\2\u1324\u1328\5\u0154\u00ab\2\u1325\u1328\5\u022c")
        buf.write("\u0117\2\u1326\u1328\7\u018e\2\2\u1327\u1324\3\2\2\2\u1327")
        buf.write("\u1325\3\2\2\2\u1327\u1326\3\2\2\2\u1328\u132b\3\2\2\2")
        buf.write("\u1329\u132b\5\u01b6\u00dc\2\u132a\u1320\3\2\2\2\u132a")
        buf.write("\u1329\3\2\2\2\u132b\u01b1\3\2\2\2\u132c\u132d\7\67\2")
        buf.write("\2\u132d\u132f\5\u022c\u0117\2\u132e\u1330\5\u01b4\u00db")
        buf.write("\2\u132f\u132e\3\2\2\2\u132f\u1330\3\2\2\2\u1330\u01b3")
        buf.write("\3\2\2\2\u1331\u1333\7\u01c3\2\2\u1332\u1331\3\2\2\2\u1332")
        buf.write("\u1333\3\2\2\2\u1333\u1335\3\2\2\2\u1334\u1336\5\u01b6")
        buf.write("\u00dc\2\u1335\u1334\3\2\2\2\u1336\u1337\3\2\2\2\u1337")
        buf.write("\u1335\3\2\2\2\u1337\u1338\3\2\2\2\u1338\u134a\3\2\2\2")
        buf.write("\u1339\u133b\7\u01c3\2\2\u133a\u1339\3\2\2\2\u133a\u133b")
        buf.write("\3\2\2\2\u133b\u133c\3\2\2\2\u133c\u133e\7\u0104\2\2\u133d")
        buf.write("\u133f\7\u024c\2\2\u133e\u133d\3\2\2\2\u133e\u133f\3\2")
        buf.write("\2\2\u133f\u1343\3\2\2\2\u1340\u1344\5\u0154\u00ab\2\u1341")
        buf.write("\u1344\5\u022c\u0117\2\u1342\u1344\7\u018e\2\2\u1343\u1340")
        buf.write("\3\2\2\2\u1343\u1341\3\2\2\2\u1343\u1342\3\2\2\2\u1344")
        buf.write("\u134a\3\2\2\2\u1345\u134a\5\u0208\u0105\2\u1346\u134a")
        buf.write("\5\u0206\u0104\2\u1347\u134a\5\u0202\u0102\2\u1348\u134a")
        buf.write("\5\u00caf\2\u1349\u1332\3\2\2\2\u1349\u133a\3\2\2\2\u1349")
        buf.write("\u1345\3\2\2\2\u1349\u1346\3\2\2\2\u1349\u1347\3\2\2\2")
        buf.write("\u1349\u1348\3\2\2\2\u134a\u01b5\3\2\2\2\u134b\u134d\t")
        buf.write("@\2\2\u134c\u134e\7\u024c\2\2\u134d\u134c\3\2\2\2\u134d")
        buf.write("\u134e\3\2\2\2\u134e\u1351\3\2\2\2\u134f\u1352\58\35\2")
        buf.write("\u1350\u1352\7\u018e\2\2\u1351\u134f\3\2\2\2\u1351\u1350")
        buf.write("\3\2\2\2\u1352\u135d\3\2\2\2\u1353\u1354\7*\2\2\u1354")
        buf.write("\u1356\7\u01a4\2\2\u1355\u1357\7\u024c\2\2\u1356\u1355")
        buf.write("\3\2\2\2\u1356\u1357\3\2\2\2\u1357\u135a\3\2\2\2\u1358")
        buf.write("\u135b\5\u015e\u00b0\2\u1359\u135b\7\u018e\2\2\u135a\u1358")
        buf.write("\3\2\2\2\u135a\u1359\3\2\2\2\u135b\u135d\3\2\2\2\u135c")
        buf.write("\u134b\3\2\2\2\u135c\u1353\3\2\2\2\u135d\u01b7\3\2\2\2")
        buf.write("\u135e\u1360\tA\2\2\u135f\u135e\3\2\2\2\u135f\u1360\3")
        buf.write("\2\2\2\u1360\u1361\3\2\2\2\u1361\u1364\t\66\2\2\u1362")
        buf.write("\u1364\7\u0117\2\2\u1363\u135f\3\2\2\2\u1363\u1362\3\2")
        buf.write("\2\2\u1363\u1364\3\2\2\2\u1364\u1365\3\2\2\2\u1365\u1367")
        buf.write("\7\u01b6\2\2\u1366\u1368\5\u01a8\u00d5\2\u1367\u1366\3")
        buf.write("\2\2\2\u1367\u1368\3\2\2\2\u1368\u1369\3\2\2\2\u1369\u136a")
        buf.write("\5\u0286\u0144\2\u136a\u136c\5\u01be\u00e0\2\u136b\u136d")
        buf.write("\5\u01cc\u00e7\2\u136c\u136b\3\2\2\2\u136c\u136d\3\2\2")
        buf.write("\2\u136d\u1370\3\2\2\2\u136e\u136f\7\u01be\2\2\u136f\u1371")
        buf.write("\5\u022c\u0117\2\u1370\u136e\3\2\2\2\u1370\u1371\3\2\2")
        buf.write("\2\u1371\u1373\3\2\2\2\u1372\u1374\5\u01fc\u00ff\2\u1373")
        buf.write("\u1372\3\2\2\2\u1373\u1374\3\2\2\2\u1374\u1376\3\2\2\2")
        buf.write("\u1375\u1377\5\u01fe\u0100\2\u1376\u1375\3\2\2\2\u1376")
        buf.write("\u1377\3\2\2\2\u1377\u1379\3\2\2\2\u1378\u137a\5\u0200")
        buf.write("\u0101\2\u1379\u1378\3\2\2\2\u1379\u137a\3\2\2\2\u137a")
        buf.write("\u01b9\3\2\2\2\u137b\u137d\tA\2\2\u137c\u137b\3\2\2\2")
        buf.write("\u137c\u137d\3\2\2\2\u137d\u137e\3\2\2\2\u137e\u1381\t")
        buf.write("\66\2\2\u137f\u1381\7\u0117\2\2\u1380\u137c\3\2\2\2\u1380")
        buf.write("\u137f\3\2\2\2\u1380\u1381\3\2\2\2\u1381\u1382\3\2\2\2")
        buf.write("\u1382\u1384\7\u01b6\2\2\u1383\u1385\5\u01a8\u00d5\2\u1384")
        buf.write("\u1383\3\2\2\2\u1384\u1385\3\2\2\2\u1385\u1386\3\2\2\2")
        buf.write("\u1386\u1388\5\u0286\u0144\2\u1387\u1389\5\u01f0\u00f9")
        buf.write("\2\u1388\u1387\3\2\2\2\u1388\u1389\3\2\2\2\u1389\u138c")
        buf.write("\3\2\2\2\u138a\u138b\7\u01be\2\2\u138b\u138d\5\u022c\u0117")
        buf.write("\2\u138c\u138a\3\2\2\2\u138c\u138d\3\2\2\2\u138d\u138f")
        buf.write("\3\2\2\2\u138e\u1390\5\u01fc\u00ff\2\u138f\u138e\3\2\2")
        buf.write("\2\u138f\u1390\3\2\2\2\u1390\u1392\3\2\2\2\u1391\u1393")
        buf.write("\5\u01fe\u0100\2\u1392\u1391\3\2\2\2\u1392\u1393\3\2\2")
        buf.write("\2\u1393\u1395\3\2\2\2\u1394\u1396\5\u0200\u0101\2\u1395")
        buf.write("\u1394\3\2\2\2\u1395\u1396\3\2\2\2\u1396\u1397\3\2\2\2")
        buf.write("\u1397\u139b\7\u017d\2\2\u1398\u139c\5\u028c\u0147\2\u1399")
        buf.write("\u139a\7T\2\2\u139a\u139c\5\u0262\u0132\2\u139b\u1398")
        buf.write("\3\2\2\2\u139b\u1399\3\2\2\2\u139c\u13a2\3\2\2\2\u139d")
        buf.write("\u139f\7\u01c3\2\2\u139e\u13a0\7\u009d\2\2\u139f\u139e")
        buf.write("\3\2\2\2\u139f\u13a0\3\2\2\2\u13a0\u13a1\3\2\2\2\u13a1")
        buf.write("\u13a3\7\66\2\2\u13a2\u139d\3\2\2\2\u13a2\u13a3\3\2\2")
        buf.write("\2\u13a3\u01bb\3\2\2\2\u13a4\u13a5\7\u0199\2\2\u13a5\u13a7")
        buf.write("\7\u01b6\2\2\u13a6\u13a8\5\u01a8\u00d5\2\u13a7\u13a6\3")
        buf.write("\2\2\2\u13a7\u13a8\3\2\2\2\u13a8\u13a9\3\2\2\2\u13a9\u13ac")
        buf.write("\5\u0286\u0144\2\u13aa\u13ad\5\u01c8\u00e5\2\u13ab\u13ad")
        buf.write("\5\u01c0\u00e1\2\u13ac\u13aa\3\2\2\2\u13ac\u13ab\3\2\2")
        buf.write("\2\u13ad\u13ae\3\2\2\2\u13ae\u13af\5\u01d2\u00ea\2\u13af")
        buf.write("\u01bd\3\2\2\2\u13b0\u13b4\5\u01c8\u00e5\2\u13b1\u13b4")
        buf.write("\5\u01ca\u00e6\2\u13b2\u13b4\5\u01c0\u00e1\2\u13b3\u13b0")
        buf.write("\3\2\2\2\u13b3\u13b1\3\2\2\2\u13b3\u13b2\3\2\2\2\u13b4")
        buf.write("\u01bf\3\2\2\2\u13b5\u13b6\7\u00b4\2\2\u13b6\u13b7\7\u00a4")
        buf.write("\2\2\u13b7\u13b9\5\u0286\u0144\2\u13b8\u13ba\5\u01da\u00ee")
        buf.write("\2\u13b9\u13b8\3\2\2\2\u13b9\u13ba\3\2\2\2\u13ba\u13bb")
        buf.write("\3\2\2\2\u13bb\u13bc\5\u01c2\u00e2\2\u13bc\u01c1\3\2\2")
        buf.write("\2\u13bd\u13be\7\u0198\2\2\u13be\u13bf\7\u0154\2\2\u13bf")
        buf.write("\u13c2\5\u01c4\u00e3\2\u13c0\u13c2\7\u018e\2\2\u13c1\u13bd")
        buf.write("\3\2\2\2\u13c1\u13c0\3\2\2\2\u13c2\u01c3\3\2\2\2\u13c3")
        buf.write("\u13c4\7\u019e\2\2\u13c4\u13c5\7\u0255\2\2\u13c5\u13ca")
        buf.write("\5\u024c\u0127\2\u13c6\u13c7\7\u024f\2\2\u13c7\u13c9\5")
        buf.write("\u024c\u0127\2\u13c8\u13c6\3\2\2\2\u13c9\u13cc\3\2\2\2")
        buf.write("\u13ca\u13c8\3\2\2\2\u13ca\u13cb\3\2\2\2\u13cb\u13cd\3")
        buf.write("\2\2\2\u13cc\u13ca\3\2\2\2\u13cd\u13ce\7\u0256\2\2\u13ce")
        buf.write("\u13dd\3\2\2\2\u13cf\u13d0\7\u019a\2\2\u13d0\u13d1\5\u01c6")
        buf.write("\u00e4\2\u13d1\u13d2\7\u01b8\2\2\u13d2\u13d3\5\u01c6\u00e4")
        buf.write("\2\u13d3\u13dd\3\2\2\2\u13d4\u13d5\7\u01c3\2\2\u13d5\u13d6")
        buf.write("\7\u0255\2\2\u13d6\u13d7\7\u01f8\2\2\u13d7\u13d8\7\u026c")
        buf.write("\2\2\u13d8\u13d9\7\u024f\2\2\u13d9\u13da\7\u020e\2\2\u13da")
        buf.write("\u13db\7\u026c\2\2\u13db\u13dd\7\u0256\2\2\u13dc\u13c3")
        buf.write("\3\2\2\2\u13dc\u13cf\3\2\2\2\u13dc\u13d4\3\2\2\2\u13dd")
        buf.write("\u01c5\3\2\2\2\u13de\u13df\7\u0255\2\2\u13df\u13e4\5\u024c")
        buf.write("\u0127\2\u13e0\u13e1\7\u024f\2\2\u13e1\u13e3\5\u024c\u0127")
        buf.write("\2\u13e2\u13e0\3\2\2\2\u13e3\u13e6\3\2\2\2\u13e4\u13e2")
        buf.write("\3\2\2\2\u13e4\u13e5\3\2\2\2\u13e5\u13e7\3\2\2\2\u13e6")
        buf.write("\u13e4\3\2\2\2\u13e7\u13e8\7\u0256\2\2\u13e8\u01c7\3\2")
        buf.write("\2\2\u13e9\u13f2\7\u0255\2\2\u13ea\u13ef\5\u01dc\u00ef")
        buf.write("\2\u13eb\u13ec\7\u024f\2\2\u13ec\u13ee\5\u01dc\u00ef\2")
        buf.write("\u13ed\u13eb\3\2\2\2\u13ee\u13f1\3\2\2\2\u13ef\u13ed\3")
        buf.write("\2\2\2\u13ef\u13f0\3\2\2\2\u13f0\u13f3\3\2\2\2\u13f1\u13ef")
        buf.write("\3\2\2\2\u13f2\u13ea\3\2\2\2\u13f2\u13f3\3\2\2\2\u13f3")
        buf.write("\u13f4\3\2\2\2\u13f4\u13f7\7\u0256\2\2\u13f5\u13f6\7u")
        buf.write("\2\2\u13f6\u13f8\5\u01f0\u00f9\2\u13f7\u13f5\3\2\2\2\u13f7")
        buf.write("\u13f8\3\2\2\2\u13f8\u01c9\3\2\2\2\u13f9\u13fa\7\u00a4")
        buf.write("\2\2\u13fa\u13fc\5\u0240\u0121\2\u13fb\u13fd\5\u01da\u00ee")
        buf.write("\2\u13fc\u13fb\3\2\2\2\u13fc\u13fd\3\2\2\2\u13fd\u01cb")
        buf.write("\3\2\2\2\u13fe\u13ff\7\u00b4\2\2\u13ff\u1400\7\26\2\2")
        buf.write("\u1400\u1401\5\u01ce\u00e8\2\u1401\u01cd\3\2\2\2\u1402")
        buf.write("\u1403\tB\2\2\u1403\u1404\7\u0255\2\2\u1404\u1409\5\u01d0")
        buf.write("\u00e9\2\u1405\u1406\7\u024f\2\2\u1406\u1408\5\u01d0\u00e9")
        buf.write("\2\u1407\u1405\3\2\2\2\u1408\u140b\3\2\2\2\u1409\u1407")
        buf.write("\3\2\2\2\u1409\u140a\3\2\2\2\u140a\u140c\3\2\2\2\u140b")
        buf.write("\u1409\3\2\2\2\u140c\u140d\7\u0256\2\2\u140d\u01cf\3\2")
        buf.write("\2\2\u140e\u1410\5\u024c\u0127\2\u140f\u1411\5\u022c\u0117")
        buf.write("\2\u1410\u140f\3\2\2\2\u1410\u1411\3\2\2\2\u1411\u01d1")
        buf.write("\3\2\2\2\u1412\u1413\7\u00ea\2\2\u1413\u1415\5\u022c\u0117")
        buf.write("\2\u1414\u1416\5\u01d4\u00eb\2\u1415\u1414\3\2\2\2\u1415")
        buf.write("\u1416\3\2\2\2\u1416\u01d3\3\2\2\2\u1417\u1418\7\u00aa")
        buf.write("\2\2\u1418\u1419\7\u0255\2\2\u1419\u141e\5\u01d6\u00ec")
        buf.write("\2\u141a\u141b\7\u024f\2\2\u141b\u141d\5\u01d6\u00ec\2")
        buf.write("\u141c\u141a\3\2\2\2\u141d\u1420\3\2\2\2\u141e\u141c\3")
        buf.write("\2\2\2\u141e\u141f\3\2\2\2\u141f\u1421\3\2\2\2\u1420\u141e")
        buf.write("\3\2\2\2\u1421\u1422\7\u0256\2\2\u1422\u01d5\3\2\2\2\u1423")
        buf.write("\u1425\t<\2\2\u1424\u1423\3\2\2\2\u1424\u1425\3\2\2\2")
        buf.write("\u1425\u1426\3\2\2\2\u1426\u1428\5\u01d8\u00ed\2\u1427")
        buf.write("\u1429\5\u0154\u00ab\2\u1428\u1427\3\2\2\2\u1428\u1429")
        buf.write("\3\2\2\2\u1429\u01d7\3\2\2\2\u142a\u142d\5\u022c\u0117")
        buf.write("\2\u142b\u142d\7\u01bd\2\2\u142c\u142a\3\2\2\2\u142c\u142b")
        buf.write("\3\2\2\2\u142d\u01d9\3\2\2\2\u142e\u142f\7\u0255\2\2\u142f")
        buf.write("\u1434\5\u01de\u00f0\2\u1430\u1431\7\u024f\2\2\u1431\u1433")
        buf.write("\5\u01de\u00f0\2\u1432\u1430\3\2\2\2\u1433\u1436\3\2\2")
        buf.write("\2\u1434\u1432\3\2\2\2\u1434\u1435\3\2\2\2\u1435\u1437")
        buf.write("\3\2\2\2\u1436\u1434\3\2\2\2\u1437\u1438\7\u0256\2\2\u1438")
        buf.write("\u01db\3\2\2\2\u1439\u1444\5\u01e0\u00f1\2\u143a\u1444")
        buf.write("\5\u01e4\u00f3\2\u143b\u143c\7\u016f\2\2\u143c\u1440\5")
        buf.write("\u0286\u0144\2\u143d\u143f\5\u01e2\u00f2\2\u143e\u143d")
        buf.write("\3\2\2\2\u143f\u1442\3\2\2\2\u1440\u143e\3\2\2\2\u1440")
        buf.write("\u1441\3\2\2\2\u1441\u1444\3\2\2\2\u1442\u1440\3\2\2\2")
        buf.write("\u1443\u1439\3\2\2\2\u1443\u143a\3\2\2\2\u1443\u143b\3")
        buf.write("\2\2\2\u1444\u01dd\3\2\2\2\u1445\u1448\5\u022c\u0117\2")
        buf.write("\u1446\u1447\7\u01c3\2\2\u1447\u1449\7\u00aa\2\2\u1448")
        buf.write("\u1446\3\2\2\2\u1448\u1449\3\2\2\2\u1449\u144d\3\2\2\2")
        buf.write("\u144a\u144c\5\u01e4\u00f3\2\u144b\u144a\3\2\2\2\u144c")
        buf.write("\u144f\3\2\2\2\u144d\u144b\3\2\2\2\u144d\u144e\3\2\2\2")
        buf.write("\u144e\u1452\3\2\2\2\u144f\u144d\3\2\2\2\u1450\u1452\5")
        buf.write("\u01e4\u00f3\2\u1451\u1445\3\2\2\2\u1451\u1450\3\2\2\2")
        buf.write("\u1452\u01df\3\2\2\2\u1453\u1454\5\u022c\u0117\2\u1454")
        buf.write("\u1456\5\u0240\u0121\2\u1455\u1457\5\u01d4\u00eb\2\u1456")
        buf.write("\u1455\3\2\2\2\u1456\u1457\3\2\2\2\u1457\u1459\3\2\2\2")
        buf.write("\u1458\u145a\5\u0214\u010b\2\u1459\u1458\3\2\2\2\u1459")
        buf.write("\u145a\3\2\2\2\u145a\u145e\3\2\2\2\u145b\u145d\5\u01e4")
        buf.write("\u00f3\2\u145c\u145b\3\2\2\2\u145d\u1460\3\2\2\2\u145e")
        buf.write("\u145c\3\2\2\2\u145e\u145f\3\2\2\2\u145f\u01e1\3\2\2\2")
        buf.write("\u1460\u145e\3\2\2\2\u1461\u1462\tC\2\2\u1462\u1463\t")
        buf.write("D\2\2\u1463\u01e3\3\2\2\2\u1464\u1465\7\u0186\2\2\u1465")
        buf.write("\u1467\5\u022c\u0117\2\u1466\u1464\3\2\2\2\u1466\u1467")
        buf.write("\3\2\2\2\u1467\u1468\3\2\2\2\u1468\u146a\5\u01e6\u00f4")
        buf.write("\2\u1469\u146b\5d\63\2\u146a\u1469\3\2\2\2\u146a\u146b")
        buf.write("\3\2\2\2\u146b\u146d\3\2\2\2\u146c\u146e\5f\64\2\u146d")
        buf.write("\u146c\3\2\2\2\u146d\u146e\3\2\2\2\u146e\u01e5\3\2\2\2")
        buf.write("\u146f\u1472\7Q\2\2\u1470\u1471\7\u01be\2\2\u1471\u1473")
        buf.write("\5\u022c\u0117\2\u1472\u1470\3\2\2\2\u1472\u1473\3\2\2")
        buf.write("\2\u1473\u1474\3\2\2\2\u1474\u1475\7\u0255\2\2\u1475\u1476")
        buf.write("\5\u00a0Q\2\u1476\u1477\7\u01c3\2\2\u1477\u147f\5\u01e8")
        buf.write("\u00f5\2\u1478\u1479\7\u024f\2\2\u1479\u147a\5\u00a0Q")
        buf.write("\2\u147a\u147b\7\u01c3\2\2\u147b\u147c\5\u01e8\u00f5\2")
        buf.write("\u147c\u147e\3\2\2\2\u147d\u1478\3\2\2\2\u147e\u1481\3")
        buf.write("\2\2\2\u147f\u147d\3\2\2\2\u147f\u1480\3\2\2\2\u1480\u1482")
        buf.write("\3\2\2\2\u1481\u147f\3\2\2\2\u1482\u1483\7\u0256\2\2\u1483")
        buf.write("\u1486\5\u01ee\u00f8\2\u1484\u1485\7\u01c1\2\2\u1485\u1487")
        buf.write("\5\u024c\u0127\2\u1486\u1484\3\2\2\2\u1486\u1487\3\2\2")
        buf.write("\2\u1487\u14bd\3\2\2\2\u1488\u1489\7\u0199\2\2\u1489\u148a")
        buf.write("\7}\2\2\u148a\u148c\5\u01f0\u00f9\2\u148b\u1488\3\2\2")
        buf.write("\2\u148b\u148c\3\2\2\2\u148c\u148d\3\2\2\2\u148d\u148e")
        buf.write("\7\u01b0\2\2\u148e\u1490\5\u0286\u0144\2\u148f\u1491\5")
        buf.write("\u01f0\u00f9\2\u1490\u148f\3\2\2\2\u1490\u1491\3\2\2\2")
        buf.write("\u1491\u1499\3\2\2\2\u1492\u1493\7\u008c\2\2\u1493\u1498")
        buf.write("\tE\2\2\u1494\u1495\7\u01aa\2\2\u1495\u1496\tF\2\2\u1496")
        buf.write("\u1498\5\u0204\u0103\2\u1497\u1492\3\2\2\2\u1497\u1494")
        buf.write("\3\2\2\2\u1498\u149b\3\2\2\2\u1499\u1497\3\2\2\2\u1499")
        buf.write("\u149a\3\2\2\2\u149a\u14bd\3\2\2\2\u149b\u1499\3\2\2\2")
        buf.write("\u149c\u149d\7\u0183\2\2\u149d\u149e\7\u0255\2\2\u149e")
        buf.write("\u149f\5\u024c\u0127\2\u149f\u14a2\7\u0256\2\2\u14a0\u14a1")
        buf.write("\7\u009d\2\2\u14a1\u14a3\7t\2\2\u14a2\u14a0\3\2\2\2\u14a2")
        buf.write("\u14a3\3\2\2\2\u14a3\u14bd\3\2\2\2\u14a4\u14a6\7\u01a7")
        buf.write("\2\2\u14a5\u14a4\3\2\2\2\u14a5\u14a6\3\2\2\2\u14a6\u14a7")
        buf.write("\3\2\2\2\u14a7\u14bd\7\u01a8\2\2\u14a8\u14ac\7\u01bc\2")
        buf.write("\2\u14a9\u14aa\7\u01af\2\2\u14aa\u14ac\7}\2\2\u14ab\u14a8")
        buf.write("\3\2\2\2\u14ab\u14a9\3\2\2\2\u14ac\u14ae\3\2\2\2\u14ad")
        buf.write("\u14af\5\u01f0\u00f9\2\u14ae\u14ad\3\2\2\2\u14ae\u14af")
        buf.write("\3\2\2\2\u14af\u14b0\3\2\2\2\u14b0\u14bd\5\u01ee\u00f8")
        buf.write("\2\u14b1\u14b2\7\u018e\2\2\u14b2\u14bd\5\u024c\u0127\2")
        buf.write("\u14b3\u14bd\5Z.\2\u14b4\u14b5\7a\2\2\u14b5\u14b6\7\r")
        buf.write("\2\2\u14b6\u14b7\7\u017d\2\2\u14b7\u14b8\7\u0255\2\2\u14b8")
        buf.write("\u14b9\5\u024c\u0127\2\u14b9\u14ba\7\u0256\2\2\u14ba\u14bb")
        buf.write("\7\u00fc\2\2\u14bb\u14bd\3\2\2\2\u14bc\u146f\3\2\2\2\u14bc")
        buf.write("\u148b\3\2\2\2\u14bc\u149c\3\2\2\2\u14bc\u14a5\3\2\2\2")
        buf.write("\u14bc\u14ab\3\2\2\2\u14bc\u14b1\3\2\2\2\u14bc\u14b3\3")
        buf.write("\2\2\2\u14bc\u14b4\3\2\2\2\u14bd\u01e7\3\2\2\2\u14be\u14cc")
        buf.write("\5\u0250\u0129\2\u14bf\u14cc\7\u024c\2\2\u14c0\u14cc\7")
        buf.write("\u0250\2\2\u14c1\u14cc\7\u0251\2\2\u14c2\u14cc\7\u0252")
        buf.write("\2\2\u14c3\u14cc\7\u0253\2\2\u14c4\u14cc\7\u0254\2\2\u14c5")
        buf.write("\u14cc\7\u0257\2\2\u14c6\u14cc\7\u0258\2\2\u14c7\u14cc")
        buf.write("\7\u0259\2\2\u14c8\u14cc\7\u025a\2\2\u14c9\u14cc\7\u025b")
        buf.write("\2\2\u14ca\u14cc\7\u025c\2\2\u14cb\u14be\3\2\2\2\u14cb")
        buf.write("\u14bf\3\2\2\2\u14cb\u14c0\3\2\2\2\u14cb\u14c1\3\2\2\2")
        buf.write("\u14cb\u14c2\3\2\2\2\u14cb\u14c3\3\2\2\2\u14cb\u14c4\3")
        buf.write("\2\2\2\u14cb\u14c5\3\2\2\2\u14cb\u14c6\3\2\2\2\u14cb\u14c7")
        buf.write("\3\2\2\2\u14cb\u14c8\3\2\2\2\u14cb\u14c9\3\2\2\2\u14cb")
        buf.write("\u14ca\3\2\2\2\u14cc\u01e9\3\2\2\2\u14cd\u14db\5\u01ec")
        buf.write("\u00f7\2\u14ce\u14db\7\u024c\2\2\u14cf\u14db\7\u0250\2")
        buf.write("\2\u14d0\u14db\7\u0251\2\2\u14d1\u14db\7\u0252\2\2\u14d2")
        buf.write("\u14db\7\u0253\2\2\u14d3\u14db\7\u0254\2\2\u14d4\u14db")
        buf.write("\7\u0257\2\2\u14d5\u14db\7\u0258\2\2\u14d6\u14db\7\u0259")
        buf.write("\2\2\u14d7\u14db\7\u025a\2\2\u14d8\u14db\7\u025b\2\2\u14d9")
        buf.write("\u14db\7\u025c\2\2\u14da\u14cd\3\2\2\2\u14da\u14ce\3\2")
        buf.write("\2\2\u14da\u14cf\3\2\2\2\u14da\u14d0\3\2\2\2\u14da\u14d1")
        buf.write("\3\2\2\2\u14da\u14d2\3\2\2\2\u14da\u14d3\3\2\2\2\u14da")
        buf.write("\u14d4\3\2\2\2\u14da\u14d5\3\2\2\2\u14da\u14d6\3\2\2\2")
        buf.write("\u14da\u14d7\3\2\2\2\u14da\u14d8\3\2\2\2\u14da\u14d9\3")
        buf.write("\2\2\2\u14db\u01eb\3\2\2\2\u14dc\u14dd\tG\2\2\u14dd\u01ed")
        buf.write("\3\2\2\2\u14de\u14e0\5\u00a2R\2\u14df\u14de\3\2\2\2\u14df")
        buf.write("\u14e0\3\2\2\2\u14e0\u14e2\3\2\2\2\u14e1\u14e3\5\u01fa")
        buf.write("\u00fe\2\u14e2\u14e1\3\2\2\2\u14e2\u14e3\3\2\2\2\u14e3")
        buf.write("\u14ea\3\2\2\2\u14e4\u14e5\7\u01be\2\2\u14e5\u14e8\7r")
        buf.write("\2\2\u14e6\u14e9\5\u0200\u0101\2\u14e7\u14e9\5\u0286\u0144")
        buf.write("\2\u14e8\u14e6\3\2\2\2\u14e8\u14e7\3\2\2\2\u14e9\u14eb")
        buf.write("\3\2\2\2\u14ea\u14e4\3\2\2\2\u14ea\u14eb\3\2\2\2\u14eb")
        buf.write("\u01ef\3\2\2\2\u14ec\u14ed\7\u0255\2\2\u14ed\u14ee\5\u01f2")
        buf.write("\u00fa\2\u14ee\u14ef\7\u0256\2\2\u14ef\u01f1\3\2\2\2\u14f0")
        buf.write("\u14f5\5\u0286\u0144\2\u14f1\u14f2\7\u024f\2\2\u14f2\u14f4")
        buf.write("\5\u0286\u0144\2\u14f3\u14f1\3\2\2\2\u14f4\u14f7\3\2\2")
        buf.write("\2\u14f5\u14f3\3\2\2\2\u14f5\u14f6\3\2\2\2\u14f6\u01f3")
        buf.write("\3\2\2\2\u14f7\u14f5\3\2\2\2\u14f8\u14f9\7\u0255\2\2\u14f9")
        buf.write("\u14fe\5\u01f6\u00fc\2\u14fa\u14fb\7\u024f\2\2\u14fb\u14fd")
        buf.write("\5\u01f6\u00fc\2\u14fc\u14fa\3\2\2\2\u14fd\u1500\3\2\2")
        buf.write("\2\u14fe\u14fc\3\2\2\2\u14fe\u14ff\3\2\2\2\u14ff\u1501")
        buf.write("\3\2\2\2\u1500\u14fe\3\2\2\2\u1501\u1502\7\u0256\2\2\u1502")
        buf.write("\u01f5\3\2\2\2\u1503\u1506\5\u01f8\u00fd\2\u1504\u1505")
        buf.write("\7\u024c\2\2\u1505\u1507\5\u024c\u0127\2\u1506\u1504\3")
        buf.write("\2\2\2\u1506\u1507\3\2\2\2\u1507\u01f7\3\2\2\2\u1508\u150b")
        buf.write("\5\u0230\u0119\2\u1509\u150a\7\u025d\2\2\u150a\u150c\5")
        buf.write("\u0230\u0119\2\u150b\u1509\3\2\2\2\u150b\u150c\3\2\2\2")
        buf.write("\u150c\u01f9\3\2\2\2\u150d\u150e\7\u01c3\2\2\u150e\u150f")
        buf.write("\5\u01f4\u00fb\2\u150f\u01fb\3\2\2\2\u1510\u1516\5\u01fa")
        buf.write("\u00fe\2\u1511\u1512\7\u01c3\2\2\u1512\u1516\7\u00a6\2")
        buf.write("\2\u1513\u1514\7\u0126\2\2\u1514\u1516\7\u00a6\2\2\u1515")
        buf.write("\u1510\3\2\2\2\u1515\u1511\3\2\2\2\u1515\u1513\3\2\2\2")
        buf.write("\u1516\u01fd\3\2\2\2\u1517\u1518\7\u01aa\2\2\u1518\u151e")
        buf.write("\7&\2\2\u1519\u151a\7\u00bc\2\2\u151a\u151f\7\u00de\2")
        buf.write("\2\u151b\u151c\7>\2\2\u151c\u151f\7\u00de\2\2\u151d\u151f")
        buf.write("\7I\2\2\u151e\u1519\3\2\2\2\u151e\u151b\3\2\2\2\u151e")
        buf.write("\u151d\3\2\2\2\u151f\u01ff\3\2\2\2\u1520\u1521\7\u0104")
        buf.write("\2\2\u1521\u1522\5\u022c\u0117\2\u1522\u0201\3\2\2\2\u1523")
        buf.write("\u1524\7\u00ec\2\2\u1524\u1525\7\u0104\2\2\u1525\u1527")
        buf.write("\5\u022c\u0117\2\u1526\u1528\7\u00a1\2\2\u1527\u1526\3")
        buf.write("\2\2\2\u1527\u1528\3\2\2\2\u1528\u0203\3\2\2\2\u1529\u152f")
        buf.write("\5\u0212\u010a\2\u152a\u152b\7\u00ec\2\2\u152b\u152f\t")
        buf.write("H\2\2\u152c\u152d\7\u009d\2\2\u152d\u152f\7\6\2\2\u152e")
        buf.write("\u1529\3\2\2\2\u152e\u152a\3\2\2\2\u152e\u152c\3\2\2\2")
        buf.write("\u152f\u0205\3\2\2\2\u1530\u1531\7\u00b0\2\2\u1531\u1535")
        buf.write("\7\u01b8\2\2\u1532\u1536\5\u022c\u0117\2\u1533\u1536\7")
        buf.write("\u018d\2\2\u1534\u1536\7\u01b3\2\2\u1535\u1532\3\2\2\2")
        buf.write("\u1535\u1533\3\2\2\2\u1535\u1534\3\2\2\2\u1536\u0207\3")
        buf.write("\2\2\2\u1537\u1538\7\u00d0\2\2\u1538\u1539\7\u01b8\2\2")
        buf.write("\u1539\u153a\5\u022c\u0117\2\u153a\u0209\3\2\2\2\u153b")
        buf.write("\u153c\7\u00ec\2\2\u153c\u153d\7\u00e1\2\2\u153d\u153e")
        buf.write("\5\u022c\u0117\2\u153e\u020b\3\2\2\2\u153f\u154b\7\u01b2")
        buf.write("\2\2\u1540\u154b\7y\2\2\u1541\u154b\7\u0119\2\2\u1542")
        buf.write("\u154b\7>\2\2\u1543\u154b\7\u010d\2\2\u1544\u154b\7\u01b0")
        buf.write("\2\2\u1545\u154b\7\u010c\2\2\u1546\u1548\7\u0178\2\2\u1547")
        buf.write("\u1549\7\u00be\2\2\u1548\u1547\3\2\2\2\u1548\u1549\3\2")
        buf.write("\2\2\u1549\u154b\3\2\2\2\u154a\u153f\3\2\2\2\u154a\u1540")
        buf.write("\3\2\2\2\u154a\u1541\3\2\2\2\u154a\u1542\3\2\2\2\u154a")
        buf.write("\u1543\3\2\2\2\u154a\u1544\3\2\2\2\u154a\u1545\3\2\2\2")
        buf.write("\u154a\u1546\3\2\2\2\u154b\u020d\3\2\2\2\u154c\u154d\t")
        buf.write("I\2\2\u154d\u020f\3\2\2\2\u154e\u154f\7\u00b4\2\2\u154f")
        buf.write("\u1550\7\26\2\2\u1550\u1555\5\u024c\u0127\2\u1551\u1552")
        buf.write("\7\u024f\2\2\u1552\u1554\5\u024c\u0127\2\u1553\u1551\3")
        buf.write("\2\2\2\u1554\u1557\3\2\2\2\u1555\u1553\3\2\2\2\u1555\u1556")
        buf.write("\3\2\2\2\u1556\u0211\3\2\2\2\u1557\u1555\3\2\2\2\u1558")
        buf.write("\u1559\tJ\2\2\u1559\u0213\3\2\2\2\u155a\u155b\7\u0184")
        buf.write("\2\2\u155b\u155c\5\u0286\u0144\2\u155c\u0215\3\2\2\2\u155d")
        buf.write("\u1560\5\u022c\u0117\2\u155e\u1560\5\u0218\u010d\2\u155f")
        buf.write("\u155d\3\2\2\2\u155f\u155e\3\2\2\2\u1560\u1562\3\2\2\2")
        buf.write("\u1561\u1563\5\u021a\u010e\2\u1562\u1561\3\2\2\2\u1562")
        buf.write("\u1563\3\2\2\2\u1563\u0217\3\2\2\2\u1564\u1565\7\u026e")
        buf.write("\2\2\u1565\u0219\3\2\2\2\u1566\u1568\5\u021c\u010f\2\u1567")
        buf.write("\u1566\3\2\2\2\u1568\u1569\3\2\2\2\u1569\u1567\3\2\2\2")
        buf.write("\u1569\u156a\3\2\2\2\u156a\u1574\3\2\2\2\u156b\u156d\5")
        buf.write("\u021c\u010f\2\u156c\u156b\3\2\2\2\u156d\u1570\3\2\2\2")
        buf.write("\u156e\u156c\3\2\2\2\u156e\u156f\3\2\2\2\u156f\u1571\3")
        buf.write("\2\2\2\u1570\u156e\3\2\2\2\u1571\u1572\7\u025d\2\2\u1572")
        buf.write("\u1574\7\u0259\2\2\u1573\u1567\3\2\2\2\u1573\u156e\3\2")
        buf.write("\2\2\u1574\u021b\3\2\2\2\u1575\u1576\7\u025d\2\2\u1576")
        buf.write("\u1585\5\u0230\u0119\2\u1577\u1578\7\u0261\2\2\u1578\u1579")
        buf.write("\5\u024c\u0127\2\u1579\u157a\7\u0262\2\2\u157a\u1585\3")
        buf.write("\2\2\2\u157b\u157d\7\u0261\2\2\u157c\u157e\5\u024c\u0127")
        buf.write("\2\u157d\u157c\3\2\2\2\u157d\u157e\3\2\2\2\u157e\u157f")
        buf.write("\3\2\2\2\u157f\u1581\7\u024d\2\2\u1580\u1582\5\u024c\u0127")
        buf.write("\2\u1581\u1580\3\2\2\2\u1581\u1582\3\2\2\2\u1582\u1583")
        buf.write("\3\2\2\2\u1583\u1585\7\u0262\2\2\u1584\u1575\3\2\2\2\u1584")
        buf.write("\u1577\3\2\2\2\u1584\u157b\3\2\2\2\u1585\u021d\3\2\2\2")
        buf.write("\u1586\u1588\7\67\2\2\u1587\u1589\5\u01a6\u00d4\2\u1588")
        buf.write("\u1587\3\2\2\2\u1588\u1589\3\2\2\2\u1589\u158a\3\2\2\2")
        buf.write("\u158a\u1591\5\u022c\u0117\2\u158b\u158d\7\u01c3\2\2\u158c")
        buf.write("\u158b\3\2\2\2\u158c\u158d\3\2\2\2\u158d\u158e\3\2\2\2")
        buf.write("\u158e\u158f\7\u0255\2\2\u158f\u1590\7]\2\2\u1590\u1592")
        buf.write("\7\u0256\2\2\u1591\u158c\3\2\2\2\u1591\u1592\3\2\2\2\u1592")
        buf.write("\u021f\3\2\2\2\u1593\u1595\t#\2\2\u1594\u1596\5\u01a6")
        buf.write("\u00d4\2\u1595\u1594\3\2\2\2\u1595\u1596\3\2\2\2\u1596")
        buf.write("\u1597\3\2\2\2\u1597\u1599\5\u0286\u0144\2\u1598\u159a")
        buf.write("\5\u0150\u00a9\2\u1599\u1598\3\2\2\2\u1599\u159a\3\2\2")
        buf.write("\2\u159a\u159c\3\2\2\2\u159b\u159d\5\u0212\u010a\2\u159c")
        buf.write("\u159b\3\2\2\2\u159c\u159d\3\2\2\2\u159d\u0221\3\2\2\2")
        buf.write("\u159e\u15a0\7\u010c\2\2\u159f\u15a1\5\u01a6\u00d4\2\u15a0")
        buf.write("\u159f\3\2\2\2\u15a0\u15a1\3\2\2\2\u15a1\u15a2\3\2\2\2")
        buf.write("\u15a2\u15a3\5\u022c\u0117\2\u15a3\u15a4\7\u01aa\2\2\u15a4")
        buf.write("\u15a6\5\u0286\u0144\2\u15a5\u15a7\5\u0212\u010a\2\u15a6")
        buf.write("\u15a5\3\2\2\2\u15a6\u15a7\3\2\2\2\u15a7\u0223\3\2\2\2")
        buf.write("\u15a8\u15aa\7\u00df\2\2\u15a9\u15ab\5\u01a6\u00d4\2\u15aa")
        buf.write("\u15a9\3\2\2\2\u15aa\u15ab\3\2\2\2\u15ab\u15ac\3\2\2\2")
        buf.write("\u15ac\u15ad\5\u022c\u0117\2\u15ad\u15ae\7\u01aa\2\2\u15ae")
        buf.write("\u15b0\5\u0286\u0144\2\u15af\u15b1\5\u0212\u010a\2\u15b0")
        buf.write("\u15af\3\2\2\2\u15b0\u15b1\3\2\2\2\u15b1\u0225\3\2\2\2")
        buf.write("\u15b2\u15b3\7\5\2\2\u15b3\u15dc\7\u008f\2\2\u15b4\u15dc")
        buf.write("\7\u0163\2\2\u15b5\u15dc\7.\2\2\u15b6\u15dc\7G\2\2\u15b7")
        buf.write("\u15b8\7P\2\2\u15b8\u15dc\7\u010c\2\2\u15b9\u15dc\7W\2")
        buf.write("\2\u15ba\u15dc\7\u019c\2\2\u15bb\u15bd\7\u0199\2\2\u15bc")
        buf.write("\u15bb\3\2\2\2\u15bc\u15bd\3\2\2\2\u15bd\u15be\3\2\2\2")
        buf.write("\u15be\u15dc\7\u01b6\2\2\u15bf\u15c0\7\u0199\2\2\u15c0")
        buf.write("\u15c1\7\66\2\2\u15c1\u15dc\7\u0128\2\2\u15c2\u15c4\7")
        buf.write("r\2\2\u15c3\u15c5\7\u0164\2\2\u15c4\u15c3\3\2\2\2\u15c4")
        buf.write("\u15c5\3\2\2\2\u15c5\u15dc\3\2\2\2\u15c6\u15c8\7\u008d")
        buf.write("\2\2\u15c7\u15c6\3\2\2\2\u15c7\u15c8\3\2\2\2\u15c8\u15c9")
        buf.write("\3\2\2\2\u15c9\u15dc\7\u0121\2\2\u15ca\u15cc\7\u00bf\2")
        buf.write("\2\u15cb\u15ca\3\2\2\2\u15cb\u15cc\3\2\2\2\u15cc\u15cd")
        buf.write("\3\2\2\2\u15cd\u15dc\7\177\2\2\u15ce\u15dc\7\u00c3\2\2")
        buf.write("\u15cf\u15dc\7\u00d9\2\2\u15d0\u15dc\7\u00e1\2\2\u15d1")
        buf.write("\u15dc\7\u00e7\2\2\u15d2\u15dc\7\u00ea\2\2\u15d3\u15dc")
        buf.write("\7\u00f8\2\2\u15d4\u15dc\7\u00ff\2\2\u15d5\u15dc\7\u0104")
        buf.write("\2\2\u15d6\u15dc\7\u010f\2\2\u15d7\u15d8\7\u0108\2\2\u15d8")
        buf.write("\u15d9\7\u00e4\2\2\u15d9\u15dc\t\37\2\2\u15da\u15dc\7")
        buf.write("\u01bd\2\2\u15db\u15b2\3\2\2\2\u15db\u15b4\3\2\2\2\u15db")
        buf.write("\u15b5\3\2\2\2\u15db\u15b6\3\2\2\2\u15db\u15b7\3\2\2\2")
        buf.write("\u15db\u15b9\3\2\2\2\u15db\u15ba\3\2\2\2\u15db\u15bc\3")
        buf.write("\2\2\2\u15db\u15bf\3\2\2\2\u15db\u15c2\3\2\2\2\u15db\u15c7")
        buf.write("\3\2\2\2\u15db\u15cb\3\2\2\2\u15db\u15ce\3\2\2\2\u15db")
        buf.write("\u15cf\3\2\2\2\u15db\u15d0\3\2\2\2\u15db\u15d1\3\2\2\2")
        buf.write("\u15db\u15d2\3\2\2\2\u15db\u15d3\3\2\2\2\u15db\u15d4\3")
        buf.write("\2\2\2\u15db\u15d5\3\2\2\2\u15db\u15d6\3\2\2\2\u15db\u15d7")
        buf.write("\3\2\2\2\u15db\u15da\3\2\2\2\u15dc\u15dd\3\2\2\2\u15dd")
        buf.write("\u15de\5\u0228\u0115\2\u15de\u0227\3\2\2\2\u15df\u15e1")
        buf.write("\5\u01a6\u00d4\2\u15e0\u15df\3\2\2\2\u15e0\u15e1\3\2\2")
        buf.write("\2\u15e1\u15e2\3\2\2\2\u15e2\u15e4\5\u01f2\u00fa\2\u15e3")
        buf.write("\u15e5\5\u0212\u010a\2\u15e4\u15e3\3\2\2\2\u15e4\u15e5")
        buf.write("\3\2\2\2\u15e5\u0229\3\2\2\2\u15e6\u15ea\7\u026f\2\2\u15e7")
        buf.write("\u15ea\7\u0270\2\2\u15e8\u15ea\5\u023a\u011e\2\u15e9\u15e6")
        buf.write("\3\2\2\2\u15e9\u15e7\3\2\2\2\u15e9\u15e8\3\2\2\2\u15ea")
        buf.write("\u022b\3\2\2\2\u15eb\u15ef\5\u022a\u0116\2\u15ec\u15ef")
        buf.write("\5\u0232\u011a\2\u15ed\u15ef\5\u0234\u011b\2\u15ee\u15eb")
        buf.write("\3\2\2\2\u15ee\u15ec\3\2\2\2\u15ee\u15ed\3\2\2\2\u15ef")
        buf.write("\u022d\3\2\2\2\u15f0\u15f4\5\u022a\u0116\2\u15f1\u15f4")
        buf.write("\5\u0232\u011a\2\u15f2\u15f4\5\u0236\u011c\2\u15f3\u15f0")
        buf.write("\3\2\2\2\u15f3\u15f1\3\2\2\2\u15f3\u15f2\3\2\2\2\u15f4")
        buf.write("\u022f\3\2\2\2\u15f5\u15fb\5\u022a\u0116\2\u15f6\u15fb")
        buf.write("\5\u0238\u011d\2\u15f7\u15fb\5\u0232\u011a\2\u15f8\u15fb")
        buf.write("\5\u0236\u011c\2\u15f9\u15fb\5\u0234\u011b\2\u15fa\u15f5")
        buf.write("\3\2\2\2\u15fa\u15f6\3\2\2\2\u15fa\u15f7\3\2\2\2\u15fa")
        buf.write("\u15f8\3\2\2\2\u15fa\u15f9\3\2\2\2\u15fb\u0231\3\2\2\2")
        buf.write("\u15fc\u15fd\tK\2\2\u15fd\u0233\3\2\2\2\u15fe\u15ff\t")
        buf.write("L\2\2\u15ff\u0235\3\2\2\2\u1600\u1601\tM\2\2\u1601\u0237")
        buf.write("\3\2\2\2\u1602\u1603\tN\2\2\u1603\u0239\3\2\2\2\u1604")
        buf.write("\u1605\tO\2\2\u1605\u023b\3\2\2\2\u1606\u160c\5\u022e")
        buf.write("\u0118\2\u1607\u1608\5\u022c\u0117\2\u1608\u1609\7\u025d")
        buf.write("\2\2\u1609\u160a\5\u022e\u0118\2\u160a\u160c\3\2\2\2\u160b")
        buf.write("\u1606\3\2\2\2\u160b\u1607\3\2\2\2\u160c\u023d\3\2\2\2")
        buf.write("\u160d\u1612\5\u0240\u0121\2\u160e\u160f\7\u024f\2\2\u160f")
        buf.write("\u1611\5\u0240\u0121\2\u1610\u160e\3\2\2\2\u1611\u1614")
        buf.write("\3\2\2\2\u1612\u1610\3\2\2\2\u1612\u1613\3\2\2\2\u1613")
        buf.write("\u023f\3\2\2\2\u1614\u1612\3\2\2\2\u1615\u1617\7\u014d")
        buf.write("\2\2\u1616\u1615\3\2\2\2\u1616\u1617\3\2\2\2\u1617\u1618")
        buf.write("\3\2\2\2\u1618\u1622\5\u0244\u0123\2\u1619\u161b\7\u017c")
        buf.write("\2\2\u161a\u161c\5\u0242\u0122\2\u161b\u161a\3\2\2\2\u161b")
        buf.write("\u161c\3\2\2\2\u161c\u1623\3\2\2\2\u161d\u161f\5\u0242")
        buf.write("\u0122\2\u161e\u161d\3\2\2\2\u161f\u1620\3\2\2\2\u1620")
        buf.write("\u161e\3\2\2\2\u1620\u1621\3\2\2\2\u1621\u1623\3\2\2\2")
        buf.write("\u1622\u1619\3\2\2\2\u1622\u161e\3\2\2\2\u1622\u1623\3")
        buf.write("\2\2\2\u1623\u0241\3\2\2\2\u1624\u1626\7\u0261\2\2\u1625")
        buf.write("\u1627\7\u026c\2\2\u1626\u1625\3\2\2\2\u1626\u1627\3\2")
        buf.write("\2\2\u1627\u1628\3\2\2\2\u1628\u1629\7\u0262\2\2\u1629")
        buf.write("\u0243\3\2\2\2\u162a\u1686\7\u012f\2\2\u162b\u162d\7\u0130")
        buf.write("\2\2\u162c\u162e\7\u011f\2\2\u162d\u162c\3\2\2\2\u162d")
        buf.write("\u162e\3\2\2\2\u162e\u1630\3\2\2\2\u162f\u1631\5\u0248")
        buf.write("\u0125\2\u1630\u162f\3\2\2\2\u1630\u1631\3\2\2\2\u1631")
        buf.write("\u1686\3\2\2\2\u1632\u1686\7\u0131\2\2\u1633\u1635\7\u0135")
        buf.write("\2\2\u1634\u1636\5\u024a\u0126\2\u1635\u1634\3\2\2\2\u1635")
        buf.write("\u1636\3\2\2\2\u1636\u1686\3\2\2\2\u1637\u1639\7\u0136")
        buf.write("\2\2\u1638\u163a\5\u024a\u0126\2\u1639\u1638\3\2\2\2\u1639")
        buf.write("\u163a\3\2\2\2\u163a\u1686\3\2\2\2\u163b\u163c\7H\2\2")
        buf.write("\u163c\u1686\7\u014a\2\2\u163d\u163f\7\u0139\2\2\u163e")
        buf.write("\u1640\5\u024a\u0126\2\u163f\u163e\3\2\2\2\u163f\u1640")
        buf.write("\3\2\2\2\u1640\u1686\3\2\2\2\u1641\u1686\7\u013d\2\2\u1642")
        buf.write("\u1686\7\u013e\2\2\u1643\u1645\7\u013f\2\2\u1644\u1646")
        buf.write("\5\u0246\u0124\2\u1645\u1644\3\2\2\2\u1645\u1646\3\2\2")
        buf.write("\2\u1646\u1648\3\2\2\2\u1647\u1649\5\u0248\u0125\2\u1648")
        buf.write("\u1647\3\2\2\2\u1648\u1649\3\2\2\2\u1649\u1686\3\2\2\2")
        buf.write("\u164a\u164c\7\u0141\2\2\u164b\u164a\3\2\2\2\u164b\u164c")
        buf.write("\3\2\2\2\u164c\u164d\3\2\2\2\u164d\u164f\tP\2\2\u164e")
        buf.write("\u1650\7\u011f\2\2\u164f\u164e\3\2\2\2\u164f\u1650\3\2")
        buf.write("\2\2\u1650\u1652\3\2\2\2\u1651\u1653\5\u0248\u0125\2\u1652")
        buf.write("\u1651\3\2\2\2\u1652\u1653\3\2\2\2\u1653\u1686\3\2\2\2")
        buf.write("\u1654\u1656\7\u0142\2\2\u1655\u1657\7\u011f\2\2\u1656")
        buf.write("\u1655\3\2\2\2\u1656\u1657\3\2\2\2\u1657\u1659\3\2\2\2")
        buf.write("\u1658\u165a\5\u0248\u0125\2\u1659\u1658\3\2\2\2\u1659")
        buf.write("\u165a\3\2\2\2\u165a\u1686\3\2\2\2\u165b\u165d\7\u0146")
        buf.write("\2\2\u165c\u165e\5\u024a\u0126\2\u165d\u165c\3\2\2\2\u165d")
        buf.write("\u165e\3\2\2\2\u165e\u1686\3\2\2\2\u165f\u1686\7\u014b")
        buf.write("\2\2\u1660\u1686\7\u014e\2\2\u1661\u1663\7\u0150\2\2\u1662")
        buf.write("\u1664\5\u0248\u0125\2\u1663\u1662\3\2\2\2\u1663\u1664")
        buf.write("\3\2\2\2\u1664\u1668\3\2\2\2\u1665\u1666\t\n\2\2\u1666")
        buf.write("\u1667\7\u0150\2\2\u1667\u1669\7\u012d\2\2\u1668\u1665")
        buf.write("\3\2\2\2\u1668\u1669\3\2\2\2\u1669\u1686\3\2\2\2\u166a")
        buf.write("\u166c\7\u0151\2\2\u166b\u166d\5\u0248\u0125\2\u166c\u166b")
        buf.write("\3\2\2\2\u166c\u166d\3\2\2\2\u166d\u1671\3\2\2\2\u166e")
        buf.write("\u166f\t\n\2\2\u166f\u1670\7\u0150\2\2\u1670\u1672\7\u012d")
        buf.write("\2\2\u1671\u166e\3\2\2\2\u1671\u1672\3\2\2\2\u1672\u1686")
        buf.write("\3\2\2\2\u1673\u1675\7\u0155\2\2\u1674\u1676\5\u0248\u0125")
        buf.write("\2\u1675\u1674\3\2\2\2\u1675\u1676\3\2\2\2\u1676\u1686")
        buf.write("\3\2\2\2\u1677\u1683\5\u023c\u011f\2\u1678\u1679\7\u0255")
        buf.write("\2\2\u1679\u167e\5\u024c\u0127\2\u167a\u167b\7\u024f\2")
        buf.write("\2\u167b\u167d\5\u024c\u0127\2\u167c\u167a\3\2\2\2\u167d")
        buf.write("\u1680\3\2\2\2\u167e\u167c\3\2\2\2\u167e\u167f\3\2\2\2")
        buf.write("\u167f\u1681\3\2\2\2\u1680\u167e\3\2\2\2\u1681\u1682\7")
        buf.write("\u0256\2\2\u1682\u1684\3\2\2\2\u1683\u1678\3\2\2\2\u1683")
        buf.write("\u1684\3\2\2\2\u1684\u1686\3\2\2\2\u1685\u162a\3\2\2\2")
        buf.write("\u1685\u162b\3\2\2\2\u1685\u1632\3\2\2\2\u1685\u1633\3")
        buf.write("\2\2\2\u1685\u1637\3\2\2\2\u1685\u163b\3\2\2\2\u1685\u163d")
        buf.write("\3\2\2\2\u1685\u1641\3\2\2\2\u1685\u1642\3\2\2\2\u1685")
        buf.write("\u1643\3\2\2\2\u1685\u164b\3\2\2\2\u1685\u1654\3\2\2\2")
        buf.write("\u1685\u165b\3\2\2\2\u1685\u165f\3\2\2\2\u1685\u1660\3")
        buf.write("\2\2\2\u1685\u1661\3\2\2\2\u1685\u166a\3\2\2\2\u1685\u1673")
        buf.write("\3\2\2\2\u1685\u1677\3\2\2\2\u1686\u0245\3\2\2\2\u1687")
        buf.write("\u16a3\7\u012b\2\2\u1688\u16a3\7\u0093\2\2\u1689\u16a3")
        buf.write("\78\2\2\u168a\u16a3\7h\2\2\u168b\u16a3\7\u0090\2\2\u168c")
        buf.write("\u16a3\7\u00e5\2\2\u168d\u168e\7\u012b\2\2\u168e\u168f")
        buf.write("\7\u01b8\2\2\u168f\u16a3\7\u0093\2\2\u1690\u1691\78\2")
        buf.write("\2\u1691\u1692\7\u01b8\2\2\u1692\u16a3\7h\2\2\u1693\u1694")
        buf.write("\78\2\2\u1694\u1695\7\u01b8\2\2\u1695\u16a3\7\u0090\2")
        buf.write("\2\u1696\u1697\78\2\2\u1697\u1698\7\u01b8\2\2\u1698\u16a3")
        buf.write("\7\u00e5\2\2\u1699\u169a\7h\2\2\u169a\u169b\7\u01b8\2")
        buf.write("\2\u169b\u16a3\7\u0090\2\2\u169c\u169d\7h\2\2\u169d\u169e")
        buf.write("\7\u01b8\2\2\u169e\u16a3\7\u00e5\2\2\u169f\u16a0\7\u0090")
        buf.write("\2\2\u16a0\u16a1\7\u01b8\2\2\u16a1\u16a3\7\u00e5\2\2\u16a2")
        buf.write("\u1687\3\2\2\2\u16a2\u1688\3\2\2\2\u16a2\u1689\3\2\2\2")
        buf.write("\u16a2\u168a\3\2\2\2\u16a2\u168b\3\2\2\2\u16a2\u168c\3")
        buf.write("\2\2\2\u16a2\u168d\3\2\2\2\u16a2\u1690\3\2\2\2\u16a2\u1693")
        buf.write("\3\2\2\2\u16a2\u1696\3\2\2\2\u16a2\u1699\3\2\2\2\u16a2")
        buf.write("\u169c\3\2\2\2\u16a2\u169f\3\2\2\2\u16a3\u0247\3\2\2\2")
        buf.write("\u16a4\u16a5\7\u0255\2\2\u16a5\u16a6\7\u026c\2\2\u16a6")
        buf.write("\u16a7\7\u0256\2\2\u16a7\u0249\3\2\2\2\u16a8\u16a9\7\u0255")
        buf.write("\2\2\u16a9\u16ac\7\u026c\2\2\u16aa\u16ab\7\u024f\2\2\u16ab")
        buf.write("\u16ad\7\u026c\2\2\u16ac\u16aa\3\2\2\2\u16ac\u16ad\3\2")
        buf.write("\2\2\u16ad\u16ae\3\2\2\2\u16ae\u16af\7\u0256\2\2\u16af")
        buf.write("\u024b\3\2\2\2\u16b0\u16b1\b\u0127\1\2\u16b1\u16b2\7\u0255")
        buf.write("\2\2\u16b2\u16b3\5\u024c\u0127\2\u16b3\u16b5\7\u0256\2")
        buf.write("\2\u16b4\u16b6\5\u021a\u010e\2\u16b5\u16b4\3\2\2\2\u16b5")
        buf.write("\u16b6\3\2\2\2\u16b6\u16ca\3\2\2\2\u16b7\u16b8\7\u0255")
        buf.write("\2\2\u16b8\u16bb\5\u024c\u0127\2\u16b9\u16ba\7\u024f\2")
        buf.write("\2\u16ba\u16bc\5\u024c\u0127\2\u16bb\u16b9\3\2\2\2\u16bc")
        buf.write("\u16bd\3\2\2\2\u16bd\u16bb\3\2\2\2\u16bd\u16be\3\2\2\2")
        buf.write("\u16be\u16bf\3\2\2\2\u16bf\u16c0\7\u0256\2\2\u16c0\u16ca")
        buf.write("\3\2\2\2\u16c1\u16c2\t8\2\2\u16c2\u16ca\5\u024c\u0127")
        buf.write("\32\u16c3\u16c4\5\u0250\u0129\2\u16c4\u16c5\5\u024c\u0127")
        buf.write("\24\u16c5\u16ca\3\2\2\2\u16c6\u16c7\7\u01a7\2\2\u16c7")
        buf.write("\u16ca\5\u024c\u0127\6\u16c8\u16ca\5\u0256\u012c\2\u16c9")
        buf.write("\u16b0\3\2\2\2\u16c9\u16b7\3\2\2\2\u16c9\u16c1\3\2\2\2")
        buf.write("\u16c9\u16c3\3\2\2\2\u16c9\u16c6\3\2\2\2\u16c9\u16c8\3")
        buf.write("\2\2\2\u16ca\u1752\3\2\2\2\u16cb\u16cc\f\31\2\2\u16cc")
        buf.write("\u16cd\7\20\2\2\u16cd\u16ce\7\u0150\2\2\u16ce\u16cf\7")
        buf.write("\u012d\2\2\u16cf\u1751\5\u024c\u0127\32\u16d0\u16d1\f")
        buf.write("\30\2\2\u16d1\u16d2\7\u025c\2\2\u16d2\u1751\5\u024c\u0127")
        buf.write("\31\u16d3\u16d4\f\27\2\2\u16d4\u16d5\tQ\2\2\u16d5\u1751")
        buf.write("\5\u024c\u0127\30\u16d6\u16d7\f\26\2\2\u16d7\u16d8\t8")
        buf.write("\2\2\u16d8\u1751\5\u024c\u0127\27\u16d9\u16da\f\25\2\2")
        buf.write("\u16da\u16db\5\u0250\u0129\2\u16db\u16dc\5\u024c\u0127")
        buf.write("\26\u16dc\u1751\3\2\2\2\u16dd\u16df\f\21\2\2\u16de\u16e0")
        buf.write("\7\u01a7\2\2\u16df\u16de\3\2\2\2\u16df\u16e0\3\2\2\2\u16e0")
        buf.write("\u16e1\3\2\2\2\u16e1\u16e3\7\u012e\2\2\u16e2\u16e4\tR")
        buf.write("\2\2\u16e3\u16e2\3\2\2\2\u16e3\u16e4\3\2\2\2\u16e4\u16e5")
        buf.write("\3\2\2\2\u16e5\u16e6\5\u024e\u0128\2\u16e6\u16e7\7\u017a")
        buf.write("\2\2\u16e7\u16e8\5\u024c\u0127\22\u16e8\u1751\3\2\2\2")
        buf.write("\u16e9\u16eb\f\20\2\2\u16ea\u16ec\7\u01a7\2\2\u16eb\u16ea")
        buf.write("\3\2\2\2\u16eb\u16ec\3\2\2\2\u16ec\u16f1\3\2\2\2\u16ed")
        buf.write("\u16f2\7\u016f\2\2\u16ee\u16f2\7\u0169\2\2\u16ef\u16f0")
        buf.write("\7\u0175\2\2\u16f0\u16f2\7\u01b8\2\2\u16f1\u16ed\3\2\2")
        buf.write("\2\u16f1\u16ee\3\2\2\2\u16f1\u16ef\3\2\2\2\u16f2\u16f3")
        buf.write("\3\2\2\2\u16f3\u1751\5\u024c\u0127\21\u16f4\u16f6\f\17")
        buf.write("\2\2\u16f5\u16f7\7\u01a7\2\2\u16f6\u16f5\3\2\2\2\u16f6")
        buf.write("\u16f7\3\2\2\2\u16f7\u16fc\3\2\2\2\u16f8\u16fd\7\u016f")
        buf.write("\2\2\u16f9\u16fd\7\u0169\2\2\u16fa\u16fb\7\u0175\2\2\u16fb")
        buf.write("\u16fd\7\u01b8\2\2\u16fc\u16f8\3\2\2\2\u16fc\u16f9\3\2")
        buf.write("\2\2\u16fc\u16fa\3\2\2\2\u16fd\u16fe\3\2\2\2\u16fe\u16ff")
        buf.write("\5\u024c\u0127\2\u16ff\u1700\7O\2\2\u1700\u1701\5\u024c")
        buf.write("\u0127\20\u1701\u1751\3\2\2\2\u1702\u1703\f\16\2\2\u1703")
        buf.write("\u1704\tS\2\2\u1704\u1751\5\u024c\u0127\17\u1705\u1706")
        buf.write("\f\f\2\2\u1706\u1708\7\u016b\2\2\u1707\u1709\7\u01a7\2")
        buf.write("\2\u1708\u1707\3\2\2\2\u1708\u1709\3\2\2\2\u1709\u170a")
        buf.write("\3\2\2\2\u170a\u170b\7\u0191\2\2\u170b\u170c\7\u019a\2")
        buf.write("\2\u170c\u1751\5\u024c\u0127\r\u170d\u170e\f\5\2\2\u170e")
        buf.write("\u170f\7\u017a\2\2\u170f\u1751\5\u024c\u0127\6\u1710\u1711")
        buf.write("\f\4\2\2\u1711\u1712\7\u01ac\2\2\u1712\u1751\5\u024c\u0127")
        buf.write("\5\u1713\u1714\f\36\2\2\u1714\u1715\7\u024b\2\2\u1715")
        buf.write("\u1751\5\u0240\u0121\2\u1716\u1717\f\33\2\2\u1717\u1751")
        buf.write("\5\u0214\u010b\2\u1718\u1719\f\23\2\2\u1719\u1751\5\u0250")
        buf.write("\u0129\2\u171a\u171c\f\22\2\2\u171b\u171d\7\u01a7\2\2")
        buf.write("\u171c\u171b\3\2\2\2\u171c\u171d\3\2\2\2\u171d\u171e\3")
        buf.write("\2\2\2\u171e\u171f\7\u019e\2\2\u171f\u1729\7\u0255\2\2")
        buf.write("\u1720\u172a\5\u0290\u0149\2\u1721\u1726\5\u024c\u0127")
        buf.write("\2\u1722\u1723\7\u024f\2\2\u1723\u1725\5\u024c\u0127\2")
        buf.write("\u1724\u1722\3\2\2\2\u1725\u1728\3\2\2\2\u1726\u1724\3")
        buf.write("\2\2\2\u1726\u1727\3\2\2\2\u1727\u172a\3\2\2\2\u1728\u1726")
        buf.write("\3\2\2\2\u1729\u1720\3\2\2\2\u1729\u1721\3\2\2\2\u172a")
        buf.write("\u172b\3\2\2\2\u172b\u172c\7\u0256\2\2\u172c\u1751\3\2")
        buf.write("\2\2\u172d\u172e\f\r\2\2\u172e\u1730\7\u016b\2\2\u172f")
        buf.write("\u1731\7\u01a7\2\2\u1730\u172f\3\2\2\2\u1730\u1731\3\2")
        buf.write("\2\2\u1731\u1734\3\2\2\2\u1732\u1735\5\u025c\u012f\2\u1733")
        buf.write("\u1735\7\u01a8\2\2\u1734\u1732\3\2\2\2\u1734\u1733\3\2")
        buf.write("\2\2\u1735\u1751\3\2\2\2\u1736\u1737\f\13\2\2\u1737\u1739")
        buf.write("\7\u016b\2\2\u1738\u173a\7\u01a7\2\2\u1739\u1738\3\2\2")
        buf.write("\2\u1739\u173a\3\2\2\2\u173a\u173b\3\2\2\2\u173b\u1751")
        buf.write("\7F\2\2\u173c\u173d\f\n\2\2\u173d\u173f\7\u016b\2\2\u173e")
        buf.write("\u1740\7\u01a7\2\2\u173f\u173e\3\2\2\2\u173f\u1740\3\2")
        buf.write("\2\2\u1740\u1741\3\2\2\2\u1741\u1751\7\u0115\2\2\u1742")
        buf.write("\u1743\f\t\2\2\u1743\u1745\7\u016b\2\2\u1744\u1746\7\u01a7")
        buf.write("\2\2\u1745\u1744\3\2\2\2\u1745\u1746\3\2\2\2\u1746\u1747")
        buf.write("\3\2\2\2\u1747\u1748\7\u00a4\2\2\u1748\u1749\7\u0255\2")
        buf.write("\2\u1749\u174a\5\u023e\u0120\2\u174a\u174b\7\u0256\2\2")
        buf.write("\u174b\u1751\3\2\2\2\u174c\u174d\f\b\2\2\u174d\u1751\7")
        buf.write("\u016c\2\2\u174e\u174f\f\7\2\2\u174f\u1751\7\u0171\2\2")
        buf.write("\u1750\u16cb\3\2\2\2\u1750\u16d0\3\2\2\2\u1750\u16d3\3")
        buf.write("\2\2\2\u1750\u16d6\3\2\2\2\u1750\u16d9\3\2\2\2\u1750\u16dd")
        buf.write("\3\2\2\2\u1750\u16e9\3\2\2\2\u1750\u16f4\3\2\2\2\u1750")
        buf.write("\u1702\3\2\2\2\u1750\u1705\3\2\2\2\u1750\u170d\3\2\2\2")
        buf.write("\u1750\u1710\3\2\2\2\u1750\u1713\3\2\2\2\u1750\u1716\3")
        buf.write("\2\2\2\u1750\u1718\3\2\2\2\u1750\u171a\3\2\2\2\u1750\u172d")
        buf.write("\3\2\2\2\u1750\u1736\3\2\2\2\u1750\u173c\3\2\2\2\u1750")
        buf.write("\u1742\3\2\2\2\u1750\u174c\3\2\2\2\u1750\u174e\3\2\2\2")
        buf.write("\u1751\u1754\3\2\2\2\u1752\u1750\3\2\2\2\u1752\u1753\3")
        buf.write("\2\2\2\u1753\u024d\3\2\2\2\u1754\u1752\3\2\2\2\u1755\u1756")
        buf.write("\b\u0128\1\2\u1756\u1757\7\u0255\2\2\u1757\u1758\5\u024c")
        buf.write("\u0127\2\u1758\u175a\7\u0256\2\2\u1759\u175b\5\u021a\u010e")
        buf.write("\2\u175a\u1759\3\2\2\2\u175a\u175b\3\2\2\2\u175b\u176d")
        buf.write("\3\2\2\2\u175c\u175d\7\u0255\2\2\u175d\u1760\5\u024c\u0127")
        buf.write("\2\u175e\u175f\7\u024f\2\2\u175f\u1761\5\u024c\u0127\2")
        buf.write("\u1760\u175e\3\2\2\2\u1761\u1762\3\2\2\2\u1762\u1760\3")
        buf.write("\2\2\2\u1762\u1763\3\2\2\2\u1763\u1764\3\2\2\2\u1764\u1765")
        buf.write("\7\u0256\2\2\u1765\u176d\3\2\2\2\u1766\u1767\t8\2\2\u1767")
        buf.write("\u176d\5\u024e\u0128\17\u1768\u1769\5\u0250\u0129\2\u1769")
        buf.write("\u176a\5\u024e\u0128\n\u176a\u176d\3\2\2\2\u176b\u176d")
        buf.write("\5\u0256\u012c\2\u176c\u1755\3\2\2\2\u176c\u175c\3\2\2")
        buf.write("\2\u176c\u1766\3\2\2\2\u176c\u1768\3\2\2\2\u176c\u176b")
        buf.write("\3\2\2\2\u176d\u17a3\3\2\2\2\u176e\u176f\f\16\2\2\u176f")
        buf.write("\u1770\7\u025c\2\2\u1770\u17a2\5\u024e\u0128\17\u1771")
        buf.write("\u1772\f\r\2\2\u1772\u1773\tQ\2\2\u1773\u17a2\5\u024e")
        buf.write("\u0128\16\u1774\u1775\f\f\2\2\u1775\u1776\t8\2\2\u1776")
        buf.write("\u17a2\5\u024e\u0128\r\u1777\u1778\f\13\2\2\u1778\u1779")
        buf.write("\5\u0250\u0129\2\u1779\u177a\5\u024e\u0128\f\u177a\u17a2")
        buf.write("\3\2\2\2\u177b\u177c\f\b\2\2\u177c\u177d\tS\2\2\u177d")
        buf.write("\u17a2\5\u024e\u0128\t\u177e\u177f\f\7\2\2\u177f\u1781")
        buf.write("\7\u016b\2\2\u1780\u1782\7\u01a7\2\2\u1781\u1780\3\2\2")
        buf.write("\2\u1781\u1782\3\2\2\2\u1782\u1783\3\2\2\2\u1783\u1784")
        buf.write("\7\u0191\2\2\u1784\u1785\7\u019a\2\2\u1785\u17a2\5\u024e")
        buf.write("\u0128\b\u1786\u1787\f\22\2\2\u1787\u1788\7\u024b\2\2")
        buf.write("\u1788\u17a2\5\u0240\u0121\2\u1789\u178a\f\t\2\2\u178a")
        buf.write("\u17a2\5\u0250\u0129\2\u178b\u178c\f\6\2\2\u178c\u178e")
        buf.write("\7\u016b\2\2\u178d\u178f\7\u01a7\2\2\u178e\u178d\3\2\2")
        buf.write("\2\u178e\u178f\3\2\2\2\u178f\u1790\3\2\2\2\u1790\u17a2")
        buf.write("\7F\2\2\u1791\u1792\f\5\2\2\u1792\u1794\7\u016b\2\2\u1793")
        buf.write("\u1795\7\u01a7\2\2\u1794\u1793\3\2\2\2\u1794\u1795\3\2")
        buf.write("\2\2\u1795\u1796\3\2\2\2\u1796\u17a2\7\u0115\2\2\u1797")
        buf.write("\u1798\f\4\2\2\u1798\u179a\7\u016b\2\2\u1799\u179b\7\u01a7")
        buf.write("\2\2\u179a\u1799\3\2\2\2\u179a\u179b\3\2\2\2\u179b\u179c")
        buf.write("\3\2\2\2\u179c\u179d\7\u00a4\2\2\u179d\u179e\7\u0255\2")
        buf.write("\2\u179e\u179f\5\u023e\u0120\2\u179f\u17a0\7\u0256\2\2")
        buf.write("\u17a0\u17a2\3\2\2\2\u17a1\u176e\3\2\2\2\u17a1\u1771\3")
        buf.write("\2\2\2\u17a1\u1774\3\2\2\2\u17a1\u1777\3\2\2\2\u17a1\u177b")
        buf.write("\3\2\2\2\u17a1\u177e\3\2\2\2\u17a1\u1786\3\2\2\2\u17a1")
        buf.write("\u1789\3\2\2\2\u17a1\u178b\3\2\2\2\u17a1\u1791\3\2\2\2")
        buf.write("\u17a1\u1797\3\2\2\2\u17a2\u17a5\3\2\2\2\u17a3\u17a1\3")
        buf.write("\2\2\2\u17a3\u17a4\3\2\2\2\u17a4\u024f\3\2\2\2\u17a5\u17a3")
        buf.write("\3\2\2\2\u17a6\u17af\5\u01ec\u00f7\2\u17a7\u17a8\7\u00a8")
        buf.write("\2\2\u17a8\u17a9\7\u0255\2\2\u17a9\u17aa\5\u022c\u0117")
        buf.write("\2\u17aa\u17ab\7\u025d\2\2\u17ab\u17ac\5\u01ea\u00f6\2")
        buf.write("\u17ac\u17ad\7\u0256\2\2\u17ad\u17af\3\2\2\2\u17ae\u17a6")
        buf.write("\3\2\2\2\u17ae\u17a7\3\2\2\2\u17af\u0251\3\2\2\2\u17b0")
        buf.write("\u17b9\5\u01ea\u00f6\2\u17b1\u17b2\7\u00a8\2\2\u17b2\u17b3")
        buf.write("\7\u0255\2\2\u17b3\u17b4\5\u022c\u0117\2\u17b4\u17b5\7")
        buf.write("\u025d\2\2\u17b5\u17b6\5\u01ea\u00f6\2\u17b6\u17b7\7\u0256")
        buf.write("\2\2\u17b7\u17b9\3\2\2\2\u17b8\u17b0\3\2\2\2\u17b8\u17b1")
        buf.write("\3\2\2\2\u17b9\u0253\3\2\2\2\u17ba\u17bb\7\u0255\2\2\u17bb")
        buf.write("\u17bc\5\u024c\u0127\2\u17bc\u17bd\7\u024f\2\2\u17bd\u17be")
        buf.write("\5\u024c\u0127\2\u17be\u17bf\7\u0256\2\2\u17bf\u17c0\7")
        buf.write("\u0173\2\2\u17c0\u17c1\7\u0255\2\2\u17c1\u17c2\5\u024c")
        buf.write("\u0127\2\u17c2\u17c3\7\u024f\2\2\u17c3\u17c4\5\u024c\u0127")
        buf.write("\2\u17c4\u17c5\7\u0256\2\2\u17c5\u0255\3\2\2\2\u17c6\u17d9")
        buf.write("\5\u0258\u012d\2\u17c7\u17c8\7\u0255\2\2\u17c8\u17c9\5")
        buf.write("\u0290\u0149\2\u17c9\u17cb\7\u0256\2\2\u17ca\u17cc\5\u021a")
        buf.write("\u010e\2\u17cb\u17ca\3\2\2\2\u17cb\u17cc\3\2\2\2\u17cc")
        buf.write("\u17d9\3\2\2\2\u17cd\u17d9\5\u025e\u0130\2\u17ce\u17d9")
        buf.write("\7\u01a8\2\2\u17cf\u17d9\7\u0259\2\2\u17d0\u17d9\5\u0276")
        buf.write("\u013c\2\u17d1\u17d2\7\u0137\2\2\u17d2\u17d9\5\u028a\u0146")
        buf.write("\2\u17d3\u17d9\5\u0262\u0132\2\u17d4\u17d9\5\u0216\u010c")
        buf.write("\2\u17d5\u17d9\5\u0280\u0141\2\u17d6\u17d9\5\u0284\u0143")
        buf.write("\2\u17d7\u17d9\5\u0254\u012b\2\u17d8\u17c6\3\2\2\2\u17d8")
        buf.write("\u17c7\3\2\2\2\u17d8\u17cd\3\2\2\2\u17d8\u17ce\3\2\2\2")
        buf.write("\u17d8\u17cf\3\2\2\2\u17d8\u17d0\3\2\2\2\u17d8\u17d1\3")
        buf.write("\2\2\2\u17d8\u17d3\3\2\2\2\u17d8\u17d4\3\2\2\2\u17d8\u17d5")
        buf.write("\3\2\2\2\u17d8\u17d6\3\2\2\2\u17d8\u17d7\3\2\2\2\u17d9")
        buf.write("\u0257\3\2\2\2\u17da\u17de\5\u025a\u012e\2\u17db\u17de")
        buf.write("\5\u0154\u00ab\2\u17dc\u17de\5\u025c\u012f\2\u17dd\u17da")
        buf.write("\3\2\2\2\u17dd\u17db\3\2\2\2\u17dd\u17dc\3\2\2\2\u17de")
        buf.write("\u0259\3\2\2\2\u17df\u17e0\tT\2\2\u17e0\u025b\3\2\2\2")
        buf.write("\u17e1\u17e2\tU\2\2\u17e2\u025d\3\2\2\2\u17e3\u17e5\7")
        buf.write("\u0181\2\2\u17e4\u17e6\5\u024c\u0127\2\u17e5\u17e4\3\2")
        buf.write("\2\2\u17e5\u17e6\3\2\2\2\u17e6\u17ec\3\2\2\2\u17e7\u17e8")
        buf.write("\7\u01c0\2\2\u17e8\u17e9\5\u024c\u0127\2\u17e9\u17ea\7")
        buf.write("\u01b7\2\2\u17ea\u17eb\5\u024c\u0127\2\u17eb\u17ed\3\2")
        buf.write("\2\2\u17ec\u17e7\3\2\2\2\u17ed\u17ee\3\2\2\2\u17ee\u17ec")
        buf.write("\3\2\2\2\u17ee\u17ef\3\2\2\2\u17ef\u17f2\3\2\2\2\u17f0")
        buf.write("\u17f1\7\u0193\2\2\u17f1\u17f3\5\u024c\u0127\2\u17f2\u17f0")
        buf.write("\3\2\2\2\u17f2\u17f3\3\2\2\2\u17f3\u17f4\3\2\2\2\u17f4")
        buf.write("\u17f5\7\u0194\2\2\u17f5\u025f\3\2\2\2\u17f6\u17f7\tV")
        buf.write("\2\2\u17f7\u17f8\7\u0255\2\2\u17f8\u17f9\5\u024c\u0127")
        buf.write("\2\u17f9\u17fa\7\u017d\2\2\u17fa\u17fb\5\u0240\u0121\2")
        buf.write("\u17fb\u17fc\7\u0256\2\2\u17fc\u0261\3\2\2\2\u17fd\u17fe")
        buf.write("\5\u023c\u011f\2\u17fe\u180d\7\u0255\2\2\u17ff\u1801\5")
        buf.write("\u0288\u0145\2\u1800\u17ff\3\2\2\2\u1800\u1801\3\2\2\2")
        buf.write("\u1801\u1802\3\2\2\2\u1802\u1807\5\u0264\u0133\2\u1803")
        buf.write("\u1804\7\u024f\2\2\u1804\u1806\5\u0264\u0133\2\u1805\u1803")
        buf.write("\3\2\2\2\u1806\u1809\3\2\2\2\u1807\u1805\3\2\2\2\u1807")
        buf.write("\u1808\3\2\2\2\u1808\u180b\3\2\2\2\u1809\u1807\3\2\2\2")
        buf.write("\u180a\u180c\5\u02b4\u015b\2\u180b\u180a\3\2\2\2\u180b")
        buf.write("\u180c\3\2\2\2\u180c\u180e\3\2\2\2\u180d\u1800\3\2\2\2")
        buf.write("\u180d\u180e\3\2\2\2\u180e\u180f\3\2\2\2\u180f\u1816\7")
        buf.write("\u0256\2\2\u1810\u1811\7\u0125\2\2\u1811\u1812\7\u019c")
        buf.write("\2\2\u1812\u1813\7\u0255\2\2\u1813\u1814\5\u02b4\u015b")
        buf.write("\2\u1814\u1815\7\u0256\2\2\u1815\u1817\3\2\2\2\u1816\u1810")
        buf.write("\3\2\2\2\u1816\u1817\3\2\2\2\u1817\u1819\3\2\2\2\u1818")
        buf.write("\u181a\5\u0278\u013d\2\u1819\u1818\3\2\2\2\u1819\u181a")
        buf.write("\3\2\2\2\u181a\u1820\3\2\2\2\u181b\u181e\7\u00ad\2\2\u181c")
        buf.write("\u181f\5\u022c\u0117\2\u181d\u181f\5\u027a\u013e\2\u181e")
        buf.write("\u181c\3\2\2\2\u181e\u181d\3\2\2\2\u181f\u1821\3\2\2\2")
        buf.write("\u1820\u181b\3\2\2\2\u1820\u1821\3\2\2\2\u1821\u1829\3")
        buf.write("\2\2\2\u1822\u1829\5\u0268\u0135\2\u1823\u1829\5\u026a")
        buf.write("\u0136\2\u1824\u1829\5\u026c\u0137\2\u1825\u1829\5\u026e")
        buf.write("\u0138\2\u1826\u1829\5\u0270\u0139\2\u1827\u1829\5\u0272")
        buf.write("\u013a\2\u1828\u17fd\3\2\2\2\u1828\u1822\3\2\2\2\u1828")
        buf.write("\u1823\3\2\2\2\u1828\u1824\3\2\2\2\u1828\u1825\3\2\2\2")
        buf.write("\u1828\u1826\3\2\2\2\u1828\u1827\3\2\2\2\u1829\u0263\3")
        buf.write("\2\2\2\u182a\u182c\7\u01bf\2\2\u182b\u182a\3\2\2\2\u182b")
        buf.write("\u182c\3\2\2\2\u182c\u1830\3\2\2\2\u182d\u182e\5\u022c")
        buf.write("\u0117\2\u182e\u182f\5\u0266\u0134\2\u182f\u1831\3\2\2")
        buf.write("\2\u1830\u182d\3\2\2\2\u1830\u1831\3\2\2\2\u1831\u1832")
        buf.write("\3\2\2\2\u1832\u1833\5\u024c\u0127\2\u1833\u0265\3\2\2")
        buf.write("\2\u1834\u1835\tW\2\2\u1835\u0267\3\2\2\2\u1836\u1837")
        buf.write("\tX\2\2\u1837\u1838\7\u0255\2\2\u1838\u183d\5\u024c\u0127")
        buf.write("\2\u1839\u183a\7\u024f\2\2\u183a\u183c\5\u024c\u0127\2")
        buf.write("\u183b\u1839\3\2\2\2\u183c\u183f\3\2\2\2\u183d\u183b\3")
        buf.write("\2\2\2\u183d\u183e\3\2\2\2\u183e\u1840\3\2\2\2\u183f\u183d")
        buf.write("\3\2\2\2\u1840\u1841\7\u0256\2\2\u1841\u1850\3\2\2\2\u1842")
        buf.write("\u1843\7\u014c\2\2\u1843\u184c\7\u0255\2\2\u1844\u1849")
        buf.write("\5\u024c\u0127\2\u1845\u1846\7\u024f\2\2\u1846\u1848\5")
        buf.write("\u024c\u0127\2\u1847\u1845\3\2\2\2\u1848\u184b\3\2\2\2")
        buf.write("\u1849\u1847\3\2\2\2\u1849\u184a\3\2\2\2\u184a\u184d\3")
        buf.write("\2\2\2\u184b\u1849\3\2\2\2\u184c\u1844\3\2\2\2\u184c\u184d")
        buf.write("\3\2\2\2\u184d\u184e\3\2\2\2\u184e\u1850\7\u0256\2\2\u184f")
        buf.write("\u1836\3\2\2\2\u184f\u1842\3\2\2\2\u1850\u0269\3\2\2\2")
        buf.write("\u1851\u1852\7\u0138\2\2\u1852\u1855\7\u0255\2\2\u1853")
        buf.write("\u1856\5\u022c\u0117\2\u1854\u1856\5\u0154\u00ab\2\u1855")
        buf.write("\u1853\3\2\2\2\u1855\u1854\3\2\2\2\u1856\u1857\3\2\2\2")
        buf.write("\u1857\u1858\7\u019a\2\2\u1858\u1859\5\u024c\u0127\2\u1859")
        buf.write("\u185a\7\u0256\2\2\u185a\u026b\3\2\2\2\u185b\u1862\7\u0188")
        buf.write("\2\2\u185c\u1862\7\u0166\2\2\u185d\u1862\7\u018d\2\2\u185e")
        buf.write("\u1862\7\u01b3\2\2\u185f\u1862\7\u01bd\2\2\u1860\u1862")
        buf.write("\5\u0260\u0131\2\u1861\u185b\3\2\2\2\u1861\u185c\3\2\2")
        buf.write("\2\u1861\u185d\3\2\2\2\u1861\u185e\3\2\2\2\u1861\u185f")
        buf.write("\3\2\2\2\u1861\u1860\3\2\2\2\u1862\u026d\3\2\2\2\u1863")
        buf.write("\u1875\7\u0189\2\2\u1864\u1866\7\u018b\2\2\u1865\u1867")
        buf.write("\5\u0248\u0125\2\u1866\u1865\3\2\2\2\u1866\u1867\3\2\2")
        buf.write("\2\u1867\u1875\3\2\2\2\u1868\u186a\7\u018c\2\2\u1869\u186b")
        buf.write("\5\u0248\u0125\2\u186a\u1869\3\2\2\2\u186a\u186b\3\2\2")
        buf.write("\2\u186b\u1875\3\2\2\2\u186c\u186e\7\u01a5\2\2\u186d\u186f")
        buf.write("\5\u0248\u0125\2\u186e\u186d\3\2\2\2\u186e\u186f\3\2\2")
        buf.write("\2\u186f\u1875\3\2\2\2\u1870\u1872\7\u01a6\2\2\u1871\u1873")
        buf.write("\5\u0248\u0125\2\u1872\u1871\3\2\2\2\u1872\u1873\3\2\2")
        buf.write("\2\u1873\u1875\3\2\2\2\u1874\u1863\3\2\2\2\u1874\u1864")
        buf.write("\3\2\2\2\u1874\u1868\3\2\2\2\u1874\u186c\3\2\2\2\u1874")
        buf.write("\u1870\3\2\2\2\u1875\u026f\3\2\2\2\u1876\u1877\7\u0153")
        buf.write("\2\2\u1877\u1879\7\u0255\2\2\u1878\u187a\tY\2\2\u1879")
        buf.write("\u1878\3\2\2\2\u1879\u187a\3\2\2\2\u187a\u1887\3\2\2\2")
        buf.write("\u187b\u187c\5\u024c\u0127\2\u187c\u187d\7\u019a\2\2\u187d")
        buf.write("\u187e\5\u024c\u0127\2\u187e\u1888\3\2\2\2\u187f\u1881")
        buf.write("\7\u019a\2\2\u1880\u187f\3\2\2\2\u1880\u1881\3\2\2\2\u1881")
        buf.write("\u1882\3\2\2\2\u1882\u1885\5\u024c\u0127\2\u1883\u1884")
        buf.write("\7\u024f\2\2\u1884\u1886\5\u024c\u0127\2\u1885\u1883\3")
        buf.write("\2\2\2\u1885\u1886\3\2\2\2\u1886\u1888\3\2\2\2\u1887\u187b")
        buf.write("\3\2\2\2\u1887\u1880\3\2\2\2\u1888\u1889\3\2\2\2\u1889")
        buf.write("\u188a\7\u0256\2\2\u188a\u18ba\3\2\2\2\u188b\u188c\7\u014f")
        buf.write("\2\2\u188c\u188d\7\u0255\2\2\u188d\u1892\5\u024c\u0127")
        buf.write("\2\u188e\u188f\7\u024f\2\2\u188f\u1891\5\u024c\u0127\2")
        buf.write("\u1890\u188e\3\2\2\2\u1891\u1894\3\2\2\2\u1892\u1890\3")
        buf.write("\2\2\2\u1892\u1893\3\2\2\2\u1893\u1897\3\2\2\2\u1894\u1892")
        buf.write("\3\2\2\2\u1895\u1896\7\u019a\2\2\u1896\u1898\5\u024c\u0127")
        buf.write("\2\u1897\u1895\3\2\2\2\u1897\u1898\3\2\2\2\u1898\u189b")
        buf.write("\3\2\2\2\u1899\u189a\7\u0198\2\2\u189a\u189c\5\u024c\u0127")
        buf.write("\2\u189b\u1899\3\2\2\2\u189b\u189c\3\2\2\2\u189c\u189d")
        buf.write("\3\2\2\2\u189d\u189e\7\u0256\2\2\u189e\u18ba\3\2\2\2\u189f")
        buf.write("\u18a0\7\u0149\2\2\u18a0\u18a1\7\u0255\2\2\u18a1\u18a2")
        buf.write("\5\u024e\u0128\2\u18a2\u18a3\7\u019e\2\2\u18a3\u18a4\5")
        buf.write("\u024c\u0127\2\u18a4\u18a5\7\u0256\2\2\u18a5\u18ba\3\2")
        buf.write("\2\2\u18a6\u18a7\7\u0148\2\2\u18a7\u18a8\7\u0255\2\2\u18a8")
        buf.write("\u18a9\5\u024c\u0127\2\u18a9\u18aa\7\u01ae\2\2\u18aa\u18ab")
        buf.write("\5\u024c\u0127\2\u18ab\u18ac\7\u019a\2\2\u18ac\u18af\5")
        buf.write("\u024c\u0127\2\u18ad\u18ae\7\u0198\2\2\u18ae\u18b0\5\u024c")
        buf.write("\u0127\2\u18af\u18ad\3\2\2\2\u18af\u18b0\3\2\2\2\u18b0")
        buf.write("\u18b1\3\2\2\2\u18b1\u18b2\7\u0256\2\2\u18b2\u18ba\3\2")
        buf.write("\2\2\u18b3\u18b4\7\u0163\2\2\u18b4\u18b5\7\u0198\2\2\u18b5")
        buf.write("\u18b6\7\u0255\2\2\u18b6\u18b7\5\u024c\u0127\2\u18b7\u18b8")
        buf.write("\7\u0256\2\2\u18b8\u18ba\3\2\2\2\u18b9\u1876\3\2\2\2\u18b9")
        buf.write("\u188b\3\2\2\2\u18b9\u189f\3\2\2\2\u18b9\u18a6\3\2\2\2")
        buf.write("\u18b9\u18b3\3\2\2\2\u18ba\u0271\3\2\2\2\u18bb\u18bc\7")
        buf.write("\u0158\2\2\u18bc\u18bd\7\u0255\2\2\u18bd\u18be\7\u0095")
        buf.write("\2\2\u18be\u18d4\5\u022c\u0117\2\u18bf\u18c0\7\u024f\2")
        buf.write("\2\u18c0\u18c1\7\u0156\2\2\u18c1\u18c2\7\u0255\2\2\u18c2")
        buf.write("\u18c5\5\u024c\u0127\2\u18c3\u18c4\7\u017d\2\2\u18c4\u18c6")
        buf.write("\5\u022c\u0117\2\u18c5\u18c3\3\2\2\2\u18c5\u18c6\3\2\2")
        buf.write("\2\u18c6\u18cf\3\2\2\2\u18c7\u18c8\7\u024f\2\2\u18c8\u18cb")
        buf.write("\5\u024c\u0127\2\u18c9\u18ca\7\u017d\2\2\u18ca\u18cc\5")
        buf.write("\u022c\u0117\2\u18cb\u18c9\3\2\2\2\u18cb\u18cc\3\2\2\2")
        buf.write("\u18cc\u18ce\3\2\2\2\u18cd\u18c7\3\2\2\2\u18ce\u18d1\3")
        buf.write("\2\2\2\u18cf\u18cd\3\2\2\2\u18cf\u18d0\3\2\2\2\u18d0\u18d2")
        buf.write("\3\2\2\2\u18d1\u18cf\3\2\2\2\u18d2\u18d3\7\u0256\2\2\u18d3")
        buf.write("\u18d5\3\2\2\2\u18d4\u18bf\3\2\2\2\u18d4\u18d5\3\2\2\2")
        buf.write("\u18d5\u18da\3\2\2\2\u18d6\u18d7\7\u024f\2\2\u18d7\u18d9")
        buf.write("\5\u024c\u0127\2\u18d8\u18d6\3\2\2\2\u18d9\u18dc\3\2\2")
        buf.write("\2\u18da\u18d8\3\2\2\2\u18da\u18db\3\2\2\2\u18db\u18dd")
        buf.write("\3\2\2\2\u18dc\u18da\3\2\2\2\u18dd\u18de\7\u0256\2\2\u18de")
        buf.write("\u195d\3\2\2\2\u18df\u18e0\7\u015a\2\2\u18e0\u18e1\7\u0255")
        buf.write("\2\2\u18e1\u18e4\5\u024c\u0127\2\u18e2\u18e3\7\u017d\2")
        buf.write("\2\u18e3\u18e5\5\u022c\u0117\2\u18e4\u18e2\3\2\2\2\u18e4")
        buf.write("\u18e5\3\2\2\2\u18e5\u18ee\3\2\2\2\u18e6\u18e7\7\u024f")
        buf.write("\2\2\u18e7\u18ea\5\u024c\u0127\2\u18e8\u18e9\7\u017d\2")
        buf.write("\2\u18e9\u18eb\5\u022c\u0117\2\u18ea\u18e8\3\2\2\2\u18ea")
        buf.write("\u18eb\3\2\2\2\u18eb\u18ed\3\2\2\2\u18ec\u18e6\3\2\2\2")
        buf.write("\u18ed\u18f0\3\2\2\2\u18ee\u18ec\3\2\2\2\u18ee\u18ef\3")
        buf.write("\2\2\2\u18ef\u18f1\3\2\2\2\u18f0\u18ee\3\2\2\2\u18f1\u18f2")
        buf.write("\7\u0256\2\2\u18f2\u195d\3\2\2\2\u18f3\u18f4\7\u015d\2")
        buf.write("\2\u18f4\u18f5\7\u0255\2\2\u18f5\u18f6\7\u0095\2\2\u18f6")
        buf.write("\u18f9\5\u022c\u0117\2\u18f7\u18f8\7\u024f\2\2\u18f8\u18fa")
        buf.write("\5\u024c\u0127\2\u18f9\u18f7\3\2\2\2\u18f9\u18fa\3\2\2")
        buf.write("\2\u18fa\u18fb\3\2\2\2\u18fb\u18fc\7\u0256\2\2\u18fc\u195d")
        buf.write("\3\2\2\2\u18fd\u18fe\7\u015e\2\2\u18fe\u18ff\7\u0255\2")
        buf.write("\2\u18ff\u1900\5\u024c\u0127\2\u1900\u1901\7\u024f\2\2")
        buf.write("\u1901\u1905\7\u0120\2\2\u1902\u1906\5\u024c\u0127\2\u1903")
        buf.write("\u1904\7\u009d\2\2\u1904\u1906\7\u011e\2\2\u1905\u1902")
        buf.write("\3\2\2\2\u1905\u1903\3\2\2\2\u1906\u190f\3\2\2\2\u1907")
        buf.write("\u1908\7\u024f\2\2\u1908\u190d\7\u00f5\2\2\u1909\u190e")
        buf.write("\7\u012c\2\2\u190a\u190e\7\u009d\2\2\u190b\u190c\7\u009d")
        buf.write("\2\2\u190c\u190e\7\u011e\2\2\u190d\u1909\3\2\2\2\u190d")
        buf.write("\u190a\3\2\2\2\u190d\u190b\3\2\2\2\u190e\u1910\3\2\2\2")
        buf.write("\u190f\u1907\3\2\2\2\u190f\u1910\3\2\2\2\u1910\u1911\3")
        buf.write("\2\2\2\u1911\u1912\7\u0256\2\2\u1912\u195d\3\2\2\2\u1913")
        buf.write("\u1914\7\u0159\2\2\u1914\u1915\7\u0255\2\2\u1915\u1916")
        buf.write("\5\u024c\u0127\2\u1916\u1919\7\u00b5\2\2\u1917\u1918\7")
        buf.write("\26\2\2\u1918\u191a\7\u00ca\2\2\u1919\u1917\3\2\2\2\u1919")
        buf.write("\u191a\3\2\2\2\u191a\u191b\3\2\2\2\u191b\u191e\5\u024c")
        buf.write("\u0127\2\u191c\u191d\7\26\2\2\u191d\u191f\7\u00ca\2\2")
        buf.write("\u191e\u191c\3\2\2\2\u191e\u191f\3\2\2\2\u191f\u1920\3")
        buf.write("\2\2\2\u1920\u1921\7\u0256\2\2\u1921\u195d\3\2\2\2\u1922")
        buf.write("\u1923\7\u015c\2\2\u1923\u1924\7\u0255\2\2\u1924\u1925")
        buf.write("\t*\2\2\u1925\u1926\5\u024c\u0127\2\u1926\u1927\7\u0256")
        buf.write("\2\2\u1927\u195d\3\2\2\2\u1928\u1929\7\u015f\2\2\u1929")
        buf.write("\u192a\7\u0255\2\2\u192a\u192b\t*\2\2\u192b\u192c\5\u024c")
        buf.write("\u0127\2\u192c\u192d\7\u017d\2\2\u192d\u192e\5\u0240\u0121")
        buf.write("\2\u192e\u192f\7\u0256\2\2\u192f\u195d\3\2\2\2\u1930\u1931")
        buf.write("\7\u0160\2\2\u1931\u1944\7\u0255\2\2\u1932\u1933\7\u015b")
        buf.write("\2\2\u1933\u1934\7\u0255\2\2\u1934\u1935\5\u024c\u0127")
        buf.write("\2\u1935\u1936\7\u017d\2\2\u1936\u193e\5\u022c\u0117\2")
        buf.write("\u1937\u1938\7\u024f\2\2\u1938\u1939\5\u024c\u0127\2\u1939")
        buf.write("\u193a\7\u017d\2\2\u193a\u193b\5\u022c\u0117\2\u193b\u193d")
        buf.write("\3\2\2\2\u193c\u1937\3\2\2\2\u193d\u1940\3\2\2\2\u193e")
        buf.write("\u193c\3\2\2\2\u193e\u193f\3\2\2\2\u193f\u1941\3\2\2\2")
        buf.write("\u1940\u193e\3\2\2\2\u1941\u1942\7\u0256\2\2\u1942\u1943")
        buf.write("\7\u024f\2\2\u1943\u1945\3\2\2\2\u1944\u1932\3\2\2\2\u1944")
        buf.write("\u1945\3\2\2\2\u1945\u1946\3\2\2\2\u1946\u1947\5\u024c")
        buf.write("\u0127\2\u1947\u194a\7\u00b5\2\2\u1948\u1949\7\26\2\2")
        buf.write("\u1949\u194b\7\u00ca\2\2\u194a\u1948\3\2\2\2\u194a\u194b")
        buf.write("\3\2\2\2\u194b\u194c\3\2\2\2\u194c\u194f\5\u024c\u0127")
        buf.write("\2\u194d\u194e\7\26\2\2\u194e\u1950\7\u00ca\2\2\u194f")
        buf.write("\u194d\3\2\2\2\u194f\u1950\3\2\2\2\u1950\u1951\3\2\2\2")
        buf.write("\u1951\u1952\7#\2\2\u1952\u1957\5\u0274\u013b\2\u1953")
        buf.write("\u1954\7\u024f\2\2\u1954\u1956\5\u0274\u013b\2\u1955\u1953")
        buf.write("\3\2\2\2\u1956\u1959\3\2\2\2\u1957\u1955\3\2\2\2\u1957")
        buf.write("\u1958\3\2\2\2\u1958\u195a\3\2\2\2\u1959\u1957\3\2\2\2")
        buf.write("\u195a\u195b\7\u0256\2\2\u195b\u195d\3\2\2\2\u195c\u18bb")
        buf.write("\3\2\2\2\u195c\u18df\3\2\2\2\u195c\u18f3\3\2\2\2\u195c")
        buf.write("\u18fd\3\2\2\2\u195c\u1913\3\2\2\2\u195c\u1922\3\2\2\2")
        buf.write("\u195c\u1928\3\2\2\2\u195c\u1930\3\2\2\2\u195d\u0273\3")
        buf.write("\2\2\2\u195e\u1970\5\u022c\u0117\2\u195f\u1962\5\u0240")
        buf.write("\u0121\2\u1960\u1961\7\u0206\2\2\u1961\u1963\5\u024c\u0127")
        buf.write("\2\u1962\u1960\3\2\2\2\u1962\u1963\3\2\2\2\u1963\u1966")
        buf.write("\3\2\2\2\u1964\u1965\7\u018e\2\2\u1965\u1967\5\u024c\u0127")
        buf.write("\2\u1966\u1964\3\2\2\2\u1966\u1967\3\2\2\2\u1967\u196c")
        buf.write("\3\2\2\2\u1968\u196a\7\u01a7\2\2\u1969\u1968\3\2\2\2\u1969")
        buf.write("\u196a\3\2\2\2\u196a\u196b\3\2\2\2\u196b\u196d\7\u01a8")
        buf.write("\2\2\u196c\u1969\3\2\2\2\u196c\u196d\3\2\2\2\u196d\u1971")
        buf.write("\3\2\2\2\u196e\u196f\7\u0198\2\2\u196f\u1971\7\u00ab\2")
        buf.write("\2\u1970\u195f\3\2\2\2\u1970\u196e\3\2\2\2\u1971\u0275")
        buf.write("\3\2\2\2\u1972\u1973\tZ\2\2\u1973\u1976\7\u0255\2\2\u1974")
        buf.write("\u1977\5\u024c\u0127\2\u1975\u1977\5\u0290\u0149\2\u1976")
        buf.write("\u1974\3\2\2\2\u1976\u1975\3\2\2\2\u1977\u1978\3\2\2\2")
        buf.write("\u1978\u1979\7\u0256\2\2\u1979\u0277\3\2\2\2\u197a\u197b")
        buf.write("\7Z\2\2\u197b\u197c\7\u0255\2\2\u197c\u197d\7\u01c1\2")
        buf.write("\2\u197d\u197e\5\u024c\u0127\2\u197e\u197f\7\u0256\2\2")
        buf.write("\u197f\u0279\3\2\2\2\u1980\u1982\7\u0255\2\2\u1981\u1983")
        buf.write("\5\u022c\u0117\2\u1982\u1981\3\2\2\2\u1982\u1983\3\2\2")
        buf.write("\2\u1983\u1985\3\2\2\2\u1984\u1986\5\u0210\u0109\2\u1985")
        buf.write("\u1984\3\2\2\2\u1985\u1986\3\2\2\2\u1986\u1988\3\2\2\2")
        buf.write("\u1987\u1989\5\u02b4\u015b\2\u1988\u1987\3\2\2\2\u1988")
        buf.write("\u1989\3\2\2\2\u1989\u198b\3\2\2\2\u198a\u198c\5\u027c")
        buf.write("\u013f\2\u198b\u198a\3\2\2\2\u198b\u198c\3\2\2\2\u198c")
        buf.write("\u198d\3\2\2\2\u198d\u198e\7\u0256\2\2\u198e\u027b\3\2")
        buf.write("\2\2\u198f\u1996\t[\2\2\u1990\u1997\5\u027e\u0140\2\u1991")
        buf.write("\u1992\7\u012e\2\2\u1992\u1993\5\u027e\u0140\2\u1993\u1994")
        buf.write("\7\u017a\2\2\u1994\u1995\5\u027e\u0140\2\u1995\u1997\3")
        buf.write("\2\2\2\u1996\u1990\3\2\2\2\u1996\u1991\3\2\2\2\u1997\u19a1")
        buf.write("\3\2\2\2\u1998\u199f\7Q\2\2\u1999\u199a\7\63\2\2\u199a")
        buf.write("\u19a0\7\u014c\2\2\u199b\u19a0\7\u019c\2\2\u199c\u19a0")
        buf.write("\7\u0109\2\2\u199d\u199e\7\u009d\2\2\u199e\u19a0\7\u00ac")
        buf.write("\2\2\u199f\u1999\3\2\2\2\u199f\u199b\3\2\2\2\u199f\u199c")
        buf.write("\3\2\2\2\u199f\u199d\3\2\2\2\u19a0\u19a2\3\2\2\2\u19a1")
        buf.write("\u1998\3\2\2\2\u19a1\u19a2\3\2\2\2\u19a2\u027d\3\2\2\2")
        buf.write("\u19a3\u19a4\5\u024c\u0127\2\u19a4\u19a5\t\\\2\2\u19a5")
        buf.write("\u19a9\3\2\2\2\u19a6\u19a7\7\63\2\2\u19a7\u19a9\7\u014c")
        buf.write("\2\2\u19a8\u19a3\3\2\2\2\u19a8\u19a6\3\2\2\2\u19a9\u027f")
        buf.write("\3\2\2\2\u19aa\u19ad\7\u017c\2\2\u19ab\u19ae\5\u0282\u0142")
        buf.write("\2\u19ac\u19ae\5\u028a\u0146\2\u19ad\u19ab\3\2\2\2\u19ad")
        buf.write("\u19ac\3\2\2\2\u19ae\u0281\3\2\2\2\u19af\u19be\7\u0261")
        buf.write("\2\2\u19b0\u19b3\5\u024c\u0127\2\u19b1\u19b3\5\u0282\u0142")
        buf.write("\2\u19b2\u19b0\3\2\2\2\u19b2\u19b1\3\2\2\2\u19b3\u19bb")
        buf.write("\3\2\2\2\u19b4\u19b7\7\u024f\2\2\u19b5\u19b8\5\u024c\u0127")
        buf.write("\2\u19b6\u19b8\5\u0282\u0142\2\u19b7\u19b5\3\2\2\2\u19b7")
        buf.write("\u19b6\3\2\2\2\u19b8\u19ba\3\2\2\2\u19b9\u19b4\3\2\2\2")
        buf.write("\u19ba\u19bd\3\2\2\2\u19bb\u19b9\3\2\2\2\u19bb\u19bc\3")
        buf.write("\2\2\2\u19bc\u19bf\3\2\2\2\u19bd\u19bb\3\2\2\2\u19be\u19b2")
        buf.write("\3\2\2\2\u19be\u19bf\3\2\2\2\u19bf\u19c0\3\2\2\2\u19c0")
        buf.write("\u19c1\7\u0262\2\2\u19c1\u0283\3\2\2\2\u19c2\u19c3\5\u0240")
        buf.write("\u0121\2\u19c3\u19c4\5\u0154\u00ab\2\u19c4\u19cc\3\2\2")
        buf.write("\2\u19c5\u19c6\7\u013f\2\2\u19c6\u19c7\5\u0154\u00ab\2")
        buf.write("\u19c7\u19c9\5\u0246\u0124\2\u19c8\u19ca\5\u0248\u0125")
        buf.write("\2\u19c9\u19c8\3\2\2\2\u19c9\u19ca\3\2\2\2\u19ca\u19cc")
        buf.write("\3\2\2\2\u19cb\u19c2\3\2\2\2\u19cb\u19c5\3\2\2\2\u19cc")
        buf.write("\u0285\3\2\2\2\u19cd\u19d4\5\u022c\u0117\2\u19ce\u19cf")
        buf.write("\7\u025d\2\2\u19cf\u19d2\5\u022c\u0117\2\u19d0\u19d1\7")
        buf.write("\u025d\2\2\u19d1\u19d3\5\u022c\u0117\2\u19d2\u19d0\3\2")
        buf.write("\2\2\u19d2\u19d3\3\2\2\2\u19d3\u19d5\3\2\2\2\u19d4\u19ce")
        buf.write("\3\2\2\2\u19d4\u19d5\3\2\2\2\u19d5\u0287\3\2\2\2\u19d6")
        buf.write("\u19d7\t]\2\2\u19d7\u0289\3\2\2\2\u19d8\u19d9\7\u0255")
        buf.write("\2\2\u19d9\u19da\5\u028c\u0147\2\u19da\u19db\7\u0256\2")
        buf.write("\2\u19db\u028b\3\2\2\2\u19dc\u19de\5\u0292\u014a\2\u19dd")
        buf.write("\u19dc\3\2\2\2\u19dd\u19de\3\2\2\2\u19de\u19df\3\2\2\2")
        buf.write("\u19df\u19e3\5\u0296\u014c\2\u19e0\u19e2\5\u028e\u0148")
        buf.write("\2\u19e1\u19e0\3\2\2\2\u19e2\u19e5\3\2\2\2\u19e3\u19e1")
        buf.write("\3\2\2\2\u19e3\u19e4\3\2\2\2\u19e4\u028d\3\2\2\2\u19e5")
        buf.write("\u19e3\3\2\2\2\u19e6\u1a17\5\u02b4\u015b\2\u19e7\u19ea")
        buf.write("\7\u01a4\2\2\u19e8\u19eb\5\u024c\u0127\2\u19e9\u19eb\7")
        buf.write("\u0178\2\2\u19ea\u19e8\3\2\2\2\u19ea\u19e9\3\2\2\2\u19eb")
        buf.write("\u1a17\3\2\2\2\u19ec\u19ed\7\u01a9\2\2\u19ed\u19ef\5\u024c")
        buf.write("\u0127\2\u19ee\u19f0\t^\2\2\u19ef\u19ee\3\2\2\2\u19ef")
        buf.write("\u19f0\3\2\2\2\u19f0\u1a17\3\2\2\2\u19f1\u19f2\7\u0197")
        buf.write("\2\2\u19f2\u19f4\t_\2\2\u19f3\u19f5\5\u024c\u0127\2\u19f4")
        buf.write("\u19f3\3\2\2\2\u19f4\u19f5\3\2\2\2\u19f5\u19f6\3\2\2\2")
        buf.write("\u19f6\u19fa\t^\2\2\u19f7\u19fb\7\u01ab\2\2\u19f8\u19f9")
        buf.write("\7\u01c3\2\2\u19f9\u19fb\7\u0109\2\2\u19fa\u19f7\3\2\2")
        buf.write("\2\u19fa\u19f8\3\2\2\2\u19fa\u19fb\3\2\2\2\u19fb\u1a17")
        buf.write("\3\2\2\2\u19fc\u1a04\7\u0198\2\2\u19fd\u1a05\7\u0119\2")
        buf.write("\2\u19fe\u19ff\7\u009d\2\2\u19ff\u1a00\7}\2\2\u1a00\u1a05")
        buf.write("\7\u0119\2\2\u1a01\u1a05\7\u00ee\2\2\u1a02\u1a03\7}\2")
        buf.write("\2\u1a03\u1a05\7\u00ee\2\2\u1a04\u19fd\3\2\2\2\u1a04\u19fe")
        buf.write("\3\2\2\2\u1a04\u1a01\3\2\2\2\u1a04\u1a02\3\2\2\2\u1a05")
        buf.write("\u1a0f\3\2\2\2\u1a06\u1a07\7\u00a4\2\2\u1a07\u1a0c\5\u0286")
        buf.write("\u0144\2\u1a08\u1a09\7\u024f\2\2\u1a09\u1a0b\5\u0286\u0144")
        buf.write("\2\u1a0a\u1a08\3\2\2\2\u1a0b\u1a0e\3\2\2\2\u1a0c\u1a0a")
        buf.write("\3\2\2\2\u1a0c\u1a0d\3\2\2\2\u1a0d\u1a10\3\2\2\2\u1a0e")
        buf.write("\u1a0c\3\2\2\2\u1a0f\u1a06\3\2\2\2\u1a0f\u1a10\3\2\2\2")
        buf.write("\u1a10\u1a14\3\2\2\2\u1a11\u1a15\7\u00a1\2\2\u1a12\u1a13")
        buf.write("\7\u00f1\2\2\u1a13\u1a15\7\u0089\2\2\u1a14\u1a11\3\2\2")
        buf.write("\2\u1a14\u1a12\3\2\2\2\u1a14\u1a15\3\2\2\2\u1a15\u1a17")
        buf.write("\3\2\2\2\u1a16\u19e6\3\2\2\2\u1a16\u19e7\3\2\2\2\u1a16")
        buf.write("\u19ec\3\2\2\2\u1a16\u19f1\3\2\2\2\u1a16\u19fc\3\2\2\2")
        buf.write("\u1a17\u028f\3\2\2\2\u1a18\u1a1a\5\u0292\u014a\2\u1a19")
        buf.write("\u1a18\3\2\2\2\u1a19\u1a1a\3\2\2\2\u1a1a\u1a1b\3\2\2\2")
        buf.write("\u1a1b\u1a1f\5\u0298\u014d\2\u1a1c\u1a1e\5\u028e\u0148")
        buf.write("\2\u1a1d\u1a1c\3\2\2\2\u1a1e\u1a21\3\2\2\2\u1a1f\u1a1d")
        buf.write("\3\2\2\2\u1a1f\u1a20\3\2\2\2\u1a20\u0291\3\2\2\2\u1a21")
        buf.write("\u1a1f\3\2\2\2\u1a22\u1a24\7\u01c3\2\2\u1a23\u1a25\7\u00c9")
        buf.write("\2\2\u1a24\u1a23\3\2\2\2\u1a24\u1a25\3\2\2\2\u1a25\u1a26")
        buf.write("\3\2\2\2\u1a26\u1a2b\5\u0294\u014b\2\u1a27\u1a28\7\u024f")
        buf.write("\2\2\u1a28\u1a2a\5\u0294\u014b\2\u1a29\u1a27\3\2\2\2\u1a2a")
        buf.write("\u1a2d\3\2\2\2\u1a2b\u1a29\3\2\2\2\u1a2b\u1a2c\3\2\2\2")
        buf.write("\u1a2c\u0293\3\2\2\2\u1a2d\u1a2b\3\2\2\2\u1a2e\u1a3a\5")
        buf.write("\u022c\u0117\2\u1a2f\u1a30\7\u0255\2\2\u1a30\u1a35\5\u022c")
        buf.write("\u0117\2\u1a31\u1a32\7\u024f\2\2\u1a32\u1a34\5\u022c\u0117")
        buf.write("\2\u1a33\u1a31\3\2\2\2\u1a34\u1a37\3\2\2\2\u1a35\u1a33")
        buf.write("\3\2\2\2\u1a35\u1a36\3\2\2\2\u1a36\u1a38\3\2\2\2\u1a37")
        buf.write("\u1a35\3\2\2\2\u1a38\u1a39\7\u0256\2\2\u1a39\u1a3b\3\2")
        buf.write("\2\2\u1a3a\u1a2f\3\2\2\2\u1a3a\u1a3b\3\2\2\2\u1a3b\u1a3c")
        buf.write("\3\2\2\2\u1a3c\u1a41\7\u017d\2\2\u1a3d\u1a3f\7\u01a7\2")
        buf.write("\2\u1a3e\u1a3d\3\2\2\2\u1a3e\u1a3f\3\2\2\2\u1a3f\u1a40")
        buf.write("\3\2\2\2\u1a40\u1a42\7\u008d\2\2\u1a41\u1a3e\3\2\2\2\u1a41")
        buf.write("\u1a42\3\2\2\2\u1a42\u1a43\3\2\2\2\u1a43\u1a44\7\u0255")
        buf.write("\2\2\u1a44\u1a45\5\20\t\2\u1a45\u1a46\7\u0256\2\2\u1a46")
        buf.write("\u0295\3\2\2\2\u1a47\u1a48\b\u014c\1\2\u1a48\u1a49\7\u0255")
        buf.write("\2\2\u1a49\u1a4a\5\u028c\u0147\2\u1a4a\u1a4b\7\u0256\2")
        buf.write("\2\u1a4b\u1a4e\3\2\2\2\u1a4c\u1a4e\5\u029a\u014e\2\u1a4d")
        buf.write("\u1a47\3\2\2\2\u1a4d\u1a4c\3\2\2\2\u1a4e\u1a57\3\2\2\2")
        buf.write("\u1a4f\u1a50\f\4\2\2\u1a50\u1a52\t`\2\2\u1a51\u1a53\5")
        buf.write("\u0288\u0145\2\u1a52\u1a51\3\2\2\2\u1a52\u1a53\3\2\2\2")
        buf.write("\u1a53\u1a54\3\2\2\2\u1a54\u1a56\5\u0296\u014c\5\u1a55")
        buf.write("\u1a4f\3\2\2\2\u1a56\u1a59\3\2\2\2\u1a57\u1a55\3\2\2\2")
        buf.write("\u1a57\u1a58\3\2\2\2\u1a58\u0297\3\2\2\2\u1a59\u1a57\3")
        buf.write("\2\2\2\u1a5a\u1a5b\5\u0296\u014c\2\u1a5b\u1a5d\t`\2\2")
        buf.write("\u1a5c\u1a5e\5\u0288\u0145\2\u1a5d\u1a5c\3\2\2\2\u1a5d")
        buf.write("\u1a5e\3\2\2\2\u1a5e\u1a64\3\2\2\2\u1a5f\u1a65\5\u029a")
        buf.write("\u014e\2\u1a60\u1a61\7\u0255\2\2\u1a61\u1a62\5\u028c\u0147")
        buf.write("\2\u1a62\u1a63\7\u0256\2\2\u1a63\u1a65\3\2\2\2\u1a64\u1a5f")
        buf.write("\3\2\2\2\u1a64\u1a60\3\2\2\2\u1a65\u1a68\3\2\2\2\u1a66")
        buf.write("\u1a68\5\u029a\u014e\2\u1a67\u1a5a\3\2\2\2\u1a67\u1a66")
        buf.write("\3\2\2\2\u1a68\u0299\3\2\2\2\u1a69\u1a79\7\u01b2\2\2\u1a6a")
        buf.write("\u1a77\5\u0288\u0145\2\u1a6b\u1a6c\7\u01aa\2\2\u1a6c\u1a6d")
        buf.write("\7\u0255\2\2\u1a6d\u1a72\5\u024c\u0127\2\u1a6e\u1a6f\7")
        buf.write("\u024f\2\2\u1a6f\u1a71\5\u024c\u0127\2\u1a70\u1a6e\3\2")
        buf.write("\2\2\u1a71\u1a74\3\2\2\2\u1a72\u1a70\3\2\2\2\u1a72\u1a73")
        buf.write("\3\2\2\2\u1a73\u1a75\3\2\2\2\u1a74\u1a72\3\2\2\2\u1a75")
        buf.write("\u1a76\7\u0256\2\2\u1a76\u1a78\3\2\2\2\u1a77\u1a6b\3\2")
        buf.write("\2\2\u1a77\u1a78\3\2\2\2\u1a78\u1a7a\3\2\2\2\u1a79\u1a6a")
        buf.write("\3\2\2\2\u1a79\u1a7a\3\2\2\2\u1a7a\u1a7c\3\2\2\2\u1a7b")
        buf.write("\u1a7d\5\u029c\u014f\2\u1a7c\u1a7b\3\2\2\2\u1a7c\u1a7d")
        buf.write("\3\2\2\2\u1a7d\u1a7f\3\2\2\2\u1a7e\u1a80\5\u02a0\u0151")
        buf.write("\2\u1a7f\u1a7e\3\2\2\2\u1a7f\u1a80\3\2\2\2\u1a80\u1a8a")
        buf.write("\3\2\2\2\u1a81\u1a82\7\u019a\2\2\u1a82\u1a87\5\u02a2\u0152")
        buf.write("\2\u1a83\u1a84\7\u024f\2\2\u1a84\u1a86\5\u02a2\u0152\2")
        buf.write("\u1a85\u1a83\3\2\2\2\u1a86\u1a89\3\2\2\2\u1a87\u1a85\3")
        buf.write("\2\2\2\u1a87\u1a88\3\2\2\2\u1a88\u1a8b\3\2\2\2\u1a89\u1a87")
        buf.write("\3\2\2\2\u1a8a\u1a81\3\2\2\2\u1a8a\u1a8b\3\2\2\2\u1a8b")
        buf.write("\u1a8e\3\2\2\2\u1a8c\u1a8d\7\u01c1\2\2\u1a8d\u1a8f\5\u024c")
        buf.write("\u0127\2\u1a8e\u1a8c\3\2\2\2\u1a8e\u1a8f\3\2\2\2\u1a8f")
        buf.write("\u1a91\3\2\2\2\u1a90\u1a92\5\u02aa\u0156\2\u1a91\u1a90")
        buf.write("\3\2\2\2\u1a91\u1a92\3\2\2\2\u1a92\u1a95\3\2\2\2\u1a93")
        buf.write("\u1a94\7\u019d\2\2\u1a94\u1a96\5\u024c\u0127\2\u1a95\u1a93")
        buf.write("\3\2\2\2\u1a95\u1a96\3\2\2\2\u1a96\u1aa5\3\2\2\2\u1a97")
        buf.write("\u1a98\7\u01c2\2\2\u1a98\u1a99\5\u022c\u0117\2\u1a99\u1a9a")
        buf.write("\7\u017d\2\2\u1a9a\u1aa2\5\u027a\u013e\2\u1a9b\u1a9c\7")
        buf.write("\u024f\2\2\u1a9c\u1a9d\5\u022c\u0117\2\u1a9d\u1a9e\7\u017d")
        buf.write("\2\2\u1a9e\u1a9f\5\u027a\u013e\2\u1a9f\u1aa1\3\2\2\2\u1aa0")
        buf.write("\u1a9b\3\2\2\2\u1aa1\u1aa4\3\2\2\2\u1aa2\u1aa0\3\2\2\2")
        buf.write("\u1aa2\u1aa3\3\2\2\2\u1aa3\u1aa6\3\2\2\2\u1aa4\u1aa2\3")
        buf.write("\2\2\2\u1aa5\u1a97\3\2\2\2\u1aa5\u1aa6\3\2\2\2\u1aa6\u1ab1")
        buf.write("\3\2\2\2\u1aa7\u1aa9\7\u01b6\2\2\u1aa8\u1aaa\7\u01ab\2")
        buf.write("\2\u1aa9\u1aa8\3\2\2\2\u1aa9\u1aaa\3\2\2\2\u1aaa\u1aab")
        buf.write("\3\2\2\2\u1aab\u1aad\5\u0286\u0144\2\u1aac\u1aae\7\u0259")
        buf.write("\2\2\u1aad\u1aac\3\2\2\2\u1aad\u1aae\3\2\2\2\u1aae\u1ab1")
        buf.write("\3\2\2\2\u1aaf\u1ab1\5\u02b0\u0159\2\u1ab0\u1a69\3\2\2")
        buf.write("\2\u1ab0\u1aa7\3\2\2\2\u1ab0\u1aaf\3\2\2\2\u1ab1\u029b")
        buf.write("\3\2\2\2\u1ab2\u1ab7\5\u029e\u0150\2\u1ab3\u1ab4\7\u024f")
        buf.write("\2\2\u1ab4\u1ab6\5\u029e\u0150\2\u1ab5\u1ab3\3\2\2\2\u1ab6")
        buf.write("\u1ab9\3\2\2\2\u1ab7\u1ab5\3\2\2\2\u1ab7\u1ab8\3\2\2\2")
        buf.write("\u1ab8\u029d\3\2\2\2\u1ab9\u1ab7\3\2\2\2\u1aba\u1abe\5")
        buf.write("\u024c\u0127\2\u1abb\u1abc\7\u017d\2\2\u1abc\u1abf\5\u0230")
        buf.write("\u0119\2\u1abd\u1abf\5\u022a\u0116\2\u1abe\u1abb\3\2\2")
        buf.write("\2\u1abe\u1abd\3\2\2\2\u1abe\u1abf\3\2\2\2\u1abf\u029f")
        buf.write("\3\2\2\2\u1ac0\u1ac2\7\u01a1\2\2\u1ac1\u1ac3\ta\2\2\u1ac2")
        buf.write("\u1ac1\3\2\2\2\u1ac2\u1ac3\3\2\2\2\u1ac3\u1ac5\3\2\2\2")
        buf.write("\u1ac4\u1ac6\7\u01b6\2\2\u1ac5\u1ac4\3\2\2\2\u1ac5\u1ac6")
        buf.write("\3\2\2\2\u1ac6\u1ac7\3\2\2\2\u1ac7\u1ac8\5\u0286\u0144")
        buf.write("\2\u1ac8\u02a1\3\2\2\2\u1ac9\u1aca\b\u0152\1\2\u1aca\u1acb")
        buf.write("\7\u0255\2\2\u1acb\u1acc\5\u02a2\u0152\2\u1acc\u1ace\7")
        buf.write("\u0256\2\2\u1acd\u1acf\5\u02a6\u0154\2\u1ace\u1acd\3\2")
        buf.write("\2\2\u1ace\u1acf\3\2\2\2\u1acf\u1ad2\3\2\2\2\u1ad0\u1ad2")
        buf.write("\5\u02a4\u0153\2\u1ad1\u1ac9\3\2\2\2\u1ad1\u1ad0\3\2\2")
        buf.write("\2\u1ad2\u1afe\3\2\2\2\u1ad3\u1ad4\f\7\2\2\u1ad4\u1ad5")
        buf.write("\7\u0165\2\2\u1ad5\u1ad6\7\u016d\2\2\u1ad6\u1afd\5\u02a2")
        buf.write("\u0152\b\u1ad7\u1ad8\f\4\2\2\u1ad8\u1ade\7\u0170\2\2\u1ad9")
        buf.write("\u1adf\7\u016a\2\2\u1ada\u1adc\tb\2\2\u1adb\u1add\7\u0172")
        buf.write("\2\2\u1adc\u1adb\3\2\2\2\u1adc\u1add\3\2\2\2\u1add\u1adf")
        buf.write("\3\2\2\2\u1ade\u1ad9\3\2\2\2\u1ade\u1ada\3\2\2\2\u1ade")
        buf.write("\u1adf\3\2\2\2\u1adf\u1ae0\3\2\2\2\u1ae0\u1ae1\7\u016d")
        buf.write("\2\2\u1ae1\u1afd\5\u02a2\u0152\5\u1ae2\u1ae8\f\6\2\2\u1ae3")
        buf.write("\u1ae9\7\u016a\2\2\u1ae4\u1ae6\tb\2\2\u1ae5\u1ae7\7\u0172")
        buf.write("\2\2\u1ae6\u1ae5\3\2\2\2\u1ae6\u1ae7\3\2\2\2\u1ae7\u1ae9")
        buf.write("\3\2\2\2\u1ae8\u1ae3\3\2\2\2\u1ae8\u1ae4\3\2\2\2\u1ae8")
        buf.write("\u1ae9\3\2\2\2\u1ae9\u1aea\3\2\2\2\u1aea\u1aeb\7\u016d")
        buf.write("\2\2\u1aeb\u1aec\5\u02a2\u0152\2\u1aec\u1aed\7\u01aa\2")
        buf.write("\2\u1aed\u1aee\5\u024c\u0127\2\u1aee\u1afd\3\2\2\2\u1aef")
        buf.write("\u1af5\f\5\2\2\u1af0\u1af6\7\u016a\2\2\u1af1\u1af3\tb")
        buf.write("\2\2\u1af2\u1af4\7\u0172\2\2\u1af3\u1af2\3\2\2\2\u1af3")
        buf.write("\u1af4\3\2\2\2\u1af4\u1af6\3\2\2\2\u1af5\u1af0\3\2\2\2")
        buf.write("\u1af5\u1af1\3\2\2\2\u1af5\u1af6\3\2\2\2\u1af6\u1af7\3")
        buf.write("\2\2\2\u1af7\u1af8\7\u016d\2\2\u1af8\u1af9\5\u02a2\u0152")
        buf.write("\2\u1af9\u1afa\7\u01be\2\2\u1afa\u1afb\5\u01f0\u00f9\2")
        buf.write("\u1afb\u1afd\3\2\2\2\u1afc\u1ad3\3\2\2\2\u1afc\u1ad7\3")
        buf.write("\2\2\2\u1afc\u1ae2\3\2\2\2\u1afc\u1aef\3\2\2\2\u1afd\u1b00")
        buf.write("\3\2\2\2\u1afe\u1afc\3\2\2\2\u1afe\u1aff\3\2\2\2\u1aff")
        buf.write("\u02a3\3\2\2\2\u1b00\u1afe\3\2\2\2\u1b01\u1b03\7\u01ab")
        buf.write("\2\2\u1b02\u1b01\3\2\2\2\u1b02\u1b03\3\2\2\2\u1b03\u1b04")
        buf.write("\3\2\2\2\u1b04\u1b06\5\u0286\u0144\2\u1b05\u1b07\7\u0259")
        buf.write("\2\2\u1b06\u1b05\3\2\2\2\u1b06\u1b07\3\2\2\2\u1b07\u1b09")
        buf.write("\3\2\2\2\u1b08\u1b0a\5\u02a6\u0154\2\u1b09\u1b08\3\2\2")
        buf.write("\2\u1b09\u1b0a\3\2\2\2\u1b0a\u1b1b\3\2\2\2\u1b0b\u1b0c")
        buf.write("\7\u0176\2\2\u1b0c\u1b0d\5\u022c\u0117\2\u1b0d\u1b0e\7")
        buf.write("\u0255\2\2\u1b0e\u1b13\5\u024c\u0127\2\u1b0f\u1b10\7\u024f")
        buf.write("\2\2\u1b10\u1b12\5\u024c\u0127\2\u1b11\u1b0f\3\2\2\2\u1b12")
        buf.write("\u1b15\3\2\2\2\u1b13\u1b11\3\2\2\2\u1b13\u1b14\3\2\2\2")
        buf.write("\u1b14\u1b16\3\2\2\2\u1b15\u1b13\3\2\2\2\u1b16\u1b19\7")
        buf.write("\u0256\2\2\u1b17\u1b18\7\u00d1\2\2\u1b18\u1b1a\5\u024c")
        buf.write("\u0127\2\u1b19\u1b17\3\2\2\2\u1b19\u1b1a\3\2\2\2\u1b1a")
        buf.write("\u1b1c\3\2\2\2\u1b1b\u1b0b\3\2\2\2\u1b1b\u1b1c\3\2\2\2")
        buf.write("\u1b1c\u1b70\3\2\2\2\u1b1d\u1b1f\7\u01a2\2\2\u1b1e\u1b1d")
        buf.write("\3\2\2\2\u1b1e\u1b1f\3\2\2\2\u1b1f\u1b20\3\2\2\2\u1b20")
        buf.write("\u1b21\5\u028a\u0146\2\u1b21\u1b22\5\u02a6\u0154\2\u1b22")
        buf.write("\u1b70\3\2\2\2\u1b23\u1b25\7\u01a2\2\2\u1b24\u1b23\3\2")
        buf.write("\2\2\u1b24\u1b25\3\2\2\2\u1b25\u1b26\3\2\2\2\u1b26\u1b29")
        buf.write("\5\u0262\u0132\2\u1b27\u1b28\7\u01c3\2\2\u1b28\u1b2a\7")
        buf.write("\u00ab\2\2\u1b29\u1b27\3\2\2\2\u1b29\u1b2a\3\2\2\2\u1b2a")
        buf.write("\u1b3f\3\2\2\2\u1b2b\u1b2c\7\u017d\2\2\u1b2c\u1b40\5\u02a8")
        buf.write("\u0155\2\u1b2d\u1b2f\7\u017d\2\2\u1b2e\u1b2d\3\2\2\2\u1b2e")
        buf.write("\u1b2f\3\2\2\2\u1b2f\u1b30\3\2\2\2\u1b30\u1b3d\5\u022c")
        buf.write("\u0117\2\u1b31\u1b32\7\u0255\2\2\u1b32\u1b37\5\u022c\u0117")
        buf.write("\2\u1b33\u1b34\7\u024f\2\2\u1b34\u1b36\5\u022c\u0117\2")
        buf.write("\u1b35\u1b33\3\2\2\2\u1b36\u1b39\3\2\2\2\u1b37\u1b35\3")
        buf.write("\2\2\2\u1b37\u1b38\3\2\2\2\u1b38\u1b3a\3\2\2\2\u1b39\u1b37")
        buf.write("\3\2\2\2\u1b3a\u1b3b\7\u0256\2\2\u1b3b\u1b3e\3\2\2\2\u1b3c")
        buf.write("\u1b3e\5\u02a8\u0155\2\u1b3d\u1b31\3\2\2\2\u1b3d\u1b3c")
        buf.write("\3\2\2\2\u1b3d\u1b3e\3\2\2\2\u1b3e\u1b40\3\2\2\2\u1b3f")
        buf.write("\u1b2b\3\2\2\2\u1b3f\u1b2e\3\2\2\2\u1b3f\u1b40\3\2\2\2")
        buf.write("\u1b40\u1b70\3\2\2\2\u1b41\u1b43\7\u01a2\2\2\u1b42\u1b41")
        buf.write("\3\2\2\2\u1b42\u1b43\3\2\2\2\u1b43\u1b44\3\2\2\2\u1b44")
        buf.write("\u1b45\7\u00de\2\2\u1b45\u1b46\7\u019a\2\2\u1b46\u1b47")
        buf.write("\7\u0255\2\2\u1b47\u1b4a\5\u0262\u0132\2\u1b48\u1b49\7")
        buf.write("\u017d\2\2\u1b49\u1b4b\5\u02a8\u0155\2\u1b4a\u1b48\3\2")
        buf.write("\2\2\u1b4a\u1b4b\3\2\2\2\u1b4b\u1b54\3\2\2\2\u1b4c\u1b4d")
        buf.write("\7\u024f\2\2\u1b4d\u1b50\5\u0262\u0132\2\u1b4e\u1b4f\7")
        buf.write("\u017d\2\2\u1b4f\u1b51\5\u02a8\u0155\2\u1b50\u1b4e\3\2")
        buf.write("\2\2\u1b50\u1b51\3\2\2\2\u1b51\u1b53\3\2\2\2\u1b52\u1b4c")
        buf.write("\3\2\2\2\u1b53\u1b56\3\2\2\2\u1b54\u1b52\3\2\2\2\u1b54")
        buf.write("\u1b55\3\2\2\2\u1b55\u1b57\3\2\2\2\u1b56\u1b54\3\2\2\2")
        buf.write("\u1b57\u1b5a\7\u0256\2\2\u1b58\u1b59\7\u01c3\2\2\u1b59")
        buf.write("\u1b5b\7\u00ab\2\2\u1b5a\u1b58\3\2\2\2\u1b5a\u1b5b\3\2")
        buf.write("\2\2\u1b5b\u1b6d\3\2\2\2\u1b5c\u1b5e\7\u017d\2\2\u1b5d")
        buf.write("\u1b5c\3\2\2\2\u1b5d\u1b5e\3\2\2\2\u1b5e\u1b5f\3\2\2\2")
        buf.write("\u1b5f\u1b6b\5\u022c\u0117\2\u1b60\u1b61\7\u0255\2\2\u1b61")
        buf.write("\u1b66\5\u022c\u0117\2\u1b62\u1b63\7\u024f\2\2\u1b63\u1b65")
        buf.write("\5\u022c\u0117\2\u1b64\u1b62\3\2\2\2\u1b65\u1b68\3\2\2")
        buf.write("\2\u1b66\u1b64\3\2\2\2\u1b66\u1b67\3\2\2\2\u1b67\u1b69")
        buf.write("\3\2\2\2\u1b68\u1b66\3\2\2\2\u1b69\u1b6a\7\u0256\2\2\u1b6a")
        buf.write("\u1b6c\3\2\2\2\u1b6b\u1b60\3\2\2\2\u1b6b\u1b6c\3\2\2\2")
        buf.write("\u1b6c\u1b6e\3\2\2\2\u1b6d\u1b5d\3\2\2\2\u1b6d\u1b6e\3")
        buf.write("\2\2\2\u1b6e\u1b70\3\2\2\2\u1b6f\u1b02\3\2\2\2\u1b6f\u1b1e")
        buf.write("\3\2\2\2\u1b6f\u1b24\3\2\2\2\u1b6f\u1b42\3\2\2\2\u1b70")
        buf.write("\u02a5\3\2\2\2\u1b71\u1b73\7\u017d\2\2\u1b72\u1b71\3\2")
        buf.write("\2\2\u1b72\u1b73\3\2\2\2\u1b73\u1b74\3\2\2\2\u1b74\u1b80")
        buf.write("\5\u022c\u0117\2\u1b75\u1b76\7\u0255\2\2\u1b76\u1b7b\5")
        buf.write("\u022c\u0117\2\u1b77\u1b78\7\u024f\2\2\u1b78\u1b7a\5\u022c")
        buf.write("\u0117\2\u1b79\u1b77\3\2\2\2\u1b7a\u1b7d\3\2\2\2\u1b7b")
        buf.write("\u1b79\3\2\2\2\u1b7b\u1b7c\3\2\2\2\u1b7c\u1b7e\3\2\2\2")
        buf.write("\u1b7d\u1b7b\3\2\2\2\u1b7e\u1b7f\7\u0256\2\2\u1b7f\u1b81")
        buf.write("\3\2\2\2\u1b80\u1b75\3\2\2\2\u1b80\u1b81\3\2\2\2\u1b81")
        buf.write("\u02a7\3\2\2\2\u1b82\u1b83\7\u0255\2\2\u1b83\u1b84\5\u022c")
        buf.write("\u0117\2\u1b84\u1b8b\5\u0240\u0121\2\u1b85\u1b86\7\u024f")
        buf.write("\2\2\u1b86\u1b87\5\u022c\u0117\2\u1b87\u1b88\5\u0240\u0121")
        buf.write("\2\u1b88\u1b8a\3\2\2\2\u1b89\u1b85\3\2\2\2\u1b8a\u1b8d")
        buf.write("\3\2\2\2\u1b8b\u1b89\3\2\2\2\u1b8b\u1b8c\3\2\2\2\u1b8c")
        buf.write("\u1b8e\3\2\2\2\u1b8d\u1b8b\3\2\2\2\u1b8e\u1b8f\7\u0256")
        buf.write("\2\2\u1b8f\u02a9\3\2\2\2\u1b90\u1b91\7\u019c\2\2\u1b91")
        buf.write("\u1b92\7\26\2\2\u1b92\u1b93\5\u02ac\u0157\2\u1b93\u02ab")
        buf.write("\3\2\2\2\u1b94\u1b99\5\u02ae\u0158\2\u1b95\u1b96\7\u024f")
        buf.write("\2\2\u1b96\u1b98\5\u02ae\u0158\2\u1b97\u1b95\3\2\2\2\u1b98")
        buf.write("\u1b9b\3\2\2\2\u1b99\u1b97\3\2\2\2\u1b99\u1b9a\3\2\2\2")
        buf.write("\u1b9a\u02ad\3\2\2\2\u1b9b\u1b99\3\2\2\2\u1b9c\u1baa\5")
        buf.write("\u024c\u0127\2\u1b9d\u1b9e\7\u0255\2\2\u1b9e\u1baa\7\u0256")
        buf.write("\2\2\u1b9f\u1ba4\7\u00db\2\2\u1ba0\u1ba4\7\62\2\2\u1ba1")
        buf.write("\u1ba2\7\u013b\2\2\u1ba2\u1ba4\7\u00ed\2\2\u1ba3\u1b9f")
        buf.write("\3\2\2\2\u1ba3\u1ba0\3\2\2\2\u1ba3\u1ba1\3\2\2\2\u1ba4")
        buf.write("\u1ba5\3\2\2\2\u1ba5\u1ba6\7\u0255\2\2\u1ba6\u1ba7\5\u02ac")
        buf.write("\u0157\2\u1ba7\u1ba8\7\u0256\2\2\u1ba8\u1baa\3\2\2\2\u1ba9")
        buf.write("\u1b9c\3\2\2\2\u1ba9\u1b9d\3\2\2\2\u1ba9\u1ba3\3\2\2\2")
        buf.write("\u1baa\u02af\3\2\2\2\u1bab\u1bac\7\u0154\2\2\u1bac\u1bb1")
        buf.write("\5\u02b2\u015a\2\u1bad\u1bae\7\u024f\2\2\u1bae\u1bb0\5")
        buf.write("\u02b2\u015a\2\u1baf\u1bad\3\2\2\2\u1bb0\u1bb3\3\2\2\2")
        buf.write("\u1bb1\u1baf\3\2\2\2\u1bb1\u1bb2\3\2\2\2\u1bb2\u02b1\3")
        buf.write("\2\2\2\u1bb3\u1bb1\3\2\2\2\u1bb4\u1bb7\7\u0255\2\2\u1bb5")
        buf.write("\u1bb8\5\u024c\u0127\2\u1bb6\u1bb8\7\u018e\2\2\u1bb7\u1bb5")
        buf.write("\3\2\2\2\u1bb7\u1bb6\3\2\2\2\u1bb8\u1bc0\3\2\2\2\u1bb9")
        buf.write("\u1bbc\7\u024f\2\2\u1bba\u1bbd\5\u024c\u0127\2\u1bbb\u1bbd")
        buf.write("\7\u018e\2\2\u1bbc\u1bba\3\2\2\2\u1bbc\u1bbb\3\2\2\2\u1bbd")
        buf.write("\u1bbf\3\2\2\2\u1bbe\u1bb9\3\2\2\2\u1bbf\u1bc2\3\2\2\2")
        buf.write("\u1bc0\u1bbe\3\2\2\2\u1bc0\u1bc1\3\2\2\2\u1bc1\u1bc3\3")
        buf.write("\2\2\2\u1bc2\u1bc0\3\2\2\2\u1bc3\u1bc4\7\u0256\2\2\u1bc4")
        buf.write("\u02b3\3\2\2\2\u1bc5\u1bc6\7\u01ad\2\2\u1bc6\u1bc7\7\26")
        buf.write("\2\2\u1bc7\u1bcc\5\u02b6\u015c\2\u1bc8\u1bc9\7\u024f\2")
        buf.write("\2\u1bc9\u1bcb\5\u02b6\u015c\2\u1bca\u1bc8\3\2\2\2\u1bcb")
        buf.write("\u1bce\3\2\2\2\u1bcc\u1bca\3\2\2\2\u1bcc\u1bcd\3\2\2\2")
        buf.write("\u1bcd\u02b5\3\2\2\2\u1bce\u1bcc\3\2\2\2\u1bcf\u1bd1\5")
        buf.write("\u024c\u0127\2\u1bd0\u1bd2\5\u02b8\u015d\2\u1bd1\u1bd0")
        buf.write("\3\2\2\2\u1bd1\u1bd2\3\2\2\2\u1bd2\u1bd4\3\2\2\2\u1bd3")
        buf.write("\u1bd5\5\u02ba\u015e\2\u1bd4\u1bd3\3\2\2\2\u1bd4\u1bd5")
        buf.write("\3\2\2\2\u1bd5\u02b7\3\2\2\2\u1bd6\u1bdb\7\u017e\2\2\u1bd7")
        buf.write("\u1bdb\7\u0190\2\2\u1bd8\u1bd9\7\u01be\2\2\u1bd9\u1bdb")
        buf.write("\5\u0252\u012a\2\u1bda\u1bd6\3\2\2\2\u1bda\u1bd7\3\2\2")
        buf.write("\2\u1bda\u1bd8\3\2\2\2\u1bdb\u02b9\3\2\2\2\u1bdc\u1bdd")
        buf.write("\7\u00a2\2\2\u1bdd\u1bde\tc\2\2\u1bde\u02bb\3\2\2\2\u1bdf")
        buf.write("\u1be1\5\u0292\u014a\2\u1be0\u1bdf\3\2\2\2\u1be0\u1be1")
        buf.write("\3\2\2\2\u1be1\u1be2\3\2\2\2\u1be2\u1be3\7y\2\2\u1be3")
        buf.write("\u1be4\7\u01a1\2\2\u1be4\u1be7\5\u0286\u0144\2\u1be5\u1be6")
        buf.write("\7\u017d\2\2\u1be6\u1be8\5\u022c\u0117\2\u1be7\u1be5\3")
        buf.write("\2\2\2\u1be7\u1be8\3\2\2\2\u1be8\u1bec\3\2\2\2\u1be9\u1bea")
        buf.write("\7\u00ae\2\2\u1bea\u1beb\td\2\2\u1beb\u1bed\7\u011e\2")
        buf.write("\2\u1bec\u1be9\3\2\2\2\u1bec\u1bed\3\2\2\2\u1bed\u1bef")
        buf.write("\3\2\2\2\u1bee\u1bf0\5\u02be\u0160\2\u1bef\u1bee\3\2\2")
        buf.write("\2\u1bef\u1bf0\3\2\2\2\u1bf0\u1bf4\3\2\2\2\u1bf1\u1bf5")
        buf.write("\5\u028c\u0147\2\u1bf2\u1bf3\7\u018e\2\2\u1bf3\u1bf5\7")
        buf.write("\u0154\2\2\u1bf4\u1bf1\3\2\2\2\u1bf4\u1bf2\3\2\2\2\u1bf5")
        buf.write("\u1bfc\3\2\2\2\u1bf6\u1bf7\7\u01aa\2\2\u1bf7\u1bf9\7)")
        buf.write("\2\2\u1bf8\u1bfa\5\u02c2\u0162\2\u1bf9\u1bf8\3\2\2\2\u1bf9")
        buf.write("\u1bfa\3\2\2\2\u1bfa\u1bfb\3\2\2\2\u1bfb\u1bfd\5\u02c4")
        buf.write("\u0163\2\u1bfc\u1bf6\3\2\2\2\u1bfc\u1bfd\3\2\2\2\u1bfd")
        buf.write("\u1c00\3\2\2\2\u1bfe\u1bff\7\u01b1\2\2\u1bff\u1c01\5\u029c")
        buf.write("\u014f\2\u1c00\u1bfe\3\2\2\2\u1c00\u1c01\3\2\2\2\u1c01")
        buf.write("\u02bd\3\2\2\2\u1c02\u1c03\7\u0255\2\2\u1c03\u1c08\5\u02c0")
        buf.write("\u0161\2\u1c04\u1c05\7\u024f\2\2\u1c05\u1c07\5\u02c0\u0161")
        buf.write("\2\u1c06\u1c04\3\2\2\2\u1c07\u1c0a\3\2\2\2\u1c08\u1c06")
        buf.write("\3\2\2\2\u1c08\u1c09\3\2\2\2\u1c09\u1c0b\3\2\2\2\u1c0a")
        buf.write("\u1c08\3\2\2\2\u1c0b\u1c0c\7\u0256\2\2\u1c0c\u02bf\3\2")
        buf.write("\2\2\u1c0d\u1c0f\5\u022c\u0117\2\u1c0e\u1c10\5\u021a\u010e")
        buf.write("\2\u1c0f\u1c0e\3\2\2\2\u1c0f\u1c10\3\2\2\2\u1c10\u02c1")
        buf.write("\3\2\2\2\u1c11\u1c13\5\u009eP\2\u1c12\u1c14\5\u00a4S\2")
        buf.write("\u1c13\u1c12\3\2\2\2\u1c13\u1c14\3\2\2\2\u1c14\u1c19\3")
        buf.write("\2\2\2\u1c15\u1c16\7\u01aa\2\2\u1c16\u1c17\7\u0186\2\2")
        buf.write("\u1c17\u1c19\5\u022c\u0117\2\u1c18\u1c11\3\2\2\2\u1c18")
        buf.write("\u1c15\3\2\2\2\u1c19\u02c3\3\2\2\2\u1c1a\u1c1b\7\u0192")
        buf.write("\2\2\u1c1b\u1c2c\7\u009f\2\2\u1c1c\u1c1d\7\u0192\2\2\u1c1d")
        buf.write("\u1c1e\7\u0119\2\2\u1c1e\u1c1f\7\u00ec\2\2\u1c1f\u1c24")
        buf.write("\5\u02ca\u0166\2\u1c20\u1c21\7\u024f\2\2\u1c21\u1c23\5")
        buf.write("\u02ca\u0166\2\u1c22\u1c20\3\2\2\2\u1c23\u1c26\3\2\2\2")
        buf.write("\u1c24\u1c22\3\2\2\2\u1c24\u1c25\3\2\2\2\u1c25\u1c29\3")
        buf.write("\2\2\2\u1c26\u1c24\3\2\2\2\u1c27\u1c28\7\u01c1\2\2\u1c28")
        buf.write("\u1c2a\5\u024c\u0127\2\u1c29\u1c27\3\2\2\2\u1c29\u1c2a")
        buf.write("\3\2\2\2\u1c2a\u1c2c\3\2\2\2\u1c2b\u1c1a\3\2\2\2\u1c2b")
        buf.write("\u1c1c\3\2\2\2\u1c2c\u02c5\3\2\2\2\u1c2d\u1c2f\5\u0292")
        buf.write("\u014a\2\u1c2e\u1c2d\3\2\2\2\u1c2e\u1c2f\3\2\2\2\u1c2f")
        buf.write("\u1c30\3\2\2\2\u1c30\u1c31\7>\2\2\u1c31\u1c33\7\u019a")
        buf.write("\2\2\u1c32\u1c34\7\u01ab\2\2\u1c33\u1c32\3\2\2\2\u1c33")
        buf.write("\u1c34\3\2\2\2\u1c34\u1c35\3\2\2\2\u1c35\u1c37\5\u0286")
        buf.write("\u0144\2\u1c36\u1c38\7\u0259\2\2\u1c37\u1c36\3\2\2\2\u1c37")
        buf.write("\u1c38\3\2\2\2\u1c38\u1c3d\3\2\2\2\u1c39\u1c3b\7\u017d")
        buf.write("\2\2\u1c3a\u1c39\3\2\2\2\u1c3a\u1c3b\3\2\2\2\u1c3b\u1c3c")
        buf.write("\3\2\2\2\u1c3c\u1c3e\5\u022c\u0117\2\u1c3d\u1c3a\3\2\2")
        buf.write("\2\u1c3d\u1c3e\3\2\2\2\u1c3e\u1c48\3\2\2\2\u1c3f\u1c40")
        buf.write("\7\u01be\2\2\u1c40\u1c45\5\u02a2\u0152\2\u1c41\u1c42\7")
        buf.write("\u024f\2\2\u1c42\u1c44\5\u02a2\u0152\2\u1c43\u1c41\3\2")
        buf.write("\2\2\u1c44\u1c47\3\2\2\2\u1c45\u1c43\3\2\2\2\u1c45\u1c46")
        buf.write("\3\2\2\2\u1c46\u1c49\3\2\2\2\u1c47\u1c45\3\2\2\2\u1c48")
        buf.write("\u1c3f\3\2\2\2\u1c48\u1c49\3\2\2\2\u1c49\u1c51\3\2\2\2")
        buf.write("\u1c4a\u1c4f\7\u01c1\2\2\u1c4b\u1c50\5\u024c\u0127\2\u1c4c")
        buf.write("\u1c4d\7\63\2\2\u1c4d\u1c4e\7\u00a4\2\2\u1c4e\u1c50\5")
        buf.write("\u022c\u0117\2\u1c4f\u1c4b\3\2\2\2\u1c4f\u1c4c\3\2\2\2")
        buf.write("\u1c50\u1c52\3\2\2\2\u1c51\u1c4a\3\2\2\2\u1c51\u1c52\3")
        buf.write("\2\2\2\u1c52\u1c55\3\2\2\2\u1c53\u1c54\7\u01b1\2\2\u1c54")
        buf.write("\u1c56\5\u029c\u014f\2\u1c55\u1c53\3\2\2\2\u1c55\u1c56")
        buf.write("\3\2\2\2\u1c56\u02c7\3\2\2\2\u1c57\u1c59\5\u0292\u014a")
        buf.write("\2\u1c58\u1c57\3\2\2\2\u1c58\u1c59\3\2\2\2\u1c59\u1c5a")
        buf.write("\3\2\2\2\u1c5a\u1c5c\7\u0119\2\2\u1c5b\u1c5d\7\u01ab\2")
        buf.write("\2\u1c5c\u1c5b\3\2\2\2\u1c5c\u1c5d\3\2\2\2\u1c5d\u1c5e")
        buf.write("\3\2\2\2\u1c5e\u1c60\5\u0286\u0144\2\u1c5f\u1c61\7\u0259")
        buf.write("\2\2\u1c60\u1c5f\3\2\2\2\u1c60\u1c61\3\2\2\2\u1c61\u1c66")
        buf.write("\3\2\2\2\u1c62\u1c64\7\u017d\2\2\u1c63\u1c62\3\2\2\2\u1c63")
        buf.write("\u1c64\3\2\2\2\u1c64\u1c65\3\2\2\2\u1c65\u1c67\5\u022c")
        buf.write("\u0117\2\u1c66\u1c63\3\2\2\2\u1c66\u1c67\3\2\2\2\u1c67")
        buf.write("\u1c68\3\2\2\2\u1c68\u1c69\7\u00ec\2\2\u1c69\u1c6e\5\u02ca")
        buf.write("\u0166\2\u1c6a\u1c6b\7\u024f\2\2\u1c6b\u1c6d\5\u02ca\u0166")
        buf.write("\2\u1c6c\u1c6a\3\2\2\2\u1c6d\u1c70\3\2\2\2\u1c6e\u1c6c")
        buf.write("\3\2\2\2\u1c6e\u1c6f\3\2\2\2\u1c6f\u1c7a\3\2\2\2\u1c70")
        buf.write("\u1c6e\3\2\2\2\u1c71\u1c72\7\u019a\2\2\u1c72\u1c77\5\u02a2")
        buf.write("\u0152\2\u1c73\u1c74\7\u024f\2\2\u1c74\u1c76\5\u02a2\u0152")
        buf.write("\2\u1c75\u1c73\3\2\2\2\u1c76\u1c79\3\2\2\2\u1c77\u1c75")
        buf.write("\3\2\2\2\u1c77\u1c78\3\2\2\2\u1c78\u1c7b\3\2\2\2\u1c79")
        buf.write("\u1c77\3\2\2\2\u1c7a\u1c71\3\2\2\2\u1c7a\u1c7b\3\2\2\2")
        buf.write("\u1c7b\u1c83\3\2\2\2\u1c7c\u1c81\7\u01c1\2\2\u1c7d\u1c82")
        buf.write("\5\u024c\u0127\2\u1c7e\u1c7f\7\63\2\2\u1c7f\u1c80\7\u00a4")
        buf.write("\2\2\u1c80\u1c82\5\u022c\u0117\2\u1c81\u1c7d\3\2\2\2\u1c81")
        buf.write("\u1c7e\3\2\2\2\u1c82\u1c84\3\2\2\2\u1c83\u1c7c\3\2\2\2")
        buf.write("\u1c83\u1c84\3\2\2\2\u1c84\u1c87\3\2\2\2\u1c85\u1c86\7")
        buf.write("\u01b1\2\2\u1c86\u1c88\5\u029c\u014f\2\u1c87\u1c85\3\2")
        buf.write("\2\2\u1c87\u1c88\3\2\2\2\u1c88\u02c9\3\2\2\2\u1c89\u1c8a")
        buf.write("\5\u02c0\u0161\2\u1c8a\u1c8d\7\u024c\2\2\u1c8b\u1c8e\5")
        buf.write("\u024c\u0127\2\u1c8c\u1c8e\7\u018e\2\2\u1c8d\u1c8b\3\2")
        buf.write("\2\2\u1c8d\u1c8c\3\2\2\2\u1c8e\u1cb1\3\2\2\2\u1c8f\u1c90")
        buf.write("\7\u0255\2\2\u1c90\u1c95\5\u02c0\u0161\2\u1c91\u1c92\7")
        buf.write("\u024f\2\2\u1c92\u1c94\5\u02c0\u0161\2\u1c93\u1c91\3\2")
        buf.write("\2\2\u1c94\u1c97\3\2\2\2\u1c95\u1c93\3\2\2\2\u1c95\u1c96")
        buf.write("\3\2\2\2\u1c96\u1c98\3\2\2\2\u1c97\u1c95\3\2\2\2\u1c98")
        buf.write("\u1c99\7\u0256\2\2\u1c99\u1c9b\7\u024c\2\2\u1c9a\u1c9c")
        buf.write("\7\u014c\2\2\u1c9b\u1c9a\3\2\2\2\u1c9b\u1c9c\3\2\2\2\u1c9c")
        buf.write("\u1cae\3\2\2\2\u1c9d\u1ca0\7\u0255\2\2\u1c9e\u1ca1\5\u024c")
        buf.write("\u0127\2\u1c9f\u1ca1\7\u018e\2\2\u1ca0\u1c9e\3\2\2\2\u1ca0")
        buf.write("\u1c9f\3\2\2\2\u1ca1\u1ca9\3\2\2\2\u1ca2\u1ca5\7\u024f")
        buf.write("\2\2\u1ca3\u1ca6\5\u024c\u0127\2\u1ca4\u1ca6\7\u018e\2")
        buf.write("\2\u1ca5\u1ca3\3\2\2\2\u1ca5\u1ca4\3\2\2\2\u1ca6\u1ca8")
        buf.write("\3\2\2\2\u1ca7\u1ca2\3\2\2\2\u1ca8\u1cab\3\2\2\2\u1ca9")
        buf.write("\u1ca7\3\2\2\2\u1ca9\u1caa\3\2\2\2\u1caa\u1cac\3\2\2\2")
        buf.write("\u1cab\u1ca9\3\2\2\2\u1cac\u1caf\7\u0256\2\2\u1cad\u1caf")
        buf.write("\5\u028a\u0146\2\u1cae\u1c9d\3\2\2\2\u1cae\u1cad\3\2\2")
        buf.write("\2\u1caf\u1cb1\3\2\2\2\u1cb0\u1c89\3\2\2\2\u1cb0\u1c8f")
        buf.write("\3\2\2\2\u1cb1\u02cb\3\2\2\2\u1cb2\u1cb3\7\u00a0\2\2\u1cb3")
        buf.write("\u1cb6\5\u022c\u0117\2\u1cb4\u1cb5\7\u024f\2\2\u1cb5\u1cb7")
        buf.write("\5\u0154\u00ab\2\u1cb6\u1cb4\3\2\2\2\u1cb6\u1cb7\3\2\2")
        buf.write("\2\u1cb7\u02cd\3\2\2\2\u1cb8\u1cba\7\u010d\2\2\u1cb9\u1cbb")
        buf.write("\7\u01b6\2\2\u1cba\u1cb9\3\2\2\2\u1cba\u1cbb\3\2\2\2\u1cbb")
        buf.write("\u1cbc\3\2\2\2\u1cbc\u1cc1\5\u0194\u00cb\2\u1cbd\u1cbe")
        buf.write("\7\u024f\2\2\u1cbe\u1cc0\5\u0194\u00cb\2\u1cbf\u1cbd\3")
        buf.write("\2\2\2\u1cc0\u1cc3\3\2\2\2\u1cc1\u1cbf\3\2\2\2\u1cc1\u1cc2")
        buf.write("\3\2\2\2\u1cc2\u1cc6\3\2\2\2\u1cc3\u1cc1\3\2\2\2\u1cc4")
        buf.write("\u1cc5\te\2\2\u1cc5\u1cc7\7i\2\2\u1cc6\u1cc4\3\2\2\2\u1cc6")
        buf.write("\u1cc7\3\2\2\2\u1cc7\u1cc9\3\2\2\2\u1cc8\u1cca\5\u0212")
        buf.write("\u010a\2\u1cc9\u1cc8\3\2\2\2\u1cc9\u1cca\3\2\2\2\u1cca")
        buf.write("\u02cf\3\2\2\2\u1ccb\u1cd0\5\u022c\u0117\2\u1ccc\u1ccd")
        buf.write("\7\u024f\2\2\u1ccd\u1ccf\5\u022c\u0117\2\u1cce\u1ccc\3")
        buf.write("\2\2\2\u1ccf\u1cd2\3\2\2\2\u1cd0\u1cce\3\2\2\2\u1cd0\u1cd1")
        buf.write("\3\2\2\2\u1cd1\u02d1\3\2\2\2\u1cd2\u1cd0\3\2\2\2\u1cd3")
        buf.write("\u1cd9\7\u0192\2\2\u1cd4\u1cd7\7\177\2\2\u1cd5\u1cd8\5")
        buf.write("\u022c\u0117\2\u1cd6\u1cd8\5\u0154\u00ab\2\u1cd7\u1cd5")
        buf.write("\3\2\2\2\u1cd7\u1cd6\3\2\2\2\u1cd8\u1cda\3\2\2\2\u1cd9")
        buf.write("\u1cd4\3\2\2\2\u1cd9\u1cda\3\2\2\2\u1cda\u1cdb\3\2\2\2")
        buf.write("\u1cdb\u1ce4\5\u0154\u00ab\2\u1cdc\u1cdd\7\u0192\2\2\u1cdd")
        buf.write("\u1cde\5\u0154\u00ab\2\u1cde\u1ce1\7\177\2\2\u1cdf\u1ce2")
        buf.write("\5\u022c\u0117\2\u1ce0\u1ce2\5\u0154\u00ab\2\u1ce1\u1cdf")
        buf.write("\3\2\2\2\u1ce1\u1ce0\3\2\2\2\u1ce2\u1ce4\3\2\2\2\u1ce3")
        buf.write("\u1cd3\3\2\2\2\u1ce3\u1cdc\3\2\2\2\u1ce4\u02d3\3\2\2\2")
        buf.write("\u1ce5\u1ce6\7\u0268\2\2\u1ce6\u1ce9\5\u022c\u0117\2\u1ce7")
        buf.write("\u1cea\5\u022c\u0117\2\u1ce8\u1cea\5\u025c\u012f\2\u1ce9")
        buf.write("\u1ce7\3\2\2\2\u1ce9\u1ce8\3\2\2\2\u1cea\u02d5\3\2\2\2")
        buf.write("\u1ceb\u1ced\5\u02d8\u016d\2\u1cec\u1ceb\3\2\2\2\u1cec")
        buf.write("\u1ced\3\2\2\2\u1ced\u1cef\3\2\2\2\u1cee\u1cf0\5\u02da")
        buf.write("\u016e\2\u1cef\u1cee\3\2\2\2\u1cef\u1cf0\3\2\2\2\u1cf0")
        buf.write("\u1cf1\3\2\2\2\u1cf1\u1cf2\7\25\2\2\u1cf2\u1cf4\5\u02e6")
        buf.write("\u0174\2\u1cf3\u1cf5\5\u02e4\u0173\2\u1cf4\u1cf3\3\2\2")
        buf.write("\2\u1cf4\u1cf5\3\2\2\2\u1cf5\u1cf6\3\2\2\2\u1cf6\u1cf8")
        buf.write("\7\u0194\2\2\u1cf7\u1cf9\5\u022c\u0117\2\u1cf8\u1cf7\3")
        buf.write("\2\2\2\u1cf8\u1cf9\3\2\2\2\u1cf9\u02d7\3\2\2\2\u1cfa\u1cfb")
        buf.write("\7\u0265\2\2\u1cfb\u1cfc\5\u0230\u0119\2\u1cfc\u1cfd\7")
        buf.write("\u0266\2\2\u1cfd\u02d9\3\2\2\2\u1cfe\u1d02\7:\2\2\u1cff")
        buf.write("\u1d01\5\u02dc\u016f\2\u1d00\u1cff\3\2\2\2\u1d01\u1d04")
        buf.write("\3\2\2\2\u1d02\u1d00\3\2\2\2\u1d02\u1d03\3\2\2\2\u1d03")
        buf.write("\u02db\3\2\2\2\u1d04\u1d02\3\2\2\2\u1d05\u1d07\7:\2\2")
        buf.write("\u1d06\u1d05\3\2\2\2\u1d07\u1d0a\3\2\2\2\u1d08\u1d06\3")
        buf.write("\2\2\2\u1d08\u1d09\3\2\2\2\u1d09\u1d0b\3\2\2\2\u1d0a\u1d08")
        buf.write("\3\2\2\2\u1d0b\u1d0c\5\u022c\u0117\2\u1d0c\u1d0d\5\u02de")
        buf.write("\u0170\2\u1d0d\u1d0e\7\u024e\2\2\u1d0e\u02dd\3\2\2\2\u1d0f")
        buf.write("\u1d11\7\u022c\2\2\u1d10\u1d0f\3\2\2\2\u1d10\u1d11\3\2")
        buf.write("\2\2\u1d11\u1d12\3\2\2\2\u1d12\u1d14\5\u02e2\u0172\2\u1d13")
        buf.write("\u1d15\5\u0214\u010b\2\u1d14\u1d13\3\2\2\2\u1d14\u1d15")
        buf.write("\3\2\2\2\u1d15\u1d18\3\2\2\2\u1d16\u1d17\7\u01a7\2\2\u1d17")
        buf.write("\u1d19\7\u01a8\2\2\u1d18\u1d16\3\2\2\2\u1d18\u1d19\3\2")
        buf.write("\2\2\u1d19\u1d1c\3\2\2\2\u1d1a\u1d1b\tf\2\2\u1d1b\u1d1d")
        buf.write("\5\u024c\u0127\2\u1d1c\u1d1a\3\2\2\2\u1d1c\u1d1d\3\2\2")
        buf.write("\2\u1d1d\u1d34\3\2\2\2\u1d1e\u1d1f\7\u022a\2\2\u1d1f\u1d22")
        buf.write("\7\u0198\2\2\u1d20\u1d23\5\u022c\u0117\2\u1d21\u1d23\7")
        buf.write("\u026e\2\2\u1d22\u1d20\3\2\2\2\u1d22\u1d21\3\2\2\2\u1d23")
        buf.write("\u1d34\3\2\2\2\u1d24\u1d26\7\u009d\2\2\u1d25\u1d24\3\2")
        buf.write("\2\2\u1d25\u1d26\3\2\2\2\u1d26\u1d27\3\2\2\2\u1d27\u1d29")
        buf.write("\7\u00e3\2\2\u1d28\u1d25\3\2\2\2\u1d28\u1d29\3\2\2\2\u1d29")
        buf.write("\u1d2a\3\2\2\2\u1d2a\u1d2f\7\64\2\2\u1d2b\u1d2c\7\u0255")
        buf.write("\2\2\u1d2c\u1d2d\5\u02e0\u0171\2\u1d2d\u1d2e\7\u0256\2")
        buf.write("\2\u1d2e\u1d30\3\2\2\2\u1d2f\u1d2b\3\2\2\2\u1d2f\u1d30")
        buf.write("\3\2\2\2\u1d30\u1d31\3\2\2\2\u1d31\u1d32\tg\2\2\u1d32")
        buf.write("\u1d34\5\u028c\u0147\2\u1d33\u1d10\3\2\2\2\u1d33\u1d1e")
        buf.write("\3\2\2\2\u1d33\u1d28\3\2\2\2\u1d34\u02df\3\2\2\2\u1d35")
        buf.write("\u1d36\5\u022c\u0117\2\u1d36\u1d3d\5\u0240\u0121\2\u1d37")
        buf.write("\u1d38\7\u024f\2\2\u1d38\u1d39\5\u022c\u0117\2\u1d39\u1d3a")
        buf.write("\5\u0240\u0121\2\u1d3a\u1d3c\3\2\2\2\u1d3b\u1d37\3\2\2")
        buf.write("\2\u1d3c\u1d3f\3\2\2\2\u1d3d\u1d3b\3\2\2\2\u1d3d\u1d3e")
        buf.write("\3\2\2\2\u1d3e\u02e1\3\2\2\2\u1d3f\u1d3d\3\2\2\2\u1d40")
        buf.write("\u1d4a\5\u0240\u0121\2\u1d41\u1d42\5\u0286\u0144\2\u1d42")
        buf.write("\u1d43\7\u025b\2\2\u1d43\u1d44\7\u010f\2\2\u1d44\u1d4a")
        buf.write("\3\2\2\2\u1d45\u1d46\5\u023c\u011f\2\u1d46\u1d47\7\u025b")
        buf.write("\2\2\u1d47\u1d48\7\u0245\2\2\u1d48\u1d4a\3\2\2\2\u1d49")
        buf.write("\u1d40\3\2\2\2\u1d49\u1d41\3\2\2\2\u1d49\u1d45\3\2\2\2")
        buf.write("\u1d4a\u02e3\3\2\2\2\u1d4b\u1d51\7\u0235\2\2\u1d4c\u1d4d")
        buf.write("\7\u01c0\2\2\u1d4d\u1d4e\5\u024c\u0127\2\u1d4e\u1d4f\7")
        buf.write("\u01b7\2\2\u1d4f\u1d50\5\u02e6\u0174\2\u1d50\u1d52\3\2")
        buf.write("\2\2\u1d51\u1d4c\3\2\2\2\u1d52\u1d53\3\2\2\2\u1d53\u1d51")
        buf.write("\3\2\2\2\u1d53\u1d54\3\2\2\2\u1d54\u02e5\3\2\2\2\u1d55")
        buf.write("\u1d56\5\u02e8\u0175\2\u1d56\u1d57\7\u024e\2\2\u1d57\u1d59")
        buf.write("\3\2\2\2\u1d58\u1d55\3\2\2\2\u1d59\u1d5c\3\2\2\2\u1d5a")
        buf.write("\u1d58\3\2\2\2\u1d5a\u1d5b\3\2\2\2\u1d5b\u02e7\3\2\2\2")
        buf.write("\u1d5c\u1d5a\3\2\2\2\u1d5d\u1d67\5\u02d6\u016c\2\u1d5e")
        buf.write("\u1d67\5\u02ea\u0176\2\u1d5f\u1d67\5\u02f6\u017c\2\u1d60")
        buf.write("\u1d67\5\u02fc\u017f\2\u1d61\u1d67\5\u02f8\u017d\2\u1d62")
        buf.write("\u1d67\5\u02fe\u0180\2\u1d63\u1d67\5<\37\2\u1d64\u1d67")
        buf.write("\5\u0312\u018a\2\u1d65\u1d67\5\36\20\2\u1d66\u1d5d\3\2")
        buf.write("\2\2\u1d66\u1d5e\3\2\2\2\u1d66\u1d5f\3\2\2\2\u1d66\u1d60")
        buf.write("\3\2\2\2\u1d66\u1d61\3\2\2\2\u1d66\u1d62\3\2\2\2\u1d66")
        buf.write("\u1d63\3\2\2\2\u1d66\u1d64\3\2\2\2\u1d66\u1d65\3\2\2\2")
        buf.write("\u1d67\u02e9\3\2\2\2\u1d68\u1d7a\5\u02f2\u017a\2\u1d69")
        buf.write("\u1d6a\7\u023f\2\2\u1d6a\u1d7a\5\u02f0\u0179\2\u1d6b\u1d6d")
        buf.write("\7\u0237\2\2\u1d6c\u1d6e\th\2\2\u1d6d\u1d6c\3\2\2\2\u1d6d")
        buf.write("\u1d6e\3\2\2\2\u1d6e\u1d6f\3\2\2\2\u1d6f\u1d70\7\u0230")
        buf.write("\2\2\u1d70\u1d75\5\u02ee\u0178\2\u1d71\u1d72\7\u024f\2")
        buf.write("\2\u1d72\u1d74\5\u02ee\u0178\2\u1d73\u1d71\3\2\2\2\u1d74")
        buf.write("\u1d77\3\2\2\2\u1d75\u1d73\3\2\2\2\u1d75\u1d76\3\2\2\2")
        buf.write("\u1d76\u1d7a\3\2\2\2\u1d77\u1d75\3\2\2\2\u1d78\u1d7a\7")
        buf.write("\u01a8\2\2\u1d79\u1d68\3\2\2\2\u1d79\u1d69\3\2\2\2\u1d79")
        buf.write("\u1d6b\3\2\2\2\u1d79\u1d78\3\2\2\2\u1d7a\u02eb\3\2\2\2")
        buf.write("\u1d7b\u1d7e\5\u0286\u0144\2\u1d7c\u1d7e\7\u026e\2\2\u1d7d")
        buf.write("\u1d7b\3\2\2\2\u1d7d\u1d7c\3\2\2\2\u1d7e\u1d85\3\2\2\2")
        buf.write("\u1d7f\u1d80\7\u0261\2\2\u1d80\u1d81\5\u024c\u0127\2\u1d81")
        buf.write("\u1d82\7\u0262\2\2\u1d82\u1d84\3\2\2\2\u1d83\u1d7f\3\2")
        buf.write("\2\2\u1d84\u1d87\3\2\2\2\u1d85\u1d83\3\2\2\2\u1d85\u1d86")
        buf.write("\3\2\2\2\u1d86\u02ed\3\2\2\2\u1d87\u1d85\3\2\2\2\u1d88")
        buf.write("\u1d89\5\u02ec\u0177\2\u1d89\u1d8a\ti\2\2\u1d8a\u1d8b")
        buf.write("\5\u022c\u0117\2\u1d8b\u02ef\3\2\2\2\u1d8c\u1d99\5\u0288")
        buf.write("\u0145\2\u1d8d\u1d8e\7\u01aa\2\2\u1d8e\u1d8f\7\u0255\2")
        buf.write("\2\u1d8f\u1d94\5\u024c\u0127\2\u1d90\u1d91\7\u024f\2\2")
        buf.write("\u1d91\u1d93\5\u024c\u0127\2\u1d92\u1d90\3\2\2\2\u1d93")
        buf.write("\u1d96\3\2\2\2\u1d94\u1d92\3\2\2\2\u1d94\u1d95\3\2\2\2")
        buf.write("\u1d95\u1d97\3\2\2\2\u1d96\u1d94\3\2\2\2\u1d97\u1d98\7")
        buf.write("\u0256\2\2\u1d98\u1d9a\3\2\2\2\u1d99\u1d8d\3\2\2\2\u1d99")
        buf.write("\u1d9a\3\2\2\2\u1d9a\u1d9c\3\2\2\2\u1d9b\u1d8c\3\2\2\2")
        buf.write("\u1d9b\u1d9c\3\2\2\2\u1d9c\u1d9d\3\2\2\2\u1d9d\u1da7\5")
        buf.write("\u029c\u014f\2\u1d9e\u1d9f\7\u019a\2\2\u1d9f\u1da4\5\u02a2")
        buf.write("\u0152\2\u1da0\u1da1\7\u024f\2\2\u1da1\u1da3\5\u02a2\u0152")
        buf.write("\2\u1da2\u1da0\3\2\2\2\u1da3\u1da6\3\2\2\2\u1da4\u1da2")
        buf.write("\3\2\2\2\u1da4\u1da5\3\2\2\2\u1da5\u1da8\3\2\2\2\u1da6")
        buf.write("\u1da4\3\2\2\2\u1da7\u1d9e\3\2\2\2\u1da7\u1da8\3\2\2\2")
        buf.write("\u1da8\u1dab\3\2\2\2\u1da9\u1daa\7\u01c1\2\2\u1daa\u1dac")
        buf.write("\5\u024c\u0127\2\u1dab\u1da9\3\2\2\2\u1dab\u1dac\3\2\2")
        buf.write("\2\u1dac\u1dae\3\2\2\2\u1dad\u1daf\5\u02aa\u0156\2\u1dae")
        buf.write("\u1dad\3\2\2\2\u1dae\u1daf\3\2\2\2\u1daf\u1db2\3\2\2\2")
        buf.write("\u1db0\u1db1\7\u019d\2\2\u1db1\u1db3\5\u024c\u0127\2\u1db2")
        buf.write("\u1db0\3\2\2\2\u1db2\u1db3\3\2\2\2\u1db3\u1dc2\3\2\2\2")
        buf.write("\u1db4\u1db5\7\u01c2\2\2\u1db5\u1db6\5\u022c\u0117\2\u1db6")
        buf.write("\u1db7\7\u017d\2\2\u1db7\u1dbf\5\u027a\u013e\2\u1db8\u1db9")
        buf.write("\7\u024f\2\2\u1db9\u1dba\5\u022c\u0117\2\u1dba\u1dbb\7")
        buf.write("\u017d\2\2\u1dbb\u1dbc\5\u027a\u013e\2\u1dbc\u1dbe\3\2")
        buf.write("\2\2\u1dbd\u1db8\3\2\2\2\u1dbe\u1dc1\3\2\2\2\u1dbf\u1dbd")
        buf.write("\3\2\2\2\u1dbf\u1dc0\3\2\2\2\u1dc0\u1dc3\3\2\2\2\u1dc1")
        buf.write("\u1dbf\3\2\2\2\u1dc2\u1db4\3\2\2\2\u1dc2\u1dc3\3\2\2\2")
        buf.write("\u1dc3\u1dc9\3\2\2\2\u1dc4\u1dc6\t`\2\2\u1dc5\u1dc7\5")
        buf.write("\u0288\u0145\2\u1dc6\u1dc5\3\2\2\2\u1dc6\u1dc7\3\2\2\2")
        buf.write("\u1dc7\u1dc8\3\2\2\2\u1dc8\u1dca\5\u0296\u014c\2\u1dc9")
        buf.write("\u1dc4\3\2\2\2\u1dc9\u1dca\3\2\2\2\u1dca\u1dce\3\2\2\2")
        buf.write("\u1dcb\u1dcd\5\u028e\u0148\2\u1dcc\u1dcb\3\2\2\2\u1dcd")
        buf.write("\u1dd0\3\2\2\2\u1dce\u1dcc\3\2\2\2\u1dce\u1dcf\3\2\2\2")
        buf.write("\u1dcf\u02f1\3\2\2\2\u1dd0\u1dce\3\2\2\2\u1dd1\u1dd2\5")
        buf.write("\u02ec\u0177\2\u1dd2\u1dd5\ti\2\2\u1dd3\u1dd6\5\u0290")
        buf.write("\u0149\2\u1dd4\u1dd6\5\u02f0\u0179\2\u1dd5\u1dd3\3\2\2")
        buf.write("\2\u1dd5\u1dd4\3\2\2\2\u1dd6\u02f3\3\2\2\2\u1dd7\u1dd8")
        buf.write("\7T\2\2\u1dd8\u1dda\5\u024c\u0127\2\u1dd9\u1ddb\5\u030c")
        buf.write("\u0187\2\u1dda\u1dd9\3\2\2\2\u1dda\u1ddb\3\2\2\2\u1ddb")
        buf.write("\u02f5\3\2\2\2\u1ddc\u1de3\5\u0306\u0184\2\u1ddd\u1dde")
        buf.write("\7\30\2\2\u1dde\u1de3\5\u0262\u0132\2\u1ddf\u1de3\5\u030e")
        buf.write("\u0188\2\u1de0\u1de3\5\u0310\u0189\2\u1de1\u1de3\5\u0308")
        buf.write("\u0185\2\u1de2\u1ddc\3\2\2\2\u1de2\u1ddd\3\2\2\2\u1de2")
        buf.write("\u1ddf\3\2\2\2\u1de2\u1de0\3\2\2\2\u1de2\u1de1\3\2\2\2")
        buf.write("\u1de3\u02f7\3\2\2\2\u1de4\u1de5\7\u023e\2\2\u1de5\u1dea")
        buf.write("\5\u02ec\u0177\2\u1de6\u1de8\7\u009d\2\2\u1de7\u1de6\3")
        buf.write("\2\2\2\u1de7\u1de8\3\2\2\2\u1de8\u1de9\3\2\2\2\u1de9\u1deb")
        buf.write("\7\u00e3\2\2\u1dea\u1de7\3\2\2\2\u1dea\u1deb\3\2\2\2\u1deb")
        buf.write("\u1dec\3\2\2\2\u1dec\u1ded\7\u0198\2\2\u1ded\u1dee\5\u0312")
        buf.write("\u018a\2\u1dee\u1e11\3\2\2\2\u1def\u1df0\7\u023e\2\2\u1df0")
        buf.write("\u1dfc\5\u02ec\u0177\2\u1df1\u1df2\7\u0255\2\2\u1df2\u1df7")
        buf.write("\5\u02fa\u017e\2\u1df3\u1df4\7\u024f\2\2\u1df4\u1df6\5")
        buf.write("\u02fa\u017e\2\u1df5\u1df3\3\2\2\2\u1df6\u1df9\3\2\2\2")
        buf.write("\u1df7\u1df5\3\2\2\2\u1df7\u1df8\3\2\2\2\u1df8\u1dfa\3")
        buf.write("\2\2\2\u1df9\u1df7\3\2\2\2\u1dfa\u1dfb\7\u0256\2\2\u1dfb")
        buf.write("\u1dfd\3\2\2\2\u1dfc\u1df1\3\2\2\2\u1dfc\u1dfd\3\2\2\2")
        buf.write("\u1dfd\u1e11\3\2\2\2\u1dfe\u1e00\7\u0197\2\2\u1dff\u1e01")
        buf.write("\5:\36\2\u1e00\u1dff\3\2\2\2\u1e00\u1e01\3\2\2\2\u1e01")
        buf.write("\u1e03\3\2\2\2\u1e02\u1e04\t\7\2\2\u1e03\u1e02\3\2\2\2")
        buf.write("\u1e03\u1e04\3\2\2\2\u1e04\u1e05\3\2\2\2\u1e05\u1e11\5")
        buf.write("\u02ec\u0177\2\u1e06\u1e08\7\u0094\2\2\u1e07\u1e09\5:")
        buf.write("\36\2\u1e08\u1e07\3\2\2\2\u1e08\u1e09\3\2\2\2\u1e09\u1e0b")
        buf.write("\3\2\2\2\u1e0a\u1e0c\t\7\2\2\u1e0b\u1e0a\3\2\2\2\u1e0b")
        buf.write("\u1e0c\3\2\2\2\u1e0c\u1e0d\3\2\2\2\u1e0d\u1e11\5\u02ec")
        buf.write("\u0177\2\u1e0e\u1e0f\7!\2\2\u1e0f\u1e11\5\u02ec\u0177")
        buf.write("\2\u1e10\u1de4\3\2\2\2\u1e10\u1def\3\2\2\2\u1e10\u1dfe")
        buf.write("\3\2\2\2\u1e10\u1e06\3\2\2\2\u1e10\u1e0e\3\2\2\2\u1e11")
        buf.write("\u02f9\3\2\2\2\u1e12\u1e13\5\u022c\u0117\2\u1e13\u1e14")
        buf.write("\7\u0264\2\2\u1e14\u1e16\3\2\2\2\u1e15\u1e12\3\2\2\2\u1e15")
        buf.write("\u1e16\3\2\2\2\u1e16\u1e17\3\2\2\2\u1e17\u1e18\5\u024c")
        buf.write("\u0127\2\u1e18\u02fb\3\2\2\2\u1e19\u1e1f\tj\2\2\u1e1a")
        buf.write("\u1e1c\7\u017a\2\2\u1e1b\u1e1d\7\u009d\2\2\u1e1c\u1e1b")
        buf.write("\3\2\2\2\u1e1c\u1e1d\3\2\2\2\u1e1d\u1e1e\3\2\2\2\u1e1e")
        buf.write("\u1e20\7\35\2\2\u1e1f\u1e1a\3\2\2\2\u1e1f\u1e20\3\2\2")
        buf.write("\2\u1e20\u1e23\3\2\2\2\u1e21\u1e23\5\30\r\2\u1e22\u1e19")
        buf.write("\3\2\2\2\u1e22\u1e21\3\2\2\2\u1e23\u02fd\3\2\2\2\u1e24")
        buf.write("\u1e26\7\u0241\2\2\u1e25\u1e27\5\u0300\u0181\2\u1e26\u1e25")
        buf.write("\3\2\2\2\u1e26\u1e27\3\2\2\2\u1e27\u1e30\3\2\2\2\u1e28")
        buf.write("\u1e2d\5\u0154\u00ab\2\u1e29\u1e2a\7\u024f\2\2\u1e2a\u1e2c")
        buf.write("\5\u024c\u0127\2\u1e2b\u1e29\3\2\2\2\u1e2c\u1e2f\3\2\2")
        buf.write("\2\u1e2d\u1e2b\3\2\2\2\u1e2d\u1e2e\3\2\2\2\u1e2e\u1e31")
        buf.write("\3\2\2\2\u1e2f\u1e2d\3\2\2\2\u1e30\u1e28\3\2\2\2\u1e30")
        buf.write("\u1e31\3\2\2\2\u1e31\u1e33\3\2\2\2\u1e32\u1e34\5\u0302")
        buf.write("\u0182\2\u1e33\u1e32\3\2\2\2\u1e33\u1e34\3\2\2\2\u1e34")
        buf.write("\u1e4d\3\2\2\2\u1e35\u1e37\7\u0241\2\2\u1e36\u1e38\5\u0300")
        buf.write("\u0181\2\u1e37\u1e36\3\2\2\2\u1e37\u1e38\3\2\2\2\u1e38")
        buf.write("\u1e39\3\2\2\2\u1e39\u1e3b\5\u022c\u0117\2\u1e3a\u1e3c")
        buf.write("\5\u0302\u0182\2\u1e3b\u1e3a\3\2\2\2\u1e3b\u1e3c\3\2\2")
        buf.write("\2\u1e3c\u1e4d\3\2\2\2\u1e3d\u1e3f\7\u0241\2\2\u1e3e\u1e40")
        buf.write("\5\u0300\u0181\2\u1e3f\u1e3e\3\2\2\2\u1e3f\u1e40\3\2\2")
        buf.write("\2\u1e40\u1e41\3\2\2\2\u1e41\u1e42\7\u0247\2\2\u1e42\u1e44")
        buf.write("\5\u0154\u00ab\2\u1e43\u1e45\5\u0302\u0182\2\u1e44\u1e43")
        buf.write("\3\2\2\2\u1e44\u1e45\3\2\2\2\u1e45\u1e4d\3\2\2\2\u1e46")
        buf.write("\u1e47\7\u022b\2\2\u1e47\u1e4a\5\u024c\u0127\2\u1e48\u1e49")
        buf.write("\7\u024f\2\2\u1e49\u1e4b\5\u024c\u0127\2\u1e4a\u1e48\3")
        buf.write("\2\2\2\u1e4a\u1e4b\3\2\2\2\u1e4b\u1e4d\3\2\2\2\u1e4c\u1e24")
        buf.write("\3\2\2\2\u1e4c\u1e35\3\2\2\2\u1e4c\u1e3d\3\2\2\2\u1e4c")
        buf.write("\u1e46\3\2\2\2\u1e4d\u02ff\3\2\2\2\u1e4e\u1e4f\tk\2\2")
        buf.write("\u1e4f\u0301\3\2\2\2\u1e50\u1e51\7\u01be\2\2\u1e51\u1e52")
        buf.write("\5\u0304\u0183\2\u1e52\u1e53\7\u024c\2\2\u1e53\u1e5b\5")
        buf.write("\u024c\u0127\2\u1e54\u1e55\7\u024f\2\2\u1e55\u1e56\5\u0304")
        buf.write("\u0183\2\u1e56\u1e57\7\u024c\2\2\u1e57\u1e58\5\u024c\u0127")
        buf.write("\2\u1e58\u1e5a\3\2\2\2\u1e59\u1e54\3\2\2\2\u1e5a\u1e5d")
        buf.write("\3\2\2\2\u1e5b\u1e59\3\2\2\2\u1e5b\u1e5c\3\2\2\2\u1e5c")
        buf.write("\u0303\3\2\2\2\u1e5d\u1e5b\3\2\2\2\u1e5e\u1e5f\tl\2\2")
        buf.write("\u1e5f\u0305\3\2\2\2\u1e60\u1e62\7\u0243\2\2\u1e61\u1e63")
        buf.write("\5\u02f0\u0179\2\u1e62\u1e61\3\2\2\2\u1e62\u1e63\3\2\2")
        buf.write("\2\u1e63\u1e6b\3\2\2\2\u1e64\u1e65\7\u0243\2\2\u1e65\u1e66")
        buf.write("\7\u0098\2\2\u1e66\u1e6b\5\u024c\u0127\2\u1e67\u1e68\7")
        buf.write("\u0243\2\2\u1e68\u1e69\7\u0240\2\2\u1e69\u1e6b\5\u0312")
        buf.write("\u018a\2\u1e6a\u1e60\3\2\2\2\u1e6a\u1e64\3\2\2\2\u1e6a")
        buf.write("\u1e67\3\2\2\2\u1e6b\u0307\3\2\2\2\u1e6c\u1e6e\5\u02d8")
        buf.write("\u016d\2\u1e6d\u1e6c\3\2\2\2\u1e6d\u1e6e\3\2\2\2\u1e6e")
        buf.write("\u1e70\3\2\2\2\u1e6f\u1e71\5\u030a\u0186\2\u1e70\u1e6f")
        buf.write("\3\2\2\2\u1e70\u1e71\3\2\2\2\u1e71\u1e72\3\2\2\2\u1e72")
        buf.write("\u1e73\7\u023b\2\2\u1e73\u1e74\5\u02e6\u0174\2\u1e74\u1e75")
        buf.write("\7\u0194\2\2\u1e75\u1e77\7\u023b\2\2\u1e76\u1e78\5\u022c")
        buf.write("\u0117\2\u1e77\u1e76\3\2\2\2\u1e77\u1e78\3\2\2\2\u1e78")
        buf.write("\u1e82\3\2\2\2\u1e79\u1e7b\tm\2\2\u1e7a\u1e7c\5\u0230")
        buf.write("\u0119\2\u1e7b\u1e7a\3\2\2\2\u1e7b\u1e7c\3\2\2\2\u1e7c")
        buf.write("\u1e7f\3\2\2\2\u1e7d\u1e7e\7\u01c0\2\2\u1e7e\u1e80\5\u024c")
        buf.write("\u0127\2\u1e7f\u1e7d\3\2\2\2\u1e7f\u1e80\3\2\2\2\u1e80")
        buf.write("\u1e82\3\2\2\2\u1e81\u1e6d\3\2\2\2\u1e81\u1e79\3\2\2\2")
        buf.write("\u1e82\u0309\3\2\2\2\u1e83\u1e84\7\u024a\2\2\u1e84\u1eb3")
        buf.write("\5\u024c\u0127\2\u1e85\u1e86\7\u0198\2\2\u1e86\u1e87\5")
        buf.write("\u022c\u0117\2\u1e87\u1e89\7\u019e\2\2\u1e88\u1e8a\7\u0244")
        buf.write("\2\2\u1e89\u1e88\3\2\2\2\u1e89\u1e8a\3\2\2\2\u1e8a\u1e8b")
        buf.write("\3\2\2\2\u1e8b\u1e8c\5\u024c\u0127\2\u1e8c\u1e8d\7\u0267")
        buf.write("\2\2\u1e8d\u1e90\5\u024c\u0127\2\u1e8e\u1e8f\7\26\2\2")
        buf.write("\u1e8f\u1e91\5\u024c\u0127\2\u1e90\u1e8e\3\2\2\2\u1e90")
        buf.write("\u1e91\3\2\2\2\u1e91\u1eb3\3\2\2\2\u1e92\u1e93\7\u0198")
        buf.write("\2\2\u1e93\u1e94\5\u02d0\u0169\2\u1e94\u1e95\7\u019e\2")
        buf.write("\2\u1e95\u1e96\5\u0312\u018a\2\u1e96\u1eb3\3\2\2\2\u1e97")
        buf.write("\u1e98\7\u0198\2\2\u1e98\u1e99\5\u022c\u0117\2\u1e99\u1e9a")
        buf.write("\7\u019e\2\2\u1e9a\u1ea6\5\u022c\u0117\2\u1e9b\u1e9c\7")
        buf.write("\u0255\2\2\u1e9c\u1ea1\5\u02fa\u017e\2\u1e9d\u1e9e\7\u024f")
        buf.write("\2\2\u1e9e\u1ea0\5\u02fa\u017e\2\u1e9f\u1e9d\3\2\2\2\u1ea0")
        buf.write("\u1ea3\3\2\2\2\u1ea1\u1e9f\3\2\2\2\u1ea1\u1ea2\3\2\2\2")
        buf.write("\u1ea2\u1ea4\3\2\2\2\u1ea3\u1ea1\3\2\2\2\u1ea4\u1ea5\7")
        buf.write("\u0256\2\2\u1ea5\u1ea7\3\2\2\2\u1ea6\u1e9b\3\2\2\2\u1ea6")
        buf.write("\u1ea7\3\2\2\2\u1ea7\u1eb3\3\2\2\2\u1ea8\u1ea9\7\u0236")
        buf.write("\2\2\u1ea9\u1eac\5\u02d0\u0169\2\u1eaa\u1eab\7\u0246\2")
        buf.write("\2\u1eab\u1ead\7\u026c\2\2\u1eac\u1eaa\3\2\2\2\u1eac\u1ead")
        buf.write("\3\2\2\2\u1ead\u1eae\3\2\2\2\u1eae\u1eaf\7\u019e\2\2\u1eaf")
        buf.write("\u1eb0\7\u017c\2\2\u1eb0\u1eb1\5\u024c\u0127\2\u1eb1\u1eb3")
        buf.write("\3\2\2\2\u1eb2\u1e83\3\2\2\2\u1eb2\u1e85\3\2\2\2\u1eb2")
        buf.write("\u1e92\3\2\2\2\u1eb2\u1e97\3\2\2\2\u1eb2\u1ea8\3\2\2\2")
        buf.write("\u1eb3\u030b\3\2\2\2\u1eb4\u1eb5\7\u01be\2\2\u1eb5\u1eba")
        buf.write("\5\u024c\u0127\2\u1eb6\u1eb7\7\u024f\2\2\u1eb7\u1eb9\5")
        buf.write("\u024c\u0127\2\u1eb8\u1eb6\3\2\2\2\u1eb9\u1ebc\3\2\2\2")
        buf.write("\u1eba\u1eb8\3\2\2\2\u1eba\u1ebb\3\2\2\2\u1ebb\u030d\3")
        buf.write("\2\2\2\u1ebc\u1eba\3\2\2\2\u1ebd\u1ebe\7j\2\2\u1ebe\u1ebf")
        buf.write("\5\u024c\u0127\2\u1ebf\u1ec0\7\u01b7\2\2\u1ec0\u1ec8\5")
        buf.write("\u02e6\u0174\2\u1ec1\u1ec2\tn\2\2\u1ec2\u1ec3\5\u024c")
        buf.write("\u0127\2\u1ec3\u1ec4\7\u01b7\2\2\u1ec4\u1ec5\5\u02e6\u0174")
        buf.write("\2\u1ec5\u1ec7\3\2\2\2\u1ec6\u1ec1\3\2\2\2\u1ec7\u1eca")
        buf.write("\3\2\2\2\u1ec8\u1ec6\3\2\2\2\u1ec8\u1ec9\3\2\2\2\u1ec9")
        buf.write("\u1ecd\3\2\2\2\u1eca\u1ec8\3\2\2\2\u1ecb\u1ecc\7\u0193")
        buf.write("\2\2\u1ecc\u1ece\5\u02e6\u0174\2\u1ecd\u1ecb\3\2\2\2\u1ecd")
        buf.write("\u1ece\3\2\2\2\u1ece\u1ecf\3\2\2\2\u1ecf\u1ed0\7\u0194")
        buf.write("\2\2\u1ed0\u1ed1\7j\2\2\u1ed1\u030f\3\2\2\2\u1ed2\u1ed4")
        buf.write("\7\u0181\2\2\u1ed3\u1ed5\5\u024c\u0127\2\u1ed4\u1ed3\3")
        buf.write("\2\2\2\u1ed4\u1ed5\3\2\2\2\u1ed5\u1ee2\3\2\2\2\u1ed6\u1ed7")
        buf.write("\7\u01c0\2\2\u1ed7\u1edc\5\u024c\u0127\2\u1ed8\u1ed9\7")
        buf.write("\u024f\2\2\u1ed9\u1edb\5\u024c\u0127\2\u1eda\u1ed8\3\2")
        buf.write("\2\2\u1edb\u1ede\3\2\2\2\u1edc\u1eda\3\2\2\2\u1edc\u1edd")
        buf.write("\3\2\2\2\u1edd\u1edf\3\2\2\2\u1ede\u1edc\3\2\2\2\u1edf")
        buf.write("\u1ee0\7\u01b7\2\2\u1ee0\u1ee1\5\u02e6\u0174\2\u1ee1\u1ee3")
        buf.write("\3\2\2\2\u1ee2\u1ed6\3\2\2\2\u1ee3\u1ee4\3\2\2\2\u1ee4")
        buf.write("\u1ee2\3\2\2\2\u1ee4\u1ee5\3\2\2\2\u1ee5\u1ee8\3\2\2\2")
        buf.write("\u1ee6\u1ee7\7\u0193\2\2\u1ee7\u1ee9\5\u02e6\u0174\2\u1ee8")
        buf.write("\u1ee6\3\2\2\2\u1ee8\u1ee9\3\2\2\2\u1ee9\u1eea\3\2\2\2")
        buf.write("\u1eea\u1eeb\7\u0194\2\2\u1eeb\u1eec\7\u0181\2\2\u1eec")
        buf.write("\u0311\3\2\2\2\u1eed\u1ef2\5\20\t\2\u1eee\u1ef2\5\u02f4")
        buf.write("\u017b\2\u1eef\u1ef2\5(\25\2\u1ef0\u1ef2\5 \21\2\u1ef1")
        buf.write("\u1eed\3\2\2\2\u1ef1\u1eee\3\2\2\2\u1ef1\u1eef\3\2\2\2")
        buf.write("\u1ef1\u1ef0\3\2\2\2\u1ef2\u0313\3\2\2\2\u043c\u0315\u031a")
        buf.write("\u0321\u0324\u0328\u0331\u033b\u0341\u0345\u034a\u0351")
        buf.write("\u0359\u035f\u0363\u0369\u036b\u0372\u0375\u0379\u037d")
        buf.write("\u0380\u0386\u038c\u038e\u0396\u039a\u039e\u03a9\u03b0")
        buf.write("\u03b3\u03b7\u03be\u03c5\u03c8\u03d3\u03d6\u03dc\u03e0")
        buf.write("\u03e3\u03e9\u03f3\u03fb\u0404\u040a\u040d\u0411\u041a")
        buf.write("\u041c\u0423\u0427\u042d\u0431\u0438\u0440\u0446\u044b")
        buf.write("\u044e\u0458\u045d\u046a\u0473\u0477\u047a\u0482\u0487")
        buf.write("\u0491\u0493\u049d\u04a2\u04a7\u04aa\u04ad\u04b0\u04b5")
        buf.write("\u04be\u04c9\u04cd\u04d1\u04d6\u04dd\u04e7\u04ec\u04f4")
        buf.write("\u04fa\u04fd\u0500\u0503\u0505\u0509\u050d\u0511\u0519")
        buf.write("\u0520\u0526\u052a\u052c\u0531\u055b\u0562\u0587\u0596")
        buf.write("\u059f\u05a5\u05ad\u05b1\u05b8\u05bc\u05be\u05c0\u05c3")
        buf.write("\u05c8\u05ce\u05d4\u05df\u05e1\u05e5\u0606\u0619\u0641")
        buf.write("\u0648\u064e\u0651\u0655\u0658\u065c\u0663\u0668\u067e")
        buf.write("\u0682\u0685\u068a\u068d\u0691\u0695\u069e\u06a7\u06b9")
        buf.write("\u06e2\u06e8\u06eb\u06ed\u06f1\u06f6\u06fa\u0702\u0709")
        buf.write("\u070e\u071c\u071e\u0724\u072c\u0730\u0737\u073d\u0740")
        buf.write("\u0742\u074d\u0751\u0754\u075e\u0769\u0771\u0775\u0785")
        buf.write("\u078c\u0793\u0798\u079c\u07a9\u07ad\u07b4\u07bc\u07c0")
        buf.write("\u07cb\u07d2\u07d7\u07de\u07e0\u07e7\u07f2\u07f7\u07f9")
        buf.write("\u0800\u0802\u080a\u080c\u0813\u0815\u0819\u081d\u0825")
        buf.write("\u082b\u082e\u0830\u0832\u0837\u083b\u0842\u0849\u0850")
        buf.write("\u085c\u0861\u086f\u0873\u0879\u0880\u088b\u088e\u0892")
        buf.write("\u0899\u08a1\u08a9\u08ba\u08c4\u08c8\u08d1\u08d6\u08de")
        buf.write("\u08eb\u08f5\u08fa\u0907\u0913\u091b\u0922\u092a\u0934")
        buf.write("\u0940\u0947\u0952\u0956\u095d\u0960\u0965\u0969\u0970")
        buf.write("\u0975\u0978\u097a\u0982\u098c\u0990\u0993\u0996\u099a")
        buf.write("\u09a1\u09a5\u09a8\u09ab\u09ae\u09b6\u09bd\u09c5\u09ca")
        buf.write("\u09cd\u09d0\u09d9\u09e3\u09e7\u09eb\u09f0\u09f2\u09f7")
        buf.write("\u09f9\u09fc\u0a00\u0a03\u0a06\u0a0e\u0a12\u0a14\u0a24")
        buf.write("\u0a29\u0a2d\u0a2f\u0a3e\u0a41\u0a4b\u0a4e\u0a62\u0a74")
        buf.write("\u0a78\u0a7c\u0a83\u0a86\u0aa3\u0ac1\u0ac5\u0aca\u0acf")
        buf.write("\u0ad6\u0ad8\u0add\u0ae2\u0ae6\u0aed\u0afb\u0b0f\u0b1d")
        buf.write("\u0b26\u0b40\u0b49\u0b4f\u0b5a\u0b5d\u0b60\u0b69\u0b6f")
        buf.write("\u0b74\u0b79\u0b7e\u0b83\u0b8a\u0b8f\u0b98\u0b9d\u0b9f")
        buf.write("\u0ba3\u0ba8\u0bb0\u0bba\u0bc4\u0bc9\u0bd6\u0bf0\u0bf3")
        buf.write("\u0bf6\u0bf9\u0c06\u0c10\u0c18\u0c28\u0c2e\u0c31\u0c35")
        buf.write("\u0c43\u0c48\u0c51\u0c56\u0c62\u0c66\u0c6a\u0c71\u0c75")
        buf.write("\u0c7b\u0c80\u0c86\u0c8e\u0c91\u0c95\u0cb5\u0cbb\u0cbe")
        buf.write("\u0cc3\u0cc7\u0cd4\u0cd9\u0cde\u0ce7\u0cf2\u0cf5\u0cfa")
        buf.write("\u0cff\u0d01\u0d05\u0d0b\u0d16\u0d1b\u0d1f\u0d26\u0d37")
        buf.write("\u0d3d\u0d46\u0d4b\u0d58\u0d60\u0d75\u0d79\u0d7e\u0d86")
        buf.write("\u0d93\u0dcb\u0dd3\u0ddc\u0deb\u0def\u0df5\u0dfc\u0e04")
        buf.write("\u0e09\u0e12\u0e14\u0e1b\u0e1f\u0e23\u0e2e\u0e32\u0e3c")
        buf.write("\u0e41\u0e45\u0e4c\u0e4f\u0e57\u0e5c\u0e61\u0e63\u0e66")
        buf.write("\u0e6a\u0e70\u0e73\u0e76\u0e7b\u0e7d\u0e81\u0e84\u0e87")
        buf.write("\u0e90\u0e9c\u0e9e\u0ea2\u0eac\u0eaf\u0eb2\u0ec8\u0ed2")
        buf.write("\u0ee2\u0ee9\u0ef6\u0efb\u0f09\u0f12\u0f18\u0f1e\u0f20")
        buf.write("\u0f27\u0f2c\u0f33\u0f37\u0f41\u0f48\u0f4a\u0f51\u0f69")
        buf.write("\u0f7d\u0f87\u0f99\u0fcf\u0fdf\u0fe7\u0fec\u0ffe\u1002")
        buf.write("\u1009\u100b\u1012\u1015\u1022\u1033\u1036\u1039\u103c")
        buf.write("\u1047\u104e\u1053\u1056\u1059\u105e\u1063\u1067\u106d")
        buf.write("\u1077\u107e\u1084\u1088\u108e\u1094\u1097\u109c\u10a4")
        buf.write("\u10a7\u10ab\u10b3\u10b7\u10bf\u10c2\u10c6\u10cb\u10dd")
        buf.write("\u10e0\u10e4\u10e9\u10eb\u10ef\u10f5\u10fe\u110a\u110f")
        buf.write("\u1117\u1128\u112e\u1132\u113a\u1152\u115b\u115e\u1169")
        buf.write("\u1170\u1175\u1177\u117a\u117e\u1185\u118a\u118c\u1193")
        buf.write("\u1199\u119f\u11a8\u11b0\u11b9\u11be\u11c1\u11c9\u11d0")
        buf.write("\u11d5\u11d7\u11da\u11e0\u11ea\u11ef\u11f5\u11f8\u1208")
        buf.write("\u1213\u1219\u121c\u122d\u1230\u1233\u1237\u123f\u1245")
        buf.write("\u124f\u1255\u1259\u125c\u1263\u1265\u1269\u1271\u1275")
        buf.write("\u1279\u127c\u1283\u1285\u1289\u128e\u1292\u1297\u129b")
        buf.write("\u129f\u12a4\u12a9\u12b3\u12bb\u12cd\u12d1\u12d4\u12d7")
        buf.write("\u12da\u12de\u12e2\u12e6\u12ea\u12ed\u12f2\u12f6\u12f9")
        buf.write("\u1308\u130f\u1317\u131c\u131e\u1322\u1327\u132a\u132f")
        buf.write("\u1332\u1337\u133a\u133e\u1343\u1349\u134d\u1351\u1356")
        buf.write("\u135a\u135c\u135f\u1363\u1367\u136c\u1370\u1373\u1376")
        buf.write("\u1379\u137c\u1380\u1384\u1388\u138c\u138f\u1392\u1395")
        buf.write("\u139b\u139f\u13a2\u13a7\u13ac\u13b3\u13b9\u13c1\u13ca")
        buf.write("\u13dc\u13e4\u13ef\u13f2\u13f7\u13fc\u1409\u1410\u1415")
        buf.write("\u141e\u1424\u1428\u142c\u1434\u1440\u1443\u1448\u144d")
        buf.write("\u1451\u1456\u1459\u145e\u1466\u146a\u146d\u1472\u147f")
        buf.write("\u1486\u148b\u1490\u1497\u1499\u14a2\u14a5\u14ab\u14ae")
        buf.write("\u14bc\u14cb\u14da\u14df\u14e2\u14e8\u14ea\u14f5\u14fe")
        buf.write("\u1506\u150b\u1515\u151e\u1527\u152e\u1535\u1548\u154a")
        buf.write("\u1555\u155f\u1562\u1569\u156e\u1573\u157d\u1581\u1584")
        buf.write("\u1588\u158c\u1591\u1595\u1599\u159c\u15a0\u15a6\u15aa")
        buf.write("\u15b0\u15bc\u15c4\u15c7\u15cb\u15db\u15e0\u15e4\u15e9")
        buf.write("\u15ee\u15f3\u15fa\u160b\u1612\u1616\u161b\u1620\u1622")
        buf.write("\u1626\u162d\u1630\u1635\u1639\u163f\u1645\u1648\u164b")
        buf.write("\u164f\u1652\u1656\u1659\u165d\u1663\u1668\u166c\u1671")
        buf.write("\u1675\u167e\u1683\u1685\u16a2\u16ac\u16b5\u16bd\u16c9")
        buf.write("\u16df\u16e3\u16eb\u16f1\u16f6\u16fc\u1708\u171c\u1726")
        buf.write("\u1729\u1730\u1734\u1739\u173f\u1745\u1750\u1752\u175a")
        buf.write("\u1762\u176c\u1781\u178e\u1794\u179a\u17a1\u17a3\u17ae")
        buf.write("\u17b8\u17cb\u17d8\u17dd\u17e5\u17ee\u17f2\u1800\u1807")
        buf.write("\u180b\u180d\u1816\u1819\u181e\u1820\u1828\u182b\u1830")
        buf.write("\u183d\u1849\u184c\u184f\u1855\u1861\u1866\u186a\u186e")
        buf.write("\u1872\u1874\u1879\u1880\u1885\u1887\u1892\u1897\u189b")
        buf.write("\u18af\u18b9\u18c5\u18cb\u18cf\u18d4\u18da\u18e4\u18ea")
        buf.write("\u18ee\u18f9\u1905\u190d\u190f\u1919\u191e\u193e\u1944")
        buf.write("\u194a\u194f\u1957\u195c\u1962\u1966\u1969\u196c\u1970")
        buf.write("\u1976\u1982\u1985\u1988\u198b\u1996\u199f\u19a1\u19a8")
        buf.write("\u19ad\u19b2\u19b7\u19bb\u19be\u19c9\u19cb\u19d2\u19d4")
        buf.write("\u19dd\u19e3\u19ea\u19ef\u19f4\u19fa\u1a04\u1a0c\u1a0f")
        buf.write("\u1a14\u1a16\u1a19\u1a1f\u1a24\u1a2b\u1a35\u1a3a\u1a3e")
        buf.write("\u1a41\u1a4d\u1a52\u1a57\u1a5d\u1a64\u1a67\u1a72\u1a77")
        buf.write("\u1a79\u1a7c\u1a7f\u1a87\u1a8a\u1a8e\u1a91\u1a95\u1aa2")
        buf.write("\u1aa5\u1aa9\u1aad\u1ab0\u1ab7\u1abe\u1ac2\u1ac5\u1ace")
        buf.write("\u1ad1\u1adc\u1ade\u1ae6\u1ae8\u1af3\u1af5\u1afc\u1afe")
        buf.write("\u1b02\u1b06\u1b09\u1b13\u1b19\u1b1b\u1b1e\u1b24\u1b29")
        buf.write("\u1b2e\u1b37\u1b3d\u1b3f\u1b42\u1b4a\u1b50\u1b54\u1b5a")
        buf.write("\u1b5d\u1b66\u1b6b\u1b6d\u1b6f\u1b72\u1b7b\u1b80\u1b8b")
        buf.write("\u1b99\u1ba3\u1ba9\u1bb1\u1bb7\u1bbc\u1bc0\u1bcc\u1bd1")
        buf.write("\u1bd4\u1bda\u1be0\u1be7\u1bec\u1bef\u1bf4\u1bf9\u1bfc")
        buf.write("\u1c00\u1c08\u1c0f\u1c13\u1c18\u1c24\u1c29\u1c2b\u1c2e")
        buf.write("\u1c33\u1c37\u1c3a\u1c3d\u1c45\u1c48\u1c4f\u1c51\u1c55")
        buf.write("\u1c58\u1c5c\u1c60\u1c63\u1c66\u1c6e\u1c77\u1c7a\u1c81")
        buf.write("\u1c83\u1c87\u1c8d\u1c95\u1c9b\u1ca0\u1ca5\u1ca9\u1cae")
        buf.write("\u1cb0\u1cb6\u1cba\u1cc1\u1cc6\u1cc9\u1cd0\u1cd7\u1cd9")
        buf.write("\u1ce1\u1ce3\u1ce9\u1cec\u1cef\u1cf4\u1cf8\u1d02\u1d08")
        buf.write("\u1d10\u1d14\u1d18\u1d1c\u1d22\u1d25\u1d28\u1d2f\u1d33")
        buf.write("\u1d3d\u1d49\u1d53\u1d5a\u1d66\u1d6d\u1d75\u1d79\u1d7d")
        buf.write("\u1d85\u1d94\u1d99\u1d9b\u1da4\u1da7\u1dab\u1dae\u1db2")
        buf.write("\u1dbf\u1dc2\u1dc6\u1dc9\u1dce\u1dd5\u1dda\u1de2\u1de7")
        buf.write("\u1dea\u1df7\u1dfc\u1e00\u1e03\u1e08\u1e0b\u1e10\u1e15")
        buf.write("\u1e1c\u1e1f\u1e22\u1e26\u1e2d\u1e30\u1e33\u1e37\u1e3b")
        buf.write("\u1e3f\u1e44\u1e4a\u1e4c\u1e5b\u1e62\u1e6a\u1e6d\u1e70")
        buf.write("\u1e77\u1e7b\u1e7f\u1e81\u1e89\u1e90\u1ea1\u1ea6\u1eac")
        buf.write("\u1eb2\u1eba\u1ec8\u1ecd\u1ed4\u1edc\u1ee4\u1ee8\u1ef1")
        return buf.getvalue()


class postgreSQLParser ( Parser ):

    grammarFileName = "postgreSQLParser.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "'='", "':'", "';'", "','", 
                     "<INVALID>", "'<'", "'<='", "'>'", "'>='", "'('", "')'", 
                     "'+'", "'-'", "'*'", "'/'", "'%'", "'^'", "'.'", "'''", 
                     "'\"'", "'$'", "'['", "']'", "'=>'", "':='", "'<<'", 
                     "'>>'", "'..'", "'#'", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                     "<INVALID>", "<INVALID>", "<INVALID>", "' '", "<INVALID>", 
                     "<INVALID>", "'\u0009'", "'\uFEFF'" ]

    symbolicNames = [ "<INVALID>", "ABORT", "ABSOLUTE", "ACCESS", "ACTION", 
                      "ADD", "ADMIN", "AFTER", "AGGREGATE", "ALSO", "ALTER", 
                      "ALWAYS", "ASSERTION", "ASSIGNMENT", "AT", "ATTACH", 
                      "ATTRIBUTE", "BACKWARD", "BEFORE", "BEGIN", "BY", 
                      "CACHE", "CALL", "CALLED", "CASCADE", "CASCADED", 
                      "CATALOG", "CHAIN", "CHARACTERISTICS", "CHECKPOINT", 
                      "CLASS", "CLOSE", "CLUSTER", "COLUMNS", "COMMENT", 
                      "COMMENTS", "COMMIT", "COMMITTED", "CONFIGURATION", 
                      "CONFLICT", "CONNECTION", "CONSTRAINTS", "CONTENT", 
                      "CONTINUE", "CONVERSION", "COPY", "COST", "CSV", "CUBE", 
                      "CURRENT", "CURSOR", "CYCLE", "DATA", "DATABASE", 
                      "DAY", "DEALLOCATE", "DECLARE", "DEFAULTS", "DEFERRED", 
                      "DEFINER", "DELETE", "DELIMITER", "DELIMITERS", "DEPENDS", 
                      "DETACH", "DICTIONARY", "DISABLE", "DISCARD", "DOCUMENT", 
                      "DOMAIN", "DOUBLE", "DROP", "EACH", "ENABLE", "ENCODING", 
                      "ENCRYPTED", "ENUM", "ESCAPE", "EVENT", "EXCLUDE", 
                      "EXCLUDING", "EXCLUSIVE", "EXECUTE", "EXPLAIN", "EXPRESSION", 
                      "EXTENSION", "EXTERNAL", "FAMILY", "FILTER", "FIRST", 
                      "FOLLOWING", "FORCE", "FORWARD", "FUNCTION", "FUNCTIONS", 
                      "GENERATED", "GLOBAL", "GRANTED", "GROUPS", "HANDLER", 
                      "HEADER", "HOLD", "HOUR", "IDENTITY", "IF", "IMMEDIATE", 
                      "IMMUTABLE", "IMPLICIT", "IMPORT", "INCLUDE", "INCLUDING", 
                      "INCREMENT", "INDEX", "INDEXES", "INHERIT", "INHERITS", 
                      "INLINE", "INPUT", "INSENSITIVE", "INSERT", "INSTEAD", 
                      "INVOKER", "ISOLATION", "KEY", "LABEL", "LANGUAGE", 
                      "LARGE", "LAST", "LEAKPROOF", "LEVEL", "LISTEN", "LOAD", 
                      "LOCAL", "LOCATION", "LOCK", "LOCKED", "LOGGED", "MAPPING", 
                      "MATCH", "MATERIALIZED", "MAXVALUE", "METHOD", "MINUTE", 
                      "MINVALUE", "MODE", "MONTH", "MOVE", "NAME", "NAMES", 
                      "NEW", "NEXT", "NFC", "NFD", "NFKC", "NFKD", "NO", 
                      "NORMALIZED", "NOTHING", "NOTIFY", "NOWAIT", "NULLS", 
                      "OBJECT", "OF", "OFF", "OIDS", "OLD", "OPERATOR", 
                      "OPTION", "OPTIONS", "ORDINALITY", "OTHERS", "OVER", 
                      "OVERRIDING", "OWNED", "OWNER", "PARALLEL", "PARSER", 
                      "PARTIAL", "PARTITION", "PASSING", "PASSWORD", "PLANS", 
                      "POLICY", "PRECEDING", "PREPARE", "PREPARED", "PRESERVE", 
                      "PRIOR", "PRIVILEGES", "PROCEDURAL", "PROCEDURE", 
                      "PROCEDURES", "PROGRAM", "PUBLICATION", "QUOTE", "RANGE", 
                      "READ", "REASSIGN", "RECHECK", "RECURSIVE", "REF", 
                      "REFERENCING", "REFRESH", "REINDEX", "RELATIVE", "RELEASE", 
                      "RENAME", "REPEATABLE", "REPLACE", "REPLICA", "RESET", 
                      "RESTART", "RESTRICT", "RETURNS", "REVOKE", "ROLE", 
                      "ROLLBACK", "ROLLUP", "ROUTINE", "ROUTINES", "ROWS", 
                      "RULE", "SAVEPOINT", "SCHEMA", "SCHEMAS", "SCROLL", 
                      "SEARCH", "SECOND", "SECURITY", "SEQUENCE", "SEQUENCES", 
                      "SERIALIZABLE", "SERVER", "SESSION", "SET", "SETS", 
                      "SHARE", "SHOW", "SIMPLE", "SKIP_", "SNAPSHOT", "SQL", 
                      "STABLE", "STANDALONE", "START", "STATEMENT", "STATISTICS", 
                      "STDIN", "STDOUT", "STORAGE", "STORED", "STRICT", 
                      "STRIP", "SUBSCRIPTION", "SUPPORT", "SYSID", "SYSTEM", 
                      "TABLES", "TABLESPACE", "TEMP", "TEMPLATE", "TEMPORARY", 
                      "TEXT", "TIES", "TRANSACTION", "TRANSFORM", "TRIGGER", 
                      "TRUNCATE", "TRUSTED", "TYPE", "TYPES", "UESCAPE", 
                      "UNBOUNDED", "UNCOMMITTED", "UNENCRYPTED", "UNKNOWN", 
                      "UNLISTEN", "UNLOGGED", "UNTIL", "UPDATE", "VACUUM", 
                      "VALID", "VALIDATE", "VALIDATOR", "VALUE", "VARYING", 
                      "VERSION", "VIEW", "VIEWS", "VOLATILE", "WHITESPACE", 
                      "WITHIN", "WITHOUT", "WORK", "WRAPPER", "WRITE", "XML", 
                      "YEAR", "YES", "ZONE", "BETWEEN", "BIGINT", "BIT", 
                      "BOOLEAN", "CHAR", "CHARACTER", "COALESCE", "DEC", 
                      "DECIMAL", "EXISTS", "EXTRACT", "FLOAT", "GREATEST", 
                      "GROUPING", "INOUT", "INT", "INTEGER", "INTERVAL", 
                      "LEAST", "NATIONAL", "NCHAR", "NONE", "NORMALIZE", 
                      "NULLIF", "NUMERIC", "OUT", "OVERLAY", "POSITION", 
                      "PRECISION", "REAL", "ROW", "SETOF", "SMALLINT", "SUBSTRING", 
                      "TIME", "TIMESTAMP", "TREAT", "TRIM", "VALUES", "VARCHAR", 
                      "XMLATTRIBUTES", "XMLCONCAT", "XMLELEMENT", "XMLEXISTS", 
                      "XMLFOREST", "XMLNAMESPACES", "XMLPARSE", "XMLPI", 
                      "XMLROOT", "XMLSERIALIZE", "XMLTABLE", "AUTHORIZATION", 
                      "BINARY", "COLLATION", "CONCURRENTLY", "CROSS", "CURRENT_SCHEMA", 
                      "FREEZE", "FULL", "ILIKE", "INNER", "IS", "ISNULL", 
                      "JOIN", "LEFT", "LIKE", "NATURAL", "NOTNULL", "OUTER", 
                      "OVERLAPS", "RIGHT", "SIMILAR", "TABLESAMPLE", "VERBOSE", 
                      "ALL", "ANALYZE", "AND", "ANY", "ARRAY", "AS", "ASC", 
                      "ASYMMETRIC", "BOTH", "CASE", "CAST", "CHECK", "COLLATE", 
                      "COLUMN", "CONSTRAINT", "CREATE", "CURRENT_CATALOG", 
                      "CURRENT_DATE", "CURRENT_ROLE", "CURRENT_TIME", "CURRENT_TIMESTAMP", 
                      "CURRENT_USER", "DEFAULT", "DEFERRABLE", "DESC", "DISTINCT", 
                      "DO", "ELSE", "END", "EXCEPT", "FALSE", "FETCH", "FOR", 
                      "FOREIGN", "FROM", "GRANT", "GROUP", "HAVING", "IN", 
                      "INITIALLY", "INTERSECT", "INTO", "LATERAL", "LEADING", 
                      "LIMIT", "LOCALTIME", "LOCALTIMESTAMP", "NOT", "NULL", 
                      "OFFSET", "ON", "ONLY", "OR", "ORDER", "PLACING", 
                      "PRIMARY", "REFERENCES", "RETURNING", "SELECT", "SESSION_USER", 
                      "SOME", "SYMMETRIC", "TABLE", "THEN", "TO", "TRAILING", 
                      "TRUE", "UNION", "UNIQUE", "USER", "USING", "VARIADIC", 
                      "WHEN", "WHERE", "WINDOW", "WITH", "ALIGNMENT", "ALLOW_CONNECTIONS", 
                      "BASETYPE", "BUFFERS", "BYPASSRLS", "CANONICAL", "CATEGORY", 
                      "COLLATABLE", "COMBINEFUNC", "COMMUTATOR", "CONNECT", 
                      "COSTS", "CREATEDB", "CREATEROLE", "DESERIALFUNC", 
                      "DETERMINISTIC", "DISABLE_PAGE_SKIPPING", "ELEMENT", 
                      "EXTENDED", "FINALFUNC", "FINALFUNC_EXTRA", "FINALFUNC_MODIFY", 
                      "FORCE_NOT_NULL", "FORCE_NULL", "FORCE_QUOTE", "FORMAT", 
                      "GETTOKEN", "HASH", "HASHES", "HEADLINE", "HYPOTHETICAL", 
                      "INDEX_CLEANUP", "INIT", "INITCOND", "INTERNALLENGTH", 
                      "IS_TEMPLATE", "JSON", "LC_COLLATE", "LC_CTYPE", "LEFTARG", 
                      "LEXIZE", "LEXTYPES", "LIST", "LOCALE", "LOGIN", "MAIN", 
                      "MERGES", "MFINALFUNC", "MFINALFUNC_EXTRA", "MFINALFUNC_MODIFY", 
                      "MINITCOND", "MINVFUNC", "MODULUS", "MSFUNC", "MSSPACE", 
                      "MSTYPE", "NEGATOR", "NOBYPASSRLS", "NOCREATEDB", 
                      "NOCREATEROLE", "NOINHERIT", "NOLOGIN", "NOREPLICATION", 
                      "NOSUPERUSER", "OUTPUT", "PASSEDBYVALUE", "PATH", 
                      "PERMISSIVE", "PLAIN", "PREFERRED", "PROVIDER", "READ_ONLY", 
                      "READ_WRITE", "RECEIVE", "REMAINDER", "REPLICATION", 
                      "RESTRICTED", "RESTRICTIVE", "RIGHTARG", "SAFE", "SEND", 
                      "SERIALFUNC", "SETTINGS", "SFUNC", "SHAREABLE", "SKIP_LOCKED", 
                      "SORTOP", "SSPACE", "STYPE", "SUBTYPE_DIFF", "SUBTYPE_OPCLASS", 
                      "SUBTYPE", "SUMMARY", "SUPERUSER", "TIMING", "TYPMOD_IN", 
                      "TYPMOD_OUT", "UNSAFE", "USAGE", "VARIABLE", "WAL", 
                      "YAML", "ALIAS", "ASSERT", "CONSTANT", "DATATYPE", 
                      "DEBUG", "DETAIL", "DIAGNOSTICS", "ELSEIF", "ELSIF", 
                      "ERRCODE", "EXIT", "EXCEPTION", "FOREACH", "GET", 
                      "HINT", "INFO", "LOG", "LOOP", "MESSAGE", "NOTICE", 
                      "OPEN", "PERFORM", "QUERY", "RAISE", "RECORD", "RETURN", 
                      "REVERSE", "ROWTYPE", "SLICE", "SQLSTATE", "STACKED", 
                      "WARNING", "WHILE", "CAST_EXPRESSION", "EQUAL", "COLON", 
                      "SEMI_COLON", "COMMA", "NOT_EQUAL", "LTH", "LEQ", 
                      "GTH", "GEQ", "LEFT_PAREN", "RIGHT_PAREN", "PLUS", 
                      "MINUS", "MULTIPLY", "DIVIDE", "MODULAR", "EXP", "DOT", 
                      "QUOTE_CHAR", "DOUBLE_QUOTE", "DOLLAR", "LEFT_BRACKET", 
                      "RIGHT_BRACKET", "EQUAL_GTH", "COLON_EQUAL", "LESS_LESS", 
                      "GREATER_GREATER", "DOUBLE_DOT", "HASH_SIGN", "BlockComment", 
                      "LineComment", "OP_CHARS", "NUMBER_LITERAL", "REAL_NUMBER", 
                      "DOLLAR_NUMBER", "Identifier", "QuotedIdentifier", 
                      "Character_String_Literal", "BeginDollarStringConstant", 
                      "Space", "White_Space", "New_Line", "Tab", "BOM", 
                      "BAD", "Text_between_Dollar", "EndDollarStringConstant" ]

    RULE_sql = 0
    RULE_qname_parser = 1
    RULE_function_args_parser = 2
    RULE_vex_eof = 3
    RULE_plpgsql_function = 4
    RULE_plpgsql_function_test_list = 5
    RULE_statement = 6
    RULE_data_statement = 7
    RULE_script_statement = 8
    RULE_script_transaction = 9
    RULE_transaction_mode = 10
    RULE_lock_table = 11
    RULE_lock_mode = 12
    RULE_script_additional = 13
    RULE_additional_statement = 14
    RULE_explain_statement = 15
    RULE_explain_query = 16
    RULE_execute_statement = 17
    RULE_declare_statement = 18
    RULE_show_statement = 19
    RULE_explain_option = 20
    RULE_user_name = 21
    RULE_table_cols_list = 22
    RULE_table_cols = 23
    RULE_vacuum_mode = 24
    RULE_vacuum_option = 25
    RULE_analyze_mode = 26
    RULE_boolean_value = 27
    RULE_fetch_move_direction = 28
    RULE_schema_statement = 29
    RULE_schema_create = 30
    RULE_schema_alter = 31
    RULE_schema_drop = 32
    RULE_schema_import = 33
    RULE_alter_function_statement = 34
    RULE_alter_aggregate_statement = 35
    RULE_alter_extension_statement = 36
    RULE_alter_extension_action = 37
    RULE_extension_member_object = 38
    RULE_alter_schema_statement = 39
    RULE_alter_language_statement = 40
    RULE_alter_table_statement = 41
    RULE_table_action = 42
    RULE_column_action = 43
    RULE_identity_body = 44
    RULE_alter_identity = 45
    RULE_storage_option = 46
    RULE_validate_constraint = 47
    RULE_drop_constraint = 48
    RULE_table_deferrable = 49
    RULE_table_initialy_immed = 50
    RULE_function_actions_common = 51
    RULE_function_def = 52
    RULE_alter_index_statement = 53
    RULE_index_def_action = 54
    RULE_alter_default_privileges_statement = 55
    RULE_abbreviated_grant_or_revoke = 56
    RULE_grant_option_for = 57
    RULE_alter_sequence_statement = 58
    RULE_alter_view_statement = 59
    RULE_alter_view_action = 60
    RULE_alter_materialized_view_statement = 61
    RULE_alter_materialized_view_action = 62
    RULE_materialized_view_action = 63
    RULE_alter_event_trigger_statement = 64
    RULE_alter_event_trigger_action = 65
    RULE_alter_type_statement = 66
    RULE_alter_domain_statement = 67
    RULE_alter_server_statement = 68
    RULE_alter_server_action = 69
    RULE_alter_fts_statement = 70
    RULE_alter_fts_configuration = 71
    RULE_type_action = 72
    RULE_type_property = 73
    RULE_set_def_column = 74
    RULE_drop_def = 75
    RULE_create_index_statement = 76
    RULE_index_rest = 77
    RULE_index_sort = 78
    RULE_index_column = 79
    RULE_including_index = 80
    RULE_index_where = 81
    RULE_create_extension_statement = 82
    RULE_create_language_statement = 83
    RULE_create_event_trigger_statement = 84
    RULE_create_type_statement = 85
    RULE_create_domain_statement = 86
    RULE_create_server_statement = 87
    RULE_create_fts_dictionary_statement = 88
    RULE_option_with_value = 89
    RULE_create_fts_configuration_statement = 90
    RULE_create_fts_template_statement = 91
    RULE_create_fts_parser_statement = 92
    RULE_create_collation_statement = 93
    RULE_alter_collation_statement = 94
    RULE_collation_option = 95
    RULE_create_user_mapping_statement = 96
    RULE_alter_user_mapping_statement = 97
    RULE_alter_user_or_role_statement = 98
    RULE_alter_user_or_role_set_reset = 99
    RULE_set_reset_parameter = 100
    RULE_alter_group_statement = 101
    RULE_alter_group_action = 102
    RULE_alter_tablespace_statement = 103
    RULE_alter_owner_statement = 104
    RULE_alter_tablespace_action = 105
    RULE_alter_statistics_statement = 106
    RULE_set_statistics = 107
    RULE_alter_foreign_data_wrapper = 108
    RULE_alter_foreign_data_wrapper_action = 109
    RULE_alter_operator_statement = 110
    RULE_alter_operator_action = 111
    RULE_operator_set_restrict_join = 112
    RULE_drop_user_mapping_statement = 113
    RULE_drop_owned_statement = 114
    RULE_drop_operator_statement = 115
    RULE_target_operator = 116
    RULE_domain_constraint = 117
    RULE_create_transform_statement = 118
    RULE_create_access_method_statement = 119
    RULE_create_user_or_role_statement = 120
    RULE_user_or_role_option = 121
    RULE_user_or_role_option_for_alter = 122
    RULE_user_or_role_or_group_common_option = 123
    RULE_user_or_role_common_option = 124
    RULE_user_or_role_or_group_option_for_create = 125
    RULE_create_group_statement = 126
    RULE_group_option = 127
    RULE_create_tablespace_statement = 128
    RULE_create_statistics_statement = 129
    RULE_create_foreign_data_wrapper_statement = 130
    RULE_option_without_equal = 131
    RULE_create_operator_statement = 132
    RULE_operator_name = 133
    RULE_operator_option = 134
    RULE_create_aggregate_statement = 135
    RULE_aggregate_param = 136
    RULE_set_statement = 137
    RULE_set_action = 138
    RULE_session_local_option = 139
    RULE_set_statement_value = 140
    RULE_create_rewrite_statement = 141
    RULE_rewrite_command = 142
    RULE_create_trigger_statement = 143
    RULE_trigger_referencing = 144
    RULE_when_trigger = 145
    RULE_rule_common = 146
    RULE_rule_member_object = 147
    RULE_columns_permissions = 148
    RULE_table_column_privileges = 149
    RULE_permissions = 150
    RULE_permission = 151
    RULE_other_rules = 152
    RULE_grant_to_rule = 153
    RULE_revoke_from_cascade_restrict = 154
    RULE_roles_names = 155
    RULE_role_name_with_group = 156
    RULE_comment_on_statement = 157
    RULE_security_label = 158
    RULE_comment_member_object = 159
    RULE_label_member_object = 160
    RULE_create_function_statement = 161
    RULE_create_funct_params = 162
    RULE_transform_for_type = 163
    RULE_function_ret_table = 164
    RULE_function_column_name_type = 165
    RULE_function_parameters = 166
    RULE_function_args = 167
    RULE_agg_order = 168
    RULE_character_string = 169
    RULE_function_arguments = 170
    RULE_argmode = 171
    RULE_create_sequence_statement = 172
    RULE_sequence_body = 173
    RULE_signed_number_literal = 174
    RULE_signed_numerical_literal = 175
    RULE_sign = 176
    RULE_create_schema_statement = 177
    RULE_create_policy_statement = 178
    RULE_alter_policy_statement = 179
    RULE_drop_policy_statement = 180
    RULE_create_subscription_statement = 181
    RULE_alter_subscription_statement = 182
    RULE_alter_subscription_action = 183
    RULE_create_cast_statement = 184
    RULE_drop_cast_statement = 185
    RULE_create_operator_family_statement = 186
    RULE_alter_operator_family_statement = 187
    RULE_operator_family_action = 188
    RULE_add_operator_to_family = 189
    RULE_drop_operator_from_family = 190
    RULE_drop_operator_family_statement = 191
    RULE_create_operator_class_statement = 192
    RULE_create_operator_class_option = 193
    RULE_alter_operator_class_statement = 194
    RULE_drop_operator_class_statement = 195
    RULE_create_conversion_statement = 196
    RULE_alter_conversion_statement = 197
    RULE_create_publication_statement = 198
    RULE_alter_publication_statement = 199
    RULE_alter_publication_action = 200
    RULE_only_table_multiply = 201
    RULE_alter_trigger_statement = 202
    RULE_alter_rule_statement = 203
    RULE_copy_statement = 204
    RULE_copy_from_statement = 205
    RULE_copy_to_statement = 206
    RULE_copy_option_list = 207
    RULE_copy_option = 208
    RULE_create_view_statement = 209
    RULE_if_exists = 210
    RULE_if_not_exists = 211
    RULE_view_columns = 212
    RULE_with_check_option = 213
    RULE_create_database_statement = 214
    RULE_create_database_option = 215
    RULE_alter_database_statement = 216
    RULE_alter_database_action = 217
    RULE_alter_database_option = 218
    RULE_create_table_statement = 219
    RULE_create_table_as_statement = 220
    RULE_create_foreign_table_statement = 221
    RULE_define_table = 222
    RULE_define_partition = 223
    RULE_for_values_bound = 224
    RULE_partition_bound_spec = 225
    RULE_partition_bound_part = 226
    RULE_define_columns = 227
    RULE_define_type = 228
    RULE_partition_by = 229
    RULE_partition_method = 230
    RULE_partition_column = 231
    RULE_define_server = 232
    RULE_define_foreign_options = 233
    RULE_foreign_option = 234
    RULE_foreign_option_name = 235
    RULE_list_of_type_column_def = 236
    RULE_table_column_def = 237
    RULE_table_of_type_column_def = 238
    RULE_table_column_definition = 239
    RULE_like_option = 240
    RULE_constraint_common = 241
    RULE_constr_body = 242
    RULE_all_op = 243
    RULE_all_simple_op = 244
    RULE_op_chars = 245
    RULE_index_parameters = 246
    RULE_names_in_parens = 247
    RULE_names_references = 248
    RULE_storage_parameter = 249
    RULE_storage_parameter_option = 250
    RULE_storage_parameter_name = 251
    RULE_with_storage_parameter = 252
    RULE_storage_parameter_oid = 253
    RULE_on_commit = 254
    RULE_table_space = 255
    RULE_set_tablespace = 256
    RULE_action = 257
    RULE_owner_to = 258
    RULE_rename_to = 259
    RULE_set_schema = 260
    RULE_table_column_privilege = 261
    RULE_usage_select_update = 262
    RULE_partition_by_columns = 263
    RULE_cascade_restrict = 264
    RULE_collate_identifier = 265
    RULE_indirection_var = 266
    RULE_dollar_number = 267
    RULE_indirection_list = 268
    RULE_indirection = 269
    RULE_drop_database_statement = 270
    RULE_drop_function_statement = 271
    RULE_drop_trigger_statement = 272
    RULE_drop_rule_statement = 273
    RULE_drop_statements = 274
    RULE_if_exist_names_restrict_cascade = 275
    RULE_id_token = 276
    RULE_identifier = 277
    RULE_identifier_nontype = 278
    RULE_col_label = 279
    RULE_tokens_nonreserved = 280
    RULE_tokens_nonreserved_except_function_type = 281
    RULE_tokens_reserved_except_function_type = 282
    RULE_tokens_reserved = 283
    RULE_tokens_nonkeyword = 284
    RULE_schema_qualified_name_nontype = 285
    RULE_type_list = 286
    RULE_data_type = 287
    RULE_array_type = 288
    RULE_predefined_type = 289
    RULE_interval_field = 290
    RULE_type_length = 291
    RULE_precision_param = 292
    RULE_vex = 293
    RULE_vex_b = 294
    RULE_op = 295
    RULE_all_op_ref = 296
    RULE_datetime_overlaps = 297
    RULE_value_expression_primary = 298
    RULE_unsigned_value_specification = 299
    RULE_unsigned_numeric_literal = 300
    RULE_truth_value = 301
    RULE_case_expression = 302
    RULE_cast_specification = 303
    RULE_function_call = 304
    RULE_vex_or_named_notation = 305
    RULE_pointer = 306
    RULE_function_construct = 307
    RULE_extract_function = 308
    RULE_system_function = 309
    RULE_date_time_function = 310
    RULE_string_value_function = 311
    RULE_xml_function = 312
    RULE_xml_table_column = 313
    RULE_comparison_mod = 314
    RULE_filter_clause = 315
    RULE_window_definition = 316
    RULE_frame_clause = 317
    RULE_frame_bound = 318
    RULE_array_expression = 319
    RULE_array_elements = 320
    RULE_type_coercion = 321
    RULE_schema_qualified_name = 322
    RULE_set_qualifier = 323
    RULE_table_subquery = 324
    RULE_select_stmt = 325
    RULE_after_ops = 326
    RULE_select_stmt_no_parens = 327
    RULE_with_clause = 328
    RULE_with_query = 329
    RULE_select_ops = 330
    RULE_select_ops_no_parens = 331
    RULE_select_primary = 332
    RULE_select_list = 333
    RULE_select_sublist = 334
    RULE_into_table = 335
    RULE_from_item = 336
    RULE_from_primary = 337
    RULE_alias_clause = 338
    RULE_from_function_column_def = 339
    RULE_groupby_clause = 340
    RULE_grouping_element_list = 341
    RULE_grouping_element = 342
    RULE_values_stmt = 343
    RULE_values_values = 344
    RULE_orderby_clause = 345
    RULE_sort_specifier = 346
    RULE_order_specification = 347
    RULE_null_ordering = 348
    RULE_insert_stmt_for_psql = 349
    RULE_insert_columns = 350
    RULE_indirection_identifier = 351
    RULE_conflict_object = 352
    RULE_conflict_action = 353
    RULE_delete_stmt_for_psql = 354
    RULE_update_stmt_for_psql = 355
    RULE_update_set = 356
    RULE_notify_stmt = 357
    RULE_truncate_stmt = 358
    RULE_identifier_list = 359
    RULE_anonymous_block = 360
    RULE_comp_options = 361
    RULE_function_block = 362
    RULE_start_label = 363
    RULE_declarations = 364
    RULE_declaration = 365
    RULE_type_declaration = 366
    RULE_arguments_list = 367
    RULE_data_type_dec = 368
    RULE_exception_statement = 369
    RULE_function_statements = 370
    RULE_function_statement = 371
    RULE_base_statement = 372
    RULE_var = 373
    RULE_diagnostic_option = 374
    RULE_perform_stmt = 375
    RULE_assign_stmt = 376
    RULE_execute_stmt = 377
    RULE_control_statement = 378
    RULE_cursor_statement = 379
    RULE_option = 380
    RULE_transaction_statement = 381
    RULE_message_statement = 382
    RULE_log_level = 383
    RULE_raise_using = 384
    RULE_raise_param = 385
    RULE_return_stmt = 386
    RULE_loop_statement = 387
    RULE_loop_start = 388
    RULE_using_vex = 389
    RULE_if_statement = 390
    RULE_case_statement = 391
    RULE_plpgsql_query = 392

    ruleNames =  [ "sql", "qname_parser", "function_args_parser", "vex_eof", 
                   "plpgsql_function", "plpgsql_function_test_list", "statement", 
                   "data_statement", "script_statement", "script_transaction", 
                   "transaction_mode", "lock_table", "lock_mode", "script_additional", 
                   "additional_statement", "explain_statement", "explain_query", 
                   "execute_statement", "declare_statement", "show_statement", 
                   "explain_option", "user_name", "table_cols_list", "table_cols", 
                   "vacuum_mode", "vacuum_option", "analyze_mode", "boolean_value", 
                   "fetch_move_direction", "schema_statement", "schema_create", 
                   "schema_alter", "schema_drop", "schema_import", "alter_function_statement", 
                   "alter_aggregate_statement", "alter_extension_statement", 
                   "alter_extension_action", "extension_member_object", 
                   "alter_schema_statement", "alter_language_statement", 
                   "alter_table_statement", "table_action", "column_action", 
                   "identity_body", "alter_identity", "storage_option", 
                   "validate_constraint", "drop_constraint", "table_deferrable", 
                   "table_initialy_immed", "function_actions_common", "function_def", 
                   "alter_index_statement", "index_def_action", "alter_default_privileges_statement", 
                   "abbreviated_grant_or_revoke", "grant_option_for", "alter_sequence_statement", 
                   "alter_view_statement", "alter_view_action", "alter_materialized_view_statement", 
                   "alter_materialized_view_action", "materialized_view_action", 
                   "alter_event_trigger_statement", "alter_event_trigger_action", 
                   "alter_type_statement", "alter_domain_statement", "alter_server_statement", 
                   "alter_server_action", "alter_fts_statement", "alter_fts_configuration", 
                   "type_action", "type_property", "set_def_column", "drop_def", 
                   "create_index_statement", "index_rest", "index_sort", 
                   "index_column", "including_index", "index_where", "create_extension_statement", 
                   "create_language_statement", "create_event_trigger_statement", 
                   "create_type_statement", "create_domain_statement", "create_server_statement", 
                   "create_fts_dictionary_statement", "option_with_value", 
                   "create_fts_configuration_statement", "create_fts_template_statement", 
                   "create_fts_parser_statement", "create_collation_statement", 
                   "alter_collation_statement", "collation_option", "create_user_mapping_statement", 
                   "alter_user_mapping_statement", "alter_user_or_role_statement", 
                   "alter_user_or_role_set_reset", "set_reset_parameter", 
                   "alter_group_statement", "alter_group_action", "alter_tablespace_statement", 
                   "alter_owner_statement", "alter_tablespace_action", "alter_statistics_statement", 
                   "set_statistics", "alter_foreign_data_wrapper", "alter_foreign_data_wrapper_action", 
                   "alter_operator_statement", "alter_operator_action", 
                   "operator_set_restrict_join", "drop_user_mapping_statement", 
                   "drop_owned_statement", "drop_operator_statement", "target_operator", 
                   "domain_constraint", "create_transform_statement", "create_access_method_statement", 
                   "create_user_or_role_statement", "user_or_role_option", 
                   "user_or_role_option_for_alter", "user_or_role_or_group_common_option", 
                   "user_or_role_common_option", "user_or_role_or_group_option_for_create", 
                   "create_group_statement", "group_option", "create_tablespace_statement", 
                   "create_statistics_statement", "create_foreign_data_wrapper_statement", 
                   "option_without_equal", "create_operator_statement", 
                   "operator_name", "operator_option", "create_aggregate_statement", 
                   "aggregate_param", "set_statement", "set_action", "session_local_option", 
                   "set_statement_value", "create_rewrite_statement", "rewrite_command", 
                   "create_trigger_statement", "trigger_referencing", "when_trigger", 
                   "rule_common", "rule_member_object", "columns_permissions", 
                   "table_column_privileges", "permissions", "permission", 
                   "other_rules", "grant_to_rule", "revoke_from_cascade_restrict", 
                   "roles_names", "role_name_with_group", "comment_on_statement", 
                   "security_label", "comment_member_object", "label_member_object", 
                   "create_function_statement", "create_funct_params", "transform_for_type", 
                   "function_ret_table", "function_column_name_type", "function_parameters", 
                   "function_args", "agg_order", "character_string", "function_arguments", 
                   "argmode", "create_sequence_statement", "sequence_body", 
                   "signed_number_literal", "signed_numerical_literal", 
                   "sign", "create_schema_statement", "create_policy_statement", 
                   "alter_policy_statement", "drop_policy_statement", "create_subscription_statement", 
                   "alter_subscription_statement", "alter_subscription_action", 
                   "create_cast_statement", "drop_cast_statement", "create_operator_family_statement", 
                   "alter_operator_family_statement", "operator_family_action", 
                   "add_operator_to_family", "drop_operator_from_family", 
                   "drop_operator_family_statement", "create_operator_class_statement", 
                   "create_operator_class_option", "alter_operator_class_statement", 
                   "drop_operator_class_statement", "create_conversion_statement", 
                   "alter_conversion_statement", "create_publication_statement", 
                   "alter_publication_statement", "alter_publication_action", 
                   "only_table_multiply", "alter_trigger_statement", "alter_rule_statement", 
                   "copy_statement", "copy_from_statement", "copy_to_statement", 
                   "copy_option_list", "copy_option", "create_view_statement", 
                   "if_exists", "if_not_exists", "view_columns", "with_check_option", 
                   "create_database_statement", "create_database_option", 
                   "alter_database_statement", "alter_database_action", 
                   "alter_database_option", "create_table_statement", "create_table_as_statement", 
                   "create_foreign_table_statement", "define_table", "define_partition", 
                   "for_values_bound", "partition_bound_spec", "partition_bound_part", 
                   "define_columns", "define_type", "partition_by", "partition_method", 
                   "partition_column", "define_server", "define_foreign_options", 
                   "foreign_option", "foreign_option_name", "list_of_type_column_def", 
                   "table_column_def", "table_of_type_column_def", "table_column_definition", 
                   "like_option", "constraint_common", "constr_body", "all_op", 
                   "all_simple_op", "op_chars", "index_parameters", "names_in_parens", 
                   "names_references", "storage_parameter", "storage_parameter_option", 
                   "storage_parameter_name", "with_storage_parameter", "storage_parameter_oid", 
                   "on_commit", "table_space", "set_tablespace", "action", 
                   "owner_to", "rename_to", "set_schema", "table_column_privilege", 
                   "usage_select_update", "partition_by_columns", "cascade_restrict", 
                   "collate_identifier", "indirection_var", "dollar_number", 
                   "indirection_list", "indirection", "drop_database_statement", 
                   "drop_function_statement", "drop_trigger_statement", 
                   "drop_rule_statement", "drop_statements", "if_exist_names_restrict_cascade", 
                   "id_token", "identifier", "identifier_nontype", "col_label", 
                   "tokens_nonreserved", "tokens_nonreserved_except_function_type", 
                   "tokens_reserved_except_function_type", "tokens_reserved", 
                   "tokens_nonkeyword", "schema_qualified_name_nontype", 
                   "type_list", "data_type", "array_type", "predefined_type", 
                   "interval_field", "type_length", "precision_param", "vex", 
                   "vex_b", "op", "all_op_ref", "datetime_overlaps", "value_expression_primary", 
                   "unsigned_value_specification", "unsigned_numeric_literal", 
                   "truth_value", "case_expression", "cast_specification", 
                   "function_call", "vex_or_named_notation", "pointer", 
                   "function_construct", "extract_function", "system_function", 
                   "date_time_function", "string_value_function", "xml_function", 
                   "xml_table_column", "comparison_mod", "filter_clause", 
                   "window_definition", "frame_clause", "frame_bound", "array_expression", 
                   "array_elements", "type_coercion", "schema_qualified_name", 
                   "set_qualifier", "table_subquery", "select_stmt", "after_ops", 
                   "select_stmt_no_parens", "with_clause", "with_query", 
                   "select_ops", "select_ops_no_parens", "select_primary", 
                   "select_list", "select_sublist", "into_table", "from_item", 
                   "from_primary", "alias_clause", "from_function_column_def", 
                   "groupby_clause", "grouping_element_list", "grouping_element", 
                   "values_stmt", "values_values", "orderby_clause", "sort_specifier", 
                   "order_specification", "null_ordering", "insert_stmt_for_psql", 
                   "insert_columns", "indirection_identifier", "conflict_object", 
                   "conflict_action", "delete_stmt_for_psql", "update_stmt_for_psql", 
                   "update_set", "notify_stmt", "truncate_stmt", "identifier_list", 
                   "anonymous_block", "comp_options", "function_block", 
                   "start_label", "declarations", "declaration", "type_declaration", 
                   "arguments_list", "data_type_dec", "exception_statement", 
                   "function_statements", "function_statement", "base_statement", 
                   "var", "diagnostic_option", "perform_stmt", "assign_stmt", 
                   "execute_stmt", "control_statement", "cursor_statement", 
                   "option", "transaction_statement", "message_statement", 
                   "log_level", "raise_using", "raise_param", "return_stmt", 
                   "loop_statement", "loop_start", "using_vex", "if_statement", 
                   "case_statement", "plpgsql_query" ]

    EOF = Token.EOF
    ABORT=1
    ABSOLUTE=2
    ACCESS=3
    ACTION=4
    ADD=5
    ADMIN=6
    AFTER=7
    AGGREGATE=8
    ALSO=9
    ALTER=10
    ALWAYS=11
    ASSERTION=12
    ASSIGNMENT=13
    AT=14
    ATTACH=15
    ATTRIBUTE=16
    BACKWARD=17
    BEFORE=18
    BEGIN=19
    BY=20
    CACHE=21
    CALL=22
    CALLED=23
    CASCADE=24
    CASCADED=25
    CATALOG=26
    CHAIN=27
    CHARACTERISTICS=28
    CHECKPOINT=29
    CLASS=30
    CLOSE=31
    CLUSTER=32
    COLUMNS=33
    COMMENT=34
    COMMENTS=35
    COMMIT=36
    COMMITTED=37
    CONFIGURATION=38
    CONFLICT=39
    CONNECTION=40
    CONSTRAINTS=41
    CONTENT=42
    CONTINUE=43
    CONVERSION=44
    COPY=45
    COST=46
    CSV=47
    CUBE=48
    CURRENT=49
    CURSOR=50
    CYCLE=51
    DATA=52
    DATABASE=53
    DAY=54
    DEALLOCATE=55
    DECLARE=56
    DEFAULTS=57
    DEFERRED=58
    DEFINER=59
    DELETE=60
    DELIMITER=61
    DELIMITERS=62
    DEPENDS=63
    DETACH=64
    DICTIONARY=65
    DISABLE=66
    DISCARD=67
    DOCUMENT=68
    DOMAIN=69
    DOUBLE=70
    DROP=71
    EACH=72
    ENABLE=73
    ENCODING=74
    ENCRYPTED=75
    ENUM=76
    ESCAPE=77
    EVENT=78
    EXCLUDE=79
    EXCLUDING=80
    EXCLUSIVE=81
    EXECUTE=82
    EXPLAIN=83
    EXPRESSION=84
    EXTENSION=85
    EXTERNAL=86
    FAMILY=87
    FILTER=88
    FIRST=89
    FOLLOWING=90
    FORCE=91
    FORWARD=92
    FUNCTION=93
    FUNCTIONS=94
    GENERATED=95
    GLOBAL=96
    GRANTED=97
    GROUPS=98
    HANDLER=99
    HEADER=100
    HOLD=101
    HOUR=102
    IDENTITY=103
    IF=104
    IMMEDIATE=105
    IMMUTABLE=106
    IMPLICIT=107
    IMPORT=108
    INCLUDE=109
    INCLUDING=110
    INCREMENT=111
    INDEX=112
    INDEXES=113
    INHERIT=114
    INHERITS=115
    INLINE=116
    INPUT=117
    INSENSITIVE=118
    INSERT=119
    INSTEAD=120
    INVOKER=121
    ISOLATION=122
    KEY=123
    LABEL=124
    LANGUAGE=125
    LARGE=126
    LAST=127
    LEAKPROOF=128
    LEVEL=129
    LISTEN=130
    LOAD=131
    LOCAL=132
    LOCATION=133
    LOCK=134
    LOCKED=135
    LOGGED=136
    MAPPING=137
    MATCH=138
    MATERIALIZED=139
    MAXVALUE=140
    METHOD=141
    MINUTE=142
    MINVALUE=143
    MODE=144
    MONTH=145
    MOVE=146
    NAME=147
    NAMES=148
    NEW=149
    NEXT=150
    NFC=151
    NFD=152
    NFKC=153
    NFKD=154
    NO=155
    NORMALIZED=156
    NOTHING=157
    NOTIFY=158
    NOWAIT=159
    NULLS=160
    OBJECT=161
    OF=162
    OFF=163
    OIDS=164
    OLD=165
    OPERATOR=166
    OPTION=167
    OPTIONS=168
    ORDINALITY=169
    OTHERS=170
    OVER=171
    OVERRIDING=172
    OWNED=173
    OWNER=174
    PARALLEL=175
    PARSER=176
    PARTIAL=177
    PARTITION=178
    PASSING=179
    PASSWORD=180
    PLANS=181
    POLICY=182
    PRECEDING=183
    PREPARE=184
    PREPARED=185
    PRESERVE=186
    PRIOR=187
    PRIVILEGES=188
    PROCEDURAL=189
    PROCEDURE=190
    PROCEDURES=191
    PROGRAM=192
    PUBLICATION=193
    QUOTE=194
    RANGE=195
    READ=196
    REASSIGN=197
    RECHECK=198
    RECURSIVE=199
    REF=200
    REFERENCING=201
    REFRESH=202
    REINDEX=203
    RELATIVE=204
    RELEASE=205
    RENAME=206
    REPEATABLE=207
    REPLACE=208
    REPLICA=209
    RESET=210
    RESTART=211
    RESTRICT=212
    RETURNS=213
    REVOKE=214
    ROLE=215
    ROLLBACK=216
    ROLLUP=217
    ROUTINE=218
    ROUTINES=219
    ROWS=220
    RULE=221
    SAVEPOINT=222
    SCHEMA=223
    SCHEMAS=224
    SCROLL=225
    SEARCH=226
    SECOND=227
    SECURITY=228
    SEQUENCE=229
    SEQUENCES=230
    SERIALIZABLE=231
    SERVER=232
    SESSION=233
    SET=234
    SETS=235
    SHARE=236
    SHOW=237
    SIMPLE=238
    SKIP_=239
    SNAPSHOT=240
    SQL=241
    STABLE=242
    STANDALONE=243
    START=244
    STATEMENT=245
    STATISTICS=246
    STDIN=247
    STDOUT=248
    STORAGE=249
    STORED=250
    STRICT=251
    STRIP=252
    SUBSCRIPTION=253
    SUPPORT=254
    SYSID=255
    SYSTEM=256
    TABLES=257
    TABLESPACE=258
    TEMP=259
    TEMPLATE=260
    TEMPORARY=261
    TEXT=262
    TIES=263
    TRANSACTION=264
    TRANSFORM=265
    TRIGGER=266
    TRUNCATE=267
    TRUSTED=268
    TYPE=269
    TYPES=270
    UESCAPE=271
    UNBOUNDED=272
    UNCOMMITTED=273
    UNENCRYPTED=274
    UNKNOWN=275
    UNLISTEN=276
    UNLOGGED=277
    UNTIL=278
    UPDATE=279
    VACUUM=280
    VALID=281
    VALIDATE=282
    VALIDATOR=283
    VALUE=284
    VARYING=285
    VERSION=286
    VIEW=287
    VIEWS=288
    VOLATILE=289
    WHITESPACE=290
    WITHIN=291
    WITHOUT=292
    WORK=293
    WRAPPER=294
    WRITE=295
    XML=296
    YEAR=297
    YES=298
    ZONE=299
    BETWEEN=300
    BIGINT=301
    BIT=302
    BOOLEAN=303
    CHAR=304
    CHARACTER=305
    COALESCE=306
    DEC=307
    DECIMAL=308
    EXISTS=309
    EXTRACT=310
    FLOAT=311
    GREATEST=312
    GROUPING=313
    INOUT=314
    INT=315
    INTEGER=316
    INTERVAL=317
    LEAST=318
    NATIONAL=319
    NCHAR=320
    NONE=321
    NORMALIZE=322
    NULLIF=323
    NUMERIC=324
    OUT=325
    OVERLAY=326
    POSITION=327
    PRECISION=328
    REAL=329
    ROW=330
    SETOF=331
    SMALLINT=332
    SUBSTRING=333
    TIME=334
    TIMESTAMP=335
    TREAT=336
    TRIM=337
    VALUES=338
    VARCHAR=339
    XMLATTRIBUTES=340
    XMLCONCAT=341
    XMLELEMENT=342
    XMLEXISTS=343
    XMLFOREST=344
    XMLNAMESPACES=345
    XMLPARSE=346
    XMLPI=347
    XMLROOT=348
    XMLSERIALIZE=349
    XMLTABLE=350
    AUTHORIZATION=351
    BINARY=352
    COLLATION=353
    CONCURRENTLY=354
    CROSS=355
    CURRENT_SCHEMA=356
    FREEZE=357
    FULL=358
    ILIKE=359
    INNER=360
    IS=361
    ISNULL=362
    JOIN=363
    LEFT=364
    LIKE=365
    NATURAL=366
    NOTNULL=367
    OUTER=368
    OVERLAPS=369
    RIGHT=370
    SIMILAR=371
    TABLESAMPLE=372
    VERBOSE=373
    ALL=374
    ANALYZE=375
    AND=376
    ANY=377
    ARRAY=378
    AS=379
    ASC=380
    ASYMMETRIC=381
    BOTH=382
    CASE=383
    CAST=384
    CHECK=385
    COLLATE=386
    COLUMN=387
    CONSTRAINT=388
    CREATE=389
    CURRENT_CATALOG=390
    CURRENT_DATE=391
    CURRENT_ROLE=392
    CURRENT_TIME=393
    CURRENT_TIMESTAMP=394
    CURRENT_USER=395
    DEFAULT=396
    DEFERRABLE=397
    DESC=398
    DISTINCT=399
    DO=400
    ELSE=401
    END=402
    EXCEPT=403
    FALSE=404
    FETCH=405
    FOR=406
    FOREIGN=407
    FROM=408
    GRANT=409
    GROUP=410
    HAVING=411
    IN=412
    INITIALLY=413
    INTERSECT=414
    INTO=415
    LATERAL=416
    LEADING=417
    LIMIT=418
    LOCALTIME=419
    LOCALTIMESTAMP=420
    NOT=421
    NULL=422
    OFFSET=423
    ON=424
    ONLY=425
    OR=426
    ORDER=427
    PLACING=428
    PRIMARY=429
    REFERENCES=430
    RETURNING=431
    SELECT=432
    SESSION_USER=433
    SOME=434
    SYMMETRIC=435
    TABLE=436
    THEN=437
    TO=438
    TRAILING=439
    TRUE=440
    UNION=441
    UNIQUE=442
    USER=443
    USING=444
    VARIADIC=445
    WHEN=446
    WHERE=447
    WINDOW=448
    WITH=449
    ALIGNMENT=450
    ALLOW_CONNECTIONS=451
    BASETYPE=452
    BUFFERS=453
    BYPASSRLS=454
    CANONICAL=455
    CATEGORY=456
    COLLATABLE=457
    COMBINEFUNC=458
    COMMUTATOR=459
    CONNECT=460
    COSTS=461
    CREATEDB=462
    CREATEROLE=463
    DESERIALFUNC=464
    DETERMINISTIC=465
    DISABLE_PAGE_SKIPPING=466
    ELEMENT=467
    EXTENDED=468
    FINALFUNC=469
    FINALFUNC_EXTRA=470
    FINALFUNC_MODIFY=471
    FORCE_NOT_NULL=472
    FORCE_NULL=473
    FORCE_QUOTE=474
    FORMAT=475
    GETTOKEN=476
    HASH=477
    HASHES=478
    HEADLINE=479
    HYPOTHETICAL=480
    INDEX_CLEANUP=481
    INIT=482
    INITCOND=483
    INTERNALLENGTH=484
    IS_TEMPLATE=485
    JSON=486
    LC_COLLATE=487
    LC_CTYPE=488
    LEFTARG=489
    LEXIZE=490
    LEXTYPES=491
    LIST=492
    LOCALE=493
    LOGIN=494
    MAIN=495
    MERGES=496
    MFINALFUNC=497
    MFINALFUNC_EXTRA=498
    MFINALFUNC_MODIFY=499
    MINITCOND=500
    MINVFUNC=501
    MODULUS=502
    MSFUNC=503
    MSSPACE=504
    MSTYPE=505
    NEGATOR=506
    NOBYPASSRLS=507
    NOCREATEDB=508
    NOCREATEROLE=509
    NOINHERIT=510
    NOLOGIN=511
    NOREPLICATION=512
    NOSUPERUSER=513
    OUTPUT=514
    PASSEDBYVALUE=515
    PATH=516
    PERMISSIVE=517
    PLAIN=518
    PREFERRED=519
    PROVIDER=520
    READ_ONLY=521
    READ_WRITE=522
    RECEIVE=523
    REMAINDER=524
    REPLICATION=525
    RESTRICTED=526
    RESTRICTIVE=527
    RIGHTARG=528
    SAFE=529
    SEND=530
    SERIALFUNC=531
    SETTINGS=532
    SFUNC=533
    SHAREABLE=534
    SKIP_LOCKED=535
    SORTOP=536
    SSPACE=537
    STYPE=538
    SUBTYPE_DIFF=539
    SUBTYPE_OPCLASS=540
    SUBTYPE=541
    SUMMARY=542
    SUPERUSER=543
    TIMING=544
    TYPMOD_IN=545
    TYPMOD_OUT=546
    UNSAFE=547
    USAGE=548
    VARIABLE=549
    WAL=550
    YAML=551
    ALIAS=552
    ASSERT=553
    CONSTANT=554
    DATATYPE=555
    DEBUG=556
    DETAIL=557
    DIAGNOSTICS=558
    ELSEIF=559
    ELSIF=560
    ERRCODE=561
    EXIT=562
    EXCEPTION=563
    FOREACH=564
    GET=565
    HINT=566
    INFO=567
    LOG=568
    LOOP=569
    MESSAGE=570
    NOTICE=571
    OPEN=572
    PERFORM=573
    QUERY=574
    RAISE=575
    RECORD=576
    RETURN=577
    REVERSE=578
    ROWTYPE=579
    SLICE=580
    SQLSTATE=581
    STACKED=582
    WARNING=583
    WHILE=584
    CAST_EXPRESSION=585
    EQUAL=586
    COLON=587
    SEMI_COLON=588
    COMMA=589
    NOT_EQUAL=590
    LTH=591
    LEQ=592
    GTH=593
    GEQ=594
    LEFT_PAREN=595
    RIGHT_PAREN=596
    PLUS=597
    MINUS=598
    MULTIPLY=599
    DIVIDE=600
    MODULAR=601
    EXP=602
    DOT=603
    QUOTE_CHAR=604
    DOUBLE_QUOTE=605
    DOLLAR=606
    LEFT_BRACKET=607
    RIGHT_BRACKET=608
    EQUAL_GTH=609
    COLON_EQUAL=610
    LESS_LESS=611
    GREATER_GREATER=612
    DOUBLE_DOT=613
    HASH_SIGN=614
    BlockComment=615
    LineComment=616
    OP_CHARS=617
    NUMBER_LITERAL=618
    REAL_NUMBER=619
    DOLLAR_NUMBER=620
    Identifier=621
    QuotedIdentifier=622
    Character_String_Literal=623
    BeginDollarStringConstant=624
    Space=625
    White_Space=626
    New_Line=627
    Tab=628
    BOM=629
    BAD=630
    Text_between_Dollar=631
    EndDollarStringConstant=632

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.2")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class SqlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.EOF)
            else:
                return self.getToken(postgreSQLParser.EOF, i)

        def BOM(self):
            return self.getToken(postgreSQLParser.BOM, 0)

        def SEMI_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SEMI_COLON)
            else:
                return self.getToken(postgreSQLParser.SEMI_COLON, i)

        def statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.StatementContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.StatementContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_sql

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSql" ):
                listener.enterSql(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSql" ):
                listener.exitSql(self)




    def sql(self):

        localctx = postgreSQLParser.SqlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_sql)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 787
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.BOM:
                self.state = 786
                self.match(postgreSQLParser.BOM)


            self.state = 792
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.SEMI_COLON:
                self.state = 789
                self.match(postgreSQLParser.SEMI_COLON)
                self.state = 794
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 806
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DELETE))) != 0) or ((((_la - 67)) & ~0x3f) == 0 and ((1 << (_la - 67)) & ((1 << (postgreSQLParser.DISCARD - 67)) | (1 << (postgreSQLParser.DROP - 67)) | (1 << (postgreSQLParser.EXECUTE - 67)) | (1 << (postgreSQLParser.EXPLAIN - 67)) | (1 << (postgreSQLParser.IMPORT - 67)) | (1 << (postgreSQLParser.INSERT - 67)) | (1 << (postgreSQLParser.LISTEN - 67)))) != 0) or ((((_la - 131)) & ~0x3f) == 0 and ((1 << (_la - 131)) & ((1 << (postgreSQLParser.LOAD - 131)) | (1 << (postgreSQLParser.LOCK - 131)) | (1 << (postgreSQLParser.MOVE - 131)) | (1 << (postgreSQLParser.NOTIFY - 131)) | (1 << (postgreSQLParser.PREPARE - 131)))) != 0) or ((((_la - 197)) & ~0x3f) == 0 and ((1 << (_la - 197)) & ((1 << (postgreSQLParser.REASSIGN - 197)) | (1 << (postgreSQLParser.REFRESH - 197)) | (1 << (postgreSQLParser.REINDEX - 197)) | (1 << (postgreSQLParser.RELEASE - 197)) | (1 << (postgreSQLParser.RESET - 197)) | (1 << (postgreSQLParser.REVOKE - 197)) | (1 << (postgreSQLParser.ROLLBACK - 197)) | (1 << (postgreSQLParser.SAVEPOINT - 197)) | (1 << (postgreSQLParser.SECURITY - 197)) | (1 << (postgreSQLParser.SET - 197)) | (1 << (postgreSQLParser.SHOW - 197)) | (1 << (postgreSQLParser.START - 197)))) != 0) or ((((_la - 267)) & ~0x3f) == 0 and ((1 << (_la - 267)) & ((1 << (postgreSQLParser.TRUNCATE - 267)) | (1 << (postgreSQLParser.UNLISTEN - 267)) | (1 << (postgreSQLParser.UPDATE - 267)) | (1 << (postgreSQLParser.VACUUM - 267)))) != 0) or ((((_la - 338)) & ~0x3f) == 0 and ((1 << (_la - 338)) & ((1 << (postgreSQLParser.VALUES - 338)) | (1 << (postgreSQLParser.ANALYZE - 338)) | (1 << (postgreSQLParser.CREATE - 338)) | (1 << (postgreSQLParser.DO - 338)))) != 0) or ((((_la - 402)) & ~0x3f) == 0 and ((1 << (_la - 402)) & ((1 << (postgreSQLParser.END - 402)) | (1 << (postgreSQLParser.FETCH - 402)) | (1 << (postgreSQLParser.GRANT - 402)) | (1 << (postgreSQLParser.SELECT - 402)) | (1 << (postgreSQLParser.TABLE - 402)) | (1 << (postgreSQLParser.WITH - 402)))) != 0) or _la==postgreSQLParser.LEFT_PAREN:
                self.state = 795
                self.statement()
                self.state = 802
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.SEMI_COLON]:
                    self.state = 797 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while True:
                        self.state = 796
                        self.match(postgreSQLParser.SEMI_COLON)
                        self.state = 799 
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if not (_la==postgreSQLParser.SEMI_COLON):
                            break

                    pass
                elif token in [postgreSQLParser.EOF]:
                    self.state = 801
                    self.match(postgreSQLParser.EOF)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 808
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 809
            self.match(postgreSQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Qname_parserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def EOF(self):
            return self.getToken(postgreSQLParser.EOF, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_qname_parser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQname_parser" ):
                listener.enterQname_parser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQname_parser" ):
                listener.exitQname_parser(self)




    def qname_parser(self):

        localctx = postgreSQLParser.Qname_parserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_qname_parser)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 811
            self.schema_qualified_name()
            self.state = 812
            self.match(postgreSQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_args_parserContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def EOF(self):
            return self.getToken(postgreSQLParser.EOF, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_args_parser

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_args_parser" ):
                listener.enterFunction_args_parser(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_args_parser" ):
                listener.exitFunction_args_parser(self)




    def function_args_parser(self):

        localctx = postgreSQLParser.Function_args_parserContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_function_args_parser)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 815
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 814
                self.schema_qualified_name()


            self.state = 817
            self.function_args()
            self.state = 818
            self.match(postgreSQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Vex_eofContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def EOF(self):
            return self.getToken(postgreSQLParser.EOF, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_vex_eof

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVex_eof" ):
                listener.enterVex_eof(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVex_eof" ):
                listener.exitVex_eof(self)




    def vex_eof(self):

        localctx = postgreSQLParser.Vex_eofContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_vex_eof)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 820
            self.vex(0)
            self.state = 825
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 821
                self.match(postgreSQLParser.COMMA)
                self.state = 822
                self.vex(0)
                self.state = 827
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 828
            self.match(postgreSQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Plpgsql_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_block(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_blockContext,0)


        def EOF(self):
            return self.getToken(postgreSQLParser.EOF, 0)

        def comp_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Comp_optionsContext,0)


        def SEMI_COLON(self):
            return self.getToken(postgreSQLParser.SEMI_COLON, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_plpgsql_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlpgsql_function" ):
                listener.enterPlpgsql_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlpgsql_function" ):
                listener.exitPlpgsql_function(self)




    def plpgsql_function(self):

        localctx = postgreSQLParser.Plpgsql_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_plpgsql_function)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 831
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.HASH_SIGN:
                self.state = 830
                self.comp_options()


            self.state = 833
            self.function_block()
            self.state = 835
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.SEMI_COLON:
                self.state = 834
                self.match(postgreSQLParser.SEMI_COLON)


            self.state = 837
            self.match(postgreSQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Plpgsql_function_test_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EOF(self):
            return self.getToken(postgreSQLParser.EOF, 0)

        def function_block(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_blockContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_blockContext,i)


        def SEMI_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SEMI_COLON)
            else:
                return self.getToken(postgreSQLParser.SEMI_COLON, i)

        def comp_options(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Comp_optionsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Comp_optionsContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_plpgsql_function_test_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlpgsql_function_test_list" ):
                listener.enterPlpgsql_function_test_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlpgsql_function_test_list" ):
                listener.exitPlpgsql_function_test_list(self)




    def plpgsql_function_test_list(self):

        localctx = postgreSQLParser.Plpgsql_function_test_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_plpgsql_function_test_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 847
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.BEGIN or _la==postgreSQLParser.DECLARE or _la==postgreSQLParser.LESS_LESS or _la==postgreSQLParser.HASH_SIGN:
                self.state = 840
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.HASH_SIGN:
                    self.state = 839
                    self.comp_options()


                self.state = 842
                self.function_block()
                self.state = 843
                self.match(postgreSQLParser.SEMI_COLON)
                self.state = 849
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 850
            self.match(postgreSQLParser.EOF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class StatementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_statementContext,0)


        def schema_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_statementContext,0)


        def script_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Script_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStatement" ):
                listener.enterStatement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStatement" ):
                listener.exitStatement(self)




    def statement(self):

        localctx = postgreSQLParser.StatementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_statement)
        try:
            self.state = 855
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.DELETE, postgreSQLParser.INSERT, postgreSQLParser.UPDATE, postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE, postgreSQLParser.WITH, postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 852
                self.data_statement()
                pass
            elif token in [postgreSQLParser.ALTER, postgreSQLParser.COMMENT, postgreSQLParser.DROP, postgreSQLParser.IMPORT, postgreSQLParser.REVOKE, postgreSQLParser.SECURITY, postgreSQLParser.SET, postgreSQLParser.CREATE, postgreSQLParser.GRANT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 853
                self.schema_statement()
                pass
            elif token in [postgreSQLParser.ABORT, postgreSQLParser.BEGIN, postgreSQLParser.CALL, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COMMIT, postgreSQLParser.COPY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DISCARD, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCK, postgreSQLParser.MOVE, postgreSQLParser.NOTIFY, postgreSQLParser.PREPARE, postgreSQLParser.REASSIGN, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELEASE, postgreSQLParser.RESET, postgreSQLParser.ROLLBACK, postgreSQLParser.SAVEPOINT, postgreSQLParser.SHOW, postgreSQLParser.START, postgreSQLParser.TRUNCATE, postgreSQLParser.UNLISTEN, postgreSQLParser.VACUUM, postgreSQLParser.ANALYZE, postgreSQLParser.DO, postgreSQLParser.END, postgreSQLParser.FETCH]:
                self.enterOuterAlt(localctx, 3)
                self.state = 854
                self.script_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def insert_stmt_for_psql(self):
            return self.getTypedRuleContext(postgreSQLParser.Insert_stmt_for_psqlContext,0)


        def update_stmt_for_psql(self):
            return self.getTypedRuleContext(postgreSQLParser.Update_stmt_for_psqlContext,0)


        def delete_stmt_for_psql(self):
            return self.getTypedRuleContext(postgreSQLParser.Delete_stmt_for_psqlContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_data_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_statement" ):
                listener.enterData_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_statement" ):
                listener.exitData_statement(self)




    def data_statement(self):

        localctx = postgreSQLParser.Data_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_data_statement)
        try:
            self.state = 861
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,12,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 857
                self.select_stmt()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 858
                self.insert_stmt_for_psql()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 859
                self.update_stmt_for_psql()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 860
                self.delete_stmt_for_psql()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Script_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def script_transaction(self):
            return self.getTypedRuleContext(postgreSQLParser.Script_transactionContext,0)


        def script_additional(self):
            return self.getTypedRuleContext(postgreSQLParser.Script_additionalContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_script_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript_statement" ):
                listener.enterScript_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript_statement" ):
                listener.exitScript_statement(self)




    def script_statement(self):

        localctx = postgreSQLParser.Script_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_script_statement)
        try:
            self.state = 865
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,13,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 863
                self.script_transaction()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 864
                self.script_additional()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Script_transactionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def START(self):
            return self.getToken(postgreSQLParser.START, 0)

        def TRANSACTION(self):
            return self.getToken(postgreSQLParser.TRANSACTION, 0)

        def BEGIN(self):
            return self.getToken(postgreSQLParser.BEGIN, 0)

        def transaction_mode(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Transaction_modeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Transaction_modeContext,i)


        def WORK(self):
            return self.getToken(postgreSQLParser.WORK, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def COMMIT(self):
            return self.getToken(postgreSQLParser.COMMIT, 0)

        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def ABORT(self):
            return self.getToken(postgreSQLParser.ABORT, 0)

        def ROLLBACK(self):
            return self.getToken(postgreSQLParser.ROLLBACK, 0)

        def AND(self):
            return self.getToken(postgreSQLParser.AND, 0)

        def CHAIN(self):
            return self.getToken(postgreSQLParser.CHAIN, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def PREPARED(self):
            return self.getToken(postgreSQLParser.PREPARED, 0)

        def PREPARE(self):
            return self.getToken(postgreSQLParser.PREPARE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def SAVEPOINT(self):
            return self.getToken(postgreSQLParser.SAVEPOINT, 0)

        def RELEASE(self):
            return self.getToken(postgreSQLParser.RELEASE, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def lock_table(self):
            return self.getTypedRuleContext(postgreSQLParser.Lock_tableContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_script_transaction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript_transaction" ):
                listener.enterScript_transaction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript_transaction" ):
                listener.exitScript_transaction(self)




    def script_transaction(self):

        localctx = postgreSQLParser.Script_transactionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_script_transaction)
        self._la = 0 # Token type
        try:
            self.state = 924
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,26,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 873
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.START]:
                    self.state = 867
                    self.match(postgreSQLParser.START)
                    self.state = 868
                    self.match(postgreSQLParser.TRANSACTION)
                    pass
                elif token in [postgreSQLParser.BEGIN]:
                    self.state = 869
                    self.match(postgreSQLParser.BEGIN)
                    self.state = 871
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.TRANSACTION or _la==postgreSQLParser.WORK:
                        self.state = 870
                        _la = self._input.LA(1)
                        if not(_la==postgreSQLParser.TRANSACTION or _la==postgreSQLParser.WORK):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 883
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ISOLATION or _la==postgreSQLParser.READ or _la==postgreSQLParser.DEFERRABLE or _la==postgreSQLParser.NOT:
                    self.state = 875
                    self.transaction_mode()
                    self.state = 880
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 876
                        self.match(postgreSQLParser.COMMA)
                        self.state = 877
                        self.transaction_mode()
                        self.state = 882
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 885
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ABORT or _la==postgreSQLParser.COMMIT or _la==postgreSQLParser.ROLLBACK or _la==postgreSQLParser.END):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 887
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.TRANSACTION or _la==postgreSQLParser.WORK:
                    self.state = 886
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.TRANSACTION or _la==postgreSQLParser.WORK):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 894
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AND:
                    self.state = 889
                    self.match(postgreSQLParser.AND)
                    self.state = 891
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.NO:
                        self.state = 890
                        self.match(postgreSQLParser.NO)


                    self.state = 893
                    self.match(postgreSQLParser.CHAIN)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 900
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.COMMIT]:
                    self.state = 896
                    self.match(postgreSQLParser.COMMIT)
                    self.state = 897
                    self.match(postgreSQLParser.PREPARED)
                    pass
                elif token in [postgreSQLParser.PREPARE]:
                    self.state = 898
                    self.match(postgreSQLParser.PREPARE)
                    self.state = 899
                    self.match(postgreSQLParser.TRANSACTION)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 902
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 908
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.SAVEPOINT]:
                    self.state = 903
                    self.match(postgreSQLParser.SAVEPOINT)
                    pass
                elif token in [postgreSQLParser.RELEASE]:
                    self.state = 904
                    self.match(postgreSQLParser.RELEASE)
                    self.state = 906
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,22,self._ctx)
                    if la_ == 1:
                        self.state = 905
                        self.match(postgreSQLParser.SAVEPOINT)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 910
                self.identifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 911
                self.match(postgreSQLParser.ROLLBACK)
                self.state = 912
                self.match(postgreSQLParser.PREPARED)
                self.state = 913
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 914
                self.match(postgreSQLParser.ROLLBACK)
                self.state = 916
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.TRANSACTION or _la==postgreSQLParser.WORK:
                    self.state = 915
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.TRANSACTION or _la==postgreSQLParser.WORK):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 918
                self.match(postgreSQLParser.TO)
                self.state = 920
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,25,self._ctx)
                if la_ == 1:
                    self.state = 919
                    self.match(postgreSQLParser.SAVEPOINT)


                self.state = 922
                self.identifier()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 923
                self.lock_table()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Transaction_modeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ISOLATION(self):
            return self.getToken(postgreSQLParser.ISOLATION, 0)

        def LEVEL(self):
            return self.getToken(postgreSQLParser.LEVEL, 0)

        def SERIALIZABLE(self):
            return self.getToken(postgreSQLParser.SERIALIZABLE, 0)

        def REPEATABLE(self):
            return self.getToken(postgreSQLParser.REPEATABLE, 0)

        def READ(self):
            return self.getToken(postgreSQLParser.READ, 0)

        def COMMITTED(self):
            return self.getToken(postgreSQLParser.COMMITTED, 0)

        def UNCOMMITTED(self):
            return self.getToken(postgreSQLParser.UNCOMMITTED, 0)

        def WRITE(self):
            return self.getToken(postgreSQLParser.WRITE, 0)

        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def DEFERRABLE(self):
            return self.getToken(postgreSQLParser.DEFERRABLE, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_transaction_mode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransaction_mode" ):
                listener.enterTransaction_mode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransaction_mode" ):
                listener.exitTransaction_mode(self)




    def transaction_mode(self):

        localctx = postgreSQLParser.Transaction_modeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_transaction_mode)
        self._la = 0 # Token type
        try:
            self.state = 945
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,29,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 926
                self.match(postgreSQLParser.ISOLATION)
                self.state = 927
                self.match(postgreSQLParser.LEVEL)
                self.state = 935
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,27,self._ctx)
                if la_ == 1:
                    self.state = 928
                    self.match(postgreSQLParser.SERIALIZABLE)
                    pass

                elif la_ == 2:
                    self.state = 929
                    self.match(postgreSQLParser.REPEATABLE)
                    self.state = 930
                    self.match(postgreSQLParser.READ)
                    pass

                elif la_ == 3:
                    self.state = 931
                    self.match(postgreSQLParser.READ)
                    self.state = 932
                    self.match(postgreSQLParser.COMMITTED)
                    pass

                elif la_ == 4:
                    self.state = 933
                    self.match(postgreSQLParser.READ)
                    self.state = 934
                    self.match(postgreSQLParser.UNCOMMITTED)
                    pass


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 937
                self.match(postgreSQLParser.READ)
                self.state = 938
                self.match(postgreSQLParser.WRITE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 939
                self.match(postgreSQLParser.READ)
                self.state = 940
                self.match(postgreSQLParser.ONLY)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 942
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 941
                    self.match(postgreSQLParser.NOT)


                self.state = 944
                self.match(postgreSQLParser.DEFERRABLE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lock_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOCK(self):
            return self.getToken(postgreSQLParser.LOCK, 0)

        def only_table_multiply(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Only_table_multiplyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Only_table_multiplyContext,i)


        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def lock_mode(self):
            return self.getTypedRuleContext(postgreSQLParser.Lock_modeContext,0)


        def MODE(self):
            return self.getToken(postgreSQLParser.MODE, 0)

        def NOWAIT(self):
            return self.getToken(postgreSQLParser.NOWAIT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_lock_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLock_table" ):
                listener.enterLock_table(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLock_table" ):
                listener.exitLock_table(self)




    def lock_table(self):

        localctx = postgreSQLParser.Lock_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_lock_table)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 947
            self.match(postgreSQLParser.LOCK)
            self.state = 949
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLE:
                self.state = 948
                self.match(postgreSQLParser.TABLE)


            self.state = 951
            self.only_table_multiply()
            self.state = 956
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 952
                self.match(postgreSQLParser.COMMA)
                self.state = 953
                self.only_table_multiply()
                self.state = 958
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 963
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.IN:
                self.state = 959
                self.match(postgreSQLParser.IN)
                self.state = 960
                self.lock_mode()
                self.state = 961
                self.match(postgreSQLParser.MODE)


            self.state = 966
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NOWAIT:
                self.state = 965
                self.match(postgreSQLParser.NOWAIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Lock_modeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHARE(self):
            return self.getToken(postgreSQLParser.SHARE, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def ACCESS(self):
            return self.getToken(postgreSQLParser.ACCESS, 0)

        def EXCLUSIVE(self):
            return self.getToken(postgreSQLParser.EXCLUSIVE, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_lock_mode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLock_mode" ):
                listener.enterLock_mode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLock_mode" ):
                listener.exitLock_mode(self)




    def lock_mode(self):

        localctx = postgreSQLParser.Lock_modeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_lock_mode)
        self._la = 0 # Token type
        try:
            self.state = 980
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,35,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 968
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ACCESS or _la==postgreSQLParser.ROW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 969
                self.match(postgreSQLParser.SHARE)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 970
                self.match(postgreSQLParser.ROW)
                self.state = 971
                self.match(postgreSQLParser.EXCLUSIVE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 972
                self.match(postgreSQLParser.SHARE)
                self.state = 973
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.UPDATE or _la==postgreSQLParser.ROW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 974
                self.match(postgreSQLParser.EXCLUSIVE)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 975
                self.match(postgreSQLParser.SHARE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 977
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ACCESS:
                    self.state = 976
                    self.match(postgreSQLParser.ACCESS)


                self.state = 979
                self.match(postgreSQLParser.EXCLUSIVE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Script_additionalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def additional_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Additional_statementContext,0)


        def VACUUM(self):
            return self.getToken(postgreSQLParser.VACUUM, 0)

        def vacuum_mode(self):
            return self.getTypedRuleContext(postgreSQLParser.Vacuum_modeContext,0)


        def table_cols_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_cols_listContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def FETCH(self):
            return self.getToken(postgreSQLParser.FETCH, 0)

        def MOVE(self):
            return self.getToken(postgreSQLParser.MOVE, 0)

        def fetch_move_direction(self):
            return self.getTypedRuleContext(postgreSQLParser.Fetch_move_directionContext,0)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def CLOSE(self):
            return self.getToken(postgreSQLParser.CLOSE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def CALL(self):
            return self.getToken(postgreSQLParser.CALL, 0)

        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def DISCARD(self):
            return self.getToken(postgreSQLParser.DISCARD, 0)

        def PLANS(self):
            return self.getToken(postgreSQLParser.PLANS, 0)

        def SEQUENCES(self):
            return self.getToken(postgreSQLParser.SEQUENCES, 0)

        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def declare_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Declare_statementContext,0)


        def execute_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Execute_statementContext,0)


        def explain_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Explain_statementContext,0)


        def show_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Show_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_script_additional

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterScript_additional" ):
                listener.enterScript_additional(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitScript_additional" ):
                listener.exitScript_additional(self)




    def script_additional(self):

        localctx = postgreSQLParser.Script_additionalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_script_additional)
        self._la = 0 # Token type
        try:
            self.state = 1009
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CHECKPOINT, postgreSQLParser.CLUSTER, postgreSQLParser.COPY, postgreSQLParser.DEALLOCATE, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.NOTIFY, postgreSQLParser.PREPARE, postgreSQLParser.REASSIGN, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RESET, postgreSQLParser.TRUNCATE, postgreSQLParser.UNLISTEN, postgreSQLParser.ANALYZE, postgreSQLParser.DO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 982
                self.additional_statement()
                pass
            elif token in [postgreSQLParser.VACUUM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 983
                self.match(postgreSQLParser.VACUUM)
                self.state = 984
                self.vacuum_mode()
                self.state = 986
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                    self.state = 985
                    self.table_cols_list()


                pass
            elif token in [postgreSQLParser.MOVE, postgreSQLParser.FETCH]:
                self.enterOuterAlt(localctx, 3)
                self.state = 988
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.MOVE or _la==postgreSQLParser.FETCH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 990
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,37,self._ctx)
                if la_ == 1:
                    self.state = 989
                    self.fetch_move_direction()


                self.state = 993
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FROM or _la==postgreSQLParser.IN:
                    self.state = 992
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.FROM or _la==postgreSQLParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 995
                self.identifier()
                pass
            elif token in [postgreSQLParser.CLOSE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 996
                self.match(postgreSQLParser.CLOSE)
                self.state = 999
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 997
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 998
                    self.match(postgreSQLParser.ALL)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.CALL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1001
                self.match(postgreSQLParser.CALL)
                self.state = 1002
                self.function_call()
                pass
            elif token in [postgreSQLParser.DISCARD]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1003
                self.match(postgreSQLParser.DISCARD)
                self.state = 1004
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.PLANS or _la==postgreSQLParser.SEQUENCES or _la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY or _la==postgreSQLParser.ALL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.DECLARE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1005
                self.declare_statement()
                pass
            elif token in [postgreSQLParser.EXECUTE]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1006
                self.execute_statement()
                pass
            elif token in [postgreSQLParser.EXPLAIN]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1007
                self.explain_statement()
                pass
            elif token in [postgreSQLParser.SHOW]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1008
                self.show_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Additional_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def anonymous_block(self):
            return self.getTypedRuleContext(postgreSQLParser.Anonymous_blockContext,0)


        def LISTEN(self):
            return self.getToken(postgreSQLParser.LISTEN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def UNLISTEN(self):
            return self.getToken(postgreSQLParser.UNLISTEN, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def analyze_mode(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Analyze_modeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Analyze_modeContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def table_cols_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_cols_listContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def CLUSTER(self):
            return self.getToken(postgreSQLParser.CLUSTER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def CHECKPOINT(self):
            return self.getToken(postgreSQLParser.CHECKPOINT, 0)

        def LOAD(self):
            return self.getToken(postgreSQLParser.LOAD, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def DEALLOCATE(self):
            return self.getToken(postgreSQLParser.DEALLOCATE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def PREPARE(self):
            return self.getToken(postgreSQLParser.PREPARE, 0)

        def REINDEX(self):
            return self.getToken(postgreSQLParser.REINDEX, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def SYSTEM(self):
            return self.getToken(postgreSQLParser.SYSTEM, 0)

        def CONCURRENTLY(self):
            return self.getToken(postgreSQLParser.CONCURRENTLY, 0)

        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def TIME(self):
            return self.getToken(postgreSQLParser.TIME, 0)

        def ZONE(self):
            return self.getToken(postgreSQLParser.ZONE, 0)

        def SESSION(self):
            return self.getToken(postgreSQLParser.SESSION, 0)

        def AUTHORIZATION(self):
            return self.getToken(postgreSQLParser.AUTHORIZATION, 0)

        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def REFRESH(self):
            return self.getToken(postgreSQLParser.REFRESH, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def data_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_statementContext,0)


        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def REASSIGN(self):
            return self.getToken(postgreSQLParser.REASSIGN, 0)

        def OWNED(self):
            return self.getToken(postgreSQLParser.OWNED, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def user_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.User_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.User_nameContext,i)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def copy_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Copy_statementContext,0)


        def truncate_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Truncate_stmtContext,0)


        def notify_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Notify_stmtContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_additional_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdditional_statement" ):
                listener.enterAdditional_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdditional_statement" ):
                listener.exitAdditional_statement(self)




    def additional_statement(self):

        localctx = postgreSQLParser.Additional_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_additional_statement)
        self._la = 0 # Token type
        try:
            self.state = 1137
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.DO]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1011
                self.anonymous_block()
                pass
            elif token in [postgreSQLParser.LISTEN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1012
                self.match(postgreSQLParser.LISTEN)
                self.state = 1013
                self.identifier()
                pass
            elif token in [postgreSQLParser.UNLISTEN]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1014
                self.match(postgreSQLParser.UNLISTEN)
                self.state = 1017
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 1015
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.MULTIPLY]:
                    self.state = 1016
                    self.match(postgreSQLParser.MULTIPLY)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.ANALYZE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1019
                self.match(postgreSQLParser.ANALYZE)
                self.state = 1032
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.LEFT_PAREN]:
                    self.state = 1020
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 1021
                    self.analyze_mode()
                    self.state = 1026
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 1022
                        self.match(postgreSQLParser.COMMA)
                        self.state = 1023
                        self.analyze_mode()
                        self.state = 1028
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1029
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                elif token in [postgreSQLParser.VERBOSE]:
                    self.state = 1031
                    self.match(postgreSQLParser.VERBOSE)
                    pass
                elif token in [postgreSQLParser.EOF, postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.SEMI_COLON, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    pass
                else:
                    pass
                self.state = 1035
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                    self.state = 1034
                    self.table_cols_list()


                pass
            elif token in [postgreSQLParser.CLUSTER]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1037
                self.match(postgreSQLParser.CLUSTER)
                self.state = 1039
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.VERBOSE:
                    self.state = 1038
                    self.match(postgreSQLParser.VERBOSE)


                self.state = 1050
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,47,self._ctx)
                if la_ == 1:
                    self.state = 1041
                    self.identifier()
                    self.state = 1042
                    self.match(postgreSQLParser.ON)
                    self.state = 1043
                    self.schema_qualified_name()

                elif la_ == 2:
                    self.state = 1045
                    self.schema_qualified_name()
                    self.state = 1048
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.USING:
                        self.state = 1046
                        self.match(postgreSQLParser.USING)
                        self.state = 1047
                        self.identifier()




                pass
            elif token in [postgreSQLParser.CHECKPOINT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1052
                self.match(postgreSQLParser.CHECKPOINT)
                pass
            elif token in [postgreSQLParser.LOAD]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1053
                self.match(postgreSQLParser.LOAD)
                self.state = 1054
                self.match(postgreSQLParser.Character_String_Literal)
                pass
            elif token in [postgreSQLParser.DEALLOCATE]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1055
                self.match(postgreSQLParser.DEALLOCATE)
                self.state = 1057
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,48,self._ctx)
                if la_ == 1:
                    self.state = 1056
                    self.match(postgreSQLParser.PREPARE)


                self.state = 1061
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 1059
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 1060
                    self.match(postgreSQLParser.ALL)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.REINDEX]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1063
                self.match(postgreSQLParser.REINDEX)
                self.state = 1067
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 1064
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 1065
                    self.match(postgreSQLParser.VERBOSE)
                    self.state = 1066
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 1069
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DATABASE or _la==postgreSQLParser.INDEX or _la==postgreSQLParser.SCHEMA or _la==postgreSQLParser.SYSTEM or _la==postgreSQLParser.TABLE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1071
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CONCURRENTLY:
                    self.state = 1070
                    self.match(postgreSQLParser.CONCURRENTLY)


                self.state = 1073
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.RESET]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1074
                self.match(postgreSQLParser.RESET)
                self.state = 1086
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,53,self._ctx)
                if la_ == 1:
                    self.state = 1078
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,52,self._ctx)
                    if la_ == 1:
                        self.state = 1075
                        self.identifier()
                        self.state = 1076
                        self.match(postgreSQLParser.DOT)


                    self.state = 1080
                    self.identifier()
                    pass

                elif la_ == 2:
                    self.state = 1081
                    self.match(postgreSQLParser.TIME)
                    self.state = 1082
                    self.match(postgreSQLParser.ZONE)
                    pass

                elif la_ == 3:
                    self.state = 1083
                    self.match(postgreSQLParser.SESSION)
                    self.state = 1084
                    self.match(postgreSQLParser.AUTHORIZATION)
                    pass

                elif la_ == 4:
                    self.state = 1085
                    self.match(postgreSQLParser.ALL)
                    pass


                pass
            elif token in [postgreSQLParser.REFRESH]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1088
                self.match(postgreSQLParser.REFRESH)
                self.state = 1089
                self.match(postgreSQLParser.MATERIALIZED)
                self.state = 1090
                self.match(postgreSQLParser.VIEW)
                self.state = 1092
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CONCURRENTLY:
                    self.state = 1091
                    self.match(postgreSQLParser.CONCURRENTLY)


                self.state = 1094
                self.schema_qualified_name()
                self.state = 1100
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 1095
                    self.match(postgreSQLParser.WITH)
                    self.state = 1097
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.NO:
                        self.state = 1096
                        self.match(postgreSQLParser.NO)


                    self.state = 1099
                    self.match(postgreSQLParser.DATA)


                pass
            elif token in [postgreSQLParser.PREPARE]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1102
                self.match(postgreSQLParser.PREPARE)
                self.state = 1103
                self.identifier()
                self.state = 1115
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 1104
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 1105
                    self.data_type()
                    self.state = 1110
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 1106
                        self.match(postgreSQLParser.COMMA)
                        self.state = 1107
                        self.data_type()
                        self.state = 1112
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 1113
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 1117
                self.match(postgreSQLParser.AS)
                self.state = 1118
                self.data_statement()
                pass
            elif token in [postgreSQLParser.REASSIGN]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1120
                self.match(postgreSQLParser.REASSIGN)
                self.state = 1121
                self.match(postgreSQLParser.OWNED)
                self.state = 1122
                self.match(postgreSQLParser.BY)
                self.state = 1123
                self.user_name()
                self.state = 1128
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1124
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1125
                    self.user_name()
                    self.state = 1130
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1131
                self.match(postgreSQLParser.TO)
                self.state = 1132
                self.user_name()
                pass
            elif token in [postgreSQLParser.COPY]:
                self.enterOuterAlt(localctx, 14)
                self.state = 1134
                self.copy_statement()
                pass
            elif token in [postgreSQLParser.TRUNCATE]:
                self.enterOuterAlt(localctx, 15)
                self.state = 1135
                self.truncate_stmt()
                pass
            elif token in [postgreSQLParser.NOTIFY]:
                self.enterOuterAlt(localctx, 16)
                self.state = 1136
                self.notify_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Explain_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXPLAIN(self):
            return self.getToken(postgreSQLParser.EXPLAIN, 0)

        def explain_query(self):
            return self.getTypedRuleContext(postgreSQLParser.Explain_queryContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def explain_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Explain_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Explain_optionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_explain_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplain_statement" ):
                listener.enterExplain_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplain_statement" ):
                listener.exitExplain_statement(self)




    def explain_statement(self):

        localctx = postgreSQLParser.Explain_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_explain_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1139
            self.match(postgreSQLParser.EXPLAIN)
            self.state = 1157
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,64,self._ctx)
            if la_ == 1:
                self.state = 1141
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ANALYZE:
                    self.state = 1140
                    self.match(postgreSQLParser.ANALYZE)


                self.state = 1144
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.VERBOSE:
                    self.state = 1143
                    self.match(postgreSQLParser.VERBOSE)


                pass

            elif la_ == 2:
                self.state = 1146
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1147
                self.explain_option()
                self.state = 1152
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1148
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1149
                    self.explain_option()
                    self.state = 1154
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1155
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass


            self.state = 1159
            self.explain_query()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Explain_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_statementContext,0)


        def execute_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Execute_statementContext,0)


        def declare_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Declare_statementContext,0)


        def CREATE(self):
            return self.getToken(postgreSQLParser.CREATE, 0)

        def create_table_as_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_table_as_statementContext,0)


        def create_view_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_view_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_explain_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplain_query" ):
                listener.enterExplain_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplain_query" ):
                listener.exitExplain_query(self)




    def explain_query(self):

        localctx = postgreSQLParser.Explain_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_explain_query)
        try:
            self.state = 1169
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.DELETE, postgreSQLParser.INSERT, postgreSQLParser.UPDATE, postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE, postgreSQLParser.WITH, postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1161
                self.data_statement()
                pass
            elif token in [postgreSQLParser.EXECUTE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1162
                self.execute_statement()
                pass
            elif token in [postgreSQLParser.DECLARE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1163
                self.declare_statement()
                pass
            elif token in [postgreSQLParser.CREATE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1164
                self.match(postgreSQLParser.CREATE)
                self.state = 1167
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,65,self._ctx)
                if la_ == 1:
                    self.state = 1165
                    self.create_table_as_statement()
                    pass

                elif la_ == 2:
                    self.state = 1166
                    self.create_view_statement()
                    pass


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Execute_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_execute_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecute_statement" ):
                listener.enterExecute_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecute_statement" ):
                listener.exitExecute_statement(self)




    def execute_statement(self):

        localctx = postgreSQLParser.Execute_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_execute_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1171
            self.match(postgreSQLParser.EXECUTE)
            self.state = 1172
            self.identifier()
            self.state = 1184
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 1173
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1174
                self.vex(0)
                self.state = 1179
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1175
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1176
                    self.vex(0)
                    self.state = 1181
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1182
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Declare_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECLARE(self):
            return self.getToken(postgreSQLParser.DECLARE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def CURSOR(self):
            return self.getToken(postgreSQLParser.CURSOR, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def BINARY(self):
            return self.getToken(postgreSQLParser.BINARY, 0)

        def INSENSITIVE(self):
            return self.getToken(postgreSQLParser.INSENSITIVE, 0)

        def SCROLL(self):
            return self.getToken(postgreSQLParser.SCROLL, 0)

        def HOLD(self):
            return self.getToken(postgreSQLParser.HOLD, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_declare_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclare_statement" ):
                listener.enterDeclare_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclare_statement" ):
                listener.exitDeclare_statement(self)




    def declare_statement(self):

        localctx = postgreSQLParser.Declare_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_declare_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1186
            self.match(postgreSQLParser.DECLARE)
            self.state = 1187
            self.identifier()
            self.state = 1189
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.BINARY:
                self.state = 1188
                self.match(postgreSQLParser.BINARY)


            self.state = 1192
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INSENSITIVE:
                self.state = 1191
                self.match(postgreSQLParser.INSENSITIVE)


            self.state = 1198
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NO or _la==postgreSQLParser.SCROLL:
                self.state = 1195
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 1194
                    self.match(postgreSQLParser.NO)


                self.state = 1197
                self.match(postgreSQLParser.SCROLL)


            self.state = 1200
            self.match(postgreSQLParser.CURSOR)
            self.state = 1203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITHOUT or _la==postgreSQLParser.WITH:
                self.state = 1201
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.WITHOUT or _la==postgreSQLParser.WITH):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1202
                self.match(postgreSQLParser.HOLD)


            self.state = 1205
            self.match(postgreSQLParser.FOR)
            self.state = 1206
            self.select_stmt()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Show_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SHOW(self):
            return self.getToken(postgreSQLParser.SHOW, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def TIME(self):
            return self.getToken(postgreSQLParser.TIME, 0)

        def ZONE(self):
            return self.getToken(postgreSQLParser.ZONE, 0)

        def TRANSACTION(self):
            return self.getToken(postgreSQLParser.TRANSACTION, 0)

        def ISOLATION(self):
            return self.getToken(postgreSQLParser.ISOLATION, 0)

        def LEVEL(self):
            return self.getToken(postgreSQLParser.LEVEL, 0)

        def SESSION(self):
            return self.getToken(postgreSQLParser.SESSION, 0)

        def AUTHORIZATION(self):
            return self.getToken(postgreSQLParser.AUTHORIZATION, 0)

        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_show_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterShow_statement" ):
                listener.enterShow_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitShow_statement" ):
                listener.exitShow_statement(self)




    def show_statement(self):

        localctx = postgreSQLParser.Show_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_show_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1208
            self.match(postgreSQLParser.SHOW)
            self.state = 1223
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,75,self._ctx)
            if la_ == 1:
                self.state = 1212
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,74,self._ctx)
                if la_ == 1:
                    self.state = 1209
                    self.identifier()
                    self.state = 1210
                    self.match(postgreSQLParser.DOT)


                self.state = 1214
                self.identifier()
                pass

            elif la_ == 2:
                self.state = 1215
                self.match(postgreSQLParser.ALL)
                pass

            elif la_ == 3:
                self.state = 1216
                self.match(postgreSQLParser.TIME)
                self.state = 1217
                self.match(postgreSQLParser.ZONE)
                pass

            elif la_ == 4:
                self.state = 1218
                self.match(postgreSQLParser.TRANSACTION)
                self.state = 1219
                self.match(postgreSQLParser.ISOLATION)
                self.state = 1220
                self.match(postgreSQLParser.LEVEL)
                pass

            elif la_ == 5:
                self.state = 1221
                self.match(postgreSQLParser.SESSION)
                self.state = 1222
                self.match(postgreSQLParser.AUTHORIZATION)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Explain_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def COSTS(self):
            return self.getToken(postgreSQLParser.COSTS, 0)

        def SETTINGS(self):
            return self.getToken(postgreSQLParser.SETTINGS, 0)

        def BUFFERS(self):
            return self.getToken(postgreSQLParser.BUFFERS, 0)

        def WAL(self):
            return self.getToken(postgreSQLParser.WAL, 0)

        def TIMING(self):
            return self.getToken(postgreSQLParser.TIMING, 0)

        def SUMMARY(self):
            return self.getToken(postgreSQLParser.SUMMARY, 0)

        def boolean_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Boolean_valueContext,0)


        def FORMAT(self):
            return self.getToken(postgreSQLParser.FORMAT, 0)

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def XML(self):
            return self.getToken(postgreSQLParser.XML, 0)

        def JSON(self):
            return self.getToken(postgreSQLParser.JSON, 0)

        def YAML(self):
            return self.getToken(postgreSQLParser.YAML, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_explain_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExplain_option" ):
                listener.enterExplain_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExplain_option" ):
                listener.exitExplain_option(self)




    def explain_option(self):

        localctx = postgreSQLParser.Explain_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_explain_option)
        self._la = 0 # Token type
        try:
            self.state = 1231
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.VERBOSE, postgreSQLParser.ANALYZE, postgreSQLParser.BUFFERS, postgreSQLParser.COSTS, postgreSQLParser.SETTINGS, postgreSQLParser.SUMMARY, postgreSQLParser.TIMING, postgreSQLParser.WAL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1225
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.VERBOSE or _la==postgreSQLParser.ANALYZE or _la==postgreSQLParser.BUFFERS or _la==postgreSQLParser.COSTS or ((((_la - 532)) & ~0x3f) == 0 and ((1 << (_la - 532)) & ((1 << (postgreSQLParser.SETTINGS - 532)) | (1 << (postgreSQLParser.SUMMARY - 532)) | (1 << (postgreSQLParser.TIMING - 532)) | (1 << (postgreSQLParser.WAL - 532)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1227
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OFF or ((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0) or ((((_la - 618)) & ~0x3f) == 0 and ((1 << (_la - 618)) & ((1 << (postgreSQLParser.NUMBER_LITERAL - 618)) | (1 << (postgreSQLParser.Character_String_Literal - 618)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 618)))) != 0):
                    self.state = 1226
                    self.boolean_value()


                pass
            elif token in [postgreSQLParser.FORMAT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1229
                self.match(postgreSQLParser.FORMAT)
                self.state = 1230
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TEXT or _la==postgreSQLParser.XML or _la==postgreSQLParser.JSON or _la==postgreSQLParser.YAML):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def CURRENT_USER(self):
            return self.getToken(postgreSQLParser.CURRENT_USER, 0)

        def SESSION_USER(self):
            return self.getToken(postgreSQLParser.SESSION_USER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_user_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser_name" ):
                listener.enterUser_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser_name" ):
                listener.exitUser_name(self)




    def user_name(self):

        localctx = postgreSQLParser.User_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_user_name)
        try:
            self.state = 1236
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1233
                self.identifier()
                pass
            elif token in [postgreSQLParser.CURRENT_USER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1234
                self.match(postgreSQLParser.CURRENT_USER)
                pass
            elif token in [postgreSQLParser.SESSION_USER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1235
                self.match(postgreSQLParser.SESSION_USER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_cols_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_cols(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_colsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_colsContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_cols_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_cols_list" ):
                listener.enterTable_cols_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_cols_list" ):
                listener.exitTable_cols_list(self)




    def table_cols_list(self):

        localctx = postgreSQLParser.Table_cols_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_table_cols_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1238
            self.table_cols()
            self.state = 1243
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 1239
                self.match(postgreSQLParser.COMMA)
                self.state = 1240
                self.table_cols()
                self.state = 1245
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_colsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_cols

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_cols" ):
                listener.enterTable_cols(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_cols" ):
                listener.exitTable_cols(self)




    def table_cols(self):

        localctx = postgreSQLParser.Table_colsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_table_cols)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1246
            self.schema_qualified_name()
            self.state = 1258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 1247
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1248
                self.identifier()
                self.state = 1253
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1249
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1250
                    self.identifier()
                    self.state = 1255
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1256
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Vacuum_modeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vacuum_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Vacuum_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Vacuum_optionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def FULL(self):
            return self.getToken(postgreSQLParser.FULL, 0)

        def FREEZE(self):
            return self.getToken(postgreSQLParser.FREEZE, 0)

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_vacuum_mode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVacuum_mode" ):
                listener.enterVacuum_mode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVacuum_mode" ):
                listener.exitVacuum_mode(self)




    def vacuum_mode(self):

        localctx = postgreSQLParser.Vacuum_modeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 48, self.RULE_vacuum_mode)
        self._la = 0 # Token type
        try:
            self.state = 1283
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1260
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1261
                self.vacuum_option()
                self.state = 1266
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1262
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1263
                    self.vacuum_option()
                    self.state = 1268
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 1269
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.EOF, postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.VERBOSE, postgreSQLParser.ANALYZE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.SEMI_COLON, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1272
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FULL:
                    self.state = 1271
                    self.match(postgreSQLParser.FULL)


                self.state = 1275
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FREEZE:
                    self.state = 1274
                    self.match(postgreSQLParser.FREEZE)


                self.state = 1278
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.VERBOSE:
                    self.state = 1277
                    self.match(postgreSQLParser.VERBOSE)


                self.state = 1281
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ANALYZE:
                    self.state = 1280
                    self.match(postgreSQLParser.ANALYZE)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Vacuum_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FULL(self):
            return self.getToken(postgreSQLParser.FULL, 0)

        def FREEZE(self):
            return self.getToken(postgreSQLParser.FREEZE, 0)

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def DISABLE_PAGE_SKIPPING(self):
            return self.getToken(postgreSQLParser.DISABLE_PAGE_SKIPPING, 0)

        def SKIP_LOCKED(self):
            return self.getToken(postgreSQLParser.SKIP_LOCKED, 0)

        def INDEX_CLEANUP(self):
            return self.getToken(postgreSQLParser.INDEX_CLEANUP, 0)

        def TRUNCATE(self):
            return self.getToken(postgreSQLParser.TRUNCATE, 0)

        def boolean_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Boolean_valueContext,0)


        def PARALLEL(self):
            return self.getToken(postgreSQLParser.PARALLEL, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_vacuum_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVacuum_option" ):
                listener.enterVacuum_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVacuum_option" ):
                listener.exitVacuum_option(self)




    def vacuum_option(self):

        localctx = postgreSQLParser.Vacuum_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 50, self.RULE_vacuum_option)
        self._la = 0 # Token type
        try:
            self.state = 1291
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.TRUNCATE, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.VERBOSE, postgreSQLParser.ANALYZE, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.SKIP_LOCKED]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1285
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TRUNCATE or ((((_la - 357)) & ~0x3f) == 0 and ((1 << (_la - 357)) & ((1 << (postgreSQLParser.FREEZE - 357)) | (1 << (postgreSQLParser.FULL - 357)) | (1 << (postgreSQLParser.VERBOSE - 357)) | (1 << (postgreSQLParser.ANALYZE - 357)))) != 0) or _la==postgreSQLParser.DISABLE_PAGE_SKIPPING or _la==postgreSQLParser.INDEX_CLEANUP or _la==postgreSQLParser.SKIP_LOCKED):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1287
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OFF or ((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0) or ((((_la - 618)) & ~0x3f) == 0 and ((1 << (_la - 618)) & ((1 << (postgreSQLParser.NUMBER_LITERAL - 618)) | (1 << (postgreSQLParser.Character_String_Literal - 618)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 618)))) != 0):
                    self.state = 1286
                    self.boolean_value()


                pass
            elif token in [postgreSQLParser.PARALLEL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1289
                self.match(postgreSQLParser.PARALLEL)
                self.state = 1290
                self.match(postgreSQLParser.NUMBER_LITERAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Analyze_modeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def SKIP_LOCKED(self):
            return self.getToken(postgreSQLParser.SKIP_LOCKED, 0)

        def boolean_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Boolean_valueContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_analyze_mode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnalyze_mode" ):
                listener.enterAnalyze_mode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnalyze_mode" ):
                listener.exitAnalyze_mode(self)




    def analyze_mode(self):

        localctx = postgreSQLParser.Analyze_modeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 52, self.RULE_analyze_mode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1293
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.VERBOSE or _la==postgreSQLParser.SKIP_LOCKED):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1295
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OFF or ((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0) or ((((_la - 618)) & ~0x3f) == 0 and ((1 << (_la - 618)) & ((1 << (postgreSQLParser.NUMBER_LITERAL - 618)) | (1 << (postgreSQLParser.Character_String_Literal - 618)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 618)))) != 0):
                self.state = 1294
                self.boolean_value()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Boolean_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(postgreSQLParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(postgreSQLParser.FALSE, 0)

        def OFF(self):
            return self.getToken(postgreSQLParser.OFF, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_boolean_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBoolean_value" ):
                listener.enterBoolean_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBoolean_value" ):
                listener.exitBoolean_value(self)




    def boolean_value(self):

        localctx = postgreSQLParser.Boolean_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 54, self.RULE_boolean_value)
        try:
            self.state = 1303
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.TRUE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1297
                self.match(postgreSQLParser.TRUE)
                pass
            elif token in [postgreSQLParser.FALSE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1298
                self.match(postgreSQLParser.FALSE)
                pass
            elif token in [postgreSQLParser.OFF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1299
                self.match(postgreSQLParser.OFF)
                pass
            elif token in [postgreSQLParser.ON]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1300
                self.match(postgreSQLParser.ON)
                pass
            elif token in [postgreSQLParser.NUMBER_LITERAL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1301
                self.match(postgreSQLParser.NUMBER_LITERAL)
                pass
            elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1302
                self.character_string()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fetch_move_directionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NEXT(self):
            return self.getToken(postgreSQLParser.NEXT, 0)

        def PRIOR(self):
            return self.getToken(postgreSQLParser.PRIOR, 0)

        def FIRST(self):
            return self.getToken(postgreSQLParser.FIRST, 0)

        def LAST(self):
            return self.getToken(postgreSQLParser.LAST, 0)

        def signed_number_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Signed_number_literalContext,0)


        def ABSOLUTE(self):
            return self.getToken(postgreSQLParser.ABSOLUTE, 0)

        def RELATIVE(self):
            return self.getToken(postgreSQLParser.RELATIVE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def FORWARD(self):
            return self.getToken(postgreSQLParser.FORWARD, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def BACKWARD(self):
            return self.getToken(postgreSQLParser.BACKWARD, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_fetch_move_direction

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFetch_move_direction" ):
                listener.enterFetch_move_direction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFetch_move_direction" ):
                listener.exitFetch_move_direction(self)




    def fetch_move_direction(self):

        localctx = postgreSQLParser.Fetch_move_directionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 56, self.RULE_fetch_move_direction)
        self._la = 0 # Token type
        try:
            self.state = 1322
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.NEXT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1305
                self.match(postgreSQLParser.NEXT)
                pass
            elif token in [postgreSQLParser.PRIOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1306
                self.match(postgreSQLParser.PRIOR)
                pass
            elif token in [postgreSQLParser.FIRST]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1307
                self.match(postgreSQLParser.FIRST)
                pass
            elif token in [postgreSQLParser.LAST]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1308
                self.match(postgreSQLParser.LAST)
                pass
            elif token in [postgreSQLParser.ABSOLUTE, postgreSQLParser.RELATIVE, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.NUMBER_LITERAL]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1310
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ABSOLUTE or _la==postgreSQLParser.RELATIVE:
                    self.state = 1309
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.ABSOLUTE or _la==postgreSQLParser.RELATIVE):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 1312
                self.signed_number_literal()
                pass
            elif token in [postgreSQLParser.ALL]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1313
                self.match(postgreSQLParser.ALL)
                pass
            elif token in [postgreSQLParser.FORWARD]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1314
                self.match(postgreSQLParser.FORWARD)
                self.state = 1316
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ALL or _la==postgreSQLParser.NUMBER_LITERAL:
                    self.state = 1315
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.ALL or _la==postgreSQLParser.NUMBER_LITERAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [postgreSQLParser.BACKWARD]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1318
                self.match(postgreSQLParser.BACKWARD)
                self.state = 1320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ALL or _la==postgreSQLParser.NUMBER_LITERAL:
                    self.state = 1319
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.ALL or _la==postgreSQLParser.NUMBER_LITERAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_create(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_createContext,0)


        def schema_alter(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_alterContext,0)


        def schema_drop(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_dropContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_statement" ):
                listener.enterSchema_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_statement" ):
                listener.exitSchema_statement(self)




    def schema_statement(self):

        localctx = postgreSQLParser.Schema_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 58, self.RULE_schema_statement)
        try:
            self.state = 1327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.COMMENT, postgreSQLParser.IMPORT, postgreSQLParser.REVOKE, postgreSQLParser.SECURITY, postgreSQLParser.SET, postgreSQLParser.CREATE, postgreSQLParser.GRANT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1324
                self.schema_create()
                pass
            elif token in [postgreSQLParser.ALTER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1325
                self.schema_alter()
                pass
            elif token in [postgreSQLParser.DROP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1326
                self.schema_drop()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_createContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CREATE(self):
            return self.getToken(postgreSQLParser.CREATE, 0)

        def create_access_method_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_access_method_statementContext,0)


        def create_aggregate_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_aggregate_statementContext,0)


        def create_cast_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_cast_statementContext,0)


        def create_collation_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_collation_statementContext,0)


        def create_conversion_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_conversion_statementContext,0)


        def create_database_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_database_statementContext,0)


        def create_domain_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_domain_statementContext,0)


        def create_event_trigger_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_event_trigger_statementContext,0)


        def create_extension_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_extension_statementContext,0)


        def create_foreign_data_wrapper_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_foreign_data_wrapper_statementContext,0)


        def create_foreign_table_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_foreign_table_statementContext,0)


        def create_fts_configuration_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_fts_configuration_statementContext,0)


        def create_fts_dictionary_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_fts_dictionary_statementContext,0)


        def create_fts_parser_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_fts_parser_statementContext,0)


        def create_fts_template_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_fts_template_statementContext,0)


        def create_function_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_function_statementContext,0)


        def create_group_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_group_statementContext,0)


        def create_index_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_index_statementContext,0)


        def create_language_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_language_statementContext,0)


        def create_operator_class_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_operator_class_statementContext,0)


        def create_operator_family_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_operator_family_statementContext,0)


        def create_operator_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_operator_statementContext,0)


        def create_policy_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_policy_statementContext,0)


        def create_publication_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_publication_statementContext,0)


        def create_rewrite_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_rewrite_statementContext,0)


        def create_schema_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_schema_statementContext,0)


        def create_sequence_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_sequence_statementContext,0)


        def create_server_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_server_statementContext,0)


        def create_statistics_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_statistics_statementContext,0)


        def create_subscription_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_subscription_statementContext,0)


        def create_table_as_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_table_as_statementContext,0)


        def create_table_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_table_statementContext,0)


        def create_tablespace_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_tablespace_statementContext,0)


        def create_transform_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_transform_statementContext,0)


        def create_trigger_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_trigger_statementContext,0)


        def create_type_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_type_statementContext,0)


        def create_user_mapping_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_user_mapping_statementContext,0)


        def create_user_or_role_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_user_or_role_statementContext,0)


        def create_view_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_view_statementContext,0)


        def comment_on_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Comment_on_statementContext,0)


        def rule_common(self):
            return self.getTypedRuleContext(postgreSQLParser.Rule_commonContext,0)


        def schema_import(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_importContext,0)


        def security_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Security_labelContext,0)


        def set_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_create

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_create" ):
                listener.enterSchema_create(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_create" ):
                listener.exitSchema_create(self)




    def schema_create(self):

        localctx = postgreSQLParser.Schema_createContext(self, self._ctx, self.state)
        self.enterRule(localctx, 60, self.RULE_schema_create)
        try:
            self.state = 1376
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CREATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1329
                self.match(postgreSQLParser.CREATE)
                self.state = 1369
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,97,self._ctx)
                if la_ == 1:
                    self.state = 1330
                    self.create_access_method_statement()
                    pass

                elif la_ == 2:
                    self.state = 1331
                    self.create_aggregate_statement()
                    pass

                elif la_ == 3:
                    self.state = 1332
                    self.create_cast_statement()
                    pass

                elif la_ == 4:
                    self.state = 1333
                    self.create_collation_statement()
                    pass

                elif la_ == 5:
                    self.state = 1334
                    self.create_conversion_statement()
                    pass

                elif la_ == 6:
                    self.state = 1335
                    self.create_database_statement()
                    pass

                elif la_ == 7:
                    self.state = 1336
                    self.create_domain_statement()
                    pass

                elif la_ == 8:
                    self.state = 1337
                    self.create_event_trigger_statement()
                    pass

                elif la_ == 9:
                    self.state = 1338
                    self.create_extension_statement()
                    pass

                elif la_ == 10:
                    self.state = 1339
                    self.create_foreign_data_wrapper_statement()
                    pass

                elif la_ == 11:
                    self.state = 1340
                    self.create_foreign_table_statement()
                    pass

                elif la_ == 12:
                    self.state = 1341
                    self.create_fts_configuration_statement()
                    pass

                elif la_ == 13:
                    self.state = 1342
                    self.create_fts_dictionary_statement()
                    pass

                elif la_ == 14:
                    self.state = 1343
                    self.create_fts_parser_statement()
                    pass

                elif la_ == 15:
                    self.state = 1344
                    self.create_fts_template_statement()
                    pass

                elif la_ == 16:
                    self.state = 1345
                    self.create_function_statement()
                    pass

                elif la_ == 17:
                    self.state = 1346
                    self.create_group_statement()
                    pass

                elif la_ == 18:
                    self.state = 1347
                    self.create_index_statement()
                    pass

                elif la_ == 19:
                    self.state = 1348
                    self.create_language_statement()
                    pass

                elif la_ == 20:
                    self.state = 1349
                    self.create_operator_class_statement()
                    pass

                elif la_ == 21:
                    self.state = 1350
                    self.create_operator_family_statement()
                    pass

                elif la_ == 22:
                    self.state = 1351
                    self.create_operator_statement()
                    pass

                elif la_ == 23:
                    self.state = 1352
                    self.create_policy_statement()
                    pass

                elif la_ == 24:
                    self.state = 1353
                    self.create_publication_statement()
                    pass

                elif la_ == 25:
                    self.state = 1354
                    self.create_rewrite_statement()
                    pass

                elif la_ == 26:
                    self.state = 1355
                    self.create_schema_statement()
                    pass

                elif la_ == 27:
                    self.state = 1356
                    self.create_sequence_statement()
                    pass

                elif la_ == 28:
                    self.state = 1357
                    self.create_server_statement()
                    pass

                elif la_ == 29:
                    self.state = 1358
                    self.create_statistics_statement()
                    pass

                elif la_ == 30:
                    self.state = 1359
                    self.create_subscription_statement()
                    pass

                elif la_ == 31:
                    self.state = 1360
                    self.create_table_as_statement()
                    pass

                elif la_ == 32:
                    self.state = 1361
                    self.create_table_statement()
                    pass

                elif la_ == 33:
                    self.state = 1362
                    self.create_tablespace_statement()
                    pass

                elif la_ == 34:
                    self.state = 1363
                    self.create_transform_statement()
                    pass

                elif la_ == 35:
                    self.state = 1364
                    self.create_trigger_statement()
                    pass

                elif la_ == 36:
                    self.state = 1365
                    self.create_type_statement()
                    pass

                elif la_ == 37:
                    self.state = 1366
                    self.create_user_mapping_statement()
                    pass

                elif la_ == 38:
                    self.state = 1367
                    self.create_user_or_role_statement()
                    pass

                elif la_ == 39:
                    self.state = 1368
                    self.create_view_statement()
                    pass


                pass
            elif token in [postgreSQLParser.COMMENT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1371
                self.comment_on_statement()
                pass
            elif token in [postgreSQLParser.REVOKE, postgreSQLParser.GRANT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1372
                self.rule_common()
                pass
            elif token in [postgreSQLParser.IMPORT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1373
                self.schema_import()
                pass
            elif token in [postgreSQLParser.SECURITY]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1374
                self.security_label()
                pass
            elif token in [postgreSQLParser.SET]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1375
                self.set_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_alterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def alter_aggregate_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_aggregate_statementContext,0)


        def alter_collation_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_collation_statementContext,0)


        def alter_conversion_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_conversion_statementContext,0)


        def alter_default_privileges_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_default_privileges_statementContext,0)


        def alter_database_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_database_statementContext,0)


        def alter_domain_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_domain_statementContext,0)


        def alter_event_trigger_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_event_trigger_statementContext,0)


        def alter_extension_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_extension_statementContext,0)


        def alter_foreign_data_wrapper(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_foreign_data_wrapperContext,0)


        def alter_fts_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_fts_statementContext,0)


        def alter_function_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_function_statementContext,0)


        def alter_group_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_group_statementContext,0)


        def alter_index_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_index_statementContext,0)


        def alter_language_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_language_statementContext,0)


        def alter_materialized_view_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_materialized_view_statementContext,0)


        def alter_operator_class_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_operator_class_statementContext,0)


        def alter_operator_family_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_operator_family_statementContext,0)


        def alter_operator_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_operator_statementContext,0)


        def alter_owner_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_owner_statementContext,0)


        def alter_policy_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_policy_statementContext,0)


        def alter_publication_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_publication_statementContext,0)


        def alter_rule_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_rule_statementContext,0)


        def alter_schema_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_schema_statementContext,0)


        def alter_sequence_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_sequence_statementContext,0)


        def alter_server_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_server_statementContext,0)


        def alter_statistics_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_statistics_statementContext,0)


        def alter_subscription_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_subscription_statementContext,0)


        def alter_table_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_table_statementContext,0)


        def alter_tablespace_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_tablespace_statementContext,0)


        def alter_trigger_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_trigger_statementContext,0)


        def alter_type_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_type_statementContext,0)


        def alter_user_mapping_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_user_mapping_statementContext,0)


        def alter_user_or_role_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_user_or_role_statementContext,0)


        def alter_view_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_view_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_alter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_alter" ):
                listener.enterSchema_alter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_alter" ):
                listener.exitSchema_alter(self)




    def schema_alter(self):

        localctx = postgreSQLParser.Schema_alterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 62, self.RULE_schema_alter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1378
            self.match(postgreSQLParser.ALTER)
            self.state = 1413
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,99,self._ctx)
            if la_ == 1:
                self.state = 1379
                self.alter_aggregate_statement()
                pass

            elif la_ == 2:
                self.state = 1380
                self.alter_collation_statement()
                pass

            elif la_ == 3:
                self.state = 1381
                self.alter_conversion_statement()
                pass

            elif la_ == 4:
                self.state = 1382
                self.alter_default_privileges_statement()
                pass

            elif la_ == 5:
                self.state = 1383
                self.alter_database_statement()
                pass

            elif la_ == 6:
                self.state = 1384
                self.alter_domain_statement()
                pass

            elif la_ == 7:
                self.state = 1385
                self.alter_event_trigger_statement()
                pass

            elif la_ == 8:
                self.state = 1386
                self.alter_extension_statement()
                pass

            elif la_ == 9:
                self.state = 1387
                self.alter_foreign_data_wrapper()
                pass

            elif la_ == 10:
                self.state = 1388
                self.alter_fts_statement()
                pass

            elif la_ == 11:
                self.state = 1389
                self.alter_function_statement()
                pass

            elif la_ == 12:
                self.state = 1390
                self.alter_group_statement()
                pass

            elif la_ == 13:
                self.state = 1391
                self.alter_index_statement()
                pass

            elif la_ == 14:
                self.state = 1392
                self.alter_language_statement()
                pass

            elif la_ == 15:
                self.state = 1393
                self.alter_materialized_view_statement()
                pass

            elif la_ == 16:
                self.state = 1394
                self.alter_operator_class_statement()
                pass

            elif la_ == 17:
                self.state = 1395
                self.alter_operator_family_statement()
                pass

            elif la_ == 18:
                self.state = 1396
                self.alter_operator_statement()
                pass

            elif la_ == 19:
                self.state = 1397
                self.alter_owner_statement()
                pass

            elif la_ == 20:
                self.state = 1398
                self.alter_policy_statement()
                pass

            elif la_ == 21:
                self.state = 1399
                self.alter_publication_statement()
                pass

            elif la_ == 22:
                self.state = 1400
                self.alter_rule_statement()
                pass

            elif la_ == 23:
                self.state = 1401
                self.alter_schema_statement()
                pass

            elif la_ == 24:
                self.state = 1402
                self.alter_sequence_statement()
                pass

            elif la_ == 25:
                self.state = 1403
                self.alter_server_statement()
                pass

            elif la_ == 26:
                self.state = 1404
                self.alter_statistics_statement()
                pass

            elif la_ == 27:
                self.state = 1405
                self.alter_subscription_statement()
                pass

            elif la_ == 28:
                self.state = 1406
                self.alter_table_statement()
                pass

            elif la_ == 29:
                self.state = 1407
                self.alter_tablespace_statement()
                pass

            elif la_ == 30:
                self.state = 1408
                self.alter_trigger_statement()
                pass

            elif la_ == 31:
                self.state = 1409
                self.alter_type_statement()
                pass

            elif la_ == 32:
                self.state = 1410
                self.alter_user_mapping_statement()
                pass

            elif la_ == 33:
                self.state = 1411
                self.alter_user_or_role_statement()
                pass

            elif la_ == 34:
                self.state = 1412
                self.alter_view_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_dropContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def drop_cast_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_cast_statementContext,0)


        def drop_database_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_database_statementContext,0)


        def drop_function_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_function_statementContext,0)


        def drop_operator_class_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_operator_class_statementContext,0)


        def drop_operator_family_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_operator_family_statementContext,0)


        def drop_operator_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_operator_statementContext,0)


        def drop_owned_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_owned_statementContext,0)


        def drop_policy_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_policy_statementContext,0)


        def drop_rule_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_rule_statementContext,0)


        def drop_statements(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_statementsContext,0)


        def drop_trigger_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_trigger_statementContext,0)


        def drop_user_mapping_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_user_mapping_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_drop

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_drop" ):
                listener.enterSchema_drop(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_drop" ):
                listener.exitSchema_drop(self)




    def schema_drop(self):

        localctx = postgreSQLParser.Schema_dropContext(self, self._ctx, self.state)
        self.enterRule(localctx, 64, self.RULE_schema_drop)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1415
            self.match(postgreSQLParser.DROP)
            self.state = 1428
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,100,self._ctx)
            if la_ == 1:
                self.state = 1416
                self.drop_cast_statement()
                pass

            elif la_ == 2:
                self.state = 1417
                self.drop_database_statement()
                pass

            elif la_ == 3:
                self.state = 1418
                self.drop_function_statement()
                pass

            elif la_ == 4:
                self.state = 1419
                self.drop_operator_class_statement()
                pass

            elif la_ == 5:
                self.state = 1420
                self.drop_operator_family_statement()
                pass

            elif la_ == 6:
                self.state = 1421
                self.drop_operator_statement()
                pass

            elif la_ == 7:
                self.state = 1422
                self.drop_owned_statement()
                pass

            elif la_ == 8:
                self.state = 1423
                self.drop_policy_statement()
                pass

            elif la_ == 9:
                self.state = 1424
                self.drop_rule_statement()
                pass

            elif la_ == 10:
                self.state = 1425
                self.drop_statements()
                pass

            elif la_ == 11:
                self.state = 1426
                self.drop_trigger_statement()
                pass

            elif la_ == 12:
                self.state = 1427
                self.drop_user_mapping_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_importContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def IMPORT(self):
            return self.getToken(postgreSQLParser.IMPORT, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def INTO(self):
            return self.getToken(postgreSQLParser.INTO, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def LIMIT(self):
            return self.getToken(postgreSQLParser.LIMIT, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def EXCEPT(self):
            return self.getToken(postgreSQLParser.EXCEPT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_import

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_import" ):
                listener.enterSchema_import(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_import" ):
                listener.exitSchema_import(self)




    def schema_import(self):

        localctx = postgreSQLParser.Schema_importContext(self, self._ctx, self.state)
        self.enterRule(localctx, 66, self.RULE_schema_import)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1430
            self.match(postgreSQLParser.IMPORT)
            self.state = 1431
            self.match(postgreSQLParser.FOREIGN)
            self.state = 1432
            self.match(postgreSQLParser.SCHEMA)
            self.state = 1433
            localctx.name = self.identifier()
            self.state = 1443
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.EXCEPT or _la==postgreSQLParser.LIMIT:
                self.state = 1437
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.LIMIT]:
                    self.state = 1434
                    self.match(postgreSQLParser.LIMIT)
                    self.state = 1435
                    self.match(postgreSQLParser.TO)
                    pass
                elif token in [postgreSQLParser.EXCEPT]:
                    self.state = 1436
                    self.match(postgreSQLParser.EXCEPT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1439
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1440
                self.identifier_list()
                self.state = 1441
                self.match(postgreSQLParser.RIGHT_PAREN)


            self.state = 1445
            self.match(postgreSQLParser.FROM)
            self.state = 1446
            self.match(postgreSQLParser.SERVER)
            self.state = 1447
            self.identifier()
            self.state = 1448
            self.match(postgreSQLParser.INTO)
            self.state = 1449
            self.identifier()
            self.state = 1451
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 1450
                self.define_foreign_options()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_function_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def DEPENDS(self):
            return self.getToken(postgreSQLParser.DEPENDS, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def function_parameters(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_parametersContext,0)


        def function_actions_common(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_actions_commonContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_actions_commonContext,i)


        def RESET(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RESET)
            else:
                return self.getToken(postgreSQLParser.RESET, i)

        def RESTRICT(self):
            return self.getToken(postgreSQLParser.RESTRICT, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def ALL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ALL)
            else:
                return self.getToken(postgreSQLParser.ALL, i)

        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DOT)
            else:
                return self.getToken(postgreSQLParser.DOT, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_function_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_function_statement" ):
                listener.enterAlter_function_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_function_statement" ):
                listener.exitAlter_function_statement(self)




    def alter_function_statement(self):

        localctx = postgreSQLParser.Alter_function_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 68, self.RULE_alter_function_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1453
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 1455
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,104,self._ctx)
            if la_ == 1:
                self.state = 1454
                self.function_parameters()


            self.state = 1484
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,111,self._ctx)
            if la_ == 1:
                self.state = 1468 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1468
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.CALLED, postgreSQLParser.COST, postgreSQLParser.EXTERNAL, postgreSQLParser.IMMUTABLE, postgreSQLParser.LANGUAGE, postgreSQLParser.LEAKPROOF, postgreSQLParser.PARALLEL, postgreSQLParser.RETURNS, postgreSQLParser.ROWS, postgreSQLParser.SECURITY, postgreSQLParser.SET, postgreSQLParser.STABLE, postgreSQLParser.STRICT, postgreSQLParser.SUPPORT, postgreSQLParser.TRANSFORM, postgreSQLParser.VOLATILE, postgreSQLParser.AS, postgreSQLParser.NOT, postgreSQLParser.WINDOW]:
                        self.state = 1457
                        self.function_actions_common()
                        pass
                    elif token in [postgreSQLParser.RESET]:
                        self.state = 1458
                        self.match(postgreSQLParser.RESET)
                        self.state = 1466
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                            self.state = 1462
                            self._errHandler.sync(self)
                            la_ = self._interp.adaptivePredict(self._input,105,self._ctx)
                            if la_ == 1:
                                self.state = 1459
                                self.identifier()
                                self.state = 1460
                                self.match(postgreSQLParser.DOT)


                            self.state = 1464
                            self.identifier()
                            pass
                        elif token in [postgreSQLParser.ALL]:
                            self.state = 1465
                            self.match(postgreSQLParser.ALL)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 1470 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.CALLED or _la==postgreSQLParser.COST or ((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (postgreSQLParser.EXTERNAL - 86)) | (1 << (postgreSQLParser.IMMUTABLE - 86)) | (1 << (postgreSQLParser.LANGUAGE - 86)) | (1 << (postgreSQLParser.LEAKPROOF - 86)))) != 0) or ((((_la - 175)) & ~0x3f) == 0 and ((1 << (_la - 175)) & ((1 << (postgreSQLParser.PARALLEL - 175)) | (1 << (postgreSQLParser.RESET - 175)) | (1 << (postgreSQLParser.RETURNS - 175)) | (1 << (postgreSQLParser.ROWS - 175)) | (1 << (postgreSQLParser.SECURITY - 175)) | (1 << (postgreSQLParser.SET - 175)))) != 0) or ((((_la - 242)) & ~0x3f) == 0 and ((1 << (_la - 242)) & ((1 << (postgreSQLParser.STABLE - 242)) | (1 << (postgreSQLParser.STRICT - 242)) | (1 << (postgreSQLParser.SUPPORT - 242)) | (1 << (postgreSQLParser.TRANSFORM - 242)) | (1 << (postgreSQLParser.VOLATILE - 242)))) != 0) or _la==postgreSQLParser.AS or _la==postgreSQLParser.NOT or _la==postgreSQLParser.WINDOW):
                        break

                self.state = 1473
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.RESTRICT:
                    self.state = 1472
                    self.match(postgreSQLParser.RESTRICT)


                pass

            elif la_ == 2:
                self.state = 1475
                self.rename_to()
                pass

            elif la_ == 3:
                self.state = 1476
                self.set_schema()
                pass

            elif la_ == 4:
                self.state = 1478
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 1477
                    self.match(postgreSQLParser.NO)


                self.state = 1480
                self.match(postgreSQLParser.DEPENDS)
                self.state = 1481
                self.match(postgreSQLParser.ON)
                self.state = 1482
                self.match(postgreSQLParser.EXTENSION)
                self.state = 1483
                self.identifier()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_aggregate_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def function_parameters(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_parametersContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_aggregate_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_aggregate_statement" ):
                listener.enterAlter_aggregate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_aggregate_statement" ):
                listener.exitAlter_aggregate_statement(self)




    def alter_aggregate_statement(self):

        localctx = postgreSQLParser.Alter_aggregate_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 70, self.RULE_alter_aggregate_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1486
            self.match(postgreSQLParser.AGGREGATE)
            self.state = 1487
            self.function_parameters()
            self.state = 1490
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.state = 1488
                self.rename_to()
                pass
            elif token in [postgreSQLParser.SET]:
                self.state = 1489
                self.set_schema()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_extension_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def alter_extension_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_extension_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_extension_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_extension_statement" ):
                listener.enterAlter_extension_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_extension_statement" ):
                listener.exitAlter_extension_statement(self)




    def alter_extension_statement(self):

        localctx = postgreSQLParser.Alter_extension_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 72, self.RULE_alter_extension_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1492
            self.match(postgreSQLParser.EXTENSION)
            self.state = 1493
            self.identifier()
            self.state = 1494
            self.alter_extension_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_extension_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def extension_member_object(self):
            return self.getTypedRuleContext(postgreSQLParser.Extension_member_objectContext,0)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_extension_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_extension_action" ):
                listener.enterAlter_extension_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_extension_action" ):
                listener.exitAlter_extension_action(self)




    def alter_extension_action(self):

        localctx = postgreSQLParser.Alter_extension_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 74, self.RULE_alter_extension_action)
        self._la = 0 # Token type
        try:
            self.state = 1507
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.SET]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1496
                self.set_schema()
                pass
            elif token in [postgreSQLParser.UPDATE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1497
                self.match(postgreSQLParser.UPDATE)
                self.state = 1503
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.TO:
                    self.state = 1498
                    self.match(postgreSQLParser.TO)
                    self.state = 1501
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                        self.state = 1499
                        self.identifier()
                        pass
                    elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                        self.state = 1500
                        self.character_string()
                        pass
                    else:
                        raise NoViableAltException(self)



                pass
            elif token in [postgreSQLParser.ADD, postgreSQLParser.DROP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1505
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ADD or _la==postgreSQLParser.DROP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1506
                self.extension_member_object()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Extension_member_objectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCESS(self):
            return self.getToken(postgreSQLParser.ACCESS, 0)

        def METHOD(self):
            return self.getToken(postgreSQLParser.METHOD, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def function_parameters(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_parametersContext,0)


        def CAST(self):
            return self.getToken(postgreSQLParser.CAST, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def CONVERSION(self):
            return self.getToken(postgreSQLParser.CONVERSION, 0)

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def operator_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Operator_nameContext,0)


        def CLASS(self):
            return self.getToken(postgreSQLParser.CLASS, 0)

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def ROUTINE(self):
            return self.getToken(postgreSQLParser.ROUTINE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def TRANSFORM(self):
            return self.getToken(postgreSQLParser.TRANSFORM, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_extension_member_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtension_member_object" ):
                listener.enterExtension_member_object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtension_member_object" ):
                listener.exitExtension_member_object(self)




    def extension_member_object(self):

        localctx = postgreSQLParser.Extension_member_objectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 76, self.RULE_extension_member_object)
        self._la = 0 # Token type
        try:
            self.state = 1599
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,118,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1509
                self.match(postgreSQLParser.ACCESS)
                self.state = 1510
                self.match(postgreSQLParser.METHOD)
                self.state = 1511
                self.schema_qualified_name()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1512
                self.match(postgreSQLParser.AGGREGATE)
                self.state = 1513
                self.function_parameters()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1514
                self.match(postgreSQLParser.CAST)
                self.state = 1515
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1516
                self.schema_qualified_name()
                self.state = 1517
                self.match(postgreSQLParser.AS)
                self.state = 1518
                self.schema_qualified_name()
                self.state = 1519
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1521
                self.match(postgreSQLParser.COLLATION)
                self.state = 1522
                self.identifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1523
                self.match(postgreSQLParser.CONVERSION)
                self.state = 1524
                self.identifier()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1525
                self.match(postgreSQLParser.DOMAIN)
                self.state = 1526
                self.schema_qualified_name()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1527
                self.match(postgreSQLParser.EVENT)
                self.state = 1528
                self.match(postgreSQLParser.TRIGGER)
                self.state = 1529
                self.identifier()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1530
                self.match(postgreSQLParser.FOREIGN)
                self.state = 1531
                self.match(postgreSQLParser.DATA)
                self.state = 1532
                self.match(postgreSQLParser.WRAPPER)
                self.state = 1533
                self.identifier()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1534
                self.match(postgreSQLParser.FOREIGN)
                self.state = 1535
                self.match(postgreSQLParser.TABLE)
                self.state = 1536
                self.schema_qualified_name()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1537
                self.match(postgreSQLParser.FUNCTION)
                self.state = 1538
                self.function_parameters()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1540
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.MATERIALIZED:
                    self.state = 1539
                    self.match(postgreSQLParser.MATERIALIZED)


                self.state = 1542
                self.match(postgreSQLParser.VIEW)
                self.state = 1543
                self.schema_qualified_name()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1544
                self.match(postgreSQLParser.OPERATOR)
                self.state = 1545
                self.operator_name()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1546
                self.match(postgreSQLParser.OPERATOR)
                self.state = 1547
                self.match(postgreSQLParser.CLASS)
                self.state = 1548
                self.schema_qualified_name()
                self.state = 1549
                self.match(postgreSQLParser.USING)
                self.state = 1550
                self.identifier()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1552
                self.match(postgreSQLParser.OPERATOR)
                self.state = 1553
                self.match(postgreSQLParser.FAMILY)
                self.state = 1554
                self.schema_qualified_name()
                self.state = 1555
                self.match(postgreSQLParser.USING)
                self.state = 1556
                self.identifier()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1559
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PROCEDURAL:
                    self.state = 1558
                    self.match(postgreSQLParser.PROCEDURAL)


                self.state = 1561
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 1562
                self.identifier()
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1563
                self.match(postgreSQLParser.PROCEDURE)
                self.state = 1564
                self.function_parameters()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1565
                self.match(postgreSQLParser.ROUTINE)
                self.state = 1566
                self.function_parameters()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1567
                self.match(postgreSQLParser.SCHEMA)
                self.state = 1568
                self.identifier()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1569
                self.match(postgreSQLParser.SEQUENCE)
                self.state = 1570
                self.schema_qualified_name()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 1571
                self.match(postgreSQLParser.SERVER)
                self.state = 1572
                self.identifier()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 1573
                self.match(postgreSQLParser.TABLE)
                self.state = 1574
                self.schema_qualified_name()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 1575
                self.match(postgreSQLParser.TEXT)
                self.state = 1576
                self.match(postgreSQLParser.SEARCH)
                self.state = 1577
                self.match(postgreSQLParser.CONFIGURATION)
                self.state = 1578
                self.schema_qualified_name()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 1579
                self.match(postgreSQLParser.TEXT)
                self.state = 1580
                self.match(postgreSQLParser.SEARCH)
                self.state = 1581
                self.match(postgreSQLParser.DICTIONARY)
                self.state = 1582
                self.schema_qualified_name()
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 1583
                self.match(postgreSQLParser.TEXT)
                self.state = 1584
                self.match(postgreSQLParser.SEARCH)
                self.state = 1585
                self.match(postgreSQLParser.PARSER)
                self.state = 1586
                self.schema_qualified_name()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 1587
                self.match(postgreSQLParser.TEXT)
                self.state = 1588
                self.match(postgreSQLParser.SEARCH)
                self.state = 1589
                self.match(postgreSQLParser.TEMPLATE)
                self.state = 1590
                self.schema_qualified_name()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 1591
                self.match(postgreSQLParser.TRANSFORM)
                self.state = 1592
                self.match(postgreSQLParser.FOR)
                self.state = 1593
                self.identifier()
                self.state = 1594
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 1595
                self.identifier()
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 1597
                self.match(postgreSQLParser.TYPE)
                self.state = 1598
                self.schema_qualified_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_schema_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_schema_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_schema_statement" ):
                listener.enterAlter_schema_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_schema_statement" ):
                listener.exitAlter_schema_statement(self)




    def alter_schema_statement(self):

        localctx = postgreSQLParser.Alter_schema_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 78, self.RULE_alter_schema_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1601
            self.match(postgreSQLParser.SCHEMA)
            self.state = 1602
            self.identifier()
            self.state = 1603
            self.rename_to()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_language_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_language_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_language_statement" ):
                listener.enterAlter_language_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_language_statement" ):
                listener.exitAlter_language_statement(self)




    def alter_language_statement(self):

        localctx = postgreSQLParser.Alter_language_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 80, self.RULE_alter_language_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1606
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.PROCEDURAL:
                self.state = 1605
                self.match(postgreSQLParser.PROCEDURAL)


            self.state = 1608
            self.match(postgreSQLParser.LANGUAGE)
            self.state = 1609
            localctx.name = self.identifier()
            self.state = 1612
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.state = 1610
                self.rename_to()
                pass
            elif token in [postgreSQLParser.OWNER]:
                self.state = 1611
                self.owner_to()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_table_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tn = None # Schema_qualified_nameContext
            self.child = None # Schema_qualified_nameContext

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def table_action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_actionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_actionContext,i)


        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def ATTACH(self):
            return self.getToken(postgreSQLParser.ATTACH, 0)

        def PARTITION(self):
            return self.getToken(postgreSQLParser.PARTITION, 0)

        def for_values_bound(self):
            return self.getTypedRuleContext(postgreSQLParser.For_values_boundContext,0)


        def DETACH(self):
            return self.getToken(postgreSQLParser.DETACH, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_table_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_table_statement" ):
                listener.enterAlter_table_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_table_statement" ):
                listener.exitAlter_table_statement(self)




    def alter_table_statement(self):

        localctx = postgreSQLParser.Alter_table_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 82, self.RULE_alter_table_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1615
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FOREIGN:
                self.state = 1614
                self.match(postgreSQLParser.FOREIGN)


            self.state = 1617
            self.match(postgreSQLParser.TABLE)
            self.state = 1619
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,122,self._ctx)
            if la_ == 1:
                self.state = 1618
                self.if_exists()


            self.state = 1622
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ONLY:
                self.state = 1621
                self.match(postgreSQLParser.ONLY)


            self.state = 1624
            localctx.tn = self.schema_qualified_name()
            self.state = 1626
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.MULTIPLY:
                self.state = 1625
                self.match(postgreSQLParser.MULTIPLY)


            self.state = 1660
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,127,self._ctx)
            if la_ == 1:
                self.state = 1628
                self.table_action()
                self.state = 1633
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1629
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1630
                    self.table_action()
                    self.state = 1635
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.state = 1636
                self.match(postgreSQLParser.RENAME)
                self.state = 1638
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 1637
                    self.match(postgreSQLParser.COLUMN)


                self.state = 1640
                self.identifier()
                self.state = 1641
                self.match(postgreSQLParser.TO)
                self.state = 1642
                self.identifier()
                pass

            elif la_ == 3:
                self.state = 1644
                self.set_schema()
                pass

            elif la_ == 4:
                self.state = 1645
                self.rename_to()
                pass

            elif la_ == 5:
                self.state = 1646
                self.match(postgreSQLParser.RENAME)
                self.state = 1647
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 1648
                self.identifier()
                self.state = 1649
                self.match(postgreSQLParser.TO)
                self.state = 1650
                self.identifier()
                pass

            elif la_ == 6:
                self.state = 1652
                self.match(postgreSQLParser.ATTACH)
                self.state = 1653
                self.match(postgreSQLParser.PARTITION)
                self.state = 1654
                localctx.child = self.schema_qualified_name()
                self.state = 1655
                self.for_values_bound()
                pass

            elif la_ == 7:
                self.state = 1657
                self.match(postgreSQLParser.DETACH)
                self.state = 1658
                self.match(postgreSQLParser.PARTITION)
                self.state = 1659
                localctx.child = self.schema_qualified_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.column = None # IdentifierContext
            self.tabl_constraint = None # Constraint_commonContext
            self.not_valid = None # Token
            self.trigger_name = None # Schema_qualified_nameContext
            self.rewrite_rule_name = None # Schema_qualified_nameContext
            self.index_name = None # Schema_qualified_nameContext
            self.parent_table = None # Schema_qualified_nameContext
            self.type_name = None # Schema_qualified_nameContext

        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def table_column_definition(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_column_definitionContext,0)


        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def column_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Column_actionContext,0)


        def constraint_common(self):
            return self.getTypedRuleContext(postgreSQLParser.Constraint_commonContext,0)


        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def VALID(self):
            return self.getToken(postgreSQLParser.VALID, 0)

        def validate_constraint(self):
            return self.getTypedRuleContext(postgreSQLParser.Validate_constraintContext,0)


        def drop_constraint(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_constraintContext,0)


        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def DISABLE(self):
            return self.getToken(postgreSQLParser.DISABLE, 0)

        def ENABLE(self):
            return self.getToken(postgreSQLParser.ENABLE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def REPLICA(self):
            return self.getToken(postgreSQLParser.REPLICA, 0)

        def ALWAYS(self):
            return self.getToken(postgreSQLParser.ALWAYS, 0)

        def RULE(self):
            return self.getToken(postgreSQLParser.RULE, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def LEVEL(self):
            return self.getToken(postgreSQLParser.LEVEL, 0)

        def SECURITY(self):
            return self.getToken(postgreSQLParser.SECURITY, 0)

        def FORCE(self):
            return self.getToken(postgreSQLParser.FORCE, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def CLUSTER(self):
            return self.getToken(postgreSQLParser.CLUSTER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def OIDS(self):
            return self.getToken(postgreSQLParser.OIDS, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def LOGGED(self):
            return self.getToken(postgreSQLParser.LOGGED, 0)

        def UNLOGGED(self):
            return self.getToken(postgreSQLParser.UNLOGGED, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def INHERIT(self):
            return self.getToken(postgreSQLParser.INHERIT, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_tablespace(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_tablespaceContext,0)


        def IDENTITY(self):
            return self.getToken(postgreSQLParser.IDENTITY, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def FULL(self):
            return self.getToken(postgreSQLParser.FULL, 0)

        def NOTHING(self):
            return self.getToken(postgreSQLParser.NOTHING, 0)

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def table_deferrable(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_deferrableContext,0)


        def table_initialy_immed(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_initialy_immedContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_action" ):
                listener.enterTable_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_action" ):
                listener.exitTable_action(self)




    def table_action(self):

        localctx = postgreSQLParser.Table_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 84, self.RULE_table_action)
        self._la = 0 # Token type
        try:
            self.state = 1771
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,140,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1662
                self.match(postgreSQLParser.ADD)
                self.state = 1664
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 1663
                    self.match(postgreSQLParser.COLUMN)


                self.state = 1667
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,129,self._ctx)
                if la_ == 1:
                    self.state = 1666
                    self.if_not_exists()


                self.state = 1669
                self.table_column_definition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1670
                self.match(postgreSQLParser.DROP)
                self.state = 1672
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 1671
                    self.match(postgreSQLParser.COLUMN)


                self.state = 1675
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,131,self._ctx)
                if la_ == 1:
                    self.state = 1674
                    self.if_exists()


                self.state = 1677
                localctx.column = self.identifier()
                self.state = 1679
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                    self.state = 1678
                    self.cascade_restrict()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1681
                self.match(postgreSQLParser.ALTER)
                self.state = 1683
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 1682
                    self.match(postgreSQLParser.COLUMN)


                self.state = 1685
                localctx.column = self.identifier()
                self.state = 1686
                self.column_action()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1688
                self.match(postgreSQLParser.ADD)
                self.state = 1689
                localctx.tabl_constraint = self.constraint_common()
                self.state = 1692
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 1690
                    self.match(postgreSQLParser.NOT)
                    self.state = 1691
                    localctx.not_valid = self.match(postgreSQLParser.VALID)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1694
                self.validate_constraint()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1695
                self.drop_constraint()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1696
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DISABLE or _la==postgreSQLParser.ENABLE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1697
                self.match(postgreSQLParser.TRIGGER)
                self.state = 1701
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 1698
                    localctx.trigger_name = self.schema_qualified_name()
                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 1699
                    self.match(postgreSQLParser.ALL)
                    pass
                elif token in [postgreSQLParser.USER]:
                    self.state = 1700
                    self.match(postgreSQLParser.USER)
                    pass
                elif token in [postgreSQLParser.EOF, postgreSQLParser.SEMI_COLON, postgreSQLParser.COMMA]:
                    pass
                else:
                    pass
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1703
                self.match(postgreSQLParser.ENABLE)
                self.state = 1704
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ALWAYS or _la==postgreSQLParser.REPLICA):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1705
                self.match(postgreSQLParser.TRIGGER)
                self.state = 1706
                localctx.trigger_name = self.schema_qualified_name()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1707
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DISABLE or _la==postgreSQLParser.ENABLE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1708
                self.match(postgreSQLParser.RULE)
                self.state = 1709
                localctx.rewrite_rule_name = self.schema_qualified_name()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1710
                self.match(postgreSQLParser.ENABLE)
                self.state = 1711
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ALWAYS or _la==postgreSQLParser.REPLICA):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1712
                self.match(postgreSQLParser.RULE)
                self.state = 1713
                localctx.rewrite_rule_name = self.schema_qualified_name()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1714
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DISABLE or _la==postgreSQLParser.ENABLE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1715
                self.match(postgreSQLParser.ROW)
                self.state = 1716
                self.match(postgreSQLParser.LEVEL)
                self.state = 1717
                self.match(postgreSQLParser.SECURITY)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1719
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 1718
                    self.match(postgreSQLParser.NO)


                self.state = 1721
                self.match(postgreSQLParser.FORCE)
                self.state = 1722
                self.match(postgreSQLParser.ROW)
                self.state = 1723
                self.match(postgreSQLParser.LEVEL)
                self.state = 1724
                self.match(postgreSQLParser.SECURITY)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1725
                self.match(postgreSQLParser.CLUSTER)
                self.state = 1726
                self.match(postgreSQLParser.ON)
                self.state = 1727
                localctx.index_name = self.schema_qualified_name()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 1728
                self.match(postgreSQLParser.SET)
                self.state = 1729
                self.match(postgreSQLParser.WITHOUT)
                self.state = 1730
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CLUSTER or _la==postgreSQLParser.OIDS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 1731
                self.match(postgreSQLParser.SET)
                self.state = 1732
                self.match(postgreSQLParser.WITH)
                self.state = 1733
                self.match(postgreSQLParser.OIDS)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 1734
                self.match(postgreSQLParser.SET)
                self.state = 1735
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.LOGGED or _la==postgreSQLParser.UNLOGGED):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 1736
                self.match(postgreSQLParser.SET)
                self.state = 1737
                self.storage_parameter()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 1738
                self.match(postgreSQLParser.RESET)
                self.state = 1739
                self.names_in_parens()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 1740
                self.define_foreign_options()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 1741
                self.match(postgreSQLParser.INHERIT)
                self.state = 1742
                localctx.parent_table = self.schema_qualified_name()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 1743
                self.match(postgreSQLParser.NO)
                self.state = 1744
                self.match(postgreSQLParser.INHERIT)
                self.state = 1745
                localctx.parent_table = self.schema_qualified_name()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 1746
                self.match(postgreSQLParser.OF)
                self.state = 1747
                localctx.type_name = self.schema_qualified_name()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 1748
                self.match(postgreSQLParser.NOT)
                self.state = 1749
                self.match(postgreSQLParser.OF)
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 1750
                self.owner_to()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 1751
                self.set_tablespace()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 1752
                self.match(postgreSQLParser.REPLICA)
                self.state = 1753
                self.match(postgreSQLParser.IDENTITY)
                self.state = 1760
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.DEFAULT]:
                    self.state = 1754
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                elif token in [postgreSQLParser.FULL]:
                    self.state = 1755
                    self.match(postgreSQLParser.FULL)
                    pass
                elif token in [postgreSQLParser.NOTHING]:
                    self.state = 1756
                    self.match(postgreSQLParser.NOTHING)
                    pass
                elif token in [postgreSQLParser.USING]:
                    self.state = 1757
                    self.match(postgreSQLParser.USING)
                    self.state = 1758
                    self.match(postgreSQLParser.INDEX)
                    self.state = 1759
                    self.identifier()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 1762
                self.match(postgreSQLParser.ALTER)
                self.state = 1763
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 1764
                self.identifier()
                self.state = 1766
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.DEFERRABLE or _la==postgreSQLParser.NOT:
                    self.state = 1765
                    self.table_deferrable()


                self.state = 1769
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.INITIALLY:
                    self.state = 1768
                    self.table_initialy_immed()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Column_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.sset = None # Token

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def collate_identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Collate_identifierContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def identity_body(self):
            return self.getTypedRuleContext(postgreSQLParser.Identity_bodyContext,0)


        def set_def_column(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_def_columnContext,0)


        def drop_def(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_defContext,0)


        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def IDENTITY(self):
            return self.getToken(postgreSQLParser.IDENTITY, 0)

        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def EXPRESSION(self):
            return self.getToken(postgreSQLParser.EXPRESSION, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def set_statistics(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statisticsContext,0)


        def STORAGE(self):
            return self.getToken(postgreSQLParser.STORAGE, 0)

        def storage_option(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_optionContext,0)


        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def alter_identity(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Alter_identityContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Alter_identityContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_column_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumn_action" ):
                listener.enterColumn_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumn_action" ):
                listener.exitColumn_action(self)




    def column_action(self):

        localctx = postgreSQLParser.Column_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 86, self.RULE_column_action)
        self._la = 0 # Token type
        try:
            self.state = 1820
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,148,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1775
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.SET:
                    self.state = 1773
                    self.match(postgreSQLParser.SET)
                    self.state = 1774
                    self.match(postgreSQLParser.DATA)


                self.state = 1777
                self.match(postgreSQLParser.TYPE)
                self.state = 1778
                self.data_type()
                self.state = 1780
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLLATE:
                    self.state = 1779
                    self.collate_identifier()


                self.state = 1784
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.USING:
                    self.state = 1782
                    self.match(postgreSQLParser.USING)
                    self.state = 1783
                    self.vex(0)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1786
                self.match(postgreSQLParser.ADD)
                self.state = 1787
                self.identity_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1788
                self.set_def_column()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1789
                self.drop_def()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1792
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.SET]:
                    self.state = 1790
                    localctx.sset = self.match(postgreSQLParser.SET)
                    pass
                elif token in [postgreSQLParser.DROP]:
                    self.state = 1791
                    self.match(postgreSQLParser.DROP)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1794
                self.match(postgreSQLParser.NOT)
                self.state = 1795
                self.match(postgreSQLParser.NULL)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1796
                self.match(postgreSQLParser.DROP)
                self.state = 1797
                self.match(postgreSQLParser.IDENTITY)
                self.state = 1799
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.IF:
                    self.state = 1798
                    self.if_exists()


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1801
                self.match(postgreSQLParser.DROP)
                self.state = 1802
                self.match(postgreSQLParser.EXPRESSION)
                self.state = 1804
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.IF:
                    self.state = 1803
                    self.if_exists()


                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 1806
                self.match(postgreSQLParser.SET)
                self.state = 1807
                self.storage_parameter()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 1808
                self.set_statistics()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 1809
                self.match(postgreSQLParser.SET)
                self.state = 1810
                self.match(postgreSQLParser.STORAGE)
                self.state = 1811
                self.storage_option()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 1812
                self.match(postgreSQLParser.RESET)
                self.state = 1813
                self.names_in_parens()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 1814
                self.define_foreign_options()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 1816 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1815
                    self.alter_identity()
                    self.state = 1818 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.RESTART or _la==postgreSQLParser.SET):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Identity_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GENERATED(self):
            return self.getToken(postgreSQLParser.GENERATED, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def IDENTITY(self):
            return self.getToken(postgreSQLParser.IDENTITY, 0)

        def ALWAYS(self):
            return self.getToken(postgreSQLParser.ALWAYS, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def sequence_body(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Sequence_bodyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Sequence_bodyContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_identity_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentity_body" ):
                listener.enterIdentity_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentity_body" ):
                listener.exitIdentity_body(self)




    def identity_body(self):

        localctx = postgreSQLParser.Identity_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 88, self.RULE_identity_body)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1822
            self.match(postgreSQLParser.GENERATED)
            self.state = 1826
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ALWAYS]:
                self.state = 1823
                self.match(postgreSQLParser.ALWAYS)
                pass
            elif token in [postgreSQLParser.BY]:
                self.state = 1824
                self.match(postgreSQLParser.BY)
                self.state = 1825
                self.match(postgreSQLParser.DEFAULT)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 1828
            self.match(postgreSQLParser.AS)
            self.state = 1829
            self.match(postgreSQLParser.IDENTITY)
            self.state = 1838
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 1830
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1832 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 1831
                    self.sequence_body()
                    self.state = 1834 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.CACHE or _la==postgreSQLParser.CYCLE or ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (postgreSQLParser.INCREMENT - 111)) | (1 << (postgreSQLParser.MAXVALUE - 111)) | (1 << (postgreSQLParser.MINVALUE - 111)) | (1 << (postgreSQLParser.NO - 111)) | (1 << (postgreSQLParser.OWNED - 111)))) != 0) or _la==postgreSQLParser.SEQUENCE or _la==postgreSQLParser.START or _la==postgreSQLParser.AS):
                        break

                self.state = 1836
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_identityContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def GENERATED(self):
            return self.getToken(postgreSQLParser.GENERATED, 0)

        def ALWAYS(self):
            return self.getToken(postgreSQLParser.ALWAYS, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def sequence_body(self):
            return self.getTypedRuleContext(postgreSQLParser.Sequence_bodyContext,0)


        def RESTART(self):
            return self.getToken(postgreSQLParser.RESTART, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_identity

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_identity" ):
                listener.enterAlter_identity(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_identity" ):
                listener.exitAlter_identity(self)




    def alter_identity(self):

        localctx = postgreSQLParser.Alter_identityContext(self, self._ctx, self.state)
        self.enterRule(localctx, 90, self.RULE_alter_identity)
        self._la = 0 # Token type
        try:
            self.state = 1856
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,155,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1840
                self.match(postgreSQLParser.SET)
                self.state = 1841
                self.match(postgreSQLParser.GENERATED)
                self.state = 1845
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ALWAYS]:
                    self.state = 1842
                    self.match(postgreSQLParser.ALWAYS)
                    pass
                elif token in [postgreSQLParser.BY]:
                    self.state = 1843
                    self.match(postgreSQLParser.BY)
                    self.state = 1844
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1847
                self.match(postgreSQLParser.SET)
                self.state = 1848
                self.sequence_body()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1849
                self.match(postgreSQLParser.RESTART)
                self.state = 1854
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH or _la==postgreSQLParser.NUMBER_LITERAL:
                    self.state = 1851
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.WITH:
                        self.state = 1850
                        self.match(postgreSQLParser.WITH)


                    self.state = 1853
                    self.match(postgreSQLParser.NUMBER_LITERAL)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Storage_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLAIN(self):
            return self.getToken(postgreSQLParser.PLAIN, 0)

        def EXTERNAL(self):
            return self.getToken(postgreSQLParser.EXTERNAL, 0)

        def EXTENDED(self):
            return self.getToken(postgreSQLParser.EXTENDED, 0)

        def MAIN(self):
            return self.getToken(postgreSQLParser.MAIN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_storage_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorage_option" ):
                listener.enterStorage_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorage_option" ):
                listener.exitStorage_option(self)




    def storage_option(self):

        localctx = postgreSQLParser.Storage_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 92, self.RULE_storage_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1858
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.EXTERNAL or ((((_la - 468)) & ~0x3f) == 0 and ((1 << (_la - 468)) & ((1 << (postgreSQLParser.EXTENDED - 468)) | (1 << (postgreSQLParser.MAIN - 468)) | (1 << (postgreSQLParser.PLAIN - 468)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Validate_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.constraint_name = None # Schema_qualified_nameContext

        def VALIDATE(self):
            return self.getToken(postgreSQLParser.VALIDATE, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_validate_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValidate_constraint" ):
                listener.enterValidate_constraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValidate_constraint" ):
                listener.exitValidate_constraint(self)




    def validate_constraint(self):

        localctx = postgreSQLParser.Validate_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 94, self.RULE_validate_constraint)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1860
            self.match(postgreSQLParser.VALIDATE)
            self.state = 1861
            self.match(postgreSQLParser.CONSTRAINT)
            self.state = 1862
            localctx.constraint_name = self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.constraint_name = None # IdentifierContext

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_constraint" ):
                listener.enterDrop_constraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_constraint" ):
                listener.exitDrop_constraint(self)




    def drop_constraint(self):

        localctx = postgreSQLParser.Drop_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 96, self.RULE_drop_constraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1864
            self.match(postgreSQLParser.DROP)
            self.state = 1865
            self.match(postgreSQLParser.CONSTRAINT)
            self.state = 1867
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,156,self._ctx)
            if la_ == 1:
                self.state = 1866
                self.if_exists()


            self.state = 1869
            localctx.constraint_name = self.identifier()
            self.state = 1871
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 1870
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_deferrableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFERRABLE(self):
            return self.getToken(postgreSQLParser.DEFERRABLE, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_deferrable

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_deferrable" ):
                listener.enterTable_deferrable(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_deferrable" ):
                listener.exitTable_deferrable(self)




    def table_deferrable(self):

        localctx = postgreSQLParser.Table_deferrableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 98, self.RULE_table_deferrable)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1874
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NOT:
                self.state = 1873
                self.match(postgreSQLParser.NOT)


            self.state = 1876
            self.match(postgreSQLParser.DEFERRABLE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_initialy_immedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INITIALLY(self):
            return self.getToken(postgreSQLParser.INITIALLY, 0)

        def DEFERRED(self):
            return self.getToken(postgreSQLParser.DEFERRED, 0)

        def IMMEDIATE(self):
            return self.getToken(postgreSQLParser.IMMEDIATE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_initialy_immed

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_initialy_immed" ):
                listener.enterTable_initialy_immed(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_initialy_immed" ):
                listener.exitTable_initialy_immed(self)




    def table_initialy_immed(self):

        localctx = postgreSQLParser.Table_initialy_immedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 100, self.RULE_table_initialy_immed)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1878
            self.match(postgreSQLParser.INITIALLY)
            self.state = 1879
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.DEFERRED or _la==postgreSQLParser.IMMEDIATE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_actions_commonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.execution_cost = None # Unsigned_numeric_literalContext
            self.result_rows = None # Unsigned_numeric_literalContext
            self.config_scope = None # IdentifierContext
            self.config_param = None # IdentifierContext
            self.lang_name = None # IdentifierContext

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def NULL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NULL)
            else:
                return self.getToken(postgreSQLParser.NULL, i)

        def INPUT(self):
            return self.getToken(postgreSQLParser.INPUT, 0)

        def CALLED(self):
            return self.getToken(postgreSQLParser.CALLED, 0)

        def RETURNS(self):
            return self.getToken(postgreSQLParser.RETURNS, 0)

        def TRANSFORM(self):
            return self.getToken(postgreSQLParser.TRANSFORM, 0)

        def transform_for_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Transform_for_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Transform_for_typeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def STRICT(self):
            return self.getToken(postgreSQLParser.STRICT, 0)

        def IMMUTABLE(self):
            return self.getToken(postgreSQLParser.IMMUTABLE, 0)

        def VOLATILE(self):
            return self.getToken(postgreSQLParser.VOLATILE, 0)

        def STABLE(self):
            return self.getToken(postgreSQLParser.STABLE, 0)

        def LEAKPROOF(self):
            return self.getToken(postgreSQLParser.LEAKPROOF, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def SECURITY(self):
            return self.getToken(postgreSQLParser.SECURITY, 0)

        def INVOKER(self):
            return self.getToken(postgreSQLParser.INVOKER, 0)

        def DEFINER(self):
            return self.getToken(postgreSQLParser.DEFINER, 0)

        def EXTERNAL(self):
            return self.getToken(postgreSQLParser.EXTERNAL, 0)

        def PARALLEL(self):
            return self.getToken(postgreSQLParser.PARALLEL, 0)

        def SAFE(self):
            return self.getToken(postgreSQLParser.SAFE, 0)

        def UNSAFE(self):
            return self.getToken(postgreSQLParser.UNSAFE, 0)

        def RESTRICTED(self):
            return self.getToken(postgreSQLParser.RESTRICTED, 0)

        def COST(self):
            return self.getToken(postgreSQLParser.COST, 0)

        def unsigned_numeric_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_numeric_literalContext,0)


        def ROWS(self):
            return self.getToken(postgreSQLParser.ROWS, 0)

        def SUPPORT(self):
            return self.getToken(postgreSQLParser.SUPPORT, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def set_statement_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statement_valueContext,0)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def WINDOW(self):
            return self.getToken(postgreSQLParser.WINDOW, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def function_def(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_defContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_actions_common

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_actions_common" ):
                listener.enterFunction_actions_common(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_actions_common" ):
                listener.exitFunction_actions_common(self)




    def function_actions_common(self):

        localctx = postgreSQLParser.Function_actions_commonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 102, self.RULE_function_actions_common)
        self._la = 0 # Token type
        try:
            self.state = 1937
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CALLED, postgreSQLParser.RETURNS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 1884
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.CALLED]:
                    self.state = 1881
                    self.match(postgreSQLParser.CALLED)
                    pass
                elif token in [postgreSQLParser.RETURNS]:
                    self.state = 1882
                    self.match(postgreSQLParser.RETURNS)
                    self.state = 1883
                    self.match(postgreSQLParser.NULL)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1886
                self.match(postgreSQLParser.ON)
                self.state = 1887
                self.match(postgreSQLParser.NULL)
                self.state = 1888
                self.match(postgreSQLParser.INPUT)
                pass
            elif token in [postgreSQLParser.TRANSFORM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 1889
                self.match(postgreSQLParser.TRANSFORM)
                self.state = 1890
                self.transform_for_type()
                self.state = 1895
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 1891
                    self.match(postgreSQLParser.COMMA)
                    self.state = 1892
                    self.transform_for_type()
                    self.state = 1897
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [postgreSQLParser.STRICT]:
                self.enterOuterAlt(localctx, 3)
                self.state = 1898
                self.match(postgreSQLParser.STRICT)
                pass
            elif token in [postgreSQLParser.IMMUTABLE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 1899
                self.match(postgreSQLParser.IMMUTABLE)
                pass
            elif token in [postgreSQLParser.VOLATILE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 1900
                self.match(postgreSQLParser.VOLATILE)
                pass
            elif token in [postgreSQLParser.STABLE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 1901
                self.match(postgreSQLParser.STABLE)
                pass
            elif token in [postgreSQLParser.LEAKPROOF, postgreSQLParser.NOT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 1903
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 1902
                    self.match(postgreSQLParser.NOT)


                self.state = 1905
                self.match(postgreSQLParser.LEAKPROOF)
                pass
            elif token in [postgreSQLParser.EXTERNAL, postgreSQLParser.SECURITY]:
                self.enterOuterAlt(localctx, 8)
                self.state = 1907
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.EXTERNAL:
                    self.state = 1906
                    self.match(postgreSQLParser.EXTERNAL)


                self.state = 1909
                self.match(postgreSQLParser.SECURITY)
                self.state = 1910
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DEFINER or _la==postgreSQLParser.INVOKER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.PARALLEL]:
                self.enterOuterAlt(localctx, 9)
                self.state = 1911
                self.match(postgreSQLParser.PARALLEL)
                self.state = 1912
                _la = self._input.LA(1)
                if not(((((_la - 526)) & ~0x3f) == 0 and ((1 << (_la - 526)) & ((1 << (postgreSQLParser.RESTRICTED - 526)) | (1 << (postgreSQLParser.SAFE - 526)) | (1 << (postgreSQLParser.UNSAFE - 526)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.COST]:
                self.enterOuterAlt(localctx, 10)
                self.state = 1913
                self.match(postgreSQLParser.COST)
                self.state = 1914
                localctx.execution_cost = self.unsigned_numeric_literal()
                pass
            elif token in [postgreSQLParser.ROWS]:
                self.enterOuterAlt(localctx, 11)
                self.state = 1915
                self.match(postgreSQLParser.ROWS)
                self.state = 1916
                localctx.result_rows = self.unsigned_numeric_literal()
                pass
            elif token in [postgreSQLParser.SUPPORT]:
                self.enterOuterAlt(localctx, 12)
                self.state = 1917
                self.match(postgreSQLParser.SUPPORT)
                self.state = 1918
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.SET]:
                self.enterOuterAlt(localctx, 13)
                self.state = 1919
                self.match(postgreSQLParser.SET)
                self.state = 1923
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,163,self._ctx)
                if la_ == 1:
                    self.state = 1920
                    localctx.config_scope = self.identifier()
                    self.state = 1921
                    self.match(postgreSQLParser.DOT)


                self.state = 1925
                localctx.config_param = self.identifier()
                self.state = 1930
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.TO, postgreSQLParser.EQUAL]:
                    self.state = 1926
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.TO or _la==postgreSQLParser.EQUAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 1927
                    self.set_statement_value()
                    pass
                elif token in [postgreSQLParser.FROM]:
                    self.state = 1928
                    self.match(postgreSQLParser.FROM)
                    self.state = 1929
                    self.match(postgreSQLParser.CURRENT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.LANGUAGE]:
                self.enterOuterAlt(localctx, 14)
                self.state = 1932
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 1933
                localctx.lang_name = self.identifier()
                pass
            elif token in [postgreSQLParser.WINDOW]:
                self.enterOuterAlt(localctx, 15)
                self.state = 1934
                self.match(postgreSQLParser.WINDOW)
                pass
            elif token in [postgreSQLParser.AS]:
                self.enterOuterAlt(localctx, 16)
                self.state = 1935
                self.match(postgreSQLParser.AS)
                self.state = 1936
                self.function_def()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.definition = None # Character_stringContext
            self.symbol = None # Character_stringContext

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_def" ):
                listener.enterFunction_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_def" ):
                listener.exitFunction_def(self)




    def function_def(self):

        localctx = postgreSQLParser.Function_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 104, self.RULE_function_def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1939
            localctx.definition = self.character_string()
            self.state = 1942
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COMMA:
                self.state = 1940
                self.match(postgreSQLParser.COMMA)
                self.state = 1941
                localctx.symbol = self.character_string()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_index_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def index_def_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_def_actionContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def set_tablespace(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_tablespaceContext,0)


        def OWNED(self):
            return self.getToken(postgreSQLParser.OWNED, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_index_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_index_statement" ):
                listener.enterAlter_index_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_index_statement" ):
                listener.exitAlter_index_statement(self)




    def alter_index_statement(self):

        localctx = postgreSQLParser.Alter_index_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 106, self.RULE_alter_index_statement)
        self._la = 0 # Token type
        try:
            self.state = 1963
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,169,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1944
                self.match(postgreSQLParser.INDEX)
                self.state = 1946
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,167,self._ctx)
                if la_ == 1:
                    self.state = 1945
                    self.if_exists()


                self.state = 1948
                self.schema_qualified_name()
                self.state = 1949
                self.index_def_action()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1951
                self.match(postgreSQLParser.INDEX)
                self.state = 1952
                self.match(postgreSQLParser.ALL)
                self.state = 1953
                self.match(postgreSQLParser.IN)
                self.state = 1954
                self.match(postgreSQLParser.TABLESPACE)
                self.state = 1955
                self.identifier()
                self.state = 1959
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OWNED:
                    self.state = 1956
                    self.match(postgreSQLParser.OWNED)
                    self.state = 1957
                    self.match(postgreSQLParser.BY)
                    self.state = 1958
                    self.identifier_list()


                self.state = 1961
                self.set_tablespace()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_def_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.index = None # Schema_qualified_nameContext

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def ATTACH(self):
            return self.getToken(postgreSQLParser.ATTACH, 0)

        def PARTITION(self):
            return self.getToken(postgreSQLParser.PARTITION, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def DEPENDS(self):
            return self.getToken(postgreSQLParser.DEPENDS, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def set_statistics(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statisticsContext,0)


        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def set_tablespace(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_tablespaceContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_index_def_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_def_action" ):
                listener.enterIndex_def_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_def_action" ):
                listener.exitIndex_def_action(self)




    def index_def_action(self):

        localctx = postgreSQLParser.Index_def_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 108, self.RULE_index_def_action)
        self._la = 0 # Token type
        try:
            self.state = 1993
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,173,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 1965
                self.rename_to()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 1966
                self.match(postgreSQLParser.ATTACH)
                self.state = 1967
                self.match(postgreSQLParser.PARTITION)
                self.state = 1968
                localctx.index = self.schema_qualified_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 1970
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 1969
                    self.match(postgreSQLParser.NO)


                self.state = 1972
                self.match(postgreSQLParser.DEPENDS)
                self.state = 1973
                self.match(postgreSQLParser.ON)
                self.state = 1974
                self.match(postgreSQLParser.EXTENSION)
                self.state = 1975
                self.schema_qualified_name()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 1976
                self.match(postgreSQLParser.ALTER)
                self.state = 1978
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 1977
                    self.match(postgreSQLParser.COLUMN)


                self.state = 1982
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.NUMBER_LITERAL]:
                    self.state = 1980
                    self.match(postgreSQLParser.NUMBER_LITERAL)
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 1981
                    self.identifier()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 1984
                self.set_statistics()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 1985
                self.match(postgreSQLParser.RESET)
                self.state = 1986
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 1987
                self.identifier_list()
                self.state = 1988
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 1990
                self.set_tablespace()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 1991
                self.match(postgreSQLParser.SET)
                self.state = 1992
                self.storage_parameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_default_privileges_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def PRIVILEGES(self):
            return self.getToken(postgreSQLParser.PRIVILEGES, 0)

        def abbreviated_grant_or_revoke(self):
            return self.getTypedRuleContext(postgreSQLParser.Abbreviated_grant_or_revokeContext,0)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def identifier_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Identifier_listContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,i)


        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_default_privileges_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_default_privileges_statement" ):
                listener.enterAlter_default_privileges_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_default_privileges_statement" ):
                listener.exitAlter_default_privileges_statement(self)




    def alter_default_privileges_statement(self):

        localctx = postgreSQLParser.Alter_default_privileges_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 110, self.RULE_alter_default_privileges_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 1995
            self.match(postgreSQLParser.DEFAULT)
            self.state = 1996
            self.match(postgreSQLParser.PRIVILEGES)
            self.state = 2000
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FOR:
                self.state = 1997
                self.match(postgreSQLParser.FOR)
                self.state = 1998
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ROLE or _la==postgreSQLParser.USER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 1999
                self.identifier_list()


            self.state = 2005
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.IN:
                self.state = 2002
                self.match(postgreSQLParser.IN)
                self.state = 2003
                self.match(postgreSQLParser.SCHEMA)
                self.state = 2004
                self.identifier_list()


            self.state = 2007
            self.abbreviated_grant_or_revoke()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Abbreviated_grant_or_revokeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRANT(self):
            return self.getToken(postgreSQLParser.GRANT, 0)

        def REVOKE(self):
            return self.getToken(postgreSQLParser.REVOKE, 0)

        def table_column_privilege(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_column_privilegeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_column_privilegeContext,i)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def TABLES(self):
            return self.getToken(postgreSQLParser.TABLES, 0)

        def SEQUENCES(self):
            return self.getToken(postgreSQLParser.SEQUENCES, 0)

        def FUNCTIONS(self):
            return self.getToken(postgreSQLParser.FUNCTIONS, 0)

        def SCHEMAS(self):
            return self.getToken(postgreSQLParser.SCHEMAS, 0)

        def TYPES(self):
            return self.getToken(postgreSQLParser.TYPES, 0)

        def grant_to_rule(self):
            return self.getTypedRuleContext(postgreSQLParser.Grant_to_ruleContext,0)


        def revoke_from_cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Revoke_from_cascade_restrictContext,0)


        def usage_select_update(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Usage_select_updateContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Usage_select_updateContext,i)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def USAGE(self):
            return self.getToken(postgreSQLParser.USAGE, 0)

        def CREATE(self):
            return self.getToken(postgreSQLParser.CREATE, 0)

        def grant_option_for(self):
            return self.getTypedRuleContext(postgreSQLParser.Grant_option_forContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def PRIVILEGES(self):
            return self.getToken(postgreSQLParser.PRIVILEGES, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_abbreviated_grant_or_revoke

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAbbreviated_grant_or_revoke" ):
                listener.enterAbbreviated_grant_or_revoke(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAbbreviated_grant_or_revoke" ):
                listener.exitAbbreviated_grant_or_revoke(self)




    def abbreviated_grant_or_revoke(self):

        localctx = postgreSQLParser.Abbreviated_grant_or_revokeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 112, self.RULE_abbreviated_grant_or_revoke)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2014
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.GRANT]:
                self.state = 2009
                self.match(postgreSQLParser.GRANT)
                pass
            elif token in [postgreSQLParser.REVOKE]:
                self.state = 2010
                self.match(postgreSQLParser.REVOKE)
                self.state = 2012
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.GRANT:
                    self.state = 2011
                    self.grant_option_for()


                pass
            else:
                raise NoViableAltException(self)

            self.state = 2071
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,188,self._ctx)
            if la_ == 1:
                self.state = 2016
                self.table_column_privilege()
                self.state = 2021
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2017
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2018
                    self.table_column_privilege()
                    self.state = 2023
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2024
                self.match(postgreSQLParser.ON)
                self.state = 2025
                self.match(postgreSQLParser.TABLES)
                pass

            elif la_ == 2:
                self.state = 2039
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.UPDATE, postgreSQLParser.SELECT, postgreSQLParser.USAGE]:
                    self.state = 2027
                    self.usage_select_update()
                    self.state = 2032
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 2028
                        self.match(postgreSQLParser.COMMA)
                        self.state = 2029
                        self.usage_select_update()
                        self.state = 2034
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 2035
                    self.match(postgreSQLParser.ALL)
                    self.state = 2037
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.PRIVILEGES:
                        self.state = 2036
                        self.match(postgreSQLParser.PRIVILEGES)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2041
                self.match(postgreSQLParser.ON)
                self.state = 2042
                self.match(postgreSQLParser.SEQUENCES)
                pass

            elif la_ == 3:
                self.state = 2048
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.EXECUTE]:
                    self.state = 2043
                    self.match(postgreSQLParser.EXECUTE)
                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 2044
                    self.match(postgreSQLParser.ALL)
                    self.state = 2046
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.PRIVILEGES:
                        self.state = 2045
                        self.match(postgreSQLParser.PRIVILEGES)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2050
                self.match(postgreSQLParser.ON)
                self.state = 2051
                self.match(postgreSQLParser.FUNCTIONS)
                pass

            elif la_ == 4:
                self.state = 2058
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.USAGE]:
                    self.state = 2052
                    self.match(postgreSQLParser.USAGE)
                    pass
                elif token in [postgreSQLParser.CREATE]:
                    self.state = 2053
                    self.match(postgreSQLParser.CREATE)
                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 2054
                    self.match(postgreSQLParser.ALL)
                    self.state = 2056
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.PRIVILEGES:
                        self.state = 2055
                        self.match(postgreSQLParser.PRIVILEGES)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2060
                self.match(postgreSQLParser.ON)
                self.state = 2061
                self.match(postgreSQLParser.SCHEMAS)
                pass

            elif la_ == 5:
                self.state = 2067
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.USAGE]:
                    self.state = 2062
                    self.match(postgreSQLParser.USAGE)
                    pass
                elif token in [postgreSQLParser.ALL]:
                    self.state = 2063
                    self.match(postgreSQLParser.ALL)
                    self.state = 2065
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.PRIVILEGES:
                        self.state = 2064
                        self.match(postgreSQLParser.PRIVILEGES)


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2069
                self.match(postgreSQLParser.ON)
                self.state = 2070
                self.match(postgreSQLParser.TYPES)
                pass


            self.state = 2075
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.TO]:
                self.state = 2073
                self.grant_to_rule()
                pass
            elif token in [postgreSQLParser.FROM]:
                self.state = 2074
                self.revoke_from_cascade_restrict()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Grant_option_forContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRANT(self):
            return self.getToken(postgreSQLParser.GRANT, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_grant_option_for

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrant_option_for" ):
                listener.enterGrant_option_for(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrant_option_for" ):
                listener.exitGrant_option_for(self)




    def grant_option_for(self):

        localctx = postgreSQLParser.Grant_option_forContext(self, self._ctx, self.state)
        self.enterRule(localctx, 114, self.RULE_grant_option_for)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2077
            self.match(postgreSQLParser.GRANT)
            self.state = 2078
            self.match(postgreSQLParser.OPTION)
            self.state = 2079
            self.match(postgreSQLParser.FOR)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_sequence_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def sequence_body(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Sequence_bodyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Sequence_bodyContext,i)


        def RESTART(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RESTART)
            else:
                return self.getToken(postgreSQLParser.RESTART, i)

        def signed_number_literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Signed_number_literalContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Signed_number_literalContext,i)


        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WITH)
            else:
                return self.getToken(postgreSQLParser.WITH, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_sequence_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_sequence_statement" ):
                listener.enterAlter_sequence_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_sequence_statement" ):
                listener.exitAlter_sequence_statement(self)




    def alter_sequence_statement(self):

        localctx = postgreSQLParser.Alter_sequence_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 116, self.RULE_alter_sequence_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2081
            self.match(postgreSQLParser.SEQUENCE)
            self.state = 2083
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,190,self._ctx)
            if la_ == 1:
                self.state = 2082
                self.if_exists()


            self.state = 2085
            localctx.name = self.schema_qualified_name()
            self.state = 2101
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.EOF, postgreSQLParser.CACHE, postgreSQLParser.CYCLE, postgreSQLParser.INCREMENT, postgreSQLParser.MAXVALUE, postgreSQLParser.MINVALUE, postgreSQLParser.NO, postgreSQLParser.OWNED, postgreSQLParser.RESTART, postgreSQLParser.SEQUENCE, postgreSQLParser.START, postgreSQLParser.AS, postgreSQLParser.SEMI_COLON]:
                self.state = 2096
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.CACHE or _la==postgreSQLParser.CYCLE or ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (postgreSQLParser.INCREMENT - 111)) | (1 << (postgreSQLParser.MAXVALUE - 111)) | (1 << (postgreSQLParser.MINVALUE - 111)) | (1 << (postgreSQLParser.NO - 111)) | (1 << (postgreSQLParser.OWNED - 111)))) != 0) or ((((_la - 211)) & ~0x3f) == 0 and ((1 << (_la - 211)) & ((1 << (postgreSQLParser.RESTART - 211)) | (1 << (postgreSQLParser.SEQUENCE - 211)) | (1 << (postgreSQLParser.START - 211)))) != 0) or _la==postgreSQLParser.AS:
                    self.state = 2094
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.CACHE, postgreSQLParser.CYCLE, postgreSQLParser.INCREMENT, postgreSQLParser.MAXVALUE, postgreSQLParser.MINVALUE, postgreSQLParser.NO, postgreSQLParser.OWNED, postgreSQLParser.SEQUENCE, postgreSQLParser.START, postgreSQLParser.AS]:
                        self.state = 2086
                        self.sequence_body()
                        pass
                    elif token in [postgreSQLParser.RESTART]:
                        self.state = 2087
                        self.match(postgreSQLParser.RESTART)
                        self.state = 2092
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.WITH or ((((_la - 597)) & ~0x3f) == 0 and ((1 << (_la - 597)) & ((1 << (postgreSQLParser.PLUS - 597)) | (1 << (postgreSQLParser.MINUS - 597)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 597)))) != 0):
                            self.state = 2089
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==postgreSQLParser.WITH:
                                self.state = 2088
                                self.match(postgreSQLParser.WITH)


                            self.state = 2091
                            self.signed_number_literal()


                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 2098
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [postgreSQLParser.SET]:
                self.state = 2099
                self.set_schema()
                pass
            elif token in [postgreSQLParser.RENAME]:
                self.state = 2100
                self.rename_to()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_view_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def alter_view_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_view_actionContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_view_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_view_statement" ):
                listener.enterAlter_view_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_view_statement" ):
                listener.exitAlter_view_statement(self)




    def alter_view_statement(self):

        localctx = postgreSQLParser.Alter_view_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 118, self.RULE_alter_view_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2103
            self.match(postgreSQLParser.VIEW)
            self.state = 2105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,196,self._ctx)
            if la_ == 1:
                self.state = 2104
                self.if_exists()


            self.state = 2107
            localctx.name = self.schema_qualified_name()
            self.state = 2108
            self.alter_view_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_view_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.column_name = None # IdentifierContext

        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def set_def_column(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_def_columnContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def drop_def(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_defContext,0)


        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_view_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_view_action" ):
                listener.enterAlter_view_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_view_action" ):
                listener.exitAlter_view_action(self)




    def alter_view_action(self):

        localctx = postgreSQLParser.Alter_view_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 120, self.RULE_alter_view_action)
        self._la = 0 # Token type
        try:
            self.state = 2138
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,200,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2110
                self.match(postgreSQLParser.ALTER)
                self.state = 2112
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2111
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2114
                localctx.column_name = self.identifier()
                self.state = 2115
                self.set_def_column()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2117
                self.match(postgreSQLParser.ALTER)
                self.state = 2119
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2118
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2121
                localctx.column_name = self.identifier()
                self.state = 2122
                self.drop_def()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2124
                self.match(postgreSQLParser.RENAME)
                self.state = 2126
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2125
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2128
                self.identifier()
                self.state = 2129
                self.match(postgreSQLParser.TO)
                self.state = 2130
                self.identifier()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2132
                self.rename_to()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2133
                self.set_schema()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2134
                self.match(postgreSQLParser.SET)
                self.state = 2135
                self.storage_parameter()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2136
                self.match(postgreSQLParser.RESET)
                self.state = 2137
                self.names_in_parens()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_materialized_view_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def alter_materialized_view_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_materialized_view_actionContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def set_tablespace(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_tablespaceContext,0)


        def OWNED(self):
            return self.getToken(postgreSQLParser.OWNED, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_materialized_view_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_materialized_view_statement" ):
                listener.enterAlter_materialized_view_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_materialized_view_statement" ):
                listener.exitAlter_materialized_view_statement(self)




    def alter_materialized_view_statement(self):

        localctx = postgreSQLParser.Alter_materialized_view_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 122, self.RULE_alter_materialized_view_statement)
        self._la = 0 # Token type
        try:
            self.state = 2161
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,203,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2140
                self.match(postgreSQLParser.MATERIALIZED)
                self.state = 2141
                self.match(postgreSQLParser.VIEW)
                self.state = 2143
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,201,self._ctx)
                if la_ == 1:
                    self.state = 2142
                    self.if_exists()


                self.state = 2145
                self.schema_qualified_name()
                self.state = 2146
                self.alter_materialized_view_action()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2148
                self.match(postgreSQLParser.MATERIALIZED)
                self.state = 2149
                self.match(postgreSQLParser.VIEW)
                self.state = 2150
                self.match(postgreSQLParser.ALL)
                self.state = 2151
                self.match(postgreSQLParser.IN)
                self.state = 2152
                self.match(postgreSQLParser.TABLESPACE)
                self.state = 2153
                self.identifier()
                self.state = 2157
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OWNED:
                    self.state = 2154
                    self.match(postgreSQLParser.OWNED)
                    self.state = 2155
                    self.match(postgreSQLParser.BY)
                    self.state = 2156
                    self.identifier_list()


                self.state = 2159
                self.set_tablespace()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_materialized_view_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def DEPENDS(self):
            return self.getToken(postgreSQLParser.DEPENDS, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def materialized_view_action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Materialized_view_actionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Materialized_view_actionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_materialized_view_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_materialized_view_action" ):
                listener.enterAlter_materialized_view_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_materialized_view_action" ):
                listener.exitAlter_materialized_view_action(self)




    def alter_materialized_view_action(self):

        localctx = postgreSQLParser.Alter_materialized_view_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 124, self.RULE_alter_materialized_view_action)
        self._la = 0 # Token type
        try:
            self.state = 2188
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,207,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2163
                self.rename_to()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2164
                self.set_schema()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2165
                self.match(postgreSQLParser.RENAME)
                self.state = 2167
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2166
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2169
                self.identifier()
                self.state = 2170
                self.match(postgreSQLParser.TO)
                self.state = 2171
                self.identifier()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2174
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 2173
                    self.match(postgreSQLParser.NO)


                self.state = 2176
                self.match(postgreSQLParser.DEPENDS)
                self.state = 2177
                self.match(postgreSQLParser.ON)
                self.state = 2178
                self.match(postgreSQLParser.EXTENSION)
                self.state = 2179
                self.identifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2180
                self.materialized_view_action()
                self.state = 2185
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2181
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2182
                    self.materialized_view_action()
                    self.state = 2187
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Materialized_view_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.index_name = None # Schema_qualified_nameContext

        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def set_statistics(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statisticsContext,0)


        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def STORAGE(self):
            return self.getToken(postgreSQLParser.STORAGE, 0)

        def storage_option(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_optionContext,0)


        def CLUSTER(self):
            return self.getToken(postgreSQLParser.CLUSTER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_materialized_view_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMaterialized_view_action" ):
                listener.enterMaterialized_view_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMaterialized_view_action" ):
                listener.exitMaterialized_view_action(self)




    def materialized_view_action(self):

        localctx = postgreSQLParser.Materialized_view_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 126, self.RULE_materialized_view_action)
        self._la = 0 # Token type
        try:
            self.state = 2232
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,212,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2190
                self.match(postgreSQLParser.ALTER)
                self.state = 2192
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2191
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2194
                self.identifier()
                self.state = 2195
                self.set_statistics()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2197
                self.match(postgreSQLParser.ALTER)
                self.state = 2199
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2198
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2201
                self.identifier()
                self.state = 2202
                self.match(postgreSQLParser.SET)
                self.state = 2203
                self.storage_parameter()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2205
                self.match(postgreSQLParser.ALTER)
                self.state = 2207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2206
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2209
                self.identifier()
                self.state = 2210
                self.match(postgreSQLParser.RESET)
                self.state = 2211
                self.names_in_parens()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2213
                self.match(postgreSQLParser.ALTER)
                self.state = 2215
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLUMN:
                    self.state = 2214
                    self.match(postgreSQLParser.COLUMN)


                self.state = 2217
                self.identifier()
                self.state = 2218
                self.match(postgreSQLParser.SET)
                self.state = 2219
                self.match(postgreSQLParser.STORAGE)
                self.state = 2220
                self.storage_option()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 2222
                self.match(postgreSQLParser.CLUSTER)
                self.state = 2223
                self.match(postgreSQLParser.ON)
                self.state = 2224
                localctx.index_name = self.schema_qualified_name()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 2225
                self.match(postgreSQLParser.SET)
                self.state = 2226
                self.match(postgreSQLParser.WITHOUT)
                self.state = 2227
                self.match(postgreSQLParser.CLUSTER)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 2228
                self.match(postgreSQLParser.SET)
                self.state = 2229
                self.storage_parameter()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 2230
                self.match(postgreSQLParser.RESET)
                self.state = 2231
                self.names_in_parens()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_event_trigger_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def alter_event_trigger_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_event_trigger_actionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_event_trigger_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_event_trigger_statement" ):
                listener.enterAlter_event_trigger_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_event_trigger_statement" ):
                listener.exitAlter_event_trigger_statement(self)




    def alter_event_trigger_statement(self):

        localctx = postgreSQLParser.Alter_event_trigger_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 128, self.RULE_alter_event_trigger_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2234
            self.match(postgreSQLParser.EVENT)
            self.state = 2235
            self.match(postgreSQLParser.TRIGGER)
            self.state = 2236
            localctx.name = self.identifier()
            self.state = 2237
            self.alter_event_trigger_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_event_trigger_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISABLE(self):
            return self.getToken(postgreSQLParser.DISABLE, 0)

        def ENABLE(self):
            return self.getToken(postgreSQLParser.ENABLE, 0)

        def REPLICA(self):
            return self.getToken(postgreSQLParser.REPLICA, 0)

        def ALWAYS(self):
            return self.getToken(postgreSQLParser.ALWAYS, 0)

        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_event_trigger_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_event_trigger_action" ):
                listener.enterAlter_event_trigger_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_event_trigger_action" ):
                listener.exitAlter_event_trigger_action(self)




    def alter_event_trigger_action(self):

        localctx = postgreSQLParser.Alter_event_trigger_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 130, self.RULE_alter_event_trigger_action)
        self._la = 0 # Token type
        try:
            self.state = 2246
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.DISABLE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2239
                self.match(postgreSQLParser.DISABLE)
                pass
            elif token in [postgreSQLParser.ENABLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2240
                self.match(postgreSQLParser.ENABLE)
                self.state = 2242
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ALWAYS or _la==postgreSQLParser.REPLICA:
                    self.state = 2241
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.ALWAYS or _la==postgreSQLParser.REPLICA):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [postgreSQLParser.OWNER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2244
                self.owner_to()
                pass
            elif token in [postgreSQLParser.RENAME]:
                self.enterOuterAlt(localctx, 4)
                self.state = 2245
                self.rename_to()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_type_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.new_enum_value = None # Character_stringContext
            self.existing_enum_value = None # Character_stringContext
            self.attribute_name = None # IdentifierContext
            self.new_attribute_name = None # IdentifierContext
            self.existing_enum_name = None # Character_stringContext
            self.new_enum_name = None # Character_stringContext

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def VALUE(self):
            return self.getToken(postgreSQLParser.VALUE, 0)

        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def ATTRIBUTE(self):
            return self.getToken(postgreSQLParser.ATTRIBUTE, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def type_action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Type_actionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Type_actionContext,i)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def type_property(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Type_propertyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Type_propertyContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def BEFORE(self):
            return self.getToken(postgreSQLParser.BEFORE, 0)

        def AFTER(self):
            return self.getToken(postgreSQLParser.AFTER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_type_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_type_statement" ):
                listener.enterAlter_type_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_type_statement" ):
                listener.exitAlter_type_statement(self)




    def alter_type_statement(self):

        localctx = postgreSQLParser.Alter_type_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 132, self.RULE_alter_type_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2248
            self.match(postgreSQLParser.TYPE)
            self.state = 2249
            localctx.name = self.schema_qualified_name()
            self.state = 2296
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,220,self._ctx)
            if la_ == 1:
                self.state = 2250
                self.set_schema()
                pass

            elif la_ == 2:
                self.state = 2251
                self.rename_to()
                pass

            elif la_ == 3:
                self.state = 2252
                self.match(postgreSQLParser.ADD)
                self.state = 2253
                self.match(postgreSQLParser.VALUE)
                self.state = 2255
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.IF:
                    self.state = 2254
                    self.if_not_exists()


                self.state = 2257
                localctx.new_enum_value = self.character_string()
                self.state = 2260
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AFTER or _la==postgreSQLParser.BEFORE:
                    self.state = 2258
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.AFTER or _la==postgreSQLParser.BEFORE):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 2259
                    localctx.existing_enum_value = self.character_string()


                pass

            elif la_ == 4:
                self.state = 2262
                self.match(postgreSQLParser.RENAME)
                self.state = 2263
                self.match(postgreSQLParser.ATTRIBUTE)
                self.state = 2264
                localctx.attribute_name = self.identifier()
                self.state = 2265
                self.match(postgreSQLParser.TO)
                self.state = 2266
                localctx.new_attribute_name = self.identifier()
                self.state = 2268
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                    self.state = 2267
                    self.cascade_restrict()


                pass

            elif la_ == 5:
                self.state = 2270
                self.match(postgreSQLParser.RENAME)
                self.state = 2271
                self.match(postgreSQLParser.VALUE)
                self.state = 2272
                localctx.existing_enum_name = self.character_string()
                self.state = 2273
                self.match(postgreSQLParser.TO)
                self.state = 2274
                localctx.new_enum_name = self.character_string()
                pass

            elif la_ == 6:
                self.state = 2276
                self.type_action()
                self.state = 2281
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2277
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2278
                    self.type_action()
                    self.state = 2283
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 7:
                self.state = 2284
                self.match(postgreSQLParser.SET)
                self.state = 2285
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 2286
                self.type_property()
                self.state = 2291
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2287
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2288
                    self.type_property()
                    self.state = 2293
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2294
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_domain_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.dom_constraint = None # Domain_constraintContext
            self.not_valid = None # Token

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def set_def_column(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_def_columnContext,0)


        def drop_def(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_defContext,0)


        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def drop_constraint(self):
            return self.getTypedRuleContext(postgreSQLParser.Drop_constraintContext,0)


        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def validate_constraint(self):
            return self.getTypedRuleContext(postgreSQLParser.Validate_constraintContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def domain_constraint(self):
            return self.getTypedRuleContext(postgreSQLParser.Domain_constraintContext,0)


        def VALID(self):
            return self.getToken(postgreSQLParser.VALID, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_domain_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_domain_statement" ):
                listener.enterAlter_domain_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_domain_statement" ):
                listener.exitAlter_domain_statement(self)




    def alter_domain_statement(self):

        localctx = postgreSQLParser.Alter_domain_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 134, self.RULE_alter_domain_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2298
            self.match(postgreSQLParser.DOMAIN)
            self.state = 2299
            localctx.name = self.schema_qualified_name()
            self.state = 2321
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,222,self._ctx)
            if la_ == 1:
                self.state = 2300
                self.set_def_column()
                pass

            elif la_ == 2:
                self.state = 2301
                self.drop_def()
                pass

            elif la_ == 3:
                self.state = 2302
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DROP or _la==postgreSQLParser.SET):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2303
                self.match(postgreSQLParser.NOT)
                self.state = 2304
                self.match(postgreSQLParser.NULL)
                pass

            elif la_ == 4:
                self.state = 2305
                self.match(postgreSQLParser.ADD)
                self.state = 2306
                localctx.dom_constraint = self.domain_constraint()
                self.state = 2309
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 2307
                    self.match(postgreSQLParser.NOT)
                    self.state = 2308
                    localctx.not_valid = self.match(postgreSQLParser.VALID)


                pass

            elif la_ == 5:
                self.state = 2311
                self.drop_constraint()
                pass

            elif la_ == 6:
                self.state = 2312
                self.match(postgreSQLParser.RENAME)
                self.state = 2313
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 2314
                self.schema_qualified_name()
                self.state = 2315
                self.match(postgreSQLParser.TO)
                self.state = 2316
                self.schema_qualified_name()
                pass

            elif la_ == 7:
                self.state = 2318
                self.validate_constraint()
                pass

            elif la_ == 8:
                self.state = 2319
                self.rename_to()
                pass

            elif la_ == 9:
                self.state = 2320
                self.set_schema()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_server_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def alter_server_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_server_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_server_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_server_statement" ):
                listener.enterAlter_server_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_server_statement" ):
                listener.exitAlter_server_statement(self)




    def alter_server_statement(self):

        localctx = postgreSQLParser.Alter_server_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 136, self.RULE_alter_server_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2323
            self.match(postgreSQLParser.SERVER)
            self.state = 2324
            self.identifier()
            self.state = 2325
            self.alter_server_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_server_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_server_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_server_action" ):
                listener.enterAlter_server_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_server_action" ):
                listener.exitAlter_server_action(self)




    def alter_server_action(self):

        localctx = postgreSQLParser.Alter_server_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 138, self.RULE_alter_server_action)
        self._la = 0 # Token type
        try:
            self.state = 2336
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,224,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2329
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.VERSION:
                    self.state = 2327
                    self.match(postgreSQLParser.VERSION)
                    self.state = 2328
                    self.character_string()


                self.state = 2331
                self.define_foreign_options()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2332
                self.match(postgreSQLParser.VERSION)
                self.state = 2333
                self.character_string()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2334
                self.owner_to()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 2335
                self.rename_to()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_fts_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def alter_fts_configuration(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_fts_configurationContext,0)


        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_fts_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_fts_statement" ):
                listener.enterAlter_fts_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_fts_statement" ):
                listener.exitAlter_fts_statement(self)




    def alter_fts_statement(self):

        localctx = postgreSQLParser.Alter_fts_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 140, self.RULE_alter_fts_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2338
            self.match(postgreSQLParser.TEXT)
            self.state = 2339
            self.match(postgreSQLParser.SEARCH)
            self.state = 2354
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,226,self._ctx)
            if la_ == 1:
                self.state = 2340
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONFIGURATION or _la==postgreSQLParser.DICTIONARY or _la==postgreSQLParser.PARSER or _la==postgreSQLParser.TEMPLATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2341
                localctx.name = self.schema_qualified_name()
                self.state = 2344
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.RENAME]:
                    self.state = 2342
                    self.rename_to()
                    pass
                elif token in [postgreSQLParser.SET]:
                    self.state = 2343
                    self.set_schema()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.state = 2346
                self.match(postgreSQLParser.DICTIONARY)
                self.state = 2347
                localctx.name = self.schema_qualified_name()
                self.state = 2348
                self.storage_parameter()
                pass

            elif la_ == 3:
                self.state = 2350
                self.match(postgreSQLParser.CONFIGURATION)
                self.state = 2351
                localctx.name = self.schema_qualified_name()
                self.state = 2352
                self.alter_fts_configuration()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_fts_configurationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MAPPING(self):
            return self.getToken(postgreSQLParser.MAPPING, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def IF(self):
            return self.getToken(postgreSQLParser.IF, 0)

        def EXISTS(self):
            return self.getToken(postgreSQLParser.EXISTS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_fts_configuration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_fts_configuration" ):
                listener.enterAlter_fts_configuration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_fts_configuration" ):
                listener.exitAlter_fts_configuration(self)




    def alter_fts_configuration(self):

        localctx = postgreSQLParser.Alter_fts_configurationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 142, self.RULE_alter_fts_configuration)
        self._la = 0 # Token type
        try:
            self.state = 2388
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,230,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2356
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ADD or _la==postgreSQLParser.ALTER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2357
                self.match(postgreSQLParser.MAPPING)
                self.state = 2358
                self.match(postgreSQLParser.FOR)
                self.state = 2359
                self.identifier_list()
                self.state = 2360
                self.match(postgreSQLParser.WITH)
                self.state = 2361
                self.schema_qualified_name()
                self.state = 2366
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2362
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2363
                    self.schema_qualified_name()
                    self.state = 2368
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2369
                self.match(postgreSQLParser.ALTER)
                self.state = 2370
                self.match(postgreSQLParser.MAPPING)
                self.state = 2373
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOR:
                    self.state = 2371
                    self.match(postgreSQLParser.FOR)
                    self.state = 2372
                    self.identifier_list()


                self.state = 2375
                self.match(postgreSQLParser.REPLACE)
                self.state = 2376
                self.schema_qualified_name()
                self.state = 2377
                self.match(postgreSQLParser.WITH)
                self.state = 2378
                self.schema_qualified_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 2380
                self.match(postgreSQLParser.DROP)
                self.state = 2381
                self.match(postgreSQLParser.MAPPING)
                self.state = 2384
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.IF:
                    self.state = 2382
                    self.match(postgreSQLParser.IF)
                    self.state = 2383
                    self.match(postgreSQLParser.EXISTS)


                self.state = 2386
                self.match(postgreSQLParser.FOR)
                self.state = 2387
                self.identifier_list()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def ATTRIBUTE(self):
            return self.getToken(postgreSQLParser.ATTRIBUTE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def collate_identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Collate_identifierContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_type_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_action" ):
                listener.enterType_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_action" ):
                listener.exitType_action(self)




    def type_action(self):

        localctx = postgreSQLParser.Type_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 144, self.RULE_type_action)
        self._la = 0 # Token type
        try:
            self.state = 2424
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ADD]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2390
                self.match(postgreSQLParser.ADD)
                self.state = 2391
                self.match(postgreSQLParser.ATTRIBUTE)
                self.state = 2392
                self.identifier()
                self.state = 2393
                self.data_type()
                self.state = 2395
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLLATE:
                    self.state = 2394
                    self.collate_identifier()


                self.state = 2398
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                    self.state = 2397
                    self.cascade_restrict()


                pass
            elif token in [postgreSQLParser.DROP]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2400
                self.match(postgreSQLParser.DROP)
                self.state = 2401
                self.match(postgreSQLParser.ATTRIBUTE)
                self.state = 2403
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,233,self._ctx)
                if la_ == 1:
                    self.state = 2402
                    self.if_exists()


                self.state = 2405
                self.identifier()
                self.state = 2407
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                    self.state = 2406
                    self.cascade_restrict()


                pass
            elif token in [postgreSQLParser.ALTER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 2409
                self.match(postgreSQLParser.ALTER)
                self.state = 2410
                self.match(postgreSQLParser.ATTRIBUTE)
                self.state = 2411
                self.identifier()
                self.state = 2414
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.SET:
                    self.state = 2412
                    self.match(postgreSQLParser.SET)
                    self.state = 2413
                    self.match(postgreSQLParser.DATA)


                self.state = 2416
                self.match(postgreSQLParser.TYPE)
                self.state = 2417
                self.data_type()
                self.state = 2419
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLLATE:
                    self.state = 2418
                    self.collate_identifier()


                self.state = 2422
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                    self.state = 2421
                    self.cascade_restrict()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_propertyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.storage = None # Storage_optionContext

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def RECEIVE(self):
            return self.getToken(postgreSQLParser.RECEIVE, 0)

        def SEND(self):
            return self.getToken(postgreSQLParser.SEND, 0)

        def TYPMOD_IN(self):
            return self.getToken(postgreSQLParser.TYPMOD_IN, 0)

        def TYPMOD_OUT(self):
            return self.getToken(postgreSQLParser.TYPMOD_OUT, 0)

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def STORAGE(self):
            return self.getToken(postgreSQLParser.STORAGE, 0)

        def storage_option(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_optionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_type_property

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_property" ):
                listener.enterType_property(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_property" ):
                listener.exitType_property(self)




    def type_property(self):

        localctx = postgreSQLParser.Type_propertyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 146, self.RULE_type_property)
        self._la = 0 # Token type
        try:
            self.state = 2432
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ANALYZE, postgreSQLParser.RECEIVE, postgreSQLParser.SEND, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2426
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ANALYZE or ((((_la - 523)) & ~0x3f) == 0 and ((1 << (_la - 523)) & ((1 << (postgreSQLParser.RECEIVE - 523)) | (1 << (postgreSQLParser.SEND - 523)) | (1 << (postgreSQLParser.TYPMOD_IN - 523)) | (1 << (postgreSQLParser.TYPMOD_OUT - 523)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2427
                self.match(postgreSQLParser.EQUAL)
                self.state = 2428
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.STORAGE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2429
                self.match(postgreSQLParser.STORAGE)
                self.state = 2430
                self.match(postgreSQLParser.EQUAL)
                self.state = 2431
                localctx.storage = self.storage_option()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_def_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_def_column

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_def_column" ):
                listener.enterSet_def_column(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_def_column" ):
                listener.exitSet_def_column(self)




    def set_def_column(self):

        localctx = postgreSQLParser.Set_def_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 148, self.RULE_set_def_column)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2434
            self.match(postgreSQLParser.SET)
            self.state = 2435
            self.match(postgreSQLParser.DEFAULT)
            self.state = 2436
            self.vex(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_def" ):
                listener.enterDrop_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_def" ):
                listener.exitDrop_def(self)




    def drop_def(self):

        localctx = postgreSQLParser.Drop_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 150, self.RULE_drop_def)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2438
            self.match(postgreSQLParser.DROP)
            self.state = 2439
            self.match(postgreSQLParser.DEFAULT)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_index_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.table_name = None # Schema_qualified_nameContext

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def index_rest(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_restContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def UNIQUE(self):
            return self.getToken(postgreSQLParser.UNIQUE, 0)

        def CONCURRENTLY(self):
            return self.getToken(postgreSQLParser.CONCURRENTLY, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_index_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_index_statement" ):
                listener.enterCreate_index_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_index_statement" ):
                listener.exitCreate_index_statement(self)




    def create_index_statement(self):

        localctx = postgreSQLParser.Create_index_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 152, self.RULE_create_index_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2442
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.UNIQUE:
                self.state = 2441
                self.match(postgreSQLParser.UNIQUE)


            self.state = 2444
            self.match(postgreSQLParser.INDEX)
            self.state = 2446
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONCURRENTLY:
                self.state = 2445
                self.match(postgreSQLParser.CONCURRENTLY)


            self.state = 2449
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,242,self._ctx)
            if la_ == 1:
                self.state = 2448
                self.if_not_exists()


            self.state = 2452
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 2451
                localctx.name = self.identifier()


            self.state = 2454
            self.match(postgreSQLParser.ON)
            self.state = 2456
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ONLY:
                self.state = 2455
                self.match(postgreSQLParser.ONLY)


            self.state = 2458
            localctx.table_name = self.schema_qualified_name()
            self.state = 2459
            self.index_rest()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_restContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.method = None # IdentifierContext

        def index_sort(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_sortContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def including_index(self):
            return self.getTypedRuleContext(postgreSQLParser.Including_indexContext,0)


        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def table_space(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_spaceContext,0)


        def index_where(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_whereContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_index_rest

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_rest" ):
                listener.enterIndex_rest(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_rest" ):
                listener.exitIndex_rest(self)




    def index_rest(self):

        localctx = postgreSQLParser.Index_restContext(self, self._ctx, self.state)
        self.enterRule(localctx, 154, self.RULE_index_rest)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2463
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 2461
                self.match(postgreSQLParser.USING)
                self.state = 2462
                localctx.method = self.identifier()


            self.state = 2465
            self.index_sort()
            self.state = 2467
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INCLUDE:
                self.state = 2466
                self.including_index()


            self.state = 2470
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 2469
                self.with_storage_parameter()


            self.state = 2473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLESPACE:
                self.state = 2472
                self.table_space()


            self.state = 2476
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHERE:
                self.state = 2475
                self.index_where()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_sortContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def index_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Index_columnContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Index_columnContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_index_sort

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_sort" ):
                listener.enterIndex_sort(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_sort" ):
                listener.exitIndex_sort(self)




    def index_sort(self):

        localctx = postgreSQLParser.Index_sortContext(self, self._ctx, self.state)
        self.enterRule(localctx, 156, self.RULE_index_sort)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2478
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 2479
            self.index_column()
            self.state = 2484
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 2480
                self.match(postgreSQLParser.COMMA)
                self.state = 2481
                self.index_column()
                self.state = 2486
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2487
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.column = None # VexContext
            self.operator_class = None # Schema_qualified_nameContext

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def option_with_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Option_with_valueContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Option_with_valueContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def order_specification(self):
            return self.getTypedRuleContext(postgreSQLParser.Order_specificationContext,0)


        def null_ordering(self):
            return self.getTypedRuleContext(postgreSQLParser.Null_orderingContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_index_column

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_column" ):
                listener.enterIndex_column(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_column" ):
                listener.exitIndex_column(self)




    def index_column(self):

        localctx = postgreSQLParser.Index_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 158, self.RULE_index_column)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2489
            localctx.column = self.vex(0)
            self.state = 2491
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,251,self._ctx)
            if la_ == 1:
                self.state = 2490
                localctx.operator_class = self.schema_qualified_name()


            self.state = 2504
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 2493
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 2494
                self.option_with_value()
                self.state = 2499
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2495
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2496
                    self.option_with_value()
                    self.state = 2501
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2502
                self.match(postgreSQLParser.RIGHT_PAREN)


            self.state = 2507
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ASC or _la==postgreSQLParser.DESC or _la==postgreSQLParser.USING:
                self.state = 2506
                self.order_specification()


            self.state = 2510
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NULLS:
                self.state = 2509
                self.null_ordering()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Including_indexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDE(self):
            return self.getToken(postgreSQLParser.INCLUDE, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_including_index

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIncluding_index" ):
                listener.enterIncluding_index(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIncluding_index" ):
                listener.exitIncluding_index(self)




    def including_index(self):

        localctx = postgreSQLParser.Including_indexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 160, self.RULE_including_index)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2512
            self.match(postgreSQLParser.INCLUDE)
            self.state = 2513
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 2514
            self.identifier()
            self.state = 2519
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 2515
                self.match(postgreSQLParser.COMMA)
                self.state = 2516
                self.identifier()
                self.state = 2521
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2522
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_whereContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_index_where

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_where" ):
                listener.enterIndex_where(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_where" ):
                listener.exitIndex_where(self)




    def index_where(self):

        localctx = postgreSQLParser.Index_whereContext(self, self._ctx, self.state)
        self.enterRule(localctx, 162, self.RULE_index_where)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2524
            self.match(postgreSQLParser.WHERE)
            self.state = 2525
            self.vex(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_extension_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.schema = None # IdentifierContext

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def CASCADE(self):
            return self.getToken(postgreSQLParser.CASCADE, 0)

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_extension_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_extension_statement" ):
                listener.enterCreate_extension_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_extension_statement" ):
                listener.exitCreate_extension_statement(self)




    def create_extension_statement(self):

        localctx = postgreSQLParser.Create_extension_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 164, self.RULE_create_extension_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2527
            self.match(postgreSQLParser.EXTENSION)
            self.state = 2529
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,257,self._ctx)
            if la_ == 1:
                self.state = 2528
                self.if_not_exists()


            self.state = 2531
            localctx.name = self.identifier()
            self.state = 2533
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 2532
                self.match(postgreSQLParser.WITH)


            self.state = 2537
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.SCHEMA:
                self.state = 2535
                self.match(postgreSQLParser.SCHEMA)
                self.state = 2536
                localctx.schema = self.identifier()


            self.state = 2544
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.VERSION:
                self.state = 2539
                self.match(postgreSQLParser.VERSION)
                self.state = 2542
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 2540
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 2541
                    self.character_string()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 2551
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FROM:
                self.state = 2546
                self.match(postgreSQLParser.FROM)
                self.state = 2549
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 2547
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 2548
                    self.character_string()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 2554
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE:
                self.state = 2553
                self.match(postgreSQLParser.CASCADE)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_language_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def TRUSTED(self):
            return self.getToken(postgreSQLParser.TRUSTED, 0)

        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def HANDLER(self):
            return self.getToken(postgreSQLParser.HANDLER, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def INLINE(self):
            return self.getToken(postgreSQLParser.INLINE, 0)

        def VALIDATOR(self):
            return self.getToken(postgreSQLParser.VALIDATOR, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_language_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_language_statement" ):
                listener.enterCreate_language_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_language_statement" ):
                listener.exitCreate_language_statement(self)




    def create_language_statement(self):

        localctx = postgreSQLParser.Create_language_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 166, self.RULE_create_language_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2558
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OR:
                self.state = 2556
                self.match(postgreSQLParser.OR)
                self.state = 2557
                self.match(postgreSQLParser.REPLACE)


            self.state = 2561
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TRUSTED:
                self.state = 2560
                self.match(postgreSQLParser.TRUSTED)


            self.state = 2564
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.PROCEDURAL:
                self.state = 2563
                self.match(postgreSQLParser.PROCEDURAL)


            self.state = 2566
            self.match(postgreSQLParser.LANGUAGE)
            self.state = 2567
            localctx.name = self.identifier()
            self.state = 2578
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.HANDLER:
                self.state = 2568
                self.match(postgreSQLParser.HANDLER)
                self.state = 2569
                self.schema_qualified_name()
                self.state = 2572
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.INLINE:
                    self.state = 2570
                    self.match(postgreSQLParser.INLINE)
                    self.state = 2571
                    self.schema_qualified_name()


                self.state = 2576
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.VALIDATOR:
                    self.state = 2574
                    self.match(postgreSQLParser.VALIDATOR)
                    self.state = 2575
                    self.schema_qualified_name()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_event_trigger_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def WHEN(self):
            return self.getToken(postgreSQLParser.WHEN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def IN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.IN)
            else:
                return self.getToken(postgreSQLParser.IN, i)

        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def AND(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.AND)
            else:
                return self.getToken(postgreSQLParser.AND, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_event_trigger_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_event_trigger_statement" ):
                listener.enterCreate_event_trigger_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_event_trigger_statement" ):
                listener.exitCreate_event_trigger_statement(self)




    def create_event_trigger_statement(self):

        localctx = postgreSQLParser.Create_event_trigger_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 168, self.RULE_create_event_trigger_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2580
            self.match(postgreSQLParser.EVENT)
            self.state = 2581
            self.match(postgreSQLParser.TRIGGER)
            self.state = 2582
            localctx.name = self.identifier()
            self.state = 2583
            self.match(postgreSQLParser.ON)
            self.state = 2584
            self.identifier()
            self.state = 2605
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHEN:
                self.state = 2585
                self.match(postgreSQLParser.WHEN)
                self.state = 2601 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 2586
                        self.schema_qualified_name()
                        self.state = 2587
                        self.match(postgreSQLParser.IN)
                        self.state = 2588
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 2589
                        self.character_string()
                        self.state = 2594
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==postgreSQLParser.COMMA:
                            self.state = 2590
                            self.match(postgreSQLParser.COMMA)
                            self.state = 2591
                            self.character_string()
                            self.state = 2596
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 2597
                        self.match(postgreSQLParser.RIGHT_PAREN)
                        self.state = 2599
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.AND:
                            self.state = 2598
                            self.match(postgreSQLParser.AND)



                    else:
                        raise NoViableAltException(self)
                    self.state = 2603 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,273,self._ctx)



            self.state = 2607
            self.match(postgreSQLParser.EXECUTE)
            self.state = 2608
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2609
            self.vex(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_type_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tname = None # Schema_qualified_nameContext
            self._table_column_definition = None # Table_column_definitionContext
            self.attrs = list() # of Table_column_definitionContexts
            self._character_string = None # Character_stringContext
            self.enums = list() # of Character_stringContexts
            self.subtype_name = None # Data_typeContext
            self.subtype_operator_class = None # IdentifierContext
            self.collation = None # Schema_qualified_nameContext
            self.canonical_function = None # Schema_qualified_nameContext
            self.subtype_diff_function = None # Schema_qualified_nameContext
            self.internallength = None # Signed_numerical_literalContext
            self.input_function = None # Schema_qualified_nameContext
            self.output_function = None # Schema_qualified_nameContext
            self.receive_function = None # Schema_qualified_nameContext
            self.send_function = None # Schema_qualified_nameContext
            self.type_modifier_input_function = None # Schema_qualified_nameContext
            self.type_modifier_output_function = None # Schema_qualified_nameContext
            self.analyze_function = None # Schema_qualified_nameContext
            self.alignment = None # Data_typeContext
            self.storage = None # Storage_optionContext
            self.like_type = None # Data_typeContext
            self.category = None # Character_stringContext
            self.preferred = None # Truth_valueContext
            self.default_value = None # VexContext
            self.element = None # Data_typeContext
            self.delimiter = None # Character_stringContext
            self.collatable = None # Truth_valueContext

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def INPUT(self):
            return self.getToken(postgreSQLParser.INPUT, 0)

        def EQUAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.EQUAL)
            else:
                return self.getToken(postgreSQLParser.EQUAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def OUTPUT(self):
            return self.getToken(postgreSQLParser.OUTPUT, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def ENUM(self):
            return self.getToken(postgreSQLParser.ENUM, 0)

        def RANGE(self):
            return self.getToken(postgreSQLParser.RANGE, 0)

        def INTERNALLENGTH(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.INTERNALLENGTH)
            else:
                return self.getToken(postgreSQLParser.INTERNALLENGTH, i)

        def SUBTYPE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SUBTYPE)
            else:
                return self.getToken(postgreSQLParser.SUBTYPE, i)

        def SUBTYPE_OPCLASS(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SUBTYPE_OPCLASS)
            else:
                return self.getToken(postgreSQLParser.SUBTYPE_OPCLASS, i)

        def COLLATION(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COLLATION)
            else:
                return self.getToken(postgreSQLParser.COLLATION, i)

        def CANONICAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.CANONICAL)
            else:
                return self.getToken(postgreSQLParser.CANONICAL, i)

        def SUBTYPE_DIFF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SUBTYPE_DIFF)
            else:
                return self.getToken(postgreSQLParser.SUBTYPE_DIFF, i)

        def VARIABLE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.VARIABLE)
            else:
                return self.getToken(postgreSQLParser.VARIABLE, i)

        def RECEIVE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RECEIVE)
            else:
                return self.getToken(postgreSQLParser.RECEIVE, i)

        def SEND(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SEND)
            else:
                return self.getToken(postgreSQLParser.SEND, i)

        def TYPMOD_IN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.TYPMOD_IN)
            else:
                return self.getToken(postgreSQLParser.TYPMOD_IN, i)

        def TYPMOD_OUT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.TYPMOD_OUT)
            else:
                return self.getToken(postgreSQLParser.TYPMOD_OUT, i)

        def ANALYZE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ANALYZE)
            else:
                return self.getToken(postgreSQLParser.ANALYZE, i)

        def PASSEDBYVALUE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.PASSEDBYVALUE)
            else:
                return self.getToken(postgreSQLParser.PASSEDBYVALUE, i)

        def ALIGNMENT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ALIGNMENT)
            else:
                return self.getToken(postgreSQLParser.ALIGNMENT, i)

        def STORAGE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.STORAGE)
            else:
                return self.getToken(postgreSQLParser.STORAGE, i)

        def LIKE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LIKE)
            else:
                return self.getToken(postgreSQLParser.LIKE, i)

        def CATEGORY(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.CATEGORY)
            else:
                return self.getToken(postgreSQLParser.CATEGORY, i)

        def PREFERRED(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.PREFERRED)
            else:
                return self.getToken(postgreSQLParser.PREFERRED, i)

        def DEFAULT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DEFAULT)
            else:
                return self.getToken(postgreSQLParser.DEFAULT, i)

        def ELEMENT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ELEMENT)
            else:
                return self.getToken(postgreSQLParser.ELEMENT, i)

        def DELIMITER(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DELIMITER)
            else:
                return self.getToken(postgreSQLParser.DELIMITER, i)

        def COLLATABLE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COLLATABLE)
            else:
                return self.getToken(postgreSQLParser.COLLATABLE, i)

        def table_column_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_column_definitionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_column_definitionContext,i)


        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def signed_numerical_literal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Signed_numerical_literalContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Signed_numerical_literalContext,i)


        def storage_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Storage_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Storage_optionContext,i)


        def truth_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Truth_valueContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Truth_valueContext,i)


        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_type_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_type_statement" ):
                listener.enterCreate_type_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_type_statement" ):
                listener.exitCreate_type_statement(self)




    def create_type_statement(self):

        localctx = postgreSQLParser.Create_type_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 170, self.RULE_create_type_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2611
            self.match(postgreSQLParser.TYPE)
            self.state = 2612
            localctx.tname = self.schema_qualified_name()
            self.state = 2760
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.AS]:
                self.state = 2613
                self.match(postgreSQLParser.AS)
                self.state = 2682
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.LEFT_PAREN]:
                    self.state = 2614
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 2623
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                        self.state = 2615
                        localctx._table_column_definition = self.table_column_definition()
                        localctx.attrs.append(localctx._table_column_definition)
                        self.state = 2620
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==postgreSQLParser.COMMA:
                            self.state = 2616
                            self.match(postgreSQLParser.COMMA)
                            self.state = 2617
                            localctx._table_column_definition = self.table_column_definition()
                            localctx.attrs.append(localctx._table_column_definition)
                            self.state = 2622
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 2625
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                elif token in [postgreSQLParser.ENUM]:
                    self.state = 2626
                    self.match(postgreSQLParser.ENUM)
                    self.state = 2627
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 2636
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.Character_String_Literal or _la==postgreSQLParser.BeginDollarStringConstant:
                        self.state = 2628
                        localctx._character_string = self.character_string()
                        localctx.enums.append(localctx._character_string)
                        self.state = 2633
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==postgreSQLParser.COMMA:
                            self.state = 2629
                            self.match(postgreSQLParser.COMMA)
                            self.state = 2630
                            localctx._character_string = self.character_string()
                            localctx.enums.append(localctx._character_string)
                            self.state = 2635
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)



                    self.state = 2638
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                elif token in [postgreSQLParser.RANGE]:
                    self.state = 2639
                    self.match(postgreSQLParser.RANGE)
                    self.state = 2640
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 2656
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.SUBTYPE]:
                        self.state = 2641
                        self.match(postgreSQLParser.SUBTYPE)
                        self.state = 2642
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2643
                        localctx.subtype_name = self.data_type()
                        pass
                    elif token in [postgreSQLParser.SUBTYPE_OPCLASS]:
                        self.state = 2644
                        self.match(postgreSQLParser.SUBTYPE_OPCLASS)
                        self.state = 2645
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2646
                        localctx.subtype_operator_class = self.identifier()
                        pass
                    elif token in [postgreSQLParser.COLLATION]:
                        self.state = 2647
                        self.match(postgreSQLParser.COLLATION)
                        self.state = 2648
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2649
                        localctx.collation = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.CANONICAL]:
                        self.state = 2650
                        self.match(postgreSQLParser.CANONICAL)
                        self.state = 2651
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2652
                        localctx.canonical_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.SUBTYPE_DIFF]:
                        self.state = 2653
                        self.match(postgreSQLParser.SUBTYPE_DIFF)
                        self.state = 2654
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2655
                        localctx.subtype_diff_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.COMMA, postgreSQLParser.RIGHT_PAREN]:
                        pass
                    else:
                        pass
                    self.state = 2678
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 2658
                        self.match(postgreSQLParser.COMMA)
                        self.state = 2674
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.SUBTYPE]:
                            self.state = 2659
                            self.match(postgreSQLParser.SUBTYPE)
                            self.state = 2660
                            self.match(postgreSQLParser.EQUAL)
                            self.state = 2661
                            localctx.subtype_name = self.data_type()
                            pass
                        elif token in [postgreSQLParser.SUBTYPE_OPCLASS]:
                            self.state = 2662
                            self.match(postgreSQLParser.SUBTYPE_OPCLASS)
                            self.state = 2663
                            self.match(postgreSQLParser.EQUAL)
                            self.state = 2664
                            localctx.subtype_operator_class = self.identifier()
                            pass
                        elif token in [postgreSQLParser.COLLATION]:
                            self.state = 2665
                            self.match(postgreSQLParser.COLLATION)
                            self.state = 2666
                            self.match(postgreSQLParser.EQUAL)
                            self.state = 2667
                            localctx.collation = self.schema_qualified_name()
                            pass
                        elif token in [postgreSQLParser.CANONICAL]:
                            self.state = 2668
                            self.match(postgreSQLParser.CANONICAL)
                            self.state = 2669
                            self.match(postgreSQLParser.EQUAL)
                            self.state = 2670
                            localctx.canonical_function = self.schema_qualified_name()
                            pass
                        elif token in [postgreSQLParser.SUBTYPE_DIFF]:
                            self.state = 2671
                            self.match(postgreSQLParser.SUBTYPE_DIFF)
                            self.state = 2672
                            self.match(postgreSQLParser.EQUAL)
                            self.state = 2673
                            localctx.subtype_diff_function = self.schema_qualified_name()
                            pass
                        else:
                            raise NoViableAltException(self)

                        self.state = 2680
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 2681
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.LEFT_PAREN]:
                self.state = 2684
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 2692
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.INTERNALLENGTH:
                    self.state = 2685
                    self.match(postgreSQLParser.INTERNALLENGTH)
                    self.state = 2686
                    self.match(postgreSQLParser.EQUAL)
                    self.state = 2689
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER]:
                        self.state = 2687
                        localctx.internallength = self.signed_numerical_literal()
                        pass
                    elif token in [postgreSQLParser.VARIABLE]:
                        self.state = 2688
                        self.match(postgreSQLParser.VARIABLE)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 2691
                    self.match(postgreSQLParser.COMMA)


                self.state = 2694
                self.match(postgreSQLParser.INPUT)
                self.state = 2695
                self.match(postgreSQLParser.EQUAL)
                self.state = 2696
                localctx.input_function = self.schema_qualified_name()
                self.state = 2697
                self.match(postgreSQLParser.COMMA)
                self.state = 2698
                self.match(postgreSQLParser.OUTPUT)
                self.state = 2699
                self.match(postgreSQLParser.EQUAL)
                self.state = 2700
                localctx.output_function = self.schema_qualified_name()
                self.state = 2755
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 2701
                    self.match(postgreSQLParser.COMMA)
                    self.state = 2751
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.RECEIVE]:
                        self.state = 2702
                        self.match(postgreSQLParser.RECEIVE)
                        self.state = 2703
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2704
                        localctx.receive_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.SEND]:
                        self.state = 2705
                        self.match(postgreSQLParser.SEND)
                        self.state = 2706
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2707
                        localctx.send_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.TYPMOD_IN]:
                        self.state = 2708
                        self.match(postgreSQLParser.TYPMOD_IN)
                        self.state = 2709
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2710
                        localctx.type_modifier_input_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.TYPMOD_OUT]:
                        self.state = 2711
                        self.match(postgreSQLParser.TYPMOD_OUT)
                        self.state = 2712
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2713
                        localctx.type_modifier_output_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.ANALYZE]:
                        self.state = 2714
                        self.match(postgreSQLParser.ANALYZE)
                        self.state = 2715
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2716
                        localctx.analyze_function = self.schema_qualified_name()
                        pass
                    elif token in [postgreSQLParser.INTERNALLENGTH]:
                        self.state = 2717
                        self.match(postgreSQLParser.INTERNALLENGTH)
                        self.state = 2718
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2721
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER]:
                            self.state = 2719
                            localctx.internallength = self.signed_numerical_literal()
                            pass
                        elif token in [postgreSQLParser.VARIABLE]:
                            self.state = 2720
                            self.match(postgreSQLParser.VARIABLE)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass
                    elif token in [postgreSQLParser.PASSEDBYVALUE]:
                        self.state = 2723
                        self.match(postgreSQLParser.PASSEDBYVALUE)
                        pass
                    elif token in [postgreSQLParser.ALIGNMENT]:
                        self.state = 2724
                        self.match(postgreSQLParser.ALIGNMENT)
                        self.state = 2725
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2726
                        localctx.alignment = self.data_type()
                        pass
                    elif token in [postgreSQLParser.STORAGE]:
                        self.state = 2727
                        self.match(postgreSQLParser.STORAGE)
                        self.state = 2728
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2729
                        localctx.storage = self.storage_option()
                        pass
                    elif token in [postgreSQLParser.LIKE]:
                        self.state = 2730
                        self.match(postgreSQLParser.LIKE)
                        self.state = 2731
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2732
                        localctx.like_type = self.data_type()
                        pass
                    elif token in [postgreSQLParser.CATEGORY]:
                        self.state = 2733
                        self.match(postgreSQLParser.CATEGORY)
                        self.state = 2734
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2735
                        localctx.category = self.character_string()
                        pass
                    elif token in [postgreSQLParser.PREFERRED]:
                        self.state = 2736
                        self.match(postgreSQLParser.PREFERRED)
                        self.state = 2737
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2738
                        localctx.preferred = self.truth_value()
                        pass
                    elif token in [postgreSQLParser.DEFAULT]:
                        self.state = 2739
                        self.match(postgreSQLParser.DEFAULT)
                        self.state = 2740
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2741
                        localctx.default_value = self.vex(0)
                        pass
                    elif token in [postgreSQLParser.ELEMENT]:
                        self.state = 2742
                        self.match(postgreSQLParser.ELEMENT)
                        self.state = 2743
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2744
                        localctx.element = self.data_type()
                        pass
                    elif token in [postgreSQLParser.DELIMITER]:
                        self.state = 2745
                        self.match(postgreSQLParser.DELIMITER)
                        self.state = 2746
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2747
                        localctx.delimiter = self.character_string()
                        pass
                    elif token in [postgreSQLParser.COLLATABLE]:
                        self.state = 2748
                        self.match(postgreSQLParser.COLLATABLE)
                        self.state = 2749
                        self.match(postgreSQLParser.EQUAL)
                        self.state = 2750
                        localctx.collatable = self.truth_value()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 2757
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 2758
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.EOF, postgreSQLParser.SEMI_COLON]:
                pass
            else:
                pass
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_domain_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.dat_type = None # Data_typeContext
            self.def_value = None # VexContext
            self._domain_constraint = None # Domain_constraintContext
            self.dom_constraint = list() # of Domain_constraintContexts

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def collate_identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Collate_identifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Collate_identifierContext,i)


        def DEFAULT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DEFAULT)
            else:
                return self.getToken(postgreSQLParser.DEFAULT, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def domain_constraint(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Domain_constraintContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Domain_constraintContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_domain_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_domain_statement" ):
                listener.enterCreate_domain_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_domain_statement" ):
                listener.exitCreate_domain_statement(self)




    def create_domain_statement(self):

        localctx = postgreSQLParser.Create_domain_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 172, self.RULE_create_domain_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2762
            self.match(postgreSQLParser.DOMAIN)
            self.state = 2763
            localctx.name = self.schema_qualified_name()
            self.state = 2765
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.AS:
                self.state = 2764
                self.match(postgreSQLParser.AS)


            self.state = 2767
            localctx.dat_type = self.data_type()
            self.state = 2774
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 385)) & ~0x3f) == 0 and ((1 << (_la - 385)) & ((1 << (postgreSQLParser.CHECK - 385)) | (1 << (postgreSQLParser.COLLATE - 385)) | (1 << (postgreSQLParser.CONSTRAINT - 385)) | (1 << (postgreSQLParser.DEFAULT - 385)) | (1 << (postgreSQLParser.NOT - 385)) | (1 << (postgreSQLParser.NULL - 385)))) != 0):
                self.state = 2772
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.COLLATE]:
                    self.state = 2768
                    self.collate_identifier()
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 2769
                    self.match(postgreSQLParser.DEFAULT)
                    self.state = 2770
                    localctx.def_value = self.vex(0)
                    pass
                elif token in [postgreSQLParser.CHECK, postgreSQLParser.CONSTRAINT, postgreSQLParser.NOT, postgreSQLParser.NULL]:
                    self.state = 2771
                    localctx._domain_constraint = self.domain_constraint()
                    localctx.dom_constraint.append(localctx._domain_constraint)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 2776
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_server_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_server_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_server_statement" ):
                listener.enterCreate_server_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_server_statement" ):
                listener.exitCreate_server_statement(self)




    def create_server_statement(self):

        localctx = postgreSQLParser.Create_server_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 174, self.RULE_create_server_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2777
            self.match(postgreSQLParser.SERVER)
            self.state = 2779
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,292,self._ctx)
            if la_ == 1:
                self.state = 2778
                self.if_not_exists()


            self.state = 2781
            self.identifier()
            self.state = 2784
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TYPE:
                self.state = 2782
                self.match(postgreSQLParser.TYPE)
                self.state = 2783
                self.character_string()


            self.state = 2788
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.VERSION:
                self.state = 2786
                self.match(postgreSQLParser.VERSION)
                self.state = 2787
                self.character_string()


            self.state = 2790
            self.match(postgreSQLParser.FOREIGN)
            self.state = 2791
            self.match(postgreSQLParser.DATA)
            self.state = 2792
            self.match(postgreSQLParser.WRAPPER)
            self.state = 2793
            self.identifier()
            self.state = 2795
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 2794
                self.define_foreign_options()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_fts_dictionary_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.template = None # Schema_qualified_nameContext

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def option_with_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Option_with_valueContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Option_with_valueContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_fts_dictionary_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_fts_dictionary_statement" ):
                listener.enterCreate_fts_dictionary_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_fts_dictionary_statement" ):
                listener.exitCreate_fts_dictionary_statement(self)




    def create_fts_dictionary_statement(self):

        localctx = postgreSQLParser.Create_fts_dictionary_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 176, self.RULE_create_fts_dictionary_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2797
            self.match(postgreSQLParser.TEXT)
            self.state = 2798
            self.match(postgreSQLParser.SEARCH)
            self.state = 2799
            self.match(postgreSQLParser.DICTIONARY)
            self.state = 2800
            localctx.name = self.schema_qualified_name()
            self.state = 2801
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 2802
            self.match(postgreSQLParser.TEMPLATE)
            self.state = 2803
            self.match(postgreSQLParser.EQUAL)
            self.state = 2804
            localctx.template = self.schema_qualified_name()
            self.state = 2809
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 2805
                self.match(postgreSQLParser.COMMA)
                self.state = 2806
                self.option_with_value()
                self.state = 2811
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 2812
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Option_with_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_option_with_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOption_with_value" ):
                listener.enterOption_with_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOption_with_value" ):
                listener.exitOption_with_value(self)




    def option_with_value(self):

        localctx = postgreSQLParser.Option_with_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 178, self.RULE_option_with_value)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2814
            self.identifier()
            self.state = 2815
            self.match(postgreSQLParser.EQUAL)
            self.state = 2816
            self.vex(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_fts_configuration_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.parser_name = None # Schema_qualified_nameContext
            self.config_name = None # Schema_qualified_nameContext

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def COPY(self):
            return self.getToken(postgreSQLParser.COPY, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_fts_configuration_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_fts_configuration_statement" ):
                listener.enterCreate_fts_configuration_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_fts_configuration_statement" ):
                listener.exitCreate_fts_configuration_statement(self)




    def create_fts_configuration_statement(self):

        localctx = postgreSQLParser.Create_fts_configuration_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 180, self.RULE_create_fts_configuration_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2818
            self.match(postgreSQLParser.TEXT)
            self.state = 2819
            self.match(postgreSQLParser.SEARCH)
            self.state = 2820
            self.match(postgreSQLParser.CONFIGURATION)
            self.state = 2821
            localctx.name = self.schema_qualified_name()
            self.state = 2822
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 2829
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.PARSER]:
                self.state = 2823
                self.match(postgreSQLParser.PARSER)
                self.state = 2824
                self.match(postgreSQLParser.EQUAL)
                self.state = 2825
                localctx.parser_name = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.COPY]:
                self.state = 2826
                self.match(postgreSQLParser.COPY)
                self.state = 2827
                self.match(postgreSQLParser.EQUAL)
                self.state = 2828
                localctx.config_name = self.schema_qualified_name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2831
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_fts_template_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.init_name = None # Schema_qualified_nameContext
            self.lexize_name = None # Schema_qualified_nameContext

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def LEXIZE(self):
            return self.getToken(postgreSQLParser.LEXIZE, 0)

        def EQUAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.EQUAL)
            else:
                return self.getToken(postgreSQLParser.EQUAL, i)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def INIT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.INIT)
            else:
                return self.getToken(postgreSQLParser.INIT, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_fts_template_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_fts_template_statement" ):
                listener.enterCreate_fts_template_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_fts_template_statement" ):
                listener.exitCreate_fts_template_statement(self)




    def create_fts_template_statement(self):

        localctx = postgreSQLParser.Create_fts_template_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 182, self.RULE_create_fts_template_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2833
            self.match(postgreSQLParser.TEXT)
            self.state = 2834
            self.match(postgreSQLParser.SEARCH)
            self.state = 2835
            self.match(postgreSQLParser.TEMPLATE)
            self.state = 2836
            localctx.name = self.schema_qualified_name()
            self.state = 2837
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 2843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INIT:
                self.state = 2838
                self.match(postgreSQLParser.INIT)
                self.state = 2839
                self.match(postgreSQLParser.EQUAL)
                self.state = 2840
                localctx.init_name = self.schema_qualified_name()
                self.state = 2841
                self.match(postgreSQLParser.COMMA)


            self.state = 2845
            self.match(postgreSQLParser.LEXIZE)
            self.state = 2846
            self.match(postgreSQLParser.EQUAL)
            self.state = 2847
            localctx.lexize_name = self.schema_qualified_name()
            self.state = 2852
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COMMA:
                self.state = 2848
                self.match(postgreSQLParser.COMMA)
                self.state = 2849
                self.match(postgreSQLParser.INIT)
                self.state = 2850
                self.match(postgreSQLParser.EQUAL)
                self.state = 2851
                localctx.init_name = self.schema_qualified_name()


            self.state = 2854
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_fts_parser_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.start_func = None # Schema_qualified_nameContext
            self.gettoken_func = None # Schema_qualified_nameContext
            self.end_func = None # Schema_qualified_nameContext
            self.headline_func = None # Schema_qualified_nameContext
            self.lextypes_func = None # Schema_qualified_nameContext

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def START(self):
            return self.getToken(postgreSQLParser.START, 0)

        def EQUAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.EQUAL)
            else:
                return self.getToken(postgreSQLParser.EQUAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def GETTOKEN(self):
            return self.getToken(postgreSQLParser.GETTOKEN, 0)

        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def LEXTYPES(self):
            return self.getToken(postgreSQLParser.LEXTYPES, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def HEADLINE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.HEADLINE)
            else:
                return self.getToken(postgreSQLParser.HEADLINE, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_fts_parser_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_fts_parser_statement" ):
                listener.enterCreate_fts_parser_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_fts_parser_statement" ):
                listener.exitCreate_fts_parser_statement(self)




    def create_fts_parser_statement(self):

        localctx = postgreSQLParser.Create_fts_parser_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 184, self.RULE_create_fts_parser_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2856
            self.match(postgreSQLParser.TEXT)
            self.state = 2857
            self.match(postgreSQLParser.SEARCH)
            self.state = 2858
            self.match(postgreSQLParser.PARSER)
            self.state = 2859
            localctx.name = self.schema_qualified_name()
            self.state = 2860
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 2861
            self.match(postgreSQLParser.START)
            self.state = 2862
            self.match(postgreSQLParser.EQUAL)
            self.state = 2863
            localctx.start_func = self.schema_qualified_name()
            self.state = 2864
            self.match(postgreSQLParser.COMMA)
            self.state = 2865
            self.match(postgreSQLParser.GETTOKEN)
            self.state = 2866
            self.match(postgreSQLParser.EQUAL)
            self.state = 2867
            localctx.gettoken_func = self.schema_qualified_name()
            self.state = 2868
            self.match(postgreSQLParser.COMMA)
            self.state = 2869
            self.match(postgreSQLParser.END)
            self.state = 2870
            self.match(postgreSQLParser.EQUAL)
            self.state = 2871
            localctx.end_func = self.schema_qualified_name()
            self.state = 2872
            self.match(postgreSQLParser.COMMA)
            self.state = 2878
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.HEADLINE:
                self.state = 2873
                self.match(postgreSQLParser.HEADLINE)
                self.state = 2874
                self.match(postgreSQLParser.EQUAL)
                self.state = 2875
                localctx.headline_func = self.schema_qualified_name()
                self.state = 2876
                self.match(postgreSQLParser.COMMA)


            self.state = 2880
            self.match(postgreSQLParser.LEXTYPES)
            self.state = 2881
            self.match(postgreSQLParser.EQUAL)
            self.state = 2882
            localctx.lextypes_func = self.schema_qualified_name()
            self.state = 2887
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COMMA:
                self.state = 2883
                self.match(postgreSQLParser.COMMA)
                self.state = 2884
                self.match(postgreSQLParser.HEADLINE)
                self.state = 2885
                self.match(postgreSQLParser.EQUAL)
                self.state = 2886
                localctx.headline_func = self.schema_qualified_name()


            self.state = 2889
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_collation_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def collation_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Collation_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Collation_optionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_collation_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_collation_statement" ):
                listener.enterCreate_collation_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_collation_statement" ):
                listener.exitCreate_collation_statement(self)




    def create_collation_statement(self):

        localctx = postgreSQLParser.Create_collation_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 186, self.RULE_create_collation_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2891
            self.match(postgreSQLParser.COLLATION)
            self.state = 2893
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,302,self._ctx)
            if la_ == 1:
                self.state = 2892
                self.if_not_exists()


            self.state = 2895
            localctx.name = self.schema_qualified_name()
            self.state = 2910
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.FROM]:
                self.state = 2896
                self.match(postgreSQLParser.FROM)
                self.state = 2897
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.LEFT_PAREN]:
                self.state = 2898
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 2907
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.VERSION or ((((_la - 465)) & ~0x3f) == 0 and ((1 << (_la - 465)) & ((1 << (postgreSQLParser.DETERMINISTIC - 465)) | (1 << (postgreSQLParser.LC_COLLATE - 465)) | (1 << (postgreSQLParser.LC_CTYPE - 465)) | (1 << (postgreSQLParser.LOCALE - 465)) | (1 << (postgreSQLParser.PROVIDER - 465)))) != 0):
                    self.state = 2899
                    self.collation_option()
                    self.state = 2904
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 2900
                        self.match(postgreSQLParser.COMMA)
                        self.state = 2901
                        self.collation_option()
                        self.state = 2906
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 2909
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_collation_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def REFRESH(self):
            return self.getToken(postgreSQLParser.REFRESH, 0)

        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_collation_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_collation_statement" ):
                listener.enterAlter_collation_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_collation_statement" ):
                listener.exitAlter_collation_statement(self)




    def alter_collation_statement(self):

        localctx = postgreSQLParser.Alter_collation_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 188, self.RULE_alter_collation_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2912
            self.match(postgreSQLParser.COLLATION)
            self.state = 2913
            localctx.name = self.schema_qualified_name()
            self.state = 2919
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.REFRESH]:
                self.state = 2914
                self.match(postgreSQLParser.REFRESH)
                self.state = 2915
                self.match(postgreSQLParser.VERSION)
                pass
            elif token in [postgreSQLParser.RENAME]:
                self.state = 2916
                self.rename_to()
                pass
            elif token in [postgreSQLParser.OWNER]:
                self.state = 2917
                self.owner_to()
                pass
            elif token in [postgreSQLParser.SET]:
                self.state = 2918
                self.set_schema()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Collation_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def LOCALE(self):
            return self.getToken(postgreSQLParser.LOCALE, 0)

        def LC_COLLATE(self):
            return self.getToken(postgreSQLParser.LC_COLLATE, 0)

        def LC_CTYPE(self):
            return self.getToken(postgreSQLParser.LC_CTYPE, 0)

        def PROVIDER(self):
            return self.getToken(postgreSQLParser.PROVIDER, 0)

        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DETERMINISTIC(self):
            return self.getToken(postgreSQLParser.DETERMINISTIC, 0)

        def boolean_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Boolean_valueContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_collation_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollation_option" ):
                listener.enterCollation_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollation_option" ):
                listener.exitCollation_option(self)




    def collation_option(self):

        localctx = postgreSQLParser.Collation_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 190, self.RULE_collation_option)
        self._la = 0 # Token type
        try:
            self.state = 2930
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.VERSION, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LOCALE, postgreSQLParser.PROVIDER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 2921
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.VERSION or ((((_la - 487)) & ~0x3f) == 0 and ((1 << (_la - 487)) & ((1 << (postgreSQLParser.LC_COLLATE - 487)) | (1 << (postgreSQLParser.LC_CTYPE - 487)) | (1 << (postgreSQLParser.LOCALE - 487)) | (1 << (postgreSQLParser.PROVIDER - 487)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2922
                self.match(postgreSQLParser.EQUAL)
                self.state = 2925
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 2923
                    self.character_string()
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 2924
                    self.identifier()
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.DETERMINISTIC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 2927
                self.match(postgreSQLParser.DETERMINISTIC)
                self.state = 2928
                self.match(postgreSQLParser.EQUAL)
                self.state = 2929
                self.boolean_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_user_mapping_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.USER)
            else:
                return self.getToken(postgreSQLParser.USER, i)

        def MAPPING(self):
            return self.getToken(postgreSQLParser.MAPPING, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_user_mapping_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_user_mapping_statement" ):
                listener.enterCreate_user_mapping_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_user_mapping_statement" ):
                listener.exitCreate_user_mapping_statement(self)




    def create_user_mapping_statement(self):

        localctx = postgreSQLParser.Create_user_mapping_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 192, self.RULE_create_user_mapping_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2932
            self.match(postgreSQLParser.USER)
            self.state = 2933
            self.match(postgreSQLParser.MAPPING)
            self.state = 2935
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.IF:
                self.state = 2934
                self.if_not_exists()


            self.state = 2937
            self.match(postgreSQLParser.FOR)
            self.state = 2940
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.CURRENT_USER, postgreSQLParser.SESSION_USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 2938
                self.user_name()
                pass
            elif token in [postgreSQLParser.USER]:
                self.state = 2939
                self.match(postgreSQLParser.USER)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2942
            self.match(postgreSQLParser.SERVER)
            self.state = 2943
            self.identifier()
            self.state = 2945
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 2944
                self.define_foreign_options()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_user_mapping_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.USER)
            else:
                return self.getToken(postgreSQLParser.USER, i)

        def MAPPING(self):
            return self.getToken(postgreSQLParser.MAPPING, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_user_mapping_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_user_mapping_statement" ):
                listener.enterAlter_user_mapping_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_user_mapping_statement" ):
                listener.exitAlter_user_mapping_statement(self)




    def alter_user_mapping_statement(self):

        localctx = postgreSQLParser.Alter_user_mapping_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 194, self.RULE_alter_user_mapping_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2947
            self.match(postgreSQLParser.USER)
            self.state = 2948
            self.match(postgreSQLParser.MAPPING)
            self.state = 2949
            self.match(postgreSQLParser.FOR)
            self.state = 2952
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.CURRENT_USER, postgreSQLParser.SESSION_USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 2950
                self.user_name()
                pass
            elif token in [postgreSQLParser.USER]:
                self.state = 2951
                self.match(postgreSQLParser.USER)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2954
            self.match(postgreSQLParser.SERVER)
            self.state = 2955
            self.identifier()
            self.state = 2957
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 2956
                self.define_foreign_options()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_user_or_role_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def alter_user_or_role_set_reset(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_user_or_role_set_resetContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def user_or_role_option_for_alter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.User_or_role_option_for_alterContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.User_or_role_option_for_alterContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_user_or_role_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_user_or_role_statement" ):
                listener.enterAlter_user_or_role_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_user_or_role_statement" ):
                listener.exitAlter_user_or_role_statement(self)




    def alter_user_or_role_statement(self):

        localctx = postgreSQLParser.Alter_user_or_role_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 196, self.RULE_alter_user_or_role_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2959
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.ROLE or _la==postgreSQLParser.USER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 2973
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,316,self._ctx)
            if la_ == 1:
                self.state = 2960
                self.alter_user_or_role_set_reset()
                pass

            elif la_ == 2:
                self.state = 2961
                self.identifier()
                self.state = 2962
                self.rename_to()
                pass

            elif la_ == 3:
                self.state = 2964
                self.user_name()
                self.state = 2966
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 2965
                    self.match(postgreSQLParser.WITH)


                self.state = 2969 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 2968
                    self.user_or_role_option_for_alter()
                    self.state = 2971 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.CONNECTION or _la==postgreSQLParser.ENCRYPTED or _la==postgreSQLParser.INHERIT or _la==postgreSQLParser.PASSWORD or _la==postgreSQLParser.VALID or ((((_la - 454)) & ~0x3f) == 0 and ((1 << (_la - 454)) & ((1 << (postgreSQLParser.BYPASSRLS - 454)) | (1 << (postgreSQLParser.CREATEDB - 454)) | (1 << (postgreSQLParser.CREATEROLE - 454)) | (1 << (postgreSQLParser.LOGIN - 454)) | (1 << (postgreSQLParser.NOBYPASSRLS - 454)) | (1 << (postgreSQLParser.NOCREATEDB - 454)) | (1 << (postgreSQLParser.NOCREATEROLE - 454)) | (1 << (postgreSQLParser.NOINHERIT - 454)) | (1 << (postgreSQLParser.NOLOGIN - 454)) | (1 << (postgreSQLParser.NOREPLICATION - 454)) | (1 << (postgreSQLParser.NOSUPERUSER - 454)))) != 0) or _la==postgreSQLParser.REPLICATION or _la==postgreSQLParser.SUPERUSER):
                        break

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_user_or_role_set_resetContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def set_reset_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_reset_parameterContext,0)


        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_user_or_role_set_reset

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_user_or_role_set_reset" ):
                listener.enterAlter_user_or_role_set_reset(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_user_or_role_set_reset" ):
                listener.exitAlter_user_or_role_set_reset(self)




    def alter_user_or_role_set_reset(self):

        localctx = postgreSQLParser.Alter_user_or_role_set_resetContext(self, self._ctx, self.state)
        self.enterRule(localctx, 198, self.RULE_alter_user_or_role_set_reset)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 2977
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.CURRENT_USER, postgreSQLParser.SESSION_USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 2975
                self.user_name()
                pass
            elif token in [postgreSQLParser.ALL]:
                self.state = 2976
                self.match(postgreSQLParser.ALL)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 2982
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.IN:
                self.state = 2979
                self.match(postgreSQLParser.IN)
                self.state = 2980
                self.match(postgreSQLParser.DATABASE)
                self.state = 2981
                self.identifier()


            self.state = 2984
            self.set_reset_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_reset_parameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def set_statement_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statement_valueContext,0)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_reset_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_reset_parameter" ):
                listener.enterSet_reset_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_reset_parameter" ):
                listener.exitSet_reset_parameter(self)




    def set_reset_parameter(self):

        localctx = postgreSQLParser.Set_reset_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 200, self.RULE_set_reset_parameter)
        self._la = 0 # Token type
        try:
            self.state = 3015
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,322,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 2986
                self.match(postgreSQLParser.SET)
                self.state = 2990
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,319,self._ctx)
                if la_ == 1:
                    self.state = 2987
                    self.identifier()
                    self.state = 2988
                    self.match(postgreSQLParser.DOT)


                self.state = 2992
                self.identifier()
                self.state = 2993
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TO or _la==postgreSQLParser.EQUAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 2994
                self.set_statement_value()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 2996
                self.match(postgreSQLParser.SET)
                self.state = 3000
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,320,self._ctx)
                if la_ == 1:
                    self.state = 2997
                    self.identifier()
                    self.state = 2998
                    self.match(postgreSQLParser.DOT)


                self.state = 3002
                self.identifier()
                self.state = 3003
                self.match(postgreSQLParser.FROM)
                self.state = 3004
                self.match(postgreSQLParser.CURRENT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3006
                self.match(postgreSQLParser.RESET)
                self.state = 3010
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,321,self._ctx)
                if la_ == 1:
                    self.state = 3007
                    self.identifier()
                    self.state = 3008
                    self.match(postgreSQLParser.DOT)


                self.state = 3012
                self.identifier()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3013
                self.match(postgreSQLParser.RESET)
                self.state = 3014
                self.match(postgreSQLParser.ALL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_group_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def alter_group_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_group_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_group_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_group_statement" ):
                listener.enterAlter_group_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_group_statement" ):
                listener.exitAlter_group_statement(self)




    def alter_group_statement(self):

        localctx = postgreSQLParser.Alter_group_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 202, self.RULE_alter_group_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3017
            self.match(postgreSQLParser.GROUP)
            self.state = 3018
            self.alter_group_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_group_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_group_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_group_action" ):
                listener.enterAlter_group_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_group_action" ):
                listener.exitAlter_group_action(self)




    def alter_group_action(self):

        localctx = postgreSQLParser.Alter_group_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 204, self.RULE_alter_group_action)
        self._la = 0 # Token type
        try:
            self.state = 3028
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,323,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3020
                localctx.name = self.identifier()
                self.state = 3021
                self.rename_to()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3023
                self.user_name()
                self.state = 3024
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ADD or _la==postgreSQLParser.DROP):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3025
                self.match(postgreSQLParser.USER)
                self.state = 3026
                self.identifier_list()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_tablespace_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def alter_tablespace_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_tablespace_actionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_tablespace_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_tablespace_statement" ):
                listener.enterAlter_tablespace_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_tablespace_statement" ):
                listener.exitAlter_tablespace_statement(self)




    def alter_tablespace_statement(self):

        localctx = postgreSQLParser.Alter_tablespace_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 206, self.RULE_alter_tablespace_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3030
            self.match(postgreSQLParser.TABLESPACE)
            self.state = 3031
            localctx.name = self.identifier()
            self.state = 3032
            self.alter_tablespace_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_owner_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def target_operator(self):
            return self.getTypedRuleContext(postgreSQLParser.Target_operatorContext,0)


        def LARGE(self):
            return self.getToken(postgreSQLParser.LARGE, 0)

        def OBJECT(self):
            return self.getToken(postgreSQLParser.OBJECT, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_owner_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_owner_statement" ):
                listener.enterAlter_owner_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_owner_statement" ):
                listener.exitAlter_owner_statement(self)




    def alter_owner_statement(self):

        localctx = postgreSQLParser.Alter_owner_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 208, self.RULE_alter_owner_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3063
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.OPERATOR]:
                self.state = 3034
                self.match(postgreSQLParser.OPERATOR)
                self.state = 3035
                self.target_operator()
                pass
            elif token in [postgreSQLParser.LARGE]:
                self.state = 3036
                self.match(postgreSQLParser.LARGE)
                self.state = 3037
                self.match(postgreSQLParser.OBJECT)
                self.state = 3038
                self.match(postgreSQLParser.NUMBER_LITERAL)
                pass
            elif token in [postgreSQLParser.AGGREGATE, postgreSQLParser.FUNCTION, postgreSQLParser.PROCEDURE]:
                self.state = 3039
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.AGGREGATE or _la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3040
                localctx.name = self.schema_qualified_name()
                self.state = 3041
                self.function_args()
                pass
            elif token in [postgreSQLParser.DOMAIN, postgreSQLParser.MATERIALIZED, postgreSQLParser.SCHEMA, postgreSQLParser.SEQUENCE, postgreSQLParser.TEXT, postgreSQLParser.TYPE, postgreSQLParser.VIEW]:
                self.state = 3057
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,325,self._ctx)
                if la_ == 1:
                    self.state = 3043
                    self.match(postgreSQLParser.TEXT)
                    self.state = 3044
                    self.match(postgreSQLParser.SEARCH)
                    self.state = 3045
                    self.match(postgreSQLParser.DICTIONARY)
                    pass

                elif la_ == 2:
                    self.state = 3046
                    self.match(postgreSQLParser.TEXT)
                    self.state = 3047
                    self.match(postgreSQLParser.SEARCH)
                    self.state = 3048
                    self.match(postgreSQLParser.CONFIGURATION)
                    pass

                elif la_ == 3:
                    self.state = 3049
                    self.match(postgreSQLParser.DOMAIN)
                    pass

                elif la_ == 4:
                    self.state = 3050
                    self.match(postgreSQLParser.SCHEMA)
                    pass

                elif la_ == 5:
                    self.state = 3051
                    self.match(postgreSQLParser.SEQUENCE)
                    pass

                elif la_ == 6:
                    self.state = 3052
                    self.match(postgreSQLParser.TYPE)
                    pass

                elif la_ == 7:
                    self.state = 3054
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.MATERIALIZED:
                        self.state = 3053
                        self.match(postgreSQLParser.MATERIALIZED)


                    self.state = 3056
                    self.match(postgreSQLParser.VIEW)
                    pass


                self.state = 3060
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,326,self._ctx)
                if la_ == 1:
                    self.state = 3059
                    self.if_exists()


                self.state = 3062
                localctx.name = self.schema_qualified_name()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 3065
            self.owner_to()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_tablespace_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def option_with_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Option_with_valueContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Option_with_valueContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_tablespace_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_tablespace_action" ):
                listener.enterAlter_tablespace_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_tablespace_action" ):
                listener.exitAlter_tablespace_action(self)




    def alter_tablespace_action(self):

        localctx = postgreSQLParser.Alter_tablespace_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 210, self.RULE_alter_tablespace_action)
        self._la = 0 # Token type
        try:
            self.state = 3086
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3067
                self.rename_to()
                pass
            elif token in [postgreSQLParser.OWNER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3068
                self.owner_to()
                pass
            elif token in [postgreSQLParser.SET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3069
                self.match(postgreSQLParser.SET)
                self.state = 3070
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3071
                self.option_with_value()
                self.state = 3076
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3072
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3073
                    self.option_with_value()
                    self.state = 3078
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3079
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.RESET]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3081
                self.match(postgreSQLParser.RESET)
                self.state = 3082
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3083
                self.identifier_list()
                self.state = 3084
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_statistics_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def STATISTICS(self):
            return self.getToken(postgreSQLParser.STATISTICS, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_statistics(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statisticsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_statistics_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_statistics_statement" ):
                listener.enterAlter_statistics_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_statistics_statement" ):
                listener.exitAlter_statistics_statement(self)




    def alter_statistics_statement(self):

        localctx = postgreSQLParser.Alter_statistics_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 212, self.RULE_alter_statistics_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3088
            self.match(postgreSQLParser.STATISTICS)
            self.state = 3089
            localctx.name = self.schema_qualified_name()
            self.state = 3094
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,330,self._ctx)
            if la_ == 1:
                self.state = 3090
                self.rename_to()
                pass

            elif la_ == 2:
                self.state = 3091
                self.set_schema()
                pass

            elif la_ == 3:
                self.state = 3092
                self.owner_to()
                pass

            elif la_ == 4:
                self.state = 3093
                self.set_statistics()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_statisticsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def STATISTICS(self):
            return self.getToken(postgreSQLParser.STATISTICS, 0)

        def signed_number_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Signed_number_literalContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_statistics

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_statistics" ):
                listener.enterSet_statistics(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_statistics" ):
                listener.exitSet_statistics(self)




    def set_statistics(self):

        localctx = postgreSQLParser.Set_statisticsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 214, self.RULE_set_statistics)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3096
            self.match(postgreSQLParser.SET)
            self.state = 3097
            self.match(postgreSQLParser.STATISTICS)
            self.state = 3098
            self.signed_number_literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_foreign_data_wrapperContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def alter_foreign_data_wrapper_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_foreign_data_wrapper_actionContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_foreign_data_wrapper

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_foreign_data_wrapper" ):
                listener.enterAlter_foreign_data_wrapper(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_foreign_data_wrapper" ):
                listener.exitAlter_foreign_data_wrapper(self)




    def alter_foreign_data_wrapper(self):

        localctx = postgreSQLParser.Alter_foreign_data_wrapperContext(self, self._ctx, self.state)
        self.enterRule(localctx, 216, self.RULE_alter_foreign_data_wrapper)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3100
            self.match(postgreSQLParser.FOREIGN)
            self.state = 3101
            self.match(postgreSQLParser.DATA)
            self.state = 3102
            self.match(postgreSQLParser.WRAPPER)
            self.state = 3103
            localctx.name = self.identifier()
            self.state = 3104
            self.alter_foreign_data_wrapper_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_foreign_data_wrapper_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HANDLER(self):
            return self.getToken(postgreSQLParser.HANDLER, 0)

        def schema_qualified_name_nontype(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_name_nontypeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_name_nontypeContext,i)


        def NO(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NO)
            else:
                return self.getToken(postgreSQLParser.NO, i)

        def VALIDATOR(self):
            return self.getToken(postgreSQLParser.VALIDATOR, 0)

        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_foreign_data_wrapper_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_foreign_data_wrapper_action" ):
                listener.enterAlter_foreign_data_wrapper_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_foreign_data_wrapper_action" ):
                listener.exitAlter_foreign_data_wrapper_action(self)




    def alter_foreign_data_wrapper_action(self):

        localctx = postgreSQLParser.Alter_foreign_data_wrapper_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 218, self.RULE_alter_foreign_data_wrapper_action)
        self._la = 0 # Token type
        try:
            self.state = 3123
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.EOF, postgreSQLParser.HANDLER, postgreSQLParser.NO, postgreSQLParser.OPTIONS, postgreSQLParser.VALIDATOR, postgreSQLParser.SEMI_COLON]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3110
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,331,self._ctx)
                if la_ == 1:
                    self.state = 3106
                    self.match(postgreSQLParser.HANDLER)
                    self.state = 3107
                    self.schema_qualified_name_nontype()

                elif la_ == 2:
                    self.state = 3108
                    self.match(postgreSQLParser.NO)
                    self.state = 3109
                    self.match(postgreSQLParser.HANDLER)


                self.state = 3116
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.VALIDATOR]:
                    self.state = 3112
                    self.match(postgreSQLParser.VALIDATOR)
                    self.state = 3113
                    self.schema_qualified_name_nontype()
                    pass
                elif token in [postgreSQLParser.NO]:
                    self.state = 3114
                    self.match(postgreSQLParser.NO)
                    self.state = 3115
                    self.match(postgreSQLParser.VALIDATOR)
                    pass
                elif token in [postgreSQLParser.EOF, postgreSQLParser.OPTIONS, postgreSQLParser.SEMI_COLON]:
                    pass
                else:
                    pass
                self.state = 3119
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OPTIONS:
                    self.state = 3118
                    self.define_foreign_options()


                pass
            elif token in [postgreSQLParser.OWNER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3121
                self.owner_to()
                pass
            elif token in [postgreSQLParser.RENAME]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3122
                self.rename_to()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_operator_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def target_operator(self):
            return self.getTypedRuleContext(postgreSQLParser.Target_operatorContext,0)


        def alter_operator_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_operator_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_operator_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_operator_statement" ):
                listener.enterAlter_operator_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_operator_statement" ):
                listener.exitAlter_operator_statement(self)




    def alter_operator_statement(self):

        localctx = postgreSQLParser.Alter_operator_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 220, self.RULE_alter_operator_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3125
            self.match(postgreSQLParser.OPERATOR)
            self.state = 3126
            self.target_operator()
            self.state = 3127
            self.alter_operator_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_operator_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def operator_set_restrict_join(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Operator_set_restrict_joinContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Operator_set_restrict_joinContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_operator_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_operator_action" ):
                listener.enterAlter_operator_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_operator_action" ):
                listener.exitAlter_operator_action(self)




    def alter_operator_action(self):

        localctx = postgreSQLParser.Alter_operator_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 222, self.RULE_alter_operator_action)
        self._la = 0 # Token type
        try:
            self.state = 3142
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,336,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3129
                self.set_schema()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3130
                self.match(postgreSQLParser.SET)
                self.state = 3131
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3132
                self.operator_set_restrict_join()
                self.state = 3137
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3133
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3134
                    self.operator_set_restrict_join()
                    self.state = 3139
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3140
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Operator_set_restrict_joinContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def RESTRICT(self):
            return self.getToken(postgreSQLParser.RESTRICT, 0)

        def JOIN(self):
            return self.getToken(postgreSQLParser.JOIN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_operator_set_restrict_join

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator_set_restrict_join" ):
                listener.enterOperator_set_restrict_join(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator_set_restrict_join" ):
                listener.exitOperator_set_restrict_join(self)




    def operator_set_restrict_join(self):

        localctx = postgreSQLParser.Operator_set_restrict_joinContext(self, self._ctx, self.state)
        self.enterRule(localctx, 224, self.RULE_operator_set_restrict_join)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3144
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.RESTRICT or _la==postgreSQLParser.JOIN):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3145
            self.match(postgreSQLParser.EQUAL)
            self.state = 3146
            self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_user_mapping_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USER(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.USER)
            else:
                return self.getToken(postgreSQLParser.USER, i)

        def MAPPING(self):
            return self.getToken(postgreSQLParser.MAPPING, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_user_mapping_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_user_mapping_statement" ):
                listener.enterDrop_user_mapping_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_user_mapping_statement" ):
                listener.exitDrop_user_mapping_statement(self)




    def drop_user_mapping_statement(self):

        localctx = postgreSQLParser.Drop_user_mapping_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 226, self.RULE_drop_user_mapping_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3148
            self.match(postgreSQLParser.USER)
            self.state = 3149
            self.match(postgreSQLParser.MAPPING)
            self.state = 3151
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.IF:
                self.state = 3150
                self.if_exists()


            self.state = 3153
            self.match(postgreSQLParser.FOR)
            self.state = 3156
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.CURRENT_USER, postgreSQLParser.SESSION_USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 3154
                self.user_name()
                pass
            elif token in [postgreSQLParser.USER]:
                self.state = 3155
                self.match(postgreSQLParser.USER)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 3158
            self.match(postgreSQLParser.SERVER)
            self.state = 3159
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_owned_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWNED(self):
            return self.getToken(postgreSQLParser.OWNED, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def user_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.User_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.User_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_owned_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_owned_statement" ):
                listener.enterDrop_owned_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_owned_statement" ):
                listener.exitDrop_owned_statement(self)




    def drop_owned_statement(self):

        localctx = postgreSQLParser.Drop_owned_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 228, self.RULE_drop_owned_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3161
            self.match(postgreSQLParser.OWNED)
            self.state = 3162
            self.match(postgreSQLParser.BY)
            self.state = 3163
            self.user_name()
            self.state = 3168
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3164
                self.match(postgreSQLParser.COMMA)
                self.state = 3165
                self.user_name()
                self.state = 3170
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3172
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 3171
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_operator_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def target_operator(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Target_operatorContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Target_operatorContext,i)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_operator_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_operator_statement" ):
                listener.enterDrop_operator_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_operator_statement" ):
                listener.exitDrop_operator_statement(self)




    def drop_operator_statement(self):

        localctx = postgreSQLParser.Drop_operator_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 230, self.RULE_drop_operator_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3174
            self.match(postgreSQLParser.OPERATOR)
            self.state = 3176
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,341,self._ctx)
            if la_ == 1:
                self.state = 3175
                self.if_exists()


            self.state = 3178
            self.target_operator()
            self.state = 3183
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3179
                self.match(postgreSQLParser.COMMA)
                self.state = 3180
                self.target_operator()
                self.state = 3185
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3187
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 3186
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Target_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Operator_nameContext
            self.left_type = None # Data_typeContext
            self.right_type = None # Data_typeContext

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def operator_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Operator_nameContext,0)


        def NONE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NONE)
            else:
                return self.getToken(postgreSQLParser.NONE, i)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_target_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTarget_operator" ):
                listener.enterTarget_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTarget_operator" ):
                listener.exitTarget_operator(self)




    def target_operator(self):

        localctx = postgreSQLParser.Target_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 232, self.RULE_target_operator)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3189
            localctx.name = self.operator_name()
            self.state = 3190
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 3193
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,344,self._ctx)
            if la_ == 1:
                self.state = 3191
                localctx.left_type = self.data_type()
                pass

            elif la_ == 2:
                self.state = 3192
                self.match(postgreSQLParser.NONE)
                pass


            self.state = 3195
            self.match(postgreSQLParser.COMMA)
            self.state = 3198
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,345,self._ctx)
            if la_ == 1:
                self.state = 3196
                localctx.right_type = self.data_type()
                pass

            elif la_ == 2:
                self.state = 3197
                self.match(postgreSQLParser.NONE)
                pass


            self.state = 3200
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Domain_constraintContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def CHECK(self):
            return self.getToken(postgreSQLParser.CHECK, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_domain_constraint

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDomain_constraint" ):
                listener.enterDomain_constraint(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDomain_constraint" ):
                listener.exitDomain_constraint(self)




    def domain_constraint(self):

        localctx = postgreSQLParser.Domain_constraintContext(self, self._ctx, self.state)
        self.enterRule(localctx, 234, self.RULE_domain_constraint)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONSTRAINT:
                self.state = 3202
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 3203
                localctx.name = self.identifier()


            self.state = 3215
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CHECK]:
                self.state = 3206
                self.match(postgreSQLParser.CHECK)
                self.state = 3207
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3208
                self.vex(0)
                self.state = 3209
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.NOT, postgreSQLParser.NULL]:
                self.state = 3212
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 3211
                    self.match(postgreSQLParser.NOT)


                self.state = 3214
                self.match(postgreSQLParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_transform_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRANSFORM(self):
            return self.getToken(postgreSQLParser.TRANSFORM, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def SQL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SQL)
            else:
                return self.getToken(postgreSQLParser.SQL, i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WITH)
            else:
                return self.getToken(postgreSQLParser.WITH, i)

        def FUNCTION(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.FUNCTION)
            else:
                return self.getToken(postgreSQLParser.FUNCTION, i)

        def function_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_parametersContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_parametersContext,i)


        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_transform_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_transform_statement" ):
                listener.enterCreate_transform_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_transform_statement" ):
                listener.exitCreate_transform_statement(self)




    def create_transform_statement(self):

        localctx = postgreSQLParser.Create_transform_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 236, self.RULE_create_transform_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3219
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OR:
                self.state = 3217
                self.match(postgreSQLParser.OR)
                self.state = 3218
                self.match(postgreSQLParser.REPLACE)


            self.state = 3221
            self.match(postgreSQLParser.TRANSFORM)
            self.state = 3222
            self.match(postgreSQLParser.FOR)
            self.state = 3223
            self.data_type()
            self.state = 3224
            self.match(postgreSQLParser.LANGUAGE)
            self.state = 3225
            self.identifier()
            self.state = 3226
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 3227
            self.match(postgreSQLParser.FROM)
            self.state = 3228
            self.match(postgreSQLParser.SQL)
            self.state = 3229
            self.match(postgreSQLParser.WITH)
            self.state = 3230
            self.match(postgreSQLParser.FUNCTION)
            self.state = 3231
            self.function_parameters()
            self.state = 3232
            self.match(postgreSQLParser.COMMA)
            self.state = 3233
            self.match(postgreSQLParser.TO)
            self.state = 3234
            self.match(postgreSQLParser.SQL)
            self.state = 3235
            self.match(postgreSQLParser.WITH)
            self.state = 3236
            self.match(postgreSQLParser.FUNCTION)
            self.state = 3237
            self.function_parameters()
            self.state = 3238
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_access_method_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ACCESS(self):
            return self.getToken(postgreSQLParser.ACCESS, 0)

        def METHOD(self):
            return self.getToken(postgreSQLParser.METHOD, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def HANDLER(self):
            return self.getToken(postgreSQLParser.HANDLER, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_access_method_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_access_method_statement" ):
                listener.enterCreate_access_method_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_access_method_statement" ):
                listener.exitCreate_access_method_statement(self)




    def create_access_method_statement(self):

        localctx = postgreSQLParser.Create_access_method_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 238, self.RULE_create_access_method_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3240
            self.match(postgreSQLParser.ACCESS)
            self.state = 3241
            self.match(postgreSQLParser.METHOD)
            self.state = 3242
            self.identifier()
            self.state = 3243
            self.match(postgreSQLParser.TYPE)
            self.state = 3244
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.INDEX or _la==postgreSQLParser.TABLE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3245
            self.match(postgreSQLParser.HANDLER)
            self.state = 3246
            self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_user_or_role_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def user_or_role_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.User_or_role_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.User_or_role_optionContext,i)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_user_or_role_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_user_or_role_statement" ):
                listener.enterCreate_user_or_role_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_user_or_role_statement" ):
                listener.exitCreate_user_or_role_statement(self)




    def create_user_or_role_statement(self):

        localctx = postgreSQLParser.Create_user_or_role_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 240, self.RULE_create_user_or_role_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3248
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.ROLE or _la==postgreSQLParser.USER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3249
            localctx.name = self.identifier()
            self.state = 3260
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ADMIN or _la==postgreSQLParser.CONNECTION or _la==postgreSQLParser.ENCRYPTED or _la==postgreSQLParser.INHERIT or _la==postgreSQLParser.PASSWORD or _la==postgreSQLParser.ROLE or _la==postgreSQLParser.SYSID or _la==postgreSQLParser.VALID or ((((_la - 412)) & ~0x3f) == 0 and ((1 << (_la - 412)) & ((1 << (postgreSQLParser.IN - 412)) | (1 << (postgreSQLParser.USER - 412)) | (1 << (postgreSQLParser.WITH - 412)) | (1 << (postgreSQLParser.BYPASSRLS - 412)) | (1 << (postgreSQLParser.CREATEDB - 412)) | (1 << (postgreSQLParser.CREATEROLE - 412)))) != 0) or ((((_la - 494)) & ~0x3f) == 0 and ((1 << (_la - 494)) & ((1 << (postgreSQLParser.LOGIN - 494)) | (1 << (postgreSQLParser.NOBYPASSRLS - 494)) | (1 << (postgreSQLParser.NOCREATEDB - 494)) | (1 << (postgreSQLParser.NOCREATEROLE - 494)) | (1 << (postgreSQLParser.NOINHERIT - 494)) | (1 << (postgreSQLParser.NOLOGIN - 494)) | (1 << (postgreSQLParser.NOREPLICATION - 494)) | (1 << (postgreSQLParser.NOSUPERUSER - 494)) | (1 << (postgreSQLParser.REPLICATION - 494)) | (1 << (postgreSQLParser.SUPERUSER - 494)))) != 0):
                self.state = 3251
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 3250
                    self.match(postgreSQLParser.WITH)


                self.state = 3253
                self.user_or_role_option()
                self.state = 3257
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.ADMIN or _la==postgreSQLParser.CONNECTION or _la==postgreSQLParser.ENCRYPTED or _la==postgreSQLParser.INHERIT or _la==postgreSQLParser.PASSWORD or _la==postgreSQLParser.ROLE or _la==postgreSQLParser.SYSID or _la==postgreSQLParser.VALID or ((((_la - 412)) & ~0x3f) == 0 and ((1 << (_la - 412)) & ((1 << (postgreSQLParser.IN - 412)) | (1 << (postgreSQLParser.USER - 412)) | (1 << (postgreSQLParser.BYPASSRLS - 412)) | (1 << (postgreSQLParser.CREATEDB - 412)) | (1 << (postgreSQLParser.CREATEROLE - 412)))) != 0) or ((((_la - 494)) & ~0x3f) == 0 and ((1 << (_la - 494)) & ((1 << (postgreSQLParser.LOGIN - 494)) | (1 << (postgreSQLParser.NOBYPASSRLS - 494)) | (1 << (postgreSQLParser.NOCREATEDB - 494)) | (1 << (postgreSQLParser.NOCREATEROLE - 494)) | (1 << (postgreSQLParser.NOINHERIT - 494)) | (1 << (postgreSQLParser.NOLOGIN - 494)) | (1 << (postgreSQLParser.NOREPLICATION - 494)) | (1 << (postgreSQLParser.NOSUPERUSER - 494)) | (1 << (postgreSQLParser.REPLICATION - 494)) | (1 << (postgreSQLParser.SUPERUSER - 494)))) != 0):
                    self.state = 3254
                    self.user_or_role_option()
                    self.state = 3259
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User_or_role_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user_or_role_or_group_common_option(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_or_group_common_optionContext,0)


        def user_or_role_common_option(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_common_optionContext,0)


        def user_or_role_or_group_option_for_create(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_or_group_option_for_createContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_user_or_role_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser_or_role_option" ):
                listener.enterUser_or_role_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser_or_role_option" ):
                listener.exitUser_or_role_option(self)




    def user_or_role_option(self):

        localctx = postgreSQLParser.User_or_role_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 242, self.RULE_user_or_role_option)
        try:
            self.state = 3265
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ENCRYPTED, postgreSQLParser.INHERIT, postgreSQLParser.PASSWORD, postgreSQLParser.VALID, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.LOGIN, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOSUPERUSER, postgreSQLParser.SUPERUSER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3262
                self.user_or_role_or_group_common_option()
                pass
            elif token in [postgreSQLParser.CONNECTION, postgreSQLParser.BYPASSRLS, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOREPLICATION, postgreSQLParser.REPLICATION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3263
                self.user_or_role_common_option()
                pass
            elif token in [postgreSQLParser.ADMIN, postgreSQLParser.ROLE, postgreSQLParser.SYSID, postgreSQLParser.IN, postgreSQLParser.USER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3264
                self.user_or_role_or_group_option_for_create()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User_or_role_option_for_alterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user_or_role_or_group_common_option(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_or_group_common_optionContext,0)


        def user_or_role_common_option(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_common_optionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_user_or_role_option_for_alter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser_or_role_option_for_alter" ):
                listener.enterUser_or_role_option_for_alter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser_or_role_option_for_alter" ):
                listener.exitUser_or_role_option_for_alter(self)




    def user_or_role_option_for_alter(self):

        localctx = postgreSQLParser.User_or_role_option_for_alterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 244, self.RULE_user_or_role_option_for_alter)
        try:
            self.state = 3269
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ENCRYPTED, postgreSQLParser.INHERIT, postgreSQLParser.PASSWORD, postgreSQLParser.VALID, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.LOGIN, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOSUPERUSER, postgreSQLParser.SUPERUSER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3267
                self.user_or_role_or_group_common_option()
                pass
            elif token in [postgreSQLParser.CONNECTION, postgreSQLParser.BYPASSRLS, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOREPLICATION, postgreSQLParser.REPLICATION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3268
                self.user_or_role_common_option()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User_or_role_or_group_common_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.password = None # Token
            self.date_time = None # Token

        def SUPERUSER(self):
            return self.getToken(postgreSQLParser.SUPERUSER, 0)

        def NOSUPERUSER(self):
            return self.getToken(postgreSQLParser.NOSUPERUSER, 0)

        def CREATEDB(self):
            return self.getToken(postgreSQLParser.CREATEDB, 0)

        def NOCREATEDB(self):
            return self.getToken(postgreSQLParser.NOCREATEDB, 0)

        def CREATEROLE(self):
            return self.getToken(postgreSQLParser.CREATEROLE, 0)

        def NOCREATEROLE(self):
            return self.getToken(postgreSQLParser.NOCREATEROLE, 0)

        def INHERIT(self):
            return self.getToken(postgreSQLParser.INHERIT, 0)

        def NOINHERIT(self):
            return self.getToken(postgreSQLParser.NOINHERIT, 0)

        def LOGIN(self):
            return self.getToken(postgreSQLParser.LOGIN, 0)

        def NOLOGIN(self):
            return self.getToken(postgreSQLParser.NOLOGIN, 0)

        def PASSWORD(self):
            return self.getToken(postgreSQLParser.PASSWORD, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def ENCRYPTED(self):
            return self.getToken(postgreSQLParser.ENCRYPTED, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def VALID(self):
            return self.getToken(postgreSQLParser.VALID, 0)

        def UNTIL(self):
            return self.getToken(postgreSQLParser.UNTIL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_user_or_role_or_group_common_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser_or_role_or_group_common_option" ):
                listener.enterUser_or_role_or_group_common_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser_or_role_or_group_common_option" ):
                listener.exitUser_or_role_or_group_common_option(self)




    def user_or_role_or_group_common_option(self):

        localctx = postgreSQLParser.User_or_role_or_group_common_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 246, self.RULE_user_or_role_or_group_common_option)
        self._la = 0 # Token type
        try:
            self.state = 3292
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.SUPERUSER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3271
                self.match(postgreSQLParser.SUPERUSER)
                pass
            elif token in [postgreSQLParser.NOSUPERUSER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3272
                self.match(postgreSQLParser.NOSUPERUSER)
                pass
            elif token in [postgreSQLParser.CREATEDB]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3273
                self.match(postgreSQLParser.CREATEDB)
                pass
            elif token in [postgreSQLParser.NOCREATEDB]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3274
                self.match(postgreSQLParser.NOCREATEDB)
                pass
            elif token in [postgreSQLParser.CREATEROLE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3275
                self.match(postgreSQLParser.CREATEROLE)
                pass
            elif token in [postgreSQLParser.NOCREATEROLE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3276
                self.match(postgreSQLParser.NOCREATEROLE)
                pass
            elif token in [postgreSQLParser.INHERIT]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3277
                self.match(postgreSQLParser.INHERIT)
                pass
            elif token in [postgreSQLParser.NOINHERIT]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3278
                self.match(postgreSQLParser.NOINHERIT)
                pass
            elif token in [postgreSQLParser.LOGIN]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3279
                self.match(postgreSQLParser.LOGIN)
                pass
            elif token in [postgreSQLParser.NOLOGIN]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3280
                self.match(postgreSQLParser.NOLOGIN)
                pass
            elif token in [postgreSQLParser.ENCRYPTED, postgreSQLParser.PASSWORD]:
                self.enterOuterAlt(localctx, 11)
                self.state = 3282
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ENCRYPTED:
                    self.state = 3281
                    self.match(postgreSQLParser.ENCRYPTED)


                self.state = 3284
                self.match(postgreSQLParser.PASSWORD)
                self.state = 3287
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.Character_String_Literal]:
                    self.state = 3285
                    localctx.password = self.match(postgreSQLParser.Character_String_Literal)
                    pass
                elif token in [postgreSQLParser.NULL]:
                    self.state = 3286
                    self.match(postgreSQLParser.NULL)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.VALID]:
                self.enterOuterAlt(localctx, 12)
                self.state = 3289
                self.match(postgreSQLParser.VALID)
                self.state = 3290
                self.match(postgreSQLParser.UNTIL)
                self.state = 3291
                localctx.date_time = self.match(postgreSQLParser.Character_String_Literal)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User_or_role_common_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def REPLICATION(self):
            return self.getToken(postgreSQLParser.REPLICATION, 0)

        def NOREPLICATION(self):
            return self.getToken(postgreSQLParser.NOREPLICATION, 0)

        def BYPASSRLS(self):
            return self.getToken(postgreSQLParser.BYPASSRLS, 0)

        def NOBYPASSRLS(self):
            return self.getToken(postgreSQLParser.NOBYPASSRLS, 0)

        def CONNECTION(self):
            return self.getToken(postgreSQLParser.CONNECTION, 0)

        def LIMIT(self):
            return self.getToken(postgreSQLParser.LIMIT, 0)

        def signed_number_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Signed_number_literalContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_user_or_role_common_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser_or_role_common_option" ):
                listener.enterUser_or_role_common_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser_or_role_common_option" ):
                listener.exitUser_or_role_common_option(self)




    def user_or_role_common_option(self):

        localctx = postgreSQLParser.User_or_role_common_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 248, self.RULE_user_or_role_common_option)
        try:
            self.state = 3301
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.REPLICATION]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3294
                self.match(postgreSQLParser.REPLICATION)
                pass
            elif token in [postgreSQLParser.NOREPLICATION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3295
                self.match(postgreSQLParser.NOREPLICATION)
                pass
            elif token in [postgreSQLParser.BYPASSRLS]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3296
                self.match(postgreSQLParser.BYPASSRLS)
                pass
            elif token in [postgreSQLParser.NOBYPASSRLS]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3297
                self.match(postgreSQLParser.NOBYPASSRLS)
                pass
            elif token in [postgreSQLParser.CONNECTION]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3298
                self.match(postgreSQLParser.CONNECTION)
                self.state = 3299
                self.match(postgreSQLParser.LIMIT)
                self.state = 3300
                self.signed_number_literal()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class User_or_role_or_group_option_for_createContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SYSID(self):
            return self.getToken(postgreSQLParser.SYSID, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def ADMIN(self):
            return self.getToken(postgreSQLParser.ADMIN, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_user_or_role_or_group_option_for_create

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUser_or_role_or_group_option_for_create" ):
                listener.enterUser_or_role_or_group_option_for_create(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUser_or_role_or_group_option_for_create" ):
                listener.exitUser_or_role_or_group_option_for_create(self)




    def user_or_role_or_group_option_for_create(self):

        localctx = postgreSQLParser.User_or_role_or_group_option_for_createContext(self, self._ctx, self.state)
        self.enterRule(localctx, 250, self.RULE_user_or_role_or_group_option_for_create)
        try:
            self.state = 3315
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.SYSID]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3303
                self.match(postgreSQLParser.SYSID)
                self.state = 3304
                self.vex(0)
                pass
            elif token in [postgreSQLParser.ADMIN, postgreSQLParser.ROLE, postgreSQLParser.IN, postgreSQLParser.USER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3312
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,359,self._ctx)
                if la_ == 1:
                    self.state = 3305
                    self.match(postgreSQLParser.IN)
                    self.state = 3306
                    self.match(postgreSQLParser.ROLE)
                    pass

                elif la_ == 2:
                    self.state = 3307
                    self.match(postgreSQLParser.IN)
                    self.state = 3308
                    self.match(postgreSQLParser.GROUP)
                    pass

                elif la_ == 3:
                    self.state = 3309
                    self.match(postgreSQLParser.ROLE)
                    pass

                elif la_ == 4:
                    self.state = 3310
                    self.match(postgreSQLParser.ADMIN)
                    pass

                elif la_ == 5:
                    self.state = 3311
                    self.match(postgreSQLParser.USER)
                    pass


                self.state = 3314
                self.identifier_list()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_group_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def group_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Group_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Group_optionContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_group_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_group_statement" ):
                listener.enterCreate_group_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_group_statement" ):
                listener.exitCreate_group_statement(self)




    def create_group_statement(self):

        localctx = postgreSQLParser.Create_group_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 252, self.RULE_create_group_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3317
            self.match(postgreSQLParser.GROUP)
            self.state = 3318
            localctx.name = self.identifier()
            self.state = 3327
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ADMIN or _la==postgreSQLParser.ENCRYPTED or _la==postgreSQLParser.INHERIT or _la==postgreSQLParser.PASSWORD or _la==postgreSQLParser.ROLE or _la==postgreSQLParser.SYSID or _la==postgreSQLParser.VALID or ((((_la - 412)) & ~0x3f) == 0 and ((1 << (_la - 412)) & ((1 << (postgreSQLParser.IN - 412)) | (1 << (postgreSQLParser.USER - 412)) | (1 << (postgreSQLParser.WITH - 412)) | (1 << (postgreSQLParser.CREATEDB - 412)) | (1 << (postgreSQLParser.CREATEROLE - 412)))) != 0) or ((((_la - 494)) & ~0x3f) == 0 and ((1 << (_la - 494)) & ((1 << (postgreSQLParser.LOGIN - 494)) | (1 << (postgreSQLParser.NOCREATEDB - 494)) | (1 << (postgreSQLParser.NOCREATEROLE - 494)) | (1 << (postgreSQLParser.NOINHERIT - 494)) | (1 << (postgreSQLParser.NOLOGIN - 494)) | (1 << (postgreSQLParser.NOSUPERUSER - 494)) | (1 << (postgreSQLParser.SUPERUSER - 494)))) != 0):
                self.state = 3320
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 3319
                    self.match(postgreSQLParser.WITH)


                self.state = 3323 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 3322
                    self.group_option()
                    self.state = 3325 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.ADMIN or _la==postgreSQLParser.ENCRYPTED or _la==postgreSQLParser.INHERIT or _la==postgreSQLParser.PASSWORD or _la==postgreSQLParser.ROLE or _la==postgreSQLParser.SYSID or _la==postgreSQLParser.VALID or ((((_la - 412)) & ~0x3f) == 0 and ((1 << (_la - 412)) & ((1 << (postgreSQLParser.IN - 412)) | (1 << (postgreSQLParser.USER - 412)) | (1 << (postgreSQLParser.CREATEDB - 412)) | (1 << (postgreSQLParser.CREATEROLE - 412)))) != 0) or ((((_la - 494)) & ~0x3f) == 0 and ((1 << (_la - 494)) & ((1 << (postgreSQLParser.LOGIN - 494)) | (1 << (postgreSQLParser.NOCREATEDB - 494)) | (1 << (postgreSQLParser.NOCREATEROLE - 494)) | (1 << (postgreSQLParser.NOINHERIT - 494)) | (1 << (postgreSQLParser.NOLOGIN - 494)) | (1 << (postgreSQLParser.NOSUPERUSER - 494)) | (1 << (postgreSQLParser.SUPERUSER - 494)))) != 0)):
                        break



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Group_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user_or_role_or_group_common_option(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_or_group_common_optionContext,0)


        def user_or_role_or_group_option_for_create(self):
            return self.getTypedRuleContext(postgreSQLParser.User_or_role_or_group_option_for_createContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_group_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroup_option" ):
                listener.enterGroup_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroup_option" ):
                listener.exitGroup_option(self)




    def group_option(self):

        localctx = postgreSQLParser.Group_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 254, self.RULE_group_option)
        try:
            self.state = 3331
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ENCRYPTED, postgreSQLParser.INHERIT, postgreSQLParser.PASSWORD, postgreSQLParser.VALID, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.LOGIN, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOSUPERUSER, postgreSQLParser.SUPERUSER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3329
                self.user_or_role_or_group_common_option()
                pass
            elif token in [postgreSQLParser.ADMIN, postgreSQLParser.ROLE, postgreSQLParser.SYSID, postgreSQLParser.IN, postgreSQLParser.USER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3330
                self.user_or_role_or_group_option_for_create()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_tablespace_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.directory = None # Token

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def LOCATION(self):
            return self.getToken(postgreSQLParser.LOCATION, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def OWNER(self):
            return self.getToken(postgreSQLParser.OWNER, 0)

        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def option_with_value(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Option_with_valueContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Option_with_valueContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_tablespace_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_tablespace_statement" ):
                listener.enterCreate_tablespace_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_tablespace_statement" ):
                listener.exitCreate_tablespace_statement(self)




    def create_tablespace_statement(self):

        localctx = postgreSQLParser.Create_tablespace_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 256, self.RULE_create_tablespace_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3333
            self.match(postgreSQLParser.TABLESPACE)
            self.state = 3334
            localctx.name = self.identifier()
            self.state = 3337
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OWNER:
                self.state = 3335
                self.match(postgreSQLParser.OWNER)
                self.state = 3336
                self.user_name()


            self.state = 3339
            self.match(postgreSQLParser.LOCATION)
            self.state = 3340
            localctx.directory = self.match(postgreSQLParser.Character_String_Literal)
            self.state = 3353
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 3341
                self.match(postgreSQLParser.WITH)
                self.state = 3342
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3343
                self.option_with_value()
                self.state = 3348
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3344
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3345
                    self.option_with_value()
                    self.state = 3350
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3351
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_statistics_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def STATISTICS(self):
            return self.getToken(postgreSQLParser.STATISTICS, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def identifier_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Identifier_listContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,i)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_statistics_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_statistics_statement" ):
                listener.enterCreate_statistics_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_statistics_statement" ):
                listener.exitCreate_statistics_statement(self)




    def create_statistics_statement(self):

        localctx = postgreSQLParser.Create_statistics_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 258, self.RULE_create_statistics_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3355
            self.match(postgreSQLParser.STATISTICS)
            self.state = 3357
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,368,self._ctx)
            if la_ == 1:
                self.state = 3356
                self.if_not_exists()


            self.state = 3359
            localctx.name = self.schema_qualified_name()
            self.state = 3364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 3360
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3361
                self.identifier_list()
                self.state = 3362
                self.match(postgreSQLParser.RIGHT_PAREN)


            self.state = 3366
            self.match(postgreSQLParser.ON)
            self.state = 3367
            self.identifier()
            self.state = 3368
            self.match(postgreSQLParser.COMMA)
            self.state = 3369
            self.identifier_list()
            self.state = 3370
            self.match(postgreSQLParser.FROM)
            self.state = 3371
            self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_foreign_data_wrapper_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def HANDLER(self):
            return self.getToken(postgreSQLParser.HANDLER, 0)

        def schema_qualified_name_nontype(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_name_nontypeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_name_nontypeContext,i)


        def NO(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NO)
            else:
                return self.getToken(postgreSQLParser.NO, i)

        def VALIDATOR(self):
            return self.getToken(postgreSQLParser.VALIDATOR, 0)

        def OPTIONS(self):
            return self.getToken(postgreSQLParser.OPTIONS, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def option_without_equal(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Option_without_equalContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Option_without_equalContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_foreign_data_wrapper_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_foreign_data_wrapper_statement" ):
                listener.enterCreate_foreign_data_wrapper_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_foreign_data_wrapper_statement" ):
                listener.exitCreate_foreign_data_wrapper_statement(self)




    def create_foreign_data_wrapper_statement(self):

        localctx = postgreSQLParser.Create_foreign_data_wrapper_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 260, self.RULE_create_foreign_data_wrapper_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3373
            self.match(postgreSQLParser.FOREIGN)
            self.state = 3374
            self.match(postgreSQLParser.DATA)
            self.state = 3375
            self.match(postgreSQLParser.WRAPPER)
            self.state = 3376
            localctx.name = self.identifier()
            self.state = 3381
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,370,self._ctx)
            if la_ == 1:
                self.state = 3377
                self.match(postgreSQLParser.HANDLER)
                self.state = 3378
                self.schema_qualified_name_nontype()

            elif la_ == 2:
                self.state = 3379
                self.match(postgreSQLParser.NO)
                self.state = 3380
                self.match(postgreSQLParser.HANDLER)


            self.state = 3387
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.VALIDATOR]:
                self.state = 3383
                self.match(postgreSQLParser.VALIDATOR)
                self.state = 3384
                self.schema_qualified_name_nontype()
                pass
            elif token in [postgreSQLParser.NO]:
                self.state = 3385
                self.match(postgreSQLParser.NO)
                self.state = 3386
                self.match(postgreSQLParser.VALIDATOR)
                pass
            elif token in [postgreSQLParser.EOF, postgreSQLParser.OPTIONS, postgreSQLParser.SEMI_COLON]:
                pass
            else:
                pass
            self.state = 3401
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 3389
                self.match(postgreSQLParser.OPTIONS)
                self.state = 3390
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3391
                self.option_without_equal()
                self.state = 3396
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3392
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3393
                    self.option_without_equal()
                    self.state = 3398
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 3399
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Option_without_equalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_option_without_equal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOption_without_equal" ):
                listener.enterOption_without_equal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOption_without_equal" ):
                listener.exitOption_without_equal(self)




    def option_without_equal(self):

        localctx = postgreSQLParser.Option_without_equalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 262, self.RULE_option_without_equal)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3403
            self.identifier()
            self.state = 3404
            self.match(postgreSQLParser.Character_String_Literal)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_operator_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Operator_nameContext

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def operator_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Operator_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Operator_optionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def operator_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Operator_nameContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_operator_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_operator_statement" ):
                listener.enterCreate_operator_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_operator_statement" ):
                listener.exitCreate_operator_statement(self)




    def create_operator_statement(self):

        localctx = postgreSQLParser.Create_operator_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 264, self.RULE_create_operator_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3406
            self.match(postgreSQLParser.OPERATOR)
            self.state = 3407
            localctx.name = self.operator_name()
            self.state = 3408
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 3409
            self.operator_option()
            self.state = 3414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3410
                self.match(postgreSQLParser.COMMA)
                self.state = 3411
                self.operator_option()
                self.state = 3416
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3417
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Operator_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.schema_name = None # IdentifierContext
            self.operator = None # All_simple_opContext

        def all_simple_op(self):
            return self.getTypedRuleContext(postgreSQLParser.All_simple_opContext,0)


        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_operator_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator_name" ):
                listener.enterOperator_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator_name" ):
                listener.exitOperator_name(self)




    def operator_name(self):

        localctx = postgreSQLParser.Operator_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 266, self.RULE_operator_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3422
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 3419
                localctx.schema_name = self.identifier()
                self.state = 3420
                self.match(postgreSQLParser.DOT)


            self.state = 3424
            localctx.operator = self.all_simple_op()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Operator_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.func_name = None # Schema_qualified_nameContext
            self.restr_name = None # Schema_qualified_nameContext
            self.join_name = None # Schema_qualified_nameContext
            self.d_type = None # Data_typeContext
            self.addition_oper_name = None # All_op_refContext

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def RESTRICT(self):
            return self.getToken(postgreSQLParser.RESTRICT, 0)

        def JOIN(self):
            return self.getToken(postgreSQLParser.JOIN, 0)

        def LEFTARG(self):
            return self.getToken(postgreSQLParser.LEFTARG, 0)

        def RIGHTARG(self):
            return self.getToken(postgreSQLParser.RIGHTARG, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def COMMUTATOR(self):
            return self.getToken(postgreSQLParser.COMMUTATOR, 0)

        def NEGATOR(self):
            return self.getToken(postgreSQLParser.NEGATOR, 0)

        def all_op_ref(self):
            return self.getTypedRuleContext(postgreSQLParser.All_op_refContext,0)


        def HASHES(self):
            return self.getToken(postgreSQLParser.HASHES, 0)

        def MERGES(self):
            return self.getToken(postgreSQLParser.MERGES, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_operator_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator_option" ):
                listener.enterOperator_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator_option" ):
                listener.exitOperator_option(self)




    def operator_option(self):

        localctx = postgreSQLParser.Operator_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 268, self.RULE_operator_option)
        self._la = 0 # Token type
        try:
            self.state = 3443
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.FUNCTION, postgreSQLParser.PROCEDURE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3426
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3427
                self.match(postgreSQLParser.EQUAL)
                self.state = 3428
                localctx.func_name = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.RESTRICT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3429
                self.match(postgreSQLParser.RESTRICT)
                self.state = 3430
                self.match(postgreSQLParser.EQUAL)
                self.state = 3431
                localctx.restr_name = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.JOIN]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3432
                self.match(postgreSQLParser.JOIN)
                self.state = 3433
                self.match(postgreSQLParser.EQUAL)
                self.state = 3434
                localctx.join_name = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.LEFTARG, postgreSQLParser.RIGHTARG]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3435
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.LEFTARG or _la==postgreSQLParser.RIGHTARG):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3436
                self.match(postgreSQLParser.EQUAL)
                self.state = 3437
                localctx.d_type = self.data_type()
                pass
            elif token in [postgreSQLParser.COMMUTATOR, postgreSQLParser.NEGATOR]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3438
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.COMMUTATOR or _la==postgreSQLParser.NEGATOR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3439
                self.match(postgreSQLParser.EQUAL)
                self.state = 3440
                localctx.addition_oper_name = self.all_op_ref()
                pass
            elif token in [postgreSQLParser.HASHES]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3441
                self.match(postgreSQLParser.HASHES)
                pass
            elif token in [postgreSQLParser.MERGES]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3442
                self.match(postgreSQLParser.MERGES)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_aggregate_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.base_type = None # Data_typeContext
            self.sfunc_name = None # Schema_qualified_nameContext
            self.d_type = None # Data_typeContext

        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def SFUNC(self):
            return self.getToken(postgreSQLParser.SFUNC, 0)

        def EQUAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.EQUAL)
            else:
                return self.getToken(postgreSQLParser.EQUAL, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def STYPE(self):
            return self.getToken(postgreSQLParser.STYPE, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def BASETYPE(self):
            return self.getToken(postgreSQLParser.BASETYPE, 0)

        def aggregate_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Aggregate_paramContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Aggregate_paramContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_aggregate_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_aggregate_statement" ):
                listener.enterCreate_aggregate_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_aggregate_statement" ):
                listener.exitCreate_aggregate_statement(self)




    def create_aggregate_statement(self):

        localctx = postgreSQLParser.Create_aggregate_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 270, self.RULE_create_aggregate_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3447
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OR:
                self.state = 3445
                self.match(postgreSQLParser.OR)
                self.state = 3446
                self.match(postgreSQLParser.REPLACE)


            self.state = 3449
            self.match(postgreSQLParser.AGGREGATE)
            self.state = 3450
            localctx.name = self.schema_qualified_name()
            self.state = 3452
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,378,self._ctx)
            if la_ == 1:
                self.state = 3451
                self.function_args()


            self.state = 3454
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 3460
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.BASETYPE:
                self.state = 3455
                self.match(postgreSQLParser.BASETYPE)
                self.state = 3456
                self.match(postgreSQLParser.EQUAL)
                self.state = 3457
                localctx.base_type = self.data_type()
                self.state = 3458
                self.match(postgreSQLParser.COMMA)


            self.state = 3462
            self.match(postgreSQLParser.SFUNC)
            self.state = 3463
            self.match(postgreSQLParser.EQUAL)
            self.state = 3464
            localctx.sfunc_name = self.schema_qualified_name()
            self.state = 3465
            self.match(postgreSQLParser.COMMA)
            self.state = 3466
            self.match(postgreSQLParser.STYPE)
            self.state = 3467
            self.match(postgreSQLParser.EQUAL)
            self.state = 3468
            localctx.d_type = self.data_type()
            self.state = 3473
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3469
                self.match(postgreSQLParser.COMMA)
                self.state = 3470
                self.aggregate_param()
                self.state = 3475
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 3476
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Aggregate_paramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.s_space = None # Token
            self.final_func = None # Schema_qualified_nameContext
            self.combine_func = None # Schema_qualified_nameContext
            self.serial_func = None # Schema_qualified_nameContext
            self.deserial_func = None # Schema_qualified_nameContext
            self.init_cond = None # VexContext
            self.ms_func = None # Schema_qualified_nameContext
            self.minv_func = None # Schema_qualified_nameContext
            self.ms_type = None # Data_typeContext
            self.ms_space = None # Token
            self.mfinal_func = None # Schema_qualified_nameContext
            self.minit_cond = None # VexContext

        def SSPACE(self):
            return self.getToken(postgreSQLParser.SSPACE, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def FINALFUNC(self):
            return self.getToken(postgreSQLParser.FINALFUNC, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def FINALFUNC_EXTRA(self):
            return self.getToken(postgreSQLParser.FINALFUNC_EXTRA, 0)

        def FINALFUNC_MODIFY(self):
            return self.getToken(postgreSQLParser.FINALFUNC_MODIFY, 0)

        def READ_ONLY(self):
            return self.getToken(postgreSQLParser.READ_ONLY, 0)

        def SHAREABLE(self):
            return self.getToken(postgreSQLParser.SHAREABLE, 0)

        def READ_WRITE(self):
            return self.getToken(postgreSQLParser.READ_WRITE, 0)

        def COMBINEFUNC(self):
            return self.getToken(postgreSQLParser.COMBINEFUNC, 0)

        def SERIALFUNC(self):
            return self.getToken(postgreSQLParser.SERIALFUNC, 0)

        def DESERIALFUNC(self):
            return self.getToken(postgreSQLParser.DESERIALFUNC, 0)

        def INITCOND(self):
            return self.getToken(postgreSQLParser.INITCOND, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def MSFUNC(self):
            return self.getToken(postgreSQLParser.MSFUNC, 0)

        def MINVFUNC(self):
            return self.getToken(postgreSQLParser.MINVFUNC, 0)

        def MSTYPE(self):
            return self.getToken(postgreSQLParser.MSTYPE, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def MSSPACE(self):
            return self.getToken(postgreSQLParser.MSSPACE, 0)

        def MFINALFUNC(self):
            return self.getToken(postgreSQLParser.MFINALFUNC, 0)

        def MFINALFUNC_EXTRA(self):
            return self.getToken(postgreSQLParser.MFINALFUNC_EXTRA, 0)

        def MFINALFUNC_MODIFY(self):
            return self.getToken(postgreSQLParser.MFINALFUNC_MODIFY, 0)

        def MINITCOND(self):
            return self.getToken(postgreSQLParser.MINITCOND, 0)

        def SORTOP(self):
            return self.getToken(postgreSQLParser.SORTOP, 0)

        def all_op_ref(self):
            return self.getTypedRuleContext(postgreSQLParser.All_op_refContext,0)


        def PARALLEL(self):
            return self.getToken(postgreSQLParser.PARALLEL, 0)

        def SAFE(self):
            return self.getToken(postgreSQLParser.SAFE, 0)

        def RESTRICTED(self):
            return self.getToken(postgreSQLParser.RESTRICTED, 0)

        def UNSAFE(self):
            return self.getToken(postgreSQLParser.UNSAFE, 0)

        def HYPOTHETICAL(self):
            return self.getToken(postgreSQLParser.HYPOTHETICAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_aggregate_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAggregate_param" ):
                listener.enterAggregate_param(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAggregate_param" ):
                listener.exitAggregate_param(self)




    def aggregate_param(self):

        localctx = postgreSQLParser.Aggregate_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 272, self.RULE_aggregate_param)
        self._la = 0 # Token type
        try:
            self.state = 3529
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.SSPACE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3478
                self.match(postgreSQLParser.SSPACE)
                self.state = 3479
                self.match(postgreSQLParser.EQUAL)
                self.state = 3480
                localctx.s_space = self.match(postgreSQLParser.NUMBER_LITERAL)
                pass
            elif token in [postgreSQLParser.FINALFUNC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3481
                self.match(postgreSQLParser.FINALFUNC)
                self.state = 3482
                self.match(postgreSQLParser.EQUAL)
                self.state = 3483
                localctx.final_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.FINALFUNC_EXTRA]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3484
                self.match(postgreSQLParser.FINALFUNC_EXTRA)
                pass
            elif token in [postgreSQLParser.FINALFUNC_MODIFY]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3485
                self.match(postgreSQLParser.FINALFUNC_MODIFY)
                self.state = 3486
                self.match(postgreSQLParser.EQUAL)
                self.state = 3487
                _la = self._input.LA(1)
                if not(((((_la - 521)) & ~0x3f) == 0 and ((1 << (_la - 521)) & ((1 << (postgreSQLParser.READ_ONLY - 521)) | (1 << (postgreSQLParser.READ_WRITE - 521)) | (1 << (postgreSQLParser.SHAREABLE - 521)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.COMBINEFUNC]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3488
                self.match(postgreSQLParser.COMBINEFUNC)
                self.state = 3489
                self.match(postgreSQLParser.EQUAL)
                self.state = 3490
                localctx.combine_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.SERIALFUNC]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3491
                self.match(postgreSQLParser.SERIALFUNC)
                self.state = 3492
                self.match(postgreSQLParser.EQUAL)
                self.state = 3493
                localctx.serial_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.DESERIALFUNC]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3494
                self.match(postgreSQLParser.DESERIALFUNC)
                self.state = 3495
                self.match(postgreSQLParser.EQUAL)
                self.state = 3496
                localctx.deserial_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.INITCOND]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3497
                self.match(postgreSQLParser.INITCOND)
                self.state = 3498
                self.match(postgreSQLParser.EQUAL)
                self.state = 3499
                localctx.init_cond = self.vex(0)
                pass
            elif token in [postgreSQLParser.MSFUNC]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3500
                self.match(postgreSQLParser.MSFUNC)
                self.state = 3501
                self.match(postgreSQLParser.EQUAL)
                self.state = 3502
                localctx.ms_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.MINVFUNC]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3503
                self.match(postgreSQLParser.MINVFUNC)
                self.state = 3504
                self.match(postgreSQLParser.EQUAL)
                self.state = 3505
                localctx.minv_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.MSTYPE]:
                self.enterOuterAlt(localctx, 11)
                self.state = 3506
                self.match(postgreSQLParser.MSTYPE)
                self.state = 3507
                self.match(postgreSQLParser.EQUAL)
                self.state = 3508
                localctx.ms_type = self.data_type()
                pass
            elif token in [postgreSQLParser.MSSPACE]:
                self.enterOuterAlt(localctx, 12)
                self.state = 3509
                self.match(postgreSQLParser.MSSPACE)
                self.state = 3510
                self.match(postgreSQLParser.EQUAL)
                self.state = 3511
                localctx.ms_space = self.match(postgreSQLParser.NUMBER_LITERAL)
                pass
            elif token in [postgreSQLParser.MFINALFUNC]:
                self.enterOuterAlt(localctx, 13)
                self.state = 3512
                self.match(postgreSQLParser.MFINALFUNC)
                self.state = 3513
                self.match(postgreSQLParser.EQUAL)
                self.state = 3514
                localctx.mfinal_func = self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.MFINALFUNC_EXTRA]:
                self.enterOuterAlt(localctx, 14)
                self.state = 3515
                self.match(postgreSQLParser.MFINALFUNC_EXTRA)
                pass
            elif token in [postgreSQLParser.MFINALFUNC_MODIFY]:
                self.enterOuterAlt(localctx, 15)
                self.state = 3516
                self.match(postgreSQLParser.MFINALFUNC_MODIFY)
                self.state = 3517
                self.match(postgreSQLParser.EQUAL)
                self.state = 3518
                _la = self._input.LA(1)
                if not(((((_la - 521)) & ~0x3f) == 0 and ((1 << (_la - 521)) & ((1 << (postgreSQLParser.READ_ONLY - 521)) | (1 << (postgreSQLParser.READ_WRITE - 521)) | (1 << (postgreSQLParser.SHAREABLE - 521)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.MINITCOND]:
                self.enterOuterAlt(localctx, 16)
                self.state = 3519
                self.match(postgreSQLParser.MINITCOND)
                self.state = 3520
                self.match(postgreSQLParser.EQUAL)
                self.state = 3521
                localctx.minit_cond = self.vex(0)
                pass
            elif token in [postgreSQLParser.SORTOP]:
                self.enterOuterAlt(localctx, 17)
                self.state = 3522
                self.match(postgreSQLParser.SORTOP)
                self.state = 3523
                self.match(postgreSQLParser.EQUAL)
                self.state = 3524
                self.all_op_ref()
                pass
            elif token in [postgreSQLParser.PARALLEL]:
                self.enterOuterAlt(localctx, 18)
                self.state = 3525
                self.match(postgreSQLParser.PARALLEL)
                self.state = 3526
                self.match(postgreSQLParser.EQUAL)
                self.state = 3527
                _la = self._input.LA(1)
                if not(((((_la - 526)) & ~0x3f) == 0 and ((1 << (_la - 526)) & ((1 << (postgreSQLParser.RESTRICTED - 526)) | (1 << (postgreSQLParser.SAFE - 526)) | (1 << (postgreSQLParser.UNSAFE - 526)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.HYPOTHETICAL]:
                self.enterOuterAlt(localctx, 19)
                self.state = 3528
                self.match(postgreSQLParser.HYPOTHETICAL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def set_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_statement" ):
                listener.enterSet_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_statement" ):
                listener.exitSet_statement(self)




    def set_statement(self):

        localctx = postgreSQLParser.Set_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 274, self.RULE_set_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3531
            self.match(postgreSQLParser.SET)
            self.state = 3532
            self.set_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONSTRAINTS(self):
            return self.getToken(postgreSQLParser.CONSTRAINTS, 0)

        def DEFERRED(self):
            return self.getToken(postgreSQLParser.DEFERRED, 0)

        def IMMEDIATE(self):
            return self.getToken(postgreSQLParser.IMMEDIATE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def names_references(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_referencesContext,0)


        def TRANSACTION(self):
            return self.getToken(postgreSQLParser.TRANSACTION, 0)

        def transaction_mode(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Transaction_modeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Transaction_modeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def SNAPSHOT(self):
            return self.getToken(postgreSQLParser.SNAPSHOT, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def SESSION(self):
            return self.getToken(postgreSQLParser.SESSION, 0)

        def CHARACTERISTICS(self):
            return self.getToken(postgreSQLParser.CHARACTERISTICS, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def session_local_option(self):
            return self.getTypedRuleContext(postgreSQLParser.Session_local_optionContext,0)


        def LOCAL(self):
            return self.getToken(postgreSQLParser.LOCAL, 0)

        def XML(self):
            return self.getToken(postgreSQLParser.XML, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def DOCUMENT(self):
            return self.getToken(postgreSQLParser.DOCUMENT, 0)

        def CONTENT(self):
            return self.getToken(postgreSQLParser.CONTENT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_action" ):
                listener.enterSet_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_action" ):
                listener.exitSet_action(self)




    def set_action(self):

        localctx = postgreSQLParser.Set_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 276, self.RULE_set_action)
        self._la = 0 # Token type
        try:
            self.state = 3571
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,386,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3534
                self.match(postgreSQLParser.CONSTRAINTS)
                self.state = 3537
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ALL]:
                    self.state = 3535
                    self.match(postgreSQLParser.ALL)
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 3536
                    self.names_references()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3539
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DEFERRED or _la==postgreSQLParser.IMMEDIATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3540
                self.match(postgreSQLParser.TRANSACTION)
                self.state = 3541
                self.transaction_mode()
                self.state = 3546
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3542
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3543
                    self.transaction_mode()
                    self.state = 3548
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3549
                self.match(postgreSQLParser.TRANSACTION)
                self.state = 3550
                self.match(postgreSQLParser.SNAPSHOT)
                self.state = 3551
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3552
                self.match(postgreSQLParser.SESSION)
                self.state = 3553
                self.match(postgreSQLParser.CHARACTERISTICS)
                self.state = 3554
                self.match(postgreSQLParser.AS)
                self.state = 3555
                self.match(postgreSQLParser.TRANSACTION)
                self.state = 3556
                self.transaction_mode()
                self.state = 3561
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3557
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3558
                    self.transaction_mode()
                    self.state = 3563
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3565
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,385,self._ctx)
                if la_ == 1:
                    self.state = 3564
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.LOCAL or _la==postgreSQLParser.SESSION):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 3567
                self.session_local_option()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3568
                self.match(postgreSQLParser.XML)
                self.state = 3569
                self.match(postgreSQLParser.OPTION)
                self.state = 3570
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONTENT or _la==postgreSQLParser.DOCUMENT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Session_local_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.config_param = None # IdentifierContext

        def SESSION(self):
            return self.getToken(postgreSQLParser.SESSION, 0)

        def AUTHORIZATION(self):
            return self.getToken(postgreSQLParser.AUTHORIZATION, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def TIME(self):
            return self.getToken(postgreSQLParser.TIME, 0)

        def ZONE(self):
            return self.getToken(postgreSQLParser.ZONE, 0)

        def signed_numerical_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Signed_numerical_literalContext,0)


        def LOCAL(self):
            return self.getToken(postgreSQLParser.LOCAL, 0)

        def set_statement_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_statement_valueContext,0)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def NONE(self):
            return self.getToken(postgreSQLParser.NONE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_session_local_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSession_local_option" ):
                listener.enterSession_local_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSession_local_option" ):
                listener.exitSession_local_option(self)




    def session_local_option(self):

        localctx = postgreSQLParser.Session_local_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 278, self.RULE_session_local_option)
        self._la = 0 # Token type
        try:
            self.state = 3602
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,391,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3573
                self.match(postgreSQLParser.SESSION)
                self.state = 3574
                self.match(postgreSQLParser.AUTHORIZATION)
                self.state = 3578
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.Character_String_Literal]:
                    self.state = 3575
                    self.match(postgreSQLParser.Character_String_Literal)
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 3576
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 3577
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3580
                self.match(postgreSQLParser.TIME)
                self.state = 3581
                self.match(postgreSQLParser.ZONE)
                self.state = 3586
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.Character_String_Literal]:
                    self.state = 3582
                    self.match(postgreSQLParser.Character_String_Literal)
                    pass
                elif token in [postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER]:
                    self.state = 3583
                    self.signed_numerical_literal()
                    pass
                elif token in [postgreSQLParser.LOCAL]:
                    self.state = 3584
                    self.match(postgreSQLParser.LOCAL)
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 3585
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3591
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,389,self._ctx)
                if la_ == 1:
                    self.state = 3588
                    self.identifier()
                    self.state = 3589
                    self.match(postgreSQLParser.DOT)


                self.state = 3593
                localctx.config_param = self.identifier()
                self.state = 3594
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TO or _la==postgreSQLParser.EQUAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3595
                self.set_statement_value()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3597
                self.match(postgreSQLParser.ROLE)
                self.state = 3600
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,390,self._ctx)
                if la_ == 1:
                    self.state = 3598
                    self.identifier()
                    pass

                elif la_ == 2:
                    self.state = 3599
                    self.match(postgreSQLParser.NONE)
                    pass


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_statement_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_statement_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_statement_value" ):
                listener.enterSet_statement_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_statement_value" ):
                listener.exitSet_statement_value(self)




    def set_statement_value(self):

        localctx = postgreSQLParser.Set_statement_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 280, self.RULE_set_statement_value)
        self._la = 0 # Token type
        try:
            self.state = 3613
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3604
                self.vex(0)
                self.state = 3609
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3605
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3606
                    self.vex(0)
                    self.state = 3611
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [postgreSQLParser.DEFAULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3612
                self.match(postgreSQLParser.DEFAULT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_rewrite_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.event = None # Token
            self.table_name = None # Schema_qualified_nameContext

        def RULE(self):
            return self.getToken(postgreSQLParser.RULE, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def DO(self):
            return self.getToken(postgreSQLParser.DO, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def INSERT(self):
            return self.getToken(postgreSQLParser.INSERT, 0)

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def NOTHING(self):
            return self.getToken(postgreSQLParser.NOTHING, 0)

        def rewrite_command(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Rewrite_commandContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Rewrite_commandContext,i)


        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def ALSO(self):
            return self.getToken(postgreSQLParser.ALSO, 0)

        def INSTEAD(self):
            return self.getToken(postgreSQLParser.INSTEAD, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def SEMI_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SEMI_COLON)
            else:
                return self.getToken(postgreSQLParser.SEMI_COLON, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_rewrite_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_rewrite_statement" ):
                listener.enterCreate_rewrite_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_rewrite_statement" ):
                listener.exitCreate_rewrite_statement(self)




    def create_rewrite_statement(self):

        localctx = postgreSQLParser.Create_rewrite_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 282, self.RULE_create_rewrite_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3617
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OR:
                self.state = 3615
                self.match(postgreSQLParser.OR)
                self.state = 3616
                self.match(postgreSQLParser.REPLACE)


            self.state = 3619
            self.match(postgreSQLParser.RULE)
            self.state = 3620
            localctx.name = self.identifier()
            self.state = 3621
            self.match(postgreSQLParser.AS)
            self.state = 3622
            self.match(postgreSQLParser.ON)
            self.state = 3623
            localctx.event = self._input.LT(1)
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.DELETE or _la==postgreSQLParser.INSERT or _la==postgreSQLParser.UPDATE or _la==postgreSQLParser.SELECT):
                localctx.event = self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3624
            self.match(postgreSQLParser.TO)
            self.state = 3625
            localctx.table_name = self.schema_qualified_name()
            self.state = 3628
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHERE:
                self.state = 3626
                self.match(postgreSQLParser.WHERE)
                self.state = 3627
                self.vex(0)


            self.state = 3630
            self.match(postgreSQLParser.DO)
            self.state = 3632
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ALSO or _la==postgreSQLParser.INSTEAD:
                self.state = 3631
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ALSO or _la==postgreSQLParser.INSTEAD):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 3651
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,399,self._ctx)
            if la_ == 1:
                self.state = 3634
                self.match(postgreSQLParser.NOTHING)
                pass

            elif la_ == 2:
                self.state = 3635
                self.rewrite_command()
                pass

            elif la_ == 3:
                self.state = 3636
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3642
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,397,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 3637
                        self.rewrite_command()
                        self.state = 3638
                        self.match(postgreSQLParser.SEMI_COLON) 
                    self.state = 3644
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,397,self._ctx)

                self.state = 3645
                self.rewrite_command()
                self.state = 3647
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.SEMI_COLON:
                    self.state = 3646
                    self.match(postgreSQLParser.SEMI_COLON)


                self.state = 3649
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rewrite_commandContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def insert_stmt_for_psql(self):
            return self.getTypedRuleContext(postgreSQLParser.Insert_stmt_for_psqlContext,0)


        def update_stmt_for_psql(self):
            return self.getTypedRuleContext(postgreSQLParser.Update_stmt_for_psqlContext,0)


        def delete_stmt_for_psql(self):
            return self.getTypedRuleContext(postgreSQLParser.Delete_stmt_for_psqlContext,0)


        def notify_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Notify_stmtContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_rewrite_command

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRewrite_command" ):
                listener.enterRewrite_command(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRewrite_command" ):
                listener.exitRewrite_command(self)




    def rewrite_command(self):

        localctx = postgreSQLParser.Rewrite_commandContext(self, self._ctx, self.state)
        self.enterRule(localctx, 284, self.RULE_rewrite_command)
        try:
            self.state = 3658
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,400,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3653
                self.select_stmt()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3654
                self.insert_stmt_for_psql()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3655
                self.update_stmt_for_psql()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3656
                self.delete_stmt_for_psql()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3657
                self.notify_stmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_trigger_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.before_true = None # Token
            self.insert_true = None # Token
            self.delete_true = None # Token
            self.truncate_true = None # Token
            self.update_true = None # Token
            self.table_name = None # Schema_qualified_nameContext
            self.referenced_table_name = None # Schema_qualified_nameContext
            self.for_each_true = None # Token
            self.func_name = None # Function_callContext

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def AFTER(self):
            return self.getToken(postgreSQLParser.AFTER, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def BEFORE(self):
            return self.getToken(postgreSQLParser.BEFORE, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def table_deferrable(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_deferrableContext,0)


        def table_initialy_immed(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_initialy_immedContext,0)


        def REFERENCING(self):
            return self.getToken(postgreSQLParser.REFERENCING, 0)

        def trigger_referencing(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Trigger_referencingContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Trigger_referencingContext,i)


        def when_trigger(self):
            return self.getTypedRuleContext(postgreSQLParser.When_triggerContext,0)


        def INSTEAD(self):
            return self.getToken(postgreSQLParser.INSTEAD, 0)

        def OF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.OF)
            else:
                return self.getToken(postgreSQLParser.OF, i)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def STATEMENT(self):
            return self.getToken(postgreSQLParser.STATEMENT, 0)

        def UPDATE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.UPDATE)
            else:
                return self.getToken(postgreSQLParser.UPDATE, i)

        def OR(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.OR)
            else:
                return self.getToken(postgreSQLParser.OR, i)

        def EACH(self):
            return self.getToken(postgreSQLParser.EACH, 0)

        def INSERT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.INSERT)
            else:
                return self.getToken(postgreSQLParser.INSERT, i)

        def DELETE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DELETE)
            else:
                return self.getToken(postgreSQLParser.DELETE, i)

        def TRUNCATE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.TRUNCATE)
            else:
                return self.getToken(postgreSQLParser.TRUNCATE, i)

        def identifier_list(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Identifier_listContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_trigger_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_trigger_statement" ):
                listener.enterCreate_trigger_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_trigger_statement" ):
                listener.exitCreate_trigger_statement(self)




    def create_trigger_statement(self):

        localctx = postgreSQLParser.Create_trigger_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 286, self.RULE_create_trigger_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3661
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONSTRAINT:
                self.state = 3660
                self.match(postgreSQLParser.CONSTRAINT)


            self.state = 3663
            self.match(postgreSQLParser.TRIGGER)
            self.state = 3664
            localctx.name = self.identifier()
            self.state = 3669
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.BEFORE]:
                self.state = 3665
                localctx.before_true = self.match(postgreSQLParser.BEFORE)
                pass
            elif token in [postgreSQLParser.INSTEAD]:
                self.state = 3666
                self.match(postgreSQLParser.INSTEAD)
                self.state = 3667
                self.match(postgreSQLParser.OF)
                pass
            elif token in [postgreSQLParser.AFTER]:
                self.state = 3668
                self.match(postgreSQLParser.AFTER)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 3686 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 3681
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.DELETE, postgreSQLParser.INSERT, postgreSQLParser.TRUNCATE]:
                    self.state = 3674
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.INSERT]:
                        self.state = 3671
                        localctx.insert_true = self.match(postgreSQLParser.INSERT)
                        pass
                    elif token in [postgreSQLParser.DELETE]:
                        self.state = 3672
                        localctx.delete_true = self.match(postgreSQLParser.DELETE)
                        pass
                    elif token in [postgreSQLParser.TRUNCATE]:
                        self.state = 3673
                        localctx.truncate_true = self.match(postgreSQLParser.TRUNCATE)
                        pass
                    else:
                        raise NoViableAltException(self)

                    pass
                elif token in [postgreSQLParser.UPDATE]:
                    self.state = 3676
                    localctx.update_true = self.match(postgreSQLParser.UPDATE)
                    self.state = 3679
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.OF:
                        self.state = 3677
                        self.match(postgreSQLParser.OF)
                        self.state = 3678
                        self.identifier_list()


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3684
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OR:
                    self.state = 3683
                    self.match(postgreSQLParser.OR)


                self.state = 3688 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==postgreSQLParser.DELETE or _la==postgreSQLParser.INSERT or _la==postgreSQLParser.TRUNCATE or _la==postgreSQLParser.UPDATE):
                    break

            self.state = 3690
            self.match(postgreSQLParser.ON)
            self.state = 3691
            localctx.table_name = self.schema_qualified_name()
            self.state = 3694
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FROM:
                self.state = 3692
                self.match(postgreSQLParser.FROM)
                self.state = 3693
                localctx.referenced_table_name = self.schema_qualified_name()


            self.state = 3697
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DEFERRABLE or _la==postgreSQLParser.NOT:
                self.state = 3696
                self.table_deferrable()


            self.state = 3700
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INITIALLY:
                self.state = 3699
                self.table_initialy_immed()


            self.state = 3707
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.REFERENCING:
                self.state = 3702
                self.match(postgreSQLParser.REFERENCING)
                self.state = 3703
                self.trigger_referencing()
                self.state = 3705
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NEW or _la==postgreSQLParser.OLD:
                    self.state = 3704
                    self.trigger_referencing()




            self.state = 3714
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FOR:
                self.state = 3709
                localctx.for_each_true = self.match(postgreSQLParser.FOR)
                self.state = 3711
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.EACH:
                    self.state = 3710
                    self.match(postgreSQLParser.EACH)


                self.state = 3713
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.STATEMENT or _la==postgreSQLParser.ROW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 3717
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHEN:
                self.state = 3716
                self.when_trigger()


            self.state = 3719
            self.match(postgreSQLParser.EXECUTE)
            self.state = 3720
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3721
            localctx.func_name = self.function_call()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trigger_referencingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def OLD(self):
            return self.getToken(postgreSQLParser.OLD, 0)

        def NEW(self):
            return self.getToken(postgreSQLParser.NEW, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_trigger_referencing

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrigger_referencing" ):
                listener.enterTrigger_referencing(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrigger_referencing" ):
                listener.exitTrigger_referencing(self)




    def trigger_referencing(self):

        localctx = postgreSQLParser.Trigger_referencingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 288, self.RULE_trigger_referencing)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3723
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.NEW or _la==postgreSQLParser.OLD):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 3724
            self.match(postgreSQLParser.TABLE)
            self.state = 3726
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.AS:
                self.state = 3725
                self.match(postgreSQLParser.AS)


            self.state = 3728
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class When_triggerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WHEN(self):
            return self.getToken(postgreSQLParser.WHEN, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_when_trigger

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhen_trigger" ):
                listener.enterWhen_trigger(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhen_trigger" ):
                listener.exitWhen_trigger(self)




    def when_trigger(self):

        localctx = postgreSQLParser.When_triggerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 290, self.RULE_when_trigger)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3730
            self.match(postgreSQLParser.WHEN)
            self.state = 3731
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 3732
            self.vex(0)
            self.state = 3733
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rule_commonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def rule_member_object(self):
            return self.getTypedRuleContext(postgreSQLParser.Rule_member_objectContext,0)


        def roles_names(self):
            return self.getTypedRuleContext(postgreSQLParser.Roles_namesContext,0)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def GRANT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.GRANT)
            else:
                return self.getToken(postgreSQLParser.GRANT, i)

        def REVOKE(self):
            return self.getToken(postgreSQLParser.REVOKE, 0)

        def permissions(self):
            return self.getTypedRuleContext(postgreSQLParser.PermissionsContext,0)


        def columns_permissions(self):
            return self.getTypedRuleContext(postgreSQLParser.Columns_permissionsContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def grant_option_for(self):
            return self.getTypedRuleContext(postgreSQLParser.Grant_option_forContext,0)


        def other_rules(self):
            return self.getTypedRuleContext(postgreSQLParser.Other_rulesContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_rule_common

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule_common" ):
                listener.enterRule_common(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule_common" ):
                listener.exitRule_common(self)




    def rule_common(self):

        localctx = postgreSQLParser.Rule_commonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 292, self.RULE_rule_common)
        self._la = 0 # Token type
        try:
            self.state = 3757
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,421,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3740
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.GRANT]:
                    self.state = 3735
                    self.match(postgreSQLParser.GRANT)
                    pass
                elif token in [postgreSQLParser.REVOKE]:
                    self.state = 3736
                    self.match(postgreSQLParser.REVOKE)
                    self.state = 3738
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.GRANT:
                        self.state = 3737
                        self.grant_option_for()


                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 3744
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,419,self._ctx)
                if la_ == 1:
                    self.state = 3742
                    self.permissions()
                    pass

                elif la_ == 2:
                    self.state = 3743
                    self.columns_permissions()
                    pass


                self.state = 3746
                self.match(postgreSQLParser.ON)
                self.state = 3747
                self.rule_member_object()
                self.state = 3748
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.FROM or _la==postgreSQLParser.TO):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3749
                self.roles_names()
                self.state = 3754
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.WITH]:
                    self.state = 3750
                    self.match(postgreSQLParser.WITH)
                    self.state = 3751
                    self.match(postgreSQLParser.GRANT)
                    self.state = 3752
                    self.match(postgreSQLParser.OPTION)
                    pass
                elif token in [postgreSQLParser.CASCADE, postgreSQLParser.RESTRICT]:
                    self.state = 3753
                    self.cascade_restrict()
                    pass
                elif token in [postgreSQLParser.EOF, postgreSQLParser.SEMI_COLON]:
                    pass
                else:
                    pass
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3756
                self.other_rules()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rule_member_objectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.table_names = None # Names_referencesContext
            self._function_parameters = None # Function_parametersContext
            self.func_name = list() # of Function_parametersContexts
            self.schema_names = None # Names_referencesContext

        def names_references(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_referencesContext,0)


        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def ROUTINE(self):
            return self.getToken(postgreSQLParser.ROUTINE, 0)

        def function_parameters(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_parametersContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_parametersContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def LARGE(self):
            return self.getToken(postgreSQLParser.LARGE, 0)

        def OBJECT(self):
            return self.getToken(postgreSQLParser.OBJECT, 0)

        def NUMBER_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NUMBER_LITERAL)
            else:
                return self.getToken(postgreSQLParser.NUMBER_LITERAL, i)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def TABLES(self):
            return self.getToken(postgreSQLParser.TABLES, 0)

        def SEQUENCES(self):
            return self.getToken(postgreSQLParser.SEQUENCES, 0)

        def FUNCTIONS(self):
            return self.getToken(postgreSQLParser.FUNCTIONS, 0)

        def PROCEDURES(self):
            return self.getToken(postgreSQLParser.PROCEDURES, 0)

        def ROUTINES(self):
            return self.getToken(postgreSQLParser.ROUTINES, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_rule_member_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRule_member_object" ):
                listener.enterRule_member_object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRule_member_object" ):
                listener.exitRule_member_object(self)




    def rule_member_object(self):

        localctx = postgreSQLParser.Rule_member_objectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 294, self.RULE_rule_member_object)
        self._la = 0 # Token type
        try:
            self.state = 3808
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,425,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3760
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.TABLE:
                    self.state = 3759
                    self.match(postgreSQLParser.TABLE)


                self.state = 3762
                localctx.table_names = self.names_references()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3763
                self.match(postgreSQLParser.SEQUENCE)
                self.state = 3764
                self.names_references()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3765
                self.match(postgreSQLParser.DATABASE)
                self.state = 3766
                self.names_references()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3767
                self.match(postgreSQLParser.DOMAIN)
                self.state = 3768
                self.names_references()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3769
                self.match(postgreSQLParser.FOREIGN)
                self.state = 3770
                self.match(postgreSQLParser.DATA)
                self.state = 3771
                self.match(postgreSQLParser.WRAPPER)
                self.state = 3772
                self.names_references()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3773
                self.match(postgreSQLParser.FOREIGN)
                self.state = 3774
                self.match(postgreSQLParser.SERVER)
                self.state = 3775
                self.names_references()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 3776
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE or _la==postgreSQLParser.ROUTINE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3777
                localctx._function_parameters = self.function_parameters()
                localctx.func_name.append(localctx._function_parameters)
                self.state = 3782
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3778
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3779
                    localctx._function_parameters = self.function_parameters()
                    localctx.func_name.append(localctx._function_parameters)
                    self.state = 3784
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 3785
                self.match(postgreSQLParser.LARGE)
                self.state = 3786
                self.match(postgreSQLParser.OBJECT)
                self.state = 3787
                self.match(postgreSQLParser.NUMBER_LITERAL)
                self.state = 3792
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 3788
                    self.match(postgreSQLParser.COMMA)
                    self.state = 3789
                    self.match(postgreSQLParser.NUMBER_LITERAL)
                    self.state = 3794
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 3795
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 3796
                self.names_references()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 3797
                self.match(postgreSQLParser.SCHEMA)
                self.state = 3798
                localctx.schema_names = self.names_references()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 3799
                self.match(postgreSQLParser.TABLESPACE)
                self.state = 3800
                self.names_references()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 3801
                self.match(postgreSQLParser.TYPE)
                self.state = 3802
                self.names_references()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 3803
                self.match(postgreSQLParser.ALL)
                self.state = 3804
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.FUNCTIONS or ((((_la - 191)) & ~0x3f) == 0 and ((1 << (_la - 191)) & ((1 << (postgreSQLParser.PROCEDURES - 191)) | (1 << (postgreSQLParser.ROUTINES - 191)) | (1 << (postgreSQLParser.SEQUENCES - 191)))) != 0) or _la==postgreSQLParser.TABLES):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3805
                self.match(postgreSQLParser.IN)
                self.state = 3806
                self.match(postgreSQLParser.SCHEMA)
                self.state = 3807
                self.names_references()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Columns_permissionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_column_privileges(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_column_privilegesContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_column_privilegesContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_columns_permissions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterColumns_permissions" ):
                listener.enterColumns_permissions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitColumns_permissions" ):
                listener.exitColumns_permissions(self)




    def columns_permissions(self):

        localctx = postgreSQLParser.Columns_permissionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 296, self.RULE_columns_permissions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3810
            self.table_column_privileges()
            self.state = 3815
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3811
                self.match(postgreSQLParser.COMMA)
                self.state = 3812
                self.table_column_privileges()
                self.state = 3817
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_column_privilegesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_column_privilege(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_column_privilegeContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_column_privileges

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_column_privileges" ):
                listener.enterTable_column_privileges(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_column_privileges" ):
                listener.exitTable_column_privileges(self)




    def table_column_privileges(self):

        localctx = postgreSQLParser.Table_column_privilegesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 298, self.RULE_table_column_privileges)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3818
            self.table_column_privilege()
            self.state = 3819
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 3820
            self.identifier_list()
            self.state = 3821
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PermissionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def permission(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.PermissionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.PermissionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_permissions

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPermissions" ):
                listener.enterPermissions(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPermissions" ):
                listener.exitPermissions(self)




    def permissions(self):

        localctx = postgreSQLParser.PermissionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 300, self.RULE_permissions)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3823
            self.permission()
            self.state = 3828
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3824
                self.match(postgreSQLParser.COMMA)
                self.state = 3825
                self.permission()
                self.state = 3830
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PermissionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def PRIVILEGES(self):
            return self.getToken(postgreSQLParser.PRIVILEGES, 0)

        def CONNECT(self):
            return self.getToken(postgreSQLParser.CONNECT, 0)

        def CREATE(self):
            return self.getToken(postgreSQLParser.CREATE, 0)

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def INSERT(self):
            return self.getToken(postgreSQLParser.INSERT, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def REFERENCES(self):
            return self.getToken(postgreSQLParser.REFERENCES, 0)

        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def TRUNCATE(self):
            return self.getToken(postgreSQLParser.TRUNCATE, 0)

        def USAGE(self):
            return self.getToken(postgreSQLParser.USAGE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_permission

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPermission" ):
                listener.enterPermission(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPermission" ):
                listener.exitPermission(self)




    def permission(self):

        localctx = postgreSQLParser.PermissionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 302, self.RULE_permission)
        self._la = 0 # Token type
        try:
            self.state = 3847
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ALL]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3831
                self.match(postgreSQLParser.ALL)
                self.state = 3833
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PRIVILEGES:
                    self.state = 3832
                    self.match(postgreSQLParser.PRIVILEGES)


                pass
            elif token in [postgreSQLParser.CONNECT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3835
                self.match(postgreSQLParser.CONNECT)
                pass
            elif token in [postgreSQLParser.CREATE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 3836
                self.match(postgreSQLParser.CREATE)
                pass
            elif token in [postgreSQLParser.DELETE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 3837
                self.match(postgreSQLParser.DELETE)
                pass
            elif token in [postgreSQLParser.EXECUTE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 3838
                self.match(postgreSQLParser.EXECUTE)
                pass
            elif token in [postgreSQLParser.INSERT]:
                self.enterOuterAlt(localctx, 6)
                self.state = 3839
                self.match(postgreSQLParser.INSERT)
                pass
            elif token in [postgreSQLParser.UPDATE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 3840
                self.match(postgreSQLParser.UPDATE)
                pass
            elif token in [postgreSQLParser.REFERENCES]:
                self.enterOuterAlt(localctx, 8)
                self.state = 3841
                self.match(postgreSQLParser.REFERENCES)
                pass
            elif token in [postgreSQLParser.SELECT]:
                self.enterOuterAlt(localctx, 9)
                self.state = 3842
                self.match(postgreSQLParser.SELECT)
                pass
            elif token in [postgreSQLParser.TEMP]:
                self.enterOuterAlt(localctx, 10)
                self.state = 3843
                self.match(postgreSQLParser.TEMP)
                pass
            elif token in [postgreSQLParser.TRIGGER]:
                self.enterOuterAlt(localctx, 11)
                self.state = 3844
                self.match(postgreSQLParser.TRIGGER)
                pass
            elif token in [postgreSQLParser.TRUNCATE]:
                self.enterOuterAlt(localctx, 12)
                self.state = 3845
                self.match(postgreSQLParser.TRUNCATE)
                pass
            elif token in [postgreSQLParser.USAGE]:
                self.enterOuterAlt(localctx, 13)
                self.state = 3846
                self.match(postgreSQLParser.USAGE)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Other_rulesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GRANT(self):
            return self.getToken(postgreSQLParser.GRANT, 0)

        def names_references(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Names_referencesContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Names_referencesContext,i)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def ADMIN(self):
            return self.getToken(postgreSQLParser.ADMIN, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def REVOKE(self):
            return self.getToken(postgreSQLParser.REVOKE, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_other_rules

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOther_rules" ):
                listener.enterOther_rules(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOther_rules" ):
                listener.exitOther_rules(self)




    def other_rules(self):

        localctx = postgreSQLParser.Other_rulesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 304, self.RULE_other_rules)
        self._la = 0 # Token type
        try:
            self.state = 3870
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.GRANT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 3849
                self.match(postgreSQLParser.GRANT)
                self.state = 3850
                self.names_references()
                self.state = 3851
                self.match(postgreSQLParser.TO)
                self.state = 3852
                self.names_references()
                self.state = 3856
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 3853
                    self.match(postgreSQLParser.WITH)
                    self.state = 3854
                    self.match(postgreSQLParser.ADMIN)
                    self.state = 3855
                    self.match(postgreSQLParser.OPTION)


                pass
            elif token in [postgreSQLParser.REVOKE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 3858
                self.match(postgreSQLParser.REVOKE)
                self.state = 3862
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,431,self._ctx)
                if la_ == 1:
                    self.state = 3859
                    self.match(postgreSQLParser.ADMIN)
                    self.state = 3860
                    self.match(postgreSQLParser.OPTION)
                    self.state = 3861
                    self.match(postgreSQLParser.FOR)


                self.state = 3864
                self.names_references()
                self.state = 3865
                self.match(postgreSQLParser.FROM)
                self.state = 3866
                self.names_references()
                self.state = 3868
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                    self.state = 3867
                    self.cascade_restrict()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Grant_to_ruleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def roles_names(self):
            return self.getTypedRuleContext(postgreSQLParser.Roles_namesContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def GRANT(self):
            return self.getToken(postgreSQLParser.GRANT, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_grant_to_rule

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrant_to_rule" ):
                listener.enterGrant_to_rule(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrant_to_rule" ):
                listener.exitGrant_to_rule(self)




    def grant_to_rule(self):

        localctx = postgreSQLParser.Grant_to_ruleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 306, self.RULE_grant_to_rule)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3872
            self.match(postgreSQLParser.TO)
            self.state = 3873
            self.roles_names()
            self.state = 3877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 3874
                self.match(postgreSQLParser.WITH)
                self.state = 3875
                self.match(postgreSQLParser.GRANT)
                self.state = 3876
                self.match(postgreSQLParser.OPTION)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Revoke_from_cascade_restrictContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def roles_names(self):
            return self.getTypedRuleContext(postgreSQLParser.Roles_namesContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_revoke_from_cascade_restrict

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRevoke_from_cascade_restrict" ):
                listener.enterRevoke_from_cascade_restrict(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRevoke_from_cascade_restrict" ):
                listener.exitRevoke_from_cascade_restrict(self)




    def revoke_from_cascade_restrict(self):

        localctx = postgreSQLParser.Revoke_from_cascade_restrictContext(self, self._ctx, self.state)
        self.enterRule(localctx, 308, self.RULE_revoke_from_cascade_restrict)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3879
            self.match(postgreSQLParser.FROM)
            self.state = 3880
            self.roles_names()
            self.state = 3882
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 3881
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Roles_namesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def role_name_with_group(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Role_name_with_groupContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Role_name_with_groupContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_roles_names

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRoles_names" ):
                listener.enterRoles_names(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRoles_names" ):
                listener.exitRoles_names(self)




    def roles_names(self):

        localctx = postgreSQLParser.Roles_namesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 310, self.RULE_roles_names)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3884
            self.role_name_with_group()
            self.state = 3889
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 3885
                self.match(postgreSQLParser.COMMA)
                self.state = 3886
                self.role_name_with_group()
                self.state = 3891
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Role_name_with_groupContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_role_name_with_group

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRole_name_with_group" ):
                listener.enterRole_name_with_group(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRole_name_with_group" ):
                listener.exitRole_name_with_group(self)




    def role_name_with_group(self):

        localctx = postgreSQLParser.Role_name_with_groupContext(self, self._ctx, self.state)
        self.enterRule(localctx, 312, self.RULE_role_name_with_group)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3893
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.GROUP:
                self.state = 3892
                self.match(postgreSQLParser.GROUP)


            self.state = 3895
            self.user_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comment_on_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMENT(self):
            return self.getToken(postgreSQLParser.COMMENT, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def comment_member_object(self):
            return self.getTypedRuleContext(postgreSQLParser.Comment_member_objectContext,0)


        def IS(self):
            return self.getToken(postgreSQLParser.IS, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_comment_on_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment_on_statement" ):
                listener.enterComment_on_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment_on_statement" ):
                listener.exitComment_on_statement(self)




    def comment_on_statement(self):

        localctx = postgreSQLParser.Comment_on_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 314, self.RULE_comment_on_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3897
            self.match(postgreSQLParser.COMMENT)
            self.state = 3898
            self.match(postgreSQLParser.ON)
            self.state = 3899
            self.comment_member_object()
            self.state = 3900
            self.match(postgreSQLParser.IS)
            self.state = 3903
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.state = 3901
                self.character_string()
                pass
            elif token in [postgreSQLParser.NULL]:
                self.state = 3902
                self.match(postgreSQLParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Security_labelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SECURITY(self):
            return self.getToken(postgreSQLParser.SECURITY, 0)

        def LABEL(self):
            return self.getToken(postgreSQLParser.LABEL, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def label_member_object(self):
            return self.getTypedRuleContext(postgreSQLParser.Label_member_objectContext,0)


        def IS(self):
            return self.getToken(postgreSQLParser.IS, 0)

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_security_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSecurity_label" ):
                listener.enterSecurity_label(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSecurity_label" ):
                listener.exitSecurity_label(self)




    def security_label(self):

        localctx = postgreSQLParser.Security_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 316, self.RULE_security_label)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 3905
            self.match(postgreSQLParser.SECURITY)
            self.state = 3906
            self.match(postgreSQLParser.LABEL)
            self.state = 3912
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FOR:
                self.state = 3907
                self.match(postgreSQLParser.FOR)
                self.state = 3910
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 3908
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 3909
                    self.character_string()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 3914
            self.match(postgreSQLParser.ON)
            self.state = 3915
            self.label_member_object()
            self.state = 3916
            self.match(postgreSQLParser.IS)
            self.state = 3919
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.state = 3917
                self.character_string()
                pass
            elif token in [postgreSQLParser.NULL]:
                self.state = 3918
                self.match(postgreSQLParser.NULL)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comment_member_objectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.source = None # Data_typeContext
            self.target = None # Data_typeContext
            self.table_name = None # Schema_qualified_nameContext
            self.index_method = None # IdentifierContext

        def ACCESS(self):
            return self.getToken(postgreSQLParser.ACCESS, 0)

        def METHOD(self):
            return self.getToken(postgreSQLParser.METHOD, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def ROUTINE(self):
            return self.getToken(postgreSQLParser.ROUTINE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def CAST(self):
            return self.getToken(postgreSQLParser.CAST, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def CONVERSION(self):
            return self.getToken(postgreSQLParser.CONVERSION, 0)

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def LARGE(self):
            return self.getToken(postgreSQLParser.LARGE, 0)

        def OBJECT(self):
            return self.getToken(postgreSQLParser.OBJECT, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def target_operator(self):
            return self.getTypedRuleContext(postgreSQLParser.Target_operatorContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def CLASS(self):
            return self.getToken(postgreSQLParser.CLASS, 0)

        def POLICY(self):
            return self.getToken(postgreSQLParser.POLICY, 0)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def RULE(self):
            return self.getToken(postgreSQLParser.RULE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def STATISTICS(self):
            return self.getToken(postgreSQLParser.STATISTICS, 0)

        def SUBSCRIPTION(self):
            return self.getToken(postgreSQLParser.SUBSCRIPTION, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def TRANSFORM(self):
            return self.getToken(postgreSQLParser.TRANSFORM, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_comment_member_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComment_member_object" ):
                listener.enterComment_member_object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComment_member_object" ):
                listener.exitComment_member_object(self)




    def comment_member_object(self):

        localctx = postgreSQLParser.Comment_member_objectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 318, self.RULE_comment_member_object)
        self._la = 0 # Token type
        try:
            self.state = 4045
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,446,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 3921
                self.match(postgreSQLParser.ACCESS)
                self.state = 3922
                self.match(postgreSQLParser.METHOD)
                self.state = 3923
                self.identifier()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 3924
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.AGGREGATE or _la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE or _la==postgreSQLParser.ROUTINE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3925
                localctx.name = self.schema_qualified_name()
                self.state = 3926
                self.function_args()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 3928
                self.match(postgreSQLParser.CAST)
                self.state = 3929
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 3930
                localctx.source = self.data_type()
                self.state = 3931
                self.match(postgreSQLParser.AS)
                self.state = 3932
                localctx.target = self.data_type()
                self.state = 3933
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 3935
                self.match(postgreSQLParser.COLLATION)
                self.state = 3936
                self.identifier()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 3937
                self.match(postgreSQLParser.COLUMN)
                self.state = 3938
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 3939
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 3940
                self.identifier()
                self.state = 3941
                self.match(postgreSQLParser.ON)
                self.state = 3943
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,442,self._ctx)
                if la_ == 1:
                    self.state = 3942
                    self.match(postgreSQLParser.DOMAIN)


                self.state = 3945
                localctx.table_name = self.schema_qualified_name()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 3947
                self.match(postgreSQLParser.CONVERSION)
                self.state = 3948
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 3949
                self.match(postgreSQLParser.DATABASE)
                self.state = 3950
                self.identifier()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 3951
                self.match(postgreSQLParser.DOMAIN)
                self.state = 3952
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 3953
                self.match(postgreSQLParser.EXTENSION)
                self.state = 3954
                self.identifier()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 3955
                self.match(postgreSQLParser.EVENT)
                self.state = 3956
                self.match(postgreSQLParser.TRIGGER)
                self.state = 3957
                self.identifier()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 3958
                self.match(postgreSQLParser.FOREIGN)
                self.state = 3959
                self.match(postgreSQLParser.DATA)
                self.state = 3960
                self.match(postgreSQLParser.WRAPPER)
                self.state = 3961
                self.identifier()
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 3963
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOREIGN:
                    self.state = 3962
                    self.match(postgreSQLParser.FOREIGN)


                self.state = 3965
                self.match(postgreSQLParser.TABLE)
                self.state = 3966
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 3967
                self.match(postgreSQLParser.INDEX)
                self.state = 3968
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 3969
                self.match(postgreSQLParser.LARGE)
                self.state = 3970
                self.match(postgreSQLParser.OBJECT)
                self.state = 3971
                self.match(postgreSQLParser.NUMBER_LITERAL)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 3973
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.MATERIALIZED:
                    self.state = 3972
                    self.match(postgreSQLParser.MATERIALIZED)


                self.state = 3975
                self.match(postgreSQLParser.VIEW)
                self.state = 3976
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 3977
                self.match(postgreSQLParser.OPERATOR)
                self.state = 3978
                self.target_operator()
                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 3979
                self.match(postgreSQLParser.OPERATOR)
                self.state = 3980
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CLASS or _la==postgreSQLParser.FAMILY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 3981
                localctx.name = self.schema_qualified_name()
                self.state = 3982
                self.match(postgreSQLParser.USING)
                self.state = 3983
                localctx.index_method = self.identifier()
                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 3985
                self.match(postgreSQLParser.POLICY)
                self.state = 3986
                self.identifier()
                self.state = 3987
                self.match(postgreSQLParser.ON)
                self.state = 3988
                localctx.table_name = self.schema_qualified_name()
                pass

            elif la_ == 20:
                self.enterOuterAlt(localctx, 20)
                self.state = 3991
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PROCEDURAL:
                    self.state = 3990
                    self.match(postgreSQLParser.PROCEDURAL)


                self.state = 3993
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 3994
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 21:
                self.enterOuterAlt(localctx, 21)
                self.state = 3995
                self.match(postgreSQLParser.PUBLICATION)
                self.state = 3996
                self.identifier()
                pass

            elif la_ == 22:
                self.enterOuterAlt(localctx, 22)
                self.state = 3997
                self.match(postgreSQLParser.ROLE)
                self.state = 3998
                self.identifier()
                pass

            elif la_ == 23:
                self.enterOuterAlt(localctx, 23)
                self.state = 3999
                self.match(postgreSQLParser.RULE)
                self.state = 4000
                self.identifier()
                self.state = 4001
                self.match(postgreSQLParser.ON)
                self.state = 4002
                localctx.table_name = self.schema_qualified_name()
                pass

            elif la_ == 24:
                self.enterOuterAlt(localctx, 24)
                self.state = 4004
                self.match(postgreSQLParser.SCHEMA)
                self.state = 4005
                self.identifier()
                pass

            elif la_ == 25:
                self.enterOuterAlt(localctx, 25)
                self.state = 4006
                self.match(postgreSQLParser.SEQUENCE)
                self.state = 4007
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 26:
                self.enterOuterAlt(localctx, 26)
                self.state = 4008
                self.match(postgreSQLParser.SERVER)
                self.state = 4009
                self.identifier()
                pass

            elif la_ == 27:
                self.enterOuterAlt(localctx, 27)
                self.state = 4010
                self.match(postgreSQLParser.STATISTICS)
                self.state = 4011
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 28:
                self.enterOuterAlt(localctx, 28)
                self.state = 4012
                self.match(postgreSQLParser.SUBSCRIPTION)
                self.state = 4013
                self.identifier()
                pass

            elif la_ == 29:
                self.enterOuterAlt(localctx, 29)
                self.state = 4014
                self.match(postgreSQLParser.TABLESPACE)
                self.state = 4015
                self.identifier()
                pass

            elif la_ == 30:
                self.enterOuterAlt(localctx, 30)
                self.state = 4016
                self.match(postgreSQLParser.TEXT)
                self.state = 4017
                self.match(postgreSQLParser.SEARCH)
                self.state = 4018
                self.match(postgreSQLParser.CONFIGURATION)
                self.state = 4019
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 31:
                self.enterOuterAlt(localctx, 31)
                self.state = 4020
                self.match(postgreSQLParser.TEXT)
                self.state = 4021
                self.match(postgreSQLParser.SEARCH)
                self.state = 4022
                self.match(postgreSQLParser.DICTIONARY)
                self.state = 4023
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 32:
                self.enterOuterAlt(localctx, 32)
                self.state = 4024
                self.match(postgreSQLParser.TEXT)
                self.state = 4025
                self.match(postgreSQLParser.SEARCH)
                self.state = 4026
                self.match(postgreSQLParser.PARSER)
                self.state = 4027
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 33:
                self.enterOuterAlt(localctx, 33)
                self.state = 4028
                self.match(postgreSQLParser.TEXT)
                self.state = 4029
                self.match(postgreSQLParser.SEARCH)
                self.state = 4030
                self.match(postgreSQLParser.TEMPLATE)
                self.state = 4031
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 34:
                self.enterOuterAlt(localctx, 34)
                self.state = 4032
                self.match(postgreSQLParser.TRANSFORM)
                self.state = 4033
                self.match(postgreSQLParser.FOR)
                self.state = 4034
                localctx.name = self.schema_qualified_name()
                self.state = 4035
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 4036
                self.identifier()
                pass

            elif la_ == 35:
                self.enterOuterAlt(localctx, 35)
                self.state = 4038
                self.match(postgreSQLParser.TRIGGER)
                self.state = 4039
                self.identifier()
                self.state = 4040
                self.match(postgreSQLParser.ON)
                self.state = 4041
                localctx.table_name = self.schema_qualified_name()
                pass

            elif la_ == 36:
                self.enterOuterAlt(localctx, 36)
                self.state = 4043
                self.match(postgreSQLParser.TYPE)
                self.state = 4044
                localctx.name = self.schema_qualified_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Label_member_objectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def ROUTINE(self):
            return self.getToken(postgreSQLParser.ROUTINE, 0)

        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def LARGE(self):
            return self.getToken(postgreSQLParser.LARGE, 0)

        def OBJECT(self):
            return self.getToken(postgreSQLParser.OBJECT, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def SUBSCRIPTION(self):
            return self.getToken(postgreSQLParser.SUBSCRIPTION, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_label_member_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLabel_member_object" ):
                listener.enterLabel_member_object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLabel_member_object" ):
                listener.exitLabel_member_object(self)




    def label_member_object(self):

        localctx = postgreSQLParser.Label_member_objectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 320, self.RULE_label_member_object)
        self._la = 0 # Token type
        try:
            self.state = 4092
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.AGGREGATE, postgreSQLParser.FUNCTION, postgreSQLParser.PROCEDURE, postgreSQLParser.ROUTINE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4047
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.AGGREGATE or _la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE or _la==postgreSQLParser.ROUTINE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4048
                self.schema_qualified_name()
                self.state = 4049
                self.function_args()
                pass
            elif token in [postgreSQLParser.COLUMN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4051
                self.match(postgreSQLParser.COLUMN)
                self.state = 4052
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.DATABASE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4053
                self.match(postgreSQLParser.DATABASE)
                self.state = 4054
                self.identifier()
                pass
            elif token in [postgreSQLParser.DOMAIN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 4055
                self.match(postgreSQLParser.DOMAIN)
                self.state = 4056
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.EVENT]:
                self.enterOuterAlt(localctx, 5)
                self.state = 4057
                self.match(postgreSQLParser.EVENT)
                self.state = 4058
                self.match(postgreSQLParser.TRIGGER)
                self.state = 4059
                self.identifier()
                pass
            elif token in [postgreSQLParser.FOREIGN, postgreSQLParser.TABLE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 4061
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOREIGN:
                    self.state = 4060
                    self.match(postgreSQLParser.FOREIGN)


                self.state = 4063
                self.match(postgreSQLParser.TABLE)
                self.state = 4064
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.LARGE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 4065
                self.match(postgreSQLParser.LARGE)
                self.state = 4066
                self.match(postgreSQLParser.OBJECT)
                self.state = 4067
                self.match(postgreSQLParser.NUMBER_LITERAL)
                pass
            elif token in [postgreSQLParser.MATERIALIZED, postgreSQLParser.VIEW]:
                self.enterOuterAlt(localctx, 8)
                self.state = 4069
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.MATERIALIZED:
                    self.state = 4068
                    self.match(postgreSQLParser.MATERIALIZED)


                self.state = 4071
                self.match(postgreSQLParser.VIEW)
                self.state = 4072
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.LANGUAGE, postgreSQLParser.PROCEDURAL]:
                self.enterOuterAlt(localctx, 9)
                self.state = 4074
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PROCEDURAL:
                    self.state = 4073
                    self.match(postgreSQLParser.PROCEDURAL)


                self.state = 4076
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 4077
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.PUBLICATION]:
                self.enterOuterAlt(localctx, 10)
                self.state = 4078
                self.match(postgreSQLParser.PUBLICATION)
                self.state = 4079
                self.identifier()
                pass
            elif token in [postgreSQLParser.ROLE]:
                self.enterOuterAlt(localctx, 11)
                self.state = 4080
                self.match(postgreSQLParser.ROLE)
                self.state = 4081
                self.identifier()
                pass
            elif token in [postgreSQLParser.SCHEMA]:
                self.enterOuterAlt(localctx, 12)
                self.state = 4082
                self.match(postgreSQLParser.SCHEMA)
                self.state = 4083
                self.identifier()
                pass
            elif token in [postgreSQLParser.SEQUENCE]:
                self.enterOuterAlt(localctx, 13)
                self.state = 4084
                self.match(postgreSQLParser.SEQUENCE)
                self.state = 4085
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.SUBSCRIPTION]:
                self.enterOuterAlt(localctx, 14)
                self.state = 4086
                self.match(postgreSQLParser.SUBSCRIPTION)
                self.state = 4087
                self.identifier()
                pass
            elif token in [postgreSQLParser.TABLESPACE]:
                self.enterOuterAlt(localctx, 15)
                self.state = 4088
                self.match(postgreSQLParser.TABLESPACE)
                self.state = 4089
                self.identifier()
                pass
            elif token in [postgreSQLParser.TYPE]:
                self.enterOuterAlt(localctx, 16)
                self.state = 4090
                self.match(postgreSQLParser.TYPE)
                self.state = 4091
                self.schema_qualified_name()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_function_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.rettype_data = None # Data_typeContext
            self.ret_table = None # Function_ret_tableContext

        def function_parameters(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_parametersContext,0)


        def create_funct_params(self):
            return self.getTypedRuleContext(postgreSQLParser.Create_funct_paramsContext,0)


        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def RETURNS(self):
            return self.getToken(postgreSQLParser.RETURNS, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def function_ret_table(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_ret_tableContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_function_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_function_statement" ):
                listener.enterCreate_function_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_function_statement" ):
                listener.exitCreate_function_statement(self)




    def create_function_statement(self):

        localctx = postgreSQLParser.Create_function_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 322, self.RULE_create_function_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4096
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OR:
                self.state = 4094
                self.match(postgreSQLParser.OR)
                self.state = 4095
                self.match(postgreSQLParser.REPLACE)


            self.state = 4098
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 4099
            self.function_parameters()
            self.state = 4105
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,453,self._ctx)
            if la_ == 1:
                self.state = 4100
                self.match(postgreSQLParser.RETURNS)
                self.state = 4103
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 4101
                    localctx.rettype_data = self.data_type()
                    pass
                elif token in [postgreSQLParser.TABLE]:
                    self.state = 4102
                    localctx.ret_table = self.function_ret_table()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 4107
            self.create_funct_params()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_funct_paramsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_actions_common(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_actions_commonContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_actions_commonContext,i)


        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_funct_params

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_funct_params" ):
                listener.enterCreate_funct_params(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_funct_params" ):
                listener.exitCreate_funct_params(self)




    def create_funct_params(self):

        localctx = postgreSQLParser.Create_funct_paramsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 324, self.RULE_create_funct_params)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4110 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 4109
                self.function_actions_common()
                self.state = 4112 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==postgreSQLParser.CALLED or _la==postgreSQLParser.COST or ((((_la - 86)) & ~0x3f) == 0 and ((1 << (_la - 86)) & ((1 << (postgreSQLParser.EXTERNAL - 86)) | (1 << (postgreSQLParser.IMMUTABLE - 86)) | (1 << (postgreSQLParser.LANGUAGE - 86)) | (1 << (postgreSQLParser.LEAKPROOF - 86)))) != 0) or ((((_la - 175)) & ~0x3f) == 0 and ((1 << (_la - 175)) & ((1 << (postgreSQLParser.PARALLEL - 175)) | (1 << (postgreSQLParser.RETURNS - 175)) | (1 << (postgreSQLParser.ROWS - 175)) | (1 << (postgreSQLParser.SECURITY - 175)) | (1 << (postgreSQLParser.SET - 175)))) != 0) or ((((_la - 242)) & ~0x3f) == 0 and ((1 << (_la - 242)) & ((1 << (postgreSQLParser.STABLE - 242)) | (1 << (postgreSQLParser.STRICT - 242)) | (1 << (postgreSQLParser.SUPPORT - 242)) | (1 << (postgreSQLParser.TRANSFORM - 242)) | (1 << (postgreSQLParser.VOLATILE - 242)))) != 0) or _la==postgreSQLParser.AS or _la==postgreSQLParser.NOT or _la==postgreSQLParser.WINDOW):
                    break

            self.state = 4115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 4114
                self.with_storage_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Transform_for_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_transform_for_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransform_for_type" ):
                listener.enterTransform_for_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransform_for_type" ):
                listener.exitTransform_for_type(self)




    def transform_for_type(self):

        localctx = postgreSQLParser.Transform_for_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 326, self.RULE_transform_for_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4117
            self.match(postgreSQLParser.FOR)
            self.state = 4118
            self.match(postgreSQLParser.TYPE)
            self.state = 4119
            self.data_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_ret_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def function_column_name_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_column_name_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_column_name_typeContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_ret_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_ret_table" ):
                listener.enterFunction_ret_table(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_ret_table" ):
                listener.exitFunction_ret_table(self)




    def function_ret_table(self):

        localctx = postgreSQLParser.Function_ret_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 328, self.RULE_function_ret_table)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4121
            self.match(postgreSQLParser.TABLE)
            self.state = 4122
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 4123
            self.function_column_name_type()
            self.state = 4128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 4124
                self.match(postgreSQLParser.COMMA)
                self.state = 4125
                self.function_column_name_type()
                self.state = 4130
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 4131
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_column_name_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_column_name_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_column_name_type" ):
                listener.enterFunction_column_name_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_column_name_type" ):
                listener.exitFunction_column_name_type(self)




    def function_column_name_type(self):

        localctx = postgreSQLParser.Function_column_name_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 330, self.RULE_function_column_name_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4133
            self.identifier()
            self.state = 4134
            self.data_type()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_parametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_parameters" ):
                listener.enterFunction_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_parameters" ):
                listener.exitFunction_parameters(self)




    def function_parameters(self):

        localctx = postgreSQLParser.Function_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 332, self.RULE_function_parameters)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4136
            self.schema_qualified_name()
            self.state = 4137
            self.function_args()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_argsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def function_arguments(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_argumentsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_argumentsContext,i)


        def agg_order(self):
            return self.getTypedRuleContext(postgreSQLParser.Agg_orderContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_args

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_args" ):
                listener.enterFunction_args(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_args" ):
                listener.exitFunction_args(self)




    def function_args(self):

        localctx = postgreSQLParser.Function_argsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 334, self.RULE_function_args)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4139
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 4154
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.IN, postgreSQLParser.ORDER, postgreSQLParser.VARIADIC, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.RIGHT_PAREN, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 4148
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)))) != 0) or ((((_la - 412)) & ~0x3f) == 0 and ((1 << (_la - 412)) & ((1 << (postgreSQLParser.IN - 412)) | (1 << (postgreSQLParser.VARIADIC - 412)) | (1 << (postgreSQLParser.ALIGNMENT - 412)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 412)) | (1 << (postgreSQLParser.BASETYPE - 412)) | (1 << (postgreSQLParser.BUFFERS - 412)) | (1 << (postgreSQLParser.BYPASSRLS - 412)) | (1 << (postgreSQLParser.CANONICAL - 412)) | (1 << (postgreSQLParser.CATEGORY - 412)) | (1 << (postgreSQLParser.COLLATABLE - 412)) | (1 << (postgreSQLParser.COMBINEFUNC - 412)) | (1 << (postgreSQLParser.COMMUTATOR - 412)) | (1 << (postgreSQLParser.CONNECT - 412)) | (1 << (postgreSQLParser.COSTS - 412)) | (1 << (postgreSQLParser.CREATEDB - 412)) | (1 << (postgreSQLParser.CREATEROLE - 412)) | (1 << (postgreSQLParser.DESERIALFUNC - 412)) | (1 << (postgreSQLParser.DETERMINISTIC - 412)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 412)) | (1 << (postgreSQLParser.ELEMENT - 412)) | (1 << (postgreSQLParser.EXTENDED - 412)) | (1 << (postgreSQLParser.FINALFUNC - 412)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 412)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 412)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 412)) | (1 << (postgreSQLParser.FORCE_NULL - 412)) | (1 << (postgreSQLParser.FORCE_QUOTE - 412)) | (1 << (postgreSQLParser.FORMAT - 412)))) != 0) or ((((_la - 476)) & ~0x3f) == 0 and ((1 << (_la - 476)) & ((1 << (postgreSQLParser.GETTOKEN - 476)) | (1 << (postgreSQLParser.HASH - 476)) | (1 << (postgreSQLParser.HASHES - 476)) | (1 << (postgreSQLParser.HEADLINE - 476)) | (1 << (postgreSQLParser.HYPOTHETICAL - 476)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 476)) | (1 << (postgreSQLParser.INIT - 476)) | (1 << (postgreSQLParser.INITCOND - 476)) | (1 << (postgreSQLParser.INTERNALLENGTH - 476)) | (1 << (postgreSQLParser.IS_TEMPLATE - 476)) | (1 << (postgreSQLParser.JSON - 476)) | (1 << (postgreSQLParser.LC_COLLATE - 476)) | (1 << (postgreSQLParser.LC_CTYPE - 476)) | (1 << (postgreSQLParser.LEFTARG - 476)) | (1 << (postgreSQLParser.LEXIZE - 476)) | (1 << (postgreSQLParser.LEXTYPES - 476)) | (1 << (postgreSQLParser.LIST - 476)) | (1 << (postgreSQLParser.LOCALE - 476)) | (1 << (postgreSQLParser.LOGIN - 476)) | (1 << (postgreSQLParser.MAIN - 476)) | (1 << (postgreSQLParser.MERGES - 476)) | (1 << (postgreSQLParser.MFINALFUNC - 476)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 476)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 476)) | (1 << (postgreSQLParser.MINITCOND - 476)) | (1 << (postgreSQLParser.MINVFUNC - 476)) | (1 << (postgreSQLParser.MODULUS - 476)) | (1 << (postgreSQLParser.MSFUNC - 476)) | (1 << (postgreSQLParser.MSSPACE - 476)) | (1 << (postgreSQLParser.MSTYPE - 476)) | (1 << (postgreSQLParser.NEGATOR - 476)) | (1 << (postgreSQLParser.NOBYPASSRLS - 476)) | (1 << (postgreSQLParser.NOCREATEDB - 476)) | (1 << (postgreSQLParser.NOCREATEROLE - 476)) | (1 << (postgreSQLParser.NOINHERIT - 476)) | (1 << (postgreSQLParser.NOLOGIN - 476)) | (1 << (postgreSQLParser.NOREPLICATION - 476)) | (1 << (postgreSQLParser.NOSUPERUSER - 476)) | (1 << (postgreSQLParser.OUTPUT - 476)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 476)) | (1 << (postgreSQLParser.PATH - 476)) | (1 << (postgreSQLParser.PERMISSIVE - 476)) | (1 << (postgreSQLParser.PLAIN - 476)) | (1 << (postgreSQLParser.PREFERRED - 476)) | (1 << (postgreSQLParser.PROVIDER - 476)) | (1 << (postgreSQLParser.READ_ONLY - 476)) | (1 << (postgreSQLParser.READ_WRITE - 476)) | (1 << (postgreSQLParser.RECEIVE - 476)) | (1 << (postgreSQLParser.REMAINDER - 476)) | (1 << (postgreSQLParser.REPLICATION - 476)) | (1 << (postgreSQLParser.RESTRICTED - 476)) | (1 << (postgreSQLParser.RESTRICTIVE - 476)) | (1 << (postgreSQLParser.RIGHTARG - 476)) | (1 << (postgreSQLParser.SAFE - 476)) | (1 << (postgreSQLParser.SEND - 476)) | (1 << (postgreSQLParser.SERIALFUNC - 476)) | (1 << (postgreSQLParser.SETTINGS - 476)) | (1 << (postgreSQLParser.SFUNC - 476)) | (1 << (postgreSQLParser.SHAREABLE - 476)) | (1 << (postgreSQLParser.SKIP_LOCKED - 476)) | (1 << (postgreSQLParser.SORTOP - 476)) | (1 << (postgreSQLParser.SSPACE - 476)) | (1 << (postgreSQLParser.STYPE - 476)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 476)))) != 0) or ((((_la - 540)) & ~0x3f) == 0 and ((1 << (_la - 540)) & ((1 << (postgreSQLParser.SUBTYPE_OPCLASS - 540)) | (1 << (postgreSQLParser.SUBTYPE - 540)) | (1 << (postgreSQLParser.SUMMARY - 540)) | (1 << (postgreSQLParser.SUPERUSER - 540)) | (1 << (postgreSQLParser.TIMING - 540)) | (1 << (postgreSQLParser.TYPMOD_IN - 540)) | (1 << (postgreSQLParser.TYPMOD_OUT - 540)) | (1 << (postgreSQLParser.UNSAFE - 540)) | (1 << (postgreSQLParser.USAGE - 540)) | (1 << (postgreSQLParser.VARIABLE - 540)) | (1 << (postgreSQLParser.WAL - 540)) | (1 << (postgreSQLParser.YAML - 540)) | (1 << (postgreSQLParser.ALIAS - 540)) | (1 << (postgreSQLParser.ASSERT - 540)) | (1 << (postgreSQLParser.CONSTANT - 540)) | (1 << (postgreSQLParser.DATATYPE - 540)) | (1 << (postgreSQLParser.DEBUG - 540)) | (1 << (postgreSQLParser.DETAIL - 540)) | (1 << (postgreSQLParser.DIAGNOSTICS - 540)) | (1 << (postgreSQLParser.ELSEIF - 540)) | (1 << (postgreSQLParser.ELSIF - 540)) | (1 << (postgreSQLParser.ERRCODE - 540)) | (1 << (postgreSQLParser.EXIT - 540)) | (1 << (postgreSQLParser.EXCEPTION - 540)) | (1 << (postgreSQLParser.FOREACH - 540)) | (1 << (postgreSQLParser.GET - 540)) | (1 << (postgreSQLParser.HINT - 540)) | (1 << (postgreSQLParser.INFO - 540)) | (1 << (postgreSQLParser.LOG - 540)) | (1 << (postgreSQLParser.LOOP - 540)) | (1 << (postgreSQLParser.MESSAGE - 540)) | (1 << (postgreSQLParser.NOTICE - 540)) | (1 << (postgreSQLParser.OPEN - 540)) | (1 << (postgreSQLParser.PERFORM - 540)) | (1 << (postgreSQLParser.QUERY - 540)) | (1 << (postgreSQLParser.RAISE - 540)) | (1 << (postgreSQLParser.RECORD - 540)) | (1 << (postgreSQLParser.RETURN - 540)) | (1 << (postgreSQLParser.REVERSE - 540)) | (1 << (postgreSQLParser.ROWTYPE - 540)) | (1 << (postgreSQLParser.SLICE - 540)) | (1 << (postgreSQLParser.SQLSTATE - 540)) | (1 << (postgreSQLParser.STACKED - 540)) | (1 << (postgreSQLParser.WARNING - 540)) | (1 << (postgreSQLParser.WHILE - 540)))) != 0) or _la==postgreSQLParser.Identifier or _la==postgreSQLParser.QuotedIdentifier:
                    self.state = 4140
                    self.function_arguments()
                    self.state = 4145
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 4141
                        self.match(postgreSQLParser.COMMA)
                        self.state = 4142
                        self.function_arguments()
                        self.state = 4147
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 4151
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ORDER:
                    self.state = 4150
                    self.agg_order()


                pass
            elif token in [postgreSQLParser.MULTIPLY]:
                self.state = 4153
                self.match(postgreSQLParser.MULTIPLY)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4156
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Agg_orderContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(postgreSQLParser.ORDER, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def function_arguments(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_argumentsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_argumentsContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_agg_order

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAgg_order" ):
                listener.enterAgg_order(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAgg_order" ):
                listener.exitAgg_order(self)




    def agg_order(self):

        localctx = postgreSQLParser.Agg_orderContext(self, self._ctx, self.state)
        self.enterRule(localctx, 336, self.RULE_agg_order)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4158
            self.match(postgreSQLParser.ORDER)
            self.state = 4159
            self.match(postgreSQLParser.BY)
            self.state = 4160
            self.function_arguments()
            self.state = 4165
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 4161
                self.match(postgreSQLParser.COMMA)
                self.state = 4162
                self.function_arguments()
                self.state = 4167
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Character_stringContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BeginDollarStringConstant(self):
            return self.getToken(postgreSQLParser.BeginDollarStringConstant, 0)

        def EndDollarStringConstant(self):
            return self.getToken(postgreSQLParser.EndDollarStringConstant, 0)

        def Text_between_Dollar(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.Text_between_Dollar)
            else:
                return self.getToken(postgreSQLParser.Text_between_Dollar, i)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_character_string

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCharacter_string" ):
                listener.enterCharacter_string(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCharacter_string" ):
                listener.exitCharacter_string(self)




    def character_string(self):

        localctx = postgreSQLParser.Character_stringContext(self, self._ctx, self.state)
        self.enterRule(localctx, 338, self.RULE_character_string)
        self._la = 0 # Token type
        try:
            self.state = 4177
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.BeginDollarStringConstant]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4168
                self.match(postgreSQLParser.BeginDollarStringConstant)
                self.state = 4172
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.Text_between_Dollar:
                    self.state = 4169
                    self.match(postgreSQLParser.Text_between_Dollar)
                    self.state = 4174
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 4175
                self.match(postgreSQLParser.EndDollarStringConstant)
                pass
            elif token in [postgreSQLParser.Character_String_Literal]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4176
                self.match(postgreSQLParser.Character_String_Literal)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_argumentsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def argmode(self):
            return self.getTypedRuleContext(postgreSQLParser.ArgmodeContext,0)


        def identifier_nontype(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_nontypeContext,0)


        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_arguments

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_arguments" ):
                listener.enterFunction_arguments(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_arguments" ):
                listener.exitFunction_arguments(self)




    def function_arguments(self):

        localctx = postgreSQLParser.Function_argumentsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 340, self.RULE_function_arguments)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4180
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,464,self._ctx)
            if la_ == 1:
                self.state = 4179
                self.argmode()


            self.state = 4183
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,465,self._ctx)
            if la_ == 1:
                self.state = 4182
                self.identifier_nontype()


            self.state = 4185
            self.data_type()
            self.state = 4188
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DEFAULT or _la==postgreSQLParser.EQUAL:
                self.state = 4186
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DEFAULT or _la==postgreSQLParser.EQUAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4187
                self.vex(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ArgmodeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def OUT(self):
            return self.getToken(postgreSQLParser.OUT, 0)

        def INOUT(self):
            return self.getToken(postgreSQLParser.INOUT, 0)

        def VARIADIC(self):
            return self.getToken(postgreSQLParser.VARIADIC, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_argmode

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArgmode" ):
                listener.enterArgmode(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArgmode" ):
                listener.exitArgmode(self)




    def argmode(self):

        localctx = postgreSQLParser.ArgmodeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 342, self.RULE_argmode)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4190
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.INOUT or _la==postgreSQLParser.OUT or _la==postgreSQLParser.IN or _la==postgreSQLParser.VARIADIC):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_sequence_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def sequence_body(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Sequence_bodyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Sequence_bodyContext,i)


        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_sequence_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_sequence_statement" ):
                listener.enterCreate_sequence_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_sequence_statement" ):
                listener.exitCreate_sequence_statement(self)




    def create_sequence_statement(self):

        localctx = postgreSQLParser.Create_sequence_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 344, self.RULE_create_sequence_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4193
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY:
                self.state = 4192
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 4195
            self.match(postgreSQLParser.SEQUENCE)
            self.state = 4197
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,468,self._ctx)
            if la_ == 1:
                self.state = 4196
                self.if_not_exists()


            self.state = 4199
            localctx.name = self.schema_qualified_name()
            self.state = 4203
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.CACHE or _la==postgreSQLParser.CYCLE or ((((_la - 111)) & ~0x3f) == 0 and ((1 << (_la - 111)) & ((1 << (postgreSQLParser.INCREMENT - 111)) | (1 << (postgreSQLParser.MAXVALUE - 111)) | (1 << (postgreSQLParser.MINVALUE - 111)) | (1 << (postgreSQLParser.NO - 111)) | (1 << (postgreSQLParser.OWNED - 111)))) != 0) or _la==postgreSQLParser.SEQUENCE or _la==postgreSQLParser.START or _la==postgreSQLParser.AS:
                self.state = 4200
                self.sequence_body()
                self.state = 4205
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sequence_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.d_type = None # Token
            self.name = None # Schema_qualified_nameContext
            self.incr = None # Signed_numerical_literalContext
            self.minval = None # Signed_numerical_literalContext
            self.maxval = None # Signed_numerical_literalContext
            self.start_val = None # Signed_numerical_literalContext
            self.cache_val = None # Signed_numerical_literalContext
            self.cycle_true = None # Token
            self.cycle_val = None # Token
            self.col_name = None # Schema_qualified_nameContext

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def SMALLINT(self):
            return self.getToken(postgreSQLParser.SMALLINT, 0)

        def INTEGER(self):
            return self.getToken(postgreSQLParser.INTEGER, 0)

        def BIGINT(self):
            return self.getToken(postgreSQLParser.BIGINT, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def NAME(self):
            return self.getToken(postgreSQLParser.NAME, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def INCREMENT(self):
            return self.getToken(postgreSQLParser.INCREMENT, 0)

        def signed_numerical_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Signed_numerical_literalContext,0)


        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def MINVALUE(self):
            return self.getToken(postgreSQLParser.MINVALUE, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def MAXVALUE(self):
            return self.getToken(postgreSQLParser.MAXVALUE, 0)

        def START(self):
            return self.getToken(postgreSQLParser.START, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def CACHE(self):
            return self.getToken(postgreSQLParser.CACHE, 0)

        def CYCLE(self):
            return self.getToken(postgreSQLParser.CYCLE, 0)

        def OWNED(self):
            return self.getToken(postgreSQLParser.OWNED, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_sequence_body

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSequence_body" ):
                listener.enterSequence_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSequence_body" ):
                listener.exitSequence_body(self)




    def sequence_body(self):

        localctx = postgreSQLParser.Sequence_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 346, self.RULE_sequence_body)
        self._la = 0 # Token type
        try:
            self.state = 4242
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,475,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4206
                self.match(postgreSQLParser.AS)
                self.state = 4207
                localctx.d_type = self._input.LT(1)
                _la = self._input.LA(1)
                if not(((((_la - 301)) & ~0x3f) == 0 and ((1 << (_la - 301)) & ((1 << (postgreSQLParser.BIGINT - 301)) | (1 << (postgreSQLParser.INTEGER - 301)) | (1 << (postgreSQLParser.SMALLINT - 301)))) != 0)):
                    localctx.d_type = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4208
                self.match(postgreSQLParser.SEQUENCE)
                self.state = 4209
                self.match(postgreSQLParser.NAME)
                self.state = 4210
                localctx.name = self.schema_qualified_name()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4211
                self.match(postgreSQLParser.INCREMENT)
                self.state = 4213
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.BY:
                    self.state = 4212
                    self.match(postgreSQLParser.BY)


                self.state = 4215
                localctx.incr = self.signed_numerical_literal()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4220
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.MINVALUE]:
                    self.state = 4216
                    self.match(postgreSQLParser.MINVALUE)
                    self.state = 4217
                    localctx.minval = self.signed_numerical_literal()
                    pass
                elif token in [postgreSQLParser.NO]:
                    self.state = 4218
                    self.match(postgreSQLParser.NO)
                    self.state = 4219
                    self.match(postgreSQLParser.MINVALUE)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4226
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.MAXVALUE]:
                    self.state = 4222
                    self.match(postgreSQLParser.MAXVALUE)
                    self.state = 4223
                    localctx.maxval = self.signed_numerical_literal()
                    pass
                elif token in [postgreSQLParser.NO]:
                    self.state = 4224
                    self.match(postgreSQLParser.NO)
                    self.state = 4225
                    self.match(postgreSQLParser.MAXVALUE)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4228
                self.match(postgreSQLParser.START)
                self.state = 4230
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4229
                    self.match(postgreSQLParser.WITH)


                self.state = 4232
                localctx.start_val = self.signed_numerical_literal()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 4233
                self.match(postgreSQLParser.CACHE)
                self.state = 4234
                localctx.cache_val = self.signed_numerical_literal()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 4236
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 4235
                    localctx.cycle_true = self.match(postgreSQLParser.NO)


                self.state = 4238
                localctx.cycle_val = self.match(postgreSQLParser.CYCLE)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 4239
                self.match(postgreSQLParser.OWNED)
                self.state = 4240
                self.match(postgreSQLParser.BY)
                self.state = 4241
                localctx.col_name = self.schema_qualified_name()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_number_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def sign(self):
            return self.getTypedRuleContext(postgreSQLParser.SignContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_signed_number_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_number_literal" ):
                listener.enterSigned_number_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_number_literal" ):
                listener.exitSigned_number_literal(self)




    def signed_number_literal(self):

        localctx = postgreSQLParser.Signed_number_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 348, self.RULE_signed_number_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4245
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS:
                self.state = 4244
                self.sign()


            self.state = 4247
            self.match(postgreSQLParser.NUMBER_LITERAL)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Signed_numerical_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_numeric_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_numeric_literalContext,0)


        def sign(self):
            return self.getTypedRuleContext(postgreSQLParser.SignContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_signed_numerical_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSigned_numerical_literal" ):
                listener.enterSigned_numerical_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSigned_numerical_literal" ):
                listener.exitSigned_numerical_literal(self)




    def signed_numerical_literal(self):

        localctx = postgreSQLParser.Signed_numerical_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 350, self.RULE_signed_numerical_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4250
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS:
                self.state = 4249
                self.sign()


            self.state = 4252
            self.unsigned_numeric_literal()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class SignContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PLUS(self):
            return self.getToken(postgreSQLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(postgreSQLParser.MINUS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_sign

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSign" ):
                listener.enterSign(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSign" ):
                listener.exitSign(self)




    def sign(self):

        localctx = postgreSQLParser.SignContext(self, self._ctx, self.state)
        self.enterRule(localctx, 352, self.RULE_sign)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4254
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_schema_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.schname = None # IdentifierContext

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def AUTHORIZATION(self):
            return self.getToken(postgreSQLParser.AUTHORIZATION, 0)

        def user_name(self):
            return self.getTypedRuleContext(postgreSQLParser.User_nameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_schema_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_schema_statement" ):
                listener.enterCreate_schema_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_schema_statement" ):
                listener.exitCreate_schema_statement(self)




    def create_schema_statement(self):

        localctx = postgreSQLParser.Create_schema_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 354, self.RULE_create_schema_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4256
            self.match(postgreSQLParser.SCHEMA)
            self.state = 4258
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,478,self._ctx)
            if la_ == 1:
                self.state = 4257
                self.if_not_exists()


            self.state = 4261
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 4260
                localctx.schname = self.identifier()


            self.state = 4265
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.AUTHORIZATION:
                self.state = 4263
                self.match(postgreSQLParser.AUTHORIZATION)
                self.state = 4264
                self.user_name()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_policy_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.event = None # Token
            self.using = None # VexContext
            self.check = None # VexContext

        def POLICY(self):
            return self.getToken(postgreSQLParser.POLICY, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def user_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.User_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.User_nameContext,i)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def CHECK(self):
            return self.getToken(postgreSQLParser.CHECK, 0)

        def PERMISSIVE(self):
            return self.getToken(postgreSQLParser.PERMISSIVE, 0)

        def RESTRICTIVE(self):
            return self.getToken(postgreSQLParser.RESTRICTIVE, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def INSERT(self):
            return self.getToken(postgreSQLParser.INSERT, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_policy_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_policy_statement" ):
                listener.enterCreate_policy_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_policy_statement" ):
                listener.exitCreate_policy_statement(self)




    def create_policy_statement(self):

        localctx = postgreSQLParser.Create_policy_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 356, self.RULE_create_policy_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4267
            self.match(postgreSQLParser.POLICY)
            self.state = 4268
            self.identifier()
            self.state = 4269
            self.match(postgreSQLParser.ON)
            self.state = 4270
            self.schema_qualified_name()
            self.state = 4273
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.AS:
                self.state = 4271
                self.match(postgreSQLParser.AS)
                self.state = 4272
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.PERMISSIVE or _la==postgreSQLParser.RESTRICTIVE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 4277
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FOR:
                self.state = 4275
                self.match(postgreSQLParser.FOR)
                self.state = 4276
                localctx.event = self._input.LT(1)
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DELETE or _la==postgreSQLParser.INSERT or _la==postgreSQLParser.UPDATE or _la==postgreSQLParser.ALL or _la==postgreSQLParser.SELECT):
                    localctx.event = self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 4288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TO:
                self.state = 4279
                self.match(postgreSQLParser.TO)
                self.state = 4280
                self.user_name()
                self.state = 4285
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 4281
                    self.match(postgreSQLParser.COMMA)
                    self.state = 4282
                    self.user_name()
                    self.state = 4287
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 4292
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 4290
                self.match(postgreSQLParser.USING)
                self.state = 4291
                localctx.using = self.vex(0)


            self.state = 4297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 4294
                self.match(postgreSQLParser.WITH)
                self.state = 4295
                self.match(postgreSQLParser.CHECK)
                self.state = 4296
                localctx.check = self.vex(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_policy_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POLICY(self):
            return self.getToken(postgreSQLParser.POLICY, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def user_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.User_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.User_nameContext,i)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def CHECK(self):
            return self.getToken(postgreSQLParser.CHECK, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_policy_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_policy_statement" ):
                listener.enterAlter_policy_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_policy_statement" ):
                listener.exitAlter_policy_statement(self)




    def alter_policy_statement(self):

        localctx = postgreSQLParser.Alter_policy_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 358, self.RULE_alter_policy_statement)
        self._la = 0 # Token type
        try:
            self.state = 4329
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,491,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4299
                self.match(postgreSQLParser.POLICY)
                self.state = 4300
                self.identifier()
                self.state = 4301
                self.match(postgreSQLParser.ON)
                self.state = 4302
                self.schema_qualified_name()
                self.state = 4303
                self.rename_to()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4305
                self.match(postgreSQLParser.POLICY)
                self.state = 4306
                self.identifier()
                self.state = 4307
                self.match(postgreSQLParser.ON)
                self.state = 4308
                self.schema_qualified_name()
                self.state = 4318
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.TO:
                    self.state = 4309
                    self.match(postgreSQLParser.TO)
                    self.state = 4310
                    self.user_name()
                    self.state = 4315
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 4311
                        self.match(postgreSQLParser.COMMA)
                        self.state = 4312
                        self.user_name()
                        self.state = 4317
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 4322
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.USING:
                    self.state = 4320
                    self.match(postgreSQLParser.USING)
                    self.state = 4321
                    self.vex(0)


                self.state = 4327
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4324
                    self.match(postgreSQLParser.WITH)
                    self.state = 4325
                    self.match(postgreSQLParser.CHECK)
                    self.state = 4326
                    self.vex(0)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_policy_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def POLICY(self):
            return self.getToken(postgreSQLParser.POLICY, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_policy_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_policy_statement" ):
                listener.enterDrop_policy_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_policy_statement" ):
                listener.exitDrop_policy_statement(self)




    def drop_policy_statement(self):

        localctx = postgreSQLParser.Drop_policy_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 360, self.RULE_drop_policy_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4331
            self.match(postgreSQLParser.POLICY)
            self.state = 4333
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,492,self._ctx)
            if la_ == 1:
                self.state = 4332
                self.if_exists()


            self.state = 4335
            self.identifier()
            self.state = 4336
            self.match(postgreSQLParser.ON)
            self.state = 4337
            self.schema_qualified_name()
            self.state = 4339
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 4338
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_subscription_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBSCRIPTION(self):
            return self.getToken(postgreSQLParser.SUBSCRIPTION, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def CONNECTION(self):
            return self.getToken(postgreSQLParser.CONNECTION, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_subscription_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_subscription_statement" ):
                listener.enterCreate_subscription_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_subscription_statement" ):
                listener.exitCreate_subscription_statement(self)




    def create_subscription_statement(self):

        localctx = postgreSQLParser.Create_subscription_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 362, self.RULE_create_subscription_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4341
            self.match(postgreSQLParser.SUBSCRIPTION)
            self.state = 4342
            self.identifier()
            self.state = 4343
            self.match(postgreSQLParser.CONNECTION)
            self.state = 4344
            self.match(postgreSQLParser.Character_String_Literal)
            self.state = 4345
            self.match(postgreSQLParser.PUBLICATION)
            self.state = 4346
            self.identifier_list()
            self.state = 4348
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 4347
                self.with_storage_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_subscription_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SUBSCRIPTION(self):
            return self.getToken(postgreSQLParser.SUBSCRIPTION, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def alter_subscription_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_subscription_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_subscription_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_subscription_statement" ):
                listener.enterAlter_subscription_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_subscription_statement" ):
                listener.exitAlter_subscription_statement(self)




    def alter_subscription_statement(self):

        localctx = postgreSQLParser.Alter_subscription_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 364, self.RULE_alter_subscription_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4350
            self.match(postgreSQLParser.SUBSCRIPTION)
            self.state = 4351
            self.identifier()
            self.state = 4352
            self.alter_subscription_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_subscription_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONNECTION(self):
            return self.getToken(postgreSQLParser.CONNECTION, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def REFRESH(self):
            return self.getToken(postgreSQLParser.REFRESH, 0)

        def ENABLE(self):
            return self.getToken(postgreSQLParser.ENABLE, 0)

        def DISABLE(self):
            return self.getToken(postgreSQLParser.DISABLE, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_subscription_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_subscription_action" ):
                listener.enterAlter_subscription_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_subscription_action" ):
                listener.exitAlter_subscription_action(self)




    def alter_subscription_action(self):

        localctx = postgreSQLParser.Alter_subscription_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 366, self.RULE_alter_subscription_action)
        self._la = 0 # Token type
        try:
            self.state = 4373
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,497,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4354
                self.match(postgreSQLParser.CONNECTION)
                self.state = 4355
                self.character_string()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4356
                self.match(postgreSQLParser.SET)
                self.state = 4357
                self.match(postgreSQLParser.PUBLICATION)
                self.state = 4358
                self.identifier_list()
                self.state = 4360
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4359
                    self.with_storage_parameter()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4362
                self.match(postgreSQLParser.REFRESH)
                self.state = 4363
                self.match(postgreSQLParser.PUBLICATION)
                self.state = 4365
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4364
                    self.with_storage_parameter()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4367
                self.match(postgreSQLParser.ENABLE)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4368
                self.match(postgreSQLParser.DISABLE)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4369
                self.match(postgreSQLParser.SET)
                self.state = 4370
                self.storage_parameter()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 4371
                self.owner_to()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 4372
                self.rename_to()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_cast_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.source = None # Data_typeContext
            self.target = None # Data_typeContext
            self.func_name = None # Schema_qualified_nameContext

        def CAST(self):
            return self.getToken(postgreSQLParser.CAST, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.AS)
            else:
                return self.getToken(postgreSQLParser.AS, i)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def INOUT(self):
            return self.getToken(postgreSQLParser.INOUT, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def ASSIGNMENT(self):
            return self.getToken(postgreSQLParser.ASSIGNMENT, 0)

        def IMPLICIT(self):
            return self.getToken(postgreSQLParser.IMPLICIT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_cast_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_cast_statement" ):
                listener.enterCreate_cast_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_cast_statement" ):
                listener.exitCreate_cast_statement(self)




    def create_cast_statement(self):

        localctx = postgreSQLParser.Create_cast_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 368, self.RULE_create_cast_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4375
            self.match(postgreSQLParser.CAST)
            self.state = 4376
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 4377
            localctx.source = self.data_type()
            self.state = 4378
            self.match(postgreSQLParser.AS)
            self.state = 4379
            localctx.target = self.data_type()
            self.state = 4380
            self.match(postgreSQLParser.RIGHT_PAREN)
            self.state = 4390
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,498,self._ctx)
            if la_ == 1:
                self.state = 4381
                self.match(postgreSQLParser.WITH)
                self.state = 4382
                self.match(postgreSQLParser.FUNCTION)
                self.state = 4383
                localctx.func_name = self.schema_qualified_name()
                self.state = 4384
                self.function_args()
                pass

            elif la_ == 2:
                self.state = 4386
                self.match(postgreSQLParser.WITHOUT)
                self.state = 4387
                self.match(postgreSQLParser.FUNCTION)
                pass

            elif la_ == 3:
                self.state = 4388
                self.match(postgreSQLParser.WITH)
                self.state = 4389
                self.match(postgreSQLParser.INOUT)
                pass


            self.state = 4396
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,499,self._ctx)
            if la_ == 1:
                self.state = 4392
                self.match(postgreSQLParser.AS)
                self.state = 4393
                self.match(postgreSQLParser.ASSIGNMENT)

            elif la_ == 2:
                self.state = 4394
                self.match(postgreSQLParser.AS)
                self.state = 4395
                self.match(postgreSQLParser.IMPLICIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_cast_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.source = None # Data_typeContext
            self.target = None # Data_typeContext

        def CAST(self):
            return self.getToken(postgreSQLParser.CAST, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_cast_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_cast_statement" ):
                listener.enterDrop_cast_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_cast_statement" ):
                listener.exitDrop_cast_statement(self)




    def drop_cast_statement(self):

        localctx = postgreSQLParser.Drop_cast_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 370, self.RULE_drop_cast_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4398
            self.match(postgreSQLParser.CAST)
            self.state = 4400
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.IF:
                self.state = 4399
                self.if_exists()


            self.state = 4402
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 4403
            localctx.source = self.data_type()
            self.state = 4404
            self.match(postgreSQLParser.AS)
            self.state = 4405
            localctx.target = self.data_type()
            self.state = 4406
            self.match(postgreSQLParser.RIGHT_PAREN)
            self.state = 4408
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 4407
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_operator_family_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_operator_family_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_operator_family_statement" ):
                listener.enterCreate_operator_family_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_operator_family_statement" ):
                listener.exitCreate_operator_family_statement(self)




    def create_operator_family_statement(self):

        localctx = postgreSQLParser.Create_operator_family_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 372, self.RULE_create_operator_family_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4410
            self.match(postgreSQLParser.OPERATOR)
            self.state = 4411
            self.match(postgreSQLParser.FAMILY)
            self.state = 4412
            self.schema_qualified_name()
            self.state = 4413
            self.match(postgreSQLParser.USING)
            self.state = 4414
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_operator_family_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def operator_family_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Operator_family_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_operator_family_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_operator_family_statement" ):
                listener.enterAlter_operator_family_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_operator_family_statement" ):
                listener.exitAlter_operator_family_statement(self)




    def alter_operator_family_statement(self):

        localctx = postgreSQLParser.Alter_operator_family_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 374, self.RULE_alter_operator_family_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4416
            self.match(postgreSQLParser.OPERATOR)
            self.state = 4417
            self.match(postgreSQLParser.FAMILY)
            self.state = 4418
            self.schema_qualified_name()
            self.state = 4419
            self.match(postgreSQLParser.USING)
            self.state = 4420
            self.identifier()
            self.state = 4421
            self.operator_family_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Operator_family_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def add_operator_to_family(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Add_operator_to_familyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Add_operator_to_familyContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def drop_operator_from_family(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Drop_operator_from_familyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Drop_operator_from_familyContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_operator_family_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOperator_family_action" ):
                listener.enterOperator_family_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOperator_family_action" ):
                listener.exitOperator_family_action(self)




    def operator_family_action(self):

        localctx = postgreSQLParser.Operator_family_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 376, self.RULE_operator_family_action)
        self._la = 0 # Token type
        try:
            self.state = 4444
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4423
                self.rename_to()
                pass
            elif token in [postgreSQLParser.OWNER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4424
                self.owner_to()
                pass
            elif token in [postgreSQLParser.SET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4425
                self.set_schema()
                pass
            elif token in [postgreSQLParser.ADD]:
                self.enterOuterAlt(localctx, 4)
                self.state = 4426
                self.match(postgreSQLParser.ADD)
                self.state = 4427
                self.add_operator_to_family()
                self.state = 4432
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 4428
                    self.match(postgreSQLParser.COMMA)
                    self.state = 4429
                    self.add_operator_to_family()
                    self.state = 4434
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            elif token in [postgreSQLParser.DROP]:
                self.enterOuterAlt(localctx, 5)
                self.state = 4435
                self.match(postgreSQLParser.DROP)
                self.state = 4436
                self.drop_operator_from_family()
                self.state = 4441
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 4437
                    self.match(postgreSQLParser.COMMA)
                    self.state = 4438
                    self.drop_operator_from_family()
                    self.state = 4443
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Add_operator_to_familyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def unsigned_numeric_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_numeric_literalContext,0)


        def target_operator(self):
            return self.getTypedRuleContext(postgreSQLParser.Target_operatorContext,0)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def ORDER(self):
            return self.getToken(postgreSQLParser.ORDER, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def NONE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NONE)
            else:
                return self.getToken(postgreSQLParser.NONE, i)

        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_add_operator_to_family

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdd_operator_to_family" ):
                listener.enterAdd_operator_to_family(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdd_operator_to_family" ):
                listener.exitAdd_operator_to_family(self)




    def add_operator_to_family(self):

        localctx = postgreSQLParser.Add_operator_to_familyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 378, self.RULE_add_operator_to_family)
        self._la = 0 # Token type
        try:
            self.state = 4476
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.OPERATOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4446
                self.match(postgreSQLParser.OPERATOR)
                self.state = 4447
                self.unsigned_numeric_literal()
                self.state = 4448
                self.target_operator()
                self.state = 4455
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,505,self._ctx)
                if la_ == 1:
                    self.state = 4449
                    self.match(postgreSQLParser.FOR)
                    self.state = 4450
                    self.match(postgreSQLParser.SEARCH)

                elif la_ == 2:
                    self.state = 4451
                    self.match(postgreSQLParser.FOR)
                    self.state = 4452
                    self.match(postgreSQLParser.ORDER)
                    self.state = 4453
                    self.match(postgreSQLParser.BY)
                    self.state = 4454
                    self.schema_qualified_name()


                pass
            elif token in [postgreSQLParser.FUNCTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4457
                self.match(postgreSQLParser.FUNCTION)
                self.state = 4458
                self.unsigned_numeric_literal()
                self.state = 4472
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 4459
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 4462
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,506,self._ctx)
                    if la_ == 1:
                        self.state = 4460
                        self.data_type()
                        pass

                    elif la_ == 2:
                        self.state = 4461
                        self.match(postgreSQLParser.NONE)
                        pass


                    self.state = 4469
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.COMMA:
                        self.state = 4464
                        self.match(postgreSQLParser.COMMA)
                        self.state = 4467
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,507,self._ctx)
                        if la_ == 1:
                            self.state = 4465
                            self.data_type()
                            pass

                        elif la_ == 2:
                            self.state = 4466
                            self.match(postgreSQLParser.NONE)
                            pass




                    self.state = 4471
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 4474
                self.function_call()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_operator_from_familyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_numeric_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_numeric_literalContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def NONE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NONE)
            else:
                return self.getToken(postgreSQLParser.NONE, i)

        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_operator_from_family

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_operator_from_family" ):
                listener.enterDrop_operator_from_family(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_operator_from_family" ):
                listener.exitDrop_operator_from_family(self)




    def drop_operator_from_family(self):

        localctx = postgreSQLParser.Drop_operator_from_familyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 380, self.RULE_drop_operator_from_family)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4478
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.OPERATOR):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 4479
            self.unsigned_numeric_literal()
            self.state = 4480
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 4483
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,511,self._ctx)
            if la_ == 1:
                self.state = 4481
                self.data_type()
                pass

            elif la_ == 2:
                self.state = 4482
                self.match(postgreSQLParser.NONE)
                pass


            self.state = 4490
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COMMA:
                self.state = 4485
                self.match(postgreSQLParser.COMMA)
                self.state = 4488
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,512,self._ctx)
                if la_ == 1:
                    self.state = 4486
                    self.data_type()
                    pass

                elif la_ == 2:
                    self.state = 4487
                    self.match(postgreSQLParser.NONE)
                    pass




            self.state = 4492
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_operator_family_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_operator_family_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_operator_family_statement" ):
                listener.enterDrop_operator_family_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_operator_family_statement" ):
                listener.exitDrop_operator_family_statement(self)




    def drop_operator_family_statement(self):

        localctx = postgreSQLParser.Drop_operator_family_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 382, self.RULE_drop_operator_family_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4494
            self.match(postgreSQLParser.OPERATOR)
            self.state = 4495
            self.match(postgreSQLParser.FAMILY)
            self.state = 4497
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,514,self._ctx)
            if la_ == 1:
                self.state = 4496
                self.if_exists()


            self.state = 4499
            self.schema_qualified_name()
            self.state = 4500
            self.match(postgreSQLParser.USING)
            self.state = 4501
            self.identifier()
            self.state = 4503
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 4502
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_operator_class_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def CLASS(self):
            return self.getToken(postgreSQLParser.CLASS, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def create_operator_class_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Create_operator_class_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Create_operator_class_optionContext,i)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_operator_class_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_operator_class_statement" ):
                listener.enterCreate_operator_class_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_operator_class_statement" ):
                listener.exitCreate_operator_class_statement(self)




    def create_operator_class_statement(self):

        localctx = postgreSQLParser.Create_operator_class_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 384, self.RULE_create_operator_class_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4505
            self.match(postgreSQLParser.OPERATOR)
            self.state = 4506
            self.match(postgreSQLParser.CLASS)
            self.state = 4507
            self.schema_qualified_name()
            self.state = 4509
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DEFAULT:
                self.state = 4508
                self.match(postgreSQLParser.DEFAULT)


            self.state = 4511
            self.match(postgreSQLParser.FOR)
            self.state = 4512
            self.match(postgreSQLParser.TYPE)
            self.state = 4513
            self.data_type()
            self.state = 4514
            self.match(postgreSQLParser.USING)
            self.state = 4515
            self.identifier()
            self.state = 4518
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FAMILY:
                self.state = 4516
                self.match(postgreSQLParser.FAMILY)
                self.state = 4517
                self.schema_qualified_name()


            self.state = 4520
            self.match(postgreSQLParser.AS)
            self.state = 4521
            self.create_operator_class_option()
            self.state = 4526
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 4522
                self.match(postgreSQLParser.COMMA)
                self.state = 4523
                self.create_operator_class_option()
                self.state = 4528
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_operator_class_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Operator_nameContext

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def unsigned_numeric_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_numeric_literalContext,0)


        def operator_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Operator_nameContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def ORDER(self):
            return self.getToken(postgreSQLParser.ORDER, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def NONE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NONE)
            else:
                return self.getToken(postgreSQLParser.NONE, i)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def STORAGE(self):
            return self.getToken(postgreSQLParser.STORAGE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_operator_class_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_operator_class_option" ):
                listener.enterCreate_operator_class_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_operator_class_option" ):
                listener.exitCreate_operator_class_option(self)




    def create_operator_class_option(self):

        localctx = postgreSQLParser.Create_operator_class_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 386, self.RULE_create_operator_class_option)
        self._la = 0 # Token type
        try:
            self.state = 4574
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.OPERATOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4529
                self.match(postgreSQLParser.OPERATOR)
                self.state = 4530
                self.unsigned_numeric_literal()
                self.state = 4531
                localctx.name = self.operator_name()
                self.state = 4543
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 4532
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 4535
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,519,self._ctx)
                    if la_ == 1:
                        self.state = 4533
                        self.data_type()
                        pass

                    elif la_ == 2:
                        self.state = 4534
                        self.match(postgreSQLParser.NONE)
                        pass


                    self.state = 4537
                    self.match(postgreSQLParser.COMMA)
                    self.state = 4540
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,520,self._ctx)
                    if la_ == 1:
                        self.state = 4538
                        self.data_type()
                        pass

                    elif la_ == 2:
                        self.state = 4539
                        self.match(postgreSQLParser.NONE)
                        pass


                    self.state = 4542
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 4551
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,522,self._ctx)
                if la_ == 1:
                    self.state = 4545
                    self.match(postgreSQLParser.FOR)
                    self.state = 4546
                    self.match(postgreSQLParser.SEARCH)

                elif la_ == 2:
                    self.state = 4547
                    self.match(postgreSQLParser.FOR)
                    self.state = 4548
                    self.match(postgreSQLParser.ORDER)
                    self.state = 4549
                    self.match(postgreSQLParser.BY)
                    self.state = 4550
                    self.schema_qualified_name()


                pass
            elif token in [postgreSQLParser.FUNCTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4553
                self.match(postgreSQLParser.FUNCTION)
                self.state = 4554
                self.unsigned_numeric_literal()
                self.state = 4568
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 4555
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 4558
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,523,self._ctx)
                    if la_ == 1:
                        self.state = 4556
                        self.data_type()
                        pass

                    elif la_ == 2:
                        self.state = 4557
                        self.match(postgreSQLParser.NONE)
                        pass


                    self.state = 4565
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.COMMA:
                        self.state = 4560
                        self.match(postgreSQLParser.COMMA)
                        self.state = 4563
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,524,self._ctx)
                        if la_ == 1:
                            self.state = 4561
                            self.data_type()
                            pass

                        elif la_ == 2:
                            self.state = 4562
                            self.match(postgreSQLParser.NONE)
                            pass




                    self.state = 4567
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 4570
                self.function_call()
                pass
            elif token in [postgreSQLParser.STORAGE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 4572
                self.match(postgreSQLParser.STORAGE)
                self.state = 4573
                self.data_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_operator_class_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def CLASS(self):
            return self.getToken(postgreSQLParser.CLASS, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_operator_class_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_operator_class_statement" ):
                listener.enterAlter_operator_class_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_operator_class_statement" ):
                listener.exitAlter_operator_class_statement(self)




    def alter_operator_class_statement(self):

        localctx = postgreSQLParser.Alter_operator_class_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 388, self.RULE_alter_operator_class_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4576
            self.match(postgreSQLParser.OPERATOR)
            self.state = 4577
            self.match(postgreSQLParser.CLASS)
            self.state = 4578
            self.schema_qualified_name()
            self.state = 4579
            self.match(postgreSQLParser.USING)
            self.state = 4580
            self.identifier()
            self.state = 4584
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.state = 4581
                self.rename_to()
                pass
            elif token in [postgreSQLParser.OWNER]:
                self.state = 4582
                self.owner_to()
                pass
            elif token in [postgreSQLParser.SET]:
                self.state = 4583
                self.set_schema()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_operator_class_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def CLASS(self):
            return self.getToken(postgreSQLParser.CLASS, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_operator_class_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_operator_class_statement" ):
                listener.enterDrop_operator_class_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_operator_class_statement" ):
                listener.exitDrop_operator_class_statement(self)




    def drop_operator_class_statement(self):

        localctx = postgreSQLParser.Drop_operator_class_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 390, self.RULE_drop_operator_class_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4586
            self.match(postgreSQLParser.OPERATOR)
            self.state = 4587
            self.match(postgreSQLParser.CLASS)
            self.state = 4589
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,529,self._ctx)
            if la_ == 1:
                self.state = 4588
                self.if_exists()


            self.state = 4591
            self.schema_qualified_name()
            self.state = 4592
            self.match(postgreSQLParser.USING)
            self.state = 4593
            self.identifier()
            self.state = 4595
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 4594
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_conversion_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONVERSION(self):
            return self.getToken(postgreSQLParser.CONVERSION, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def Character_String_Literal(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.Character_String_Literal)
            else:
                return self.getToken(postgreSQLParser.Character_String_Literal, i)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_conversion_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_conversion_statement" ):
                listener.enterCreate_conversion_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_conversion_statement" ):
                listener.exitCreate_conversion_statement(self)




    def create_conversion_statement(self):

        localctx = postgreSQLParser.Create_conversion_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 392, self.RULE_create_conversion_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4598
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DEFAULT:
                self.state = 4597
                self.match(postgreSQLParser.DEFAULT)


            self.state = 4600
            self.match(postgreSQLParser.CONVERSION)
            self.state = 4601
            self.schema_qualified_name()
            self.state = 4602
            self.match(postgreSQLParser.FOR)
            self.state = 4603
            self.match(postgreSQLParser.Character_String_Literal)
            self.state = 4604
            self.match(postgreSQLParser.TO)
            self.state = 4605
            self.match(postgreSQLParser.Character_String_Literal)
            self.state = 4606
            self.match(postgreSQLParser.FROM)
            self.state = 4607
            self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_conversion_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CONVERSION(self):
            return self.getToken(postgreSQLParser.CONVERSION, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_schema(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_schemaContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_conversion_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_conversion_statement" ):
                listener.enterAlter_conversion_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_conversion_statement" ):
                listener.exitAlter_conversion_statement(self)




    def alter_conversion_statement(self):

        localctx = postgreSQLParser.Alter_conversion_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 394, self.RULE_alter_conversion_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4609
            self.match(postgreSQLParser.CONVERSION)
            self.state = 4610
            self.schema_qualified_name()
            self.state = 4614
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.state = 4611
                self.rename_to()
                pass
            elif token in [postgreSQLParser.OWNER]:
                self.state = 4612
                self.owner_to()
                pass
            elif token in [postgreSQLParser.SET]:
                self.state = 4613
                self.set_schema()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_publication_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def only_table_multiply(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Only_table_multiplyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Only_table_multiplyContext,i)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def TABLES(self):
            return self.getToken(postgreSQLParser.TABLES, 0)

        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_publication_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_publication_statement" ):
                listener.enterCreate_publication_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_publication_statement" ):
                listener.exitCreate_publication_statement(self)




    def create_publication_statement(self):

        localctx = postgreSQLParser.Create_publication_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 396, self.RULE_create_publication_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4616
            self.match(postgreSQLParser.PUBLICATION)
            self.state = 4617
            self.identifier()
            self.state = 4631
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,534,self._ctx)
            if la_ == 1:
                self.state = 4618
                self.match(postgreSQLParser.FOR)
                self.state = 4619
                self.match(postgreSQLParser.TABLE)
                self.state = 4620
                self.only_table_multiply()
                self.state = 4625
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 4621
                    self.match(postgreSQLParser.COMMA)
                    self.state = 4622
                    self.only_table_multiply()
                    self.state = 4627
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)


            elif la_ == 2:
                self.state = 4628
                self.match(postgreSQLParser.FOR)
                self.state = 4629
                self.match(postgreSQLParser.ALL)
                self.state = 4630
                self.match(postgreSQLParser.TABLES)


            self.state = 4634
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 4633
                self.with_storage_parameter()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_publication_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def alter_publication_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_publication_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_publication_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_publication_statement" ):
                listener.enterAlter_publication_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_publication_statement" ):
                listener.exitAlter_publication_statement(self)




    def alter_publication_statement(self):

        localctx = postgreSQLParser.Alter_publication_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 398, self.RULE_alter_publication_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4636
            self.match(postgreSQLParser.PUBLICATION)
            self.state = 4637
            self.identifier()
            self.state = 4638
            self.alter_publication_action()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_publication_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def only_table_multiply(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Only_table_multiplyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Only_table_multiplyContext,i)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_publication_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_publication_action" ):
                listener.enterAlter_publication_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_publication_action" ):
                listener.exitAlter_publication_action(self)




    def alter_publication_action(self):

        localctx = postgreSQLParser.Alter_publication_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 400, self.RULE_alter_publication_action)
        self._la = 0 # Token type
        try:
            self.state = 4654
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,537,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4640
                self.rename_to()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4641
                self.owner_to()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4642
                self.match(postgreSQLParser.SET)
                self.state = 4643
                self.storage_parameter()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4644
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ADD or _la==postgreSQLParser.DROP or _la==postgreSQLParser.SET):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4645
                self.match(postgreSQLParser.TABLE)
                self.state = 4646
                self.only_table_multiply()
                self.state = 4651
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 4647
                    self.match(postgreSQLParser.COMMA)
                    self.state = 4648
                    self.only_table_multiply()
                    self.state = 4653
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Only_table_multiplyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_only_table_multiply

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOnly_table_multiply" ):
                listener.enterOnly_table_multiply(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOnly_table_multiply" ):
                listener.exitOnly_table_multiply(self)




    def only_table_multiply(self):

        localctx = postgreSQLParser.Only_table_multiplyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 402, self.RULE_only_table_multiply)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4657
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ONLY:
                self.state = 4656
                self.match(postgreSQLParser.ONLY)


            self.state = 4659
            self.schema_qualified_name()
            self.state = 4661
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.MULTIPLY:
                self.state = 4660
                self.match(postgreSQLParser.MULTIPLY)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_trigger_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ON)
            else:
                return self.getToken(postgreSQLParser.ON, i)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def DEPENDS(self):
            return self.getToken(postgreSQLParser.DEPENDS, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_trigger_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_trigger_statement" ):
                listener.enterAlter_trigger_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_trigger_statement" ):
                listener.exitAlter_trigger_statement(self)




    def alter_trigger_statement(self):

        localctx = postgreSQLParser.Alter_trigger_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 404, self.RULE_alter_trigger_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4663
            self.match(postgreSQLParser.TRIGGER)
            self.state = 4664
            self.identifier()
            self.state = 4665
            self.match(postgreSQLParser.ON)
            self.state = 4666
            self.schema_qualified_name()
            self.state = 4675
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RENAME]:
                self.state = 4667
                self.rename_to()
                pass
            elif token in [postgreSQLParser.DEPENDS, postgreSQLParser.NO]:
                self.state = 4669
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 4668
                    self.match(postgreSQLParser.NO)


                self.state = 4671
                self.match(postgreSQLParser.DEPENDS)
                self.state = 4672
                self.match(postgreSQLParser.ON)
                self.state = 4673
                self.match(postgreSQLParser.EXTENSION)
                self.state = 4674
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_rule_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RULE(self):
            return self.getToken(postgreSQLParser.RULE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_rule_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_rule_statement" ):
                listener.enterAlter_rule_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_rule_statement" ):
                listener.exitAlter_rule_statement(self)




    def alter_rule_statement(self):

        localctx = postgreSQLParser.Alter_rule_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 406, self.RULE_alter_rule_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4677
            self.match(postgreSQLParser.RULE)
            self.state = 4678
            self.identifier()
            self.state = 4679
            self.match(postgreSQLParser.ON)
            self.state = 4680
            self.schema_qualified_name()
            self.state = 4681
            self.rename_to()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Copy_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def copy_to_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Copy_to_statementContext,0)


        def copy_from_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Copy_from_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_copy_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopy_statement" ):
                listener.enterCopy_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopy_statement" ):
                listener.exitCopy_statement(self)




    def copy_statement(self):

        localctx = postgreSQLParser.Copy_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 408, self.RULE_copy_statement)
        try:
            self.state = 4685
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,542,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4683
                self.copy_to_statement()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4684
                self.copy_from_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Copy_from_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COPY(self):
            return self.getToken(postgreSQLParser.COPY, 0)

        def table_cols(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_colsContext,0)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def STDIN(self):
            return self.getToken(postgreSQLParser.STDIN, 0)

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def PROGRAM(self):
            return self.getToken(postgreSQLParser.PROGRAM, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def copy_option_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Copy_option_listContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_copy_from_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopy_from_statement" ):
                listener.enterCopy_from_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopy_from_statement" ):
                listener.exitCopy_from_statement(self)




    def copy_from_statement(self):

        localctx = postgreSQLParser.Copy_from_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 410, self.RULE_copy_from_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4687
            self.match(postgreSQLParser.COPY)
            self.state = 4688
            self.table_cols()
            self.state = 4689
            self.match(postgreSQLParser.FROM)
            self.state = 4695
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.PROGRAM, postgreSQLParser.Character_String_Literal]:
                self.state = 4691
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PROGRAM:
                    self.state = 4690
                    self.match(postgreSQLParser.PROGRAM)


                self.state = 4693
                self.match(postgreSQLParser.Character_String_Literal)
                pass
            elif token in [postgreSQLParser.STDIN]:
                self.state = 4694
                self.match(postgreSQLParser.STDIN)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4707
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 47)) & ~0x3f) == 0 and ((1 << (_la - 47)) & ((1 << (postgreSQLParser.CSV - 47)) | (1 << (postgreSQLParser.DELIMITER - 47)) | (1 << (postgreSQLParser.ENCODING - 47)) | (1 << (postgreSQLParser.ESCAPE - 47)) | (1 << (postgreSQLParser.FORCE - 47)) | (1 << (postgreSQLParser.HEADER - 47)))) != 0) or _la==postgreSQLParser.OIDS or _la==postgreSQLParser.QUOTE or _la==postgreSQLParser.TEXT or _la==postgreSQLParser.BINARY or _la==postgreSQLParser.FREEZE or ((((_la - 422)) & ~0x3f) == 0 and ((1 << (_la - 422)) & ((1 << (postgreSQLParser.NULL - 422)) | (1 << (postgreSQLParser.WITH - 422)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 422)) | (1 << (postgreSQLParser.FORCE_NULL - 422)) | (1 << (postgreSQLParser.FORCE_QUOTE - 422)) | (1 << (postgreSQLParser.FORMAT - 422)))) != 0) or _la==postgreSQLParser.LEFT_PAREN:
                self.state = 4698
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4697
                    self.match(postgreSQLParser.WITH)


                self.state = 4705
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.LEFT_PAREN]:
                    self.state = 4700
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 4701
                    self.copy_option_list()
                    self.state = 4702
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                elif token in [postgreSQLParser.CSV, postgreSQLParser.DELIMITER, postgreSQLParser.ENCODING, postgreSQLParser.ESCAPE, postgreSQLParser.FORCE, postgreSQLParser.HEADER, postgreSQLParser.OIDS, postgreSQLParser.QUOTE, postgreSQLParser.TEXT, postgreSQLParser.BINARY, postgreSQLParser.FREEZE, postgreSQLParser.NULL, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT]:
                    self.state = 4704
                    self.copy_option_list()
                    pass
                else:
                    raise NoViableAltException(self)



            self.state = 4711
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHERE:
                self.state = 4709
                self.match(postgreSQLParser.WHERE)
                self.state = 4710
                self.vex(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Copy_to_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COPY(self):
            return self.getToken(postgreSQLParser.COPY, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def table_cols(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_colsContext,0)


        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def data_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_statementContext,0)


        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def STDOUT(self):
            return self.getToken(postgreSQLParser.STDOUT, 0)

        def PROGRAM(self):
            return self.getToken(postgreSQLParser.PROGRAM, 0)

        def copy_option_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Copy_option_listContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_copy_to_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopy_to_statement" ):
                listener.enterCopy_to_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopy_to_statement" ):
                listener.exitCopy_to_statement(self)




    def copy_to_statement(self):

        localctx = postgreSQLParser.Copy_to_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 412, self.RULE_copy_to_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4713
            self.match(postgreSQLParser.COPY)
            self.state = 4719
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 4714
                self.table_cols()
                pass
            elif token in [postgreSQLParser.LEFT_PAREN]:
                self.state = 4715
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 4716
                self.data_statement()
                self.state = 4717
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4721
            self.match(postgreSQLParser.TO)
            self.state = 4727
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.PROGRAM, postgreSQLParser.Character_String_Literal]:
                self.state = 4723
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PROGRAM:
                    self.state = 4722
                    self.match(postgreSQLParser.PROGRAM)


                self.state = 4725
                self.match(postgreSQLParser.Character_String_Literal)
                pass
            elif token in [postgreSQLParser.STDOUT]:
                self.state = 4726
                self.match(postgreSQLParser.STDOUT)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 4739
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 47)) & ~0x3f) == 0 and ((1 << (_la - 47)) & ((1 << (postgreSQLParser.CSV - 47)) | (1 << (postgreSQLParser.DELIMITER - 47)) | (1 << (postgreSQLParser.ENCODING - 47)) | (1 << (postgreSQLParser.ESCAPE - 47)) | (1 << (postgreSQLParser.FORCE - 47)) | (1 << (postgreSQLParser.HEADER - 47)))) != 0) or _la==postgreSQLParser.OIDS or _la==postgreSQLParser.QUOTE or _la==postgreSQLParser.TEXT or _la==postgreSQLParser.BINARY or _la==postgreSQLParser.FREEZE or ((((_la - 422)) & ~0x3f) == 0 and ((1 << (_la - 422)) & ((1 << (postgreSQLParser.NULL - 422)) | (1 << (postgreSQLParser.WITH - 422)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 422)) | (1 << (postgreSQLParser.FORCE_NULL - 422)) | (1 << (postgreSQLParser.FORCE_QUOTE - 422)) | (1 << (postgreSQLParser.FORMAT - 422)))) != 0) or _la==postgreSQLParser.LEFT_PAREN:
                self.state = 4730
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4729
                    self.match(postgreSQLParser.WITH)


                self.state = 4737
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.LEFT_PAREN]:
                    self.state = 4732
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 4733
                    self.copy_option_list()
                    self.state = 4734
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                elif token in [postgreSQLParser.CSV, postgreSQLParser.DELIMITER, postgreSQLParser.ENCODING, postgreSQLParser.ESCAPE, postgreSQLParser.FORCE, postgreSQLParser.HEADER, postgreSQLParser.OIDS, postgreSQLParser.QUOTE, postgreSQLParser.TEXT, postgreSQLParser.BINARY, postgreSQLParser.FREEZE, postgreSQLParser.NULL, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT]:
                    self.state = 4736
                    self.copy_option_list()
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Copy_option_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def copy_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Copy_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Copy_optionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_copy_option_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopy_option_list" ):
                listener.enterCopy_option_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopy_option_list" ):
                listener.exitCopy_option_list(self)




    def copy_option_list(self):

        localctx = postgreSQLParser.Copy_option_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 414, self.RULE_copy_option_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4741
            self.copy_option()
            self.state = 4748
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 47)) & ~0x3f) == 0 and ((1 << (_la - 47)) & ((1 << (postgreSQLParser.CSV - 47)) | (1 << (postgreSQLParser.DELIMITER - 47)) | (1 << (postgreSQLParser.ENCODING - 47)) | (1 << (postgreSQLParser.ESCAPE - 47)) | (1 << (postgreSQLParser.FORCE - 47)) | (1 << (postgreSQLParser.HEADER - 47)))) != 0) or _la==postgreSQLParser.OIDS or _la==postgreSQLParser.QUOTE or _la==postgreSQLParser.TEXT or _la==postgreSQLParser.BINARY or _la==postgreSQLParser.FREEZE or ((((_la - 422)) & ~0x3f) == 0 and ((1 << (_la - 422)) & ((1 << (postgreSQLParser.NULL - 422)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 422)) | (1 << (postgreSQLParser.FORCE_NULL - 422)) | (1 << (postgreSQLParser.FORCE_QUOTE - 422)) | (1 << (postgreSQLParser.FORMAT - 422)))) != 0) or _la==postgreSQLParser.COMMA:
                self.state = 4743
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COMMA:
                    self.state = 4742
                    self.match(postgreSQLParser.COMMA)


                self.state = 4745
                self.copy_option()
                self.state = 4750
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Copy_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def CSV(self):
            return self.getToken(postgreSQLParser.CSV, 0)

        def BINARY(self):
            return self.getToken(postgreSQLParser.BINARY, 0)

        def FORMAT(self):
            return self.getToken(postgreSQLParser.FORMAT, 0)

        def OIDS(self):
            return self.getToken(postgreSQLParser.OIDS, 0)

        def truth_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Truth_valueContext,0)


        def FREEZE(self):
            return self.getToken(postgreSQLParser.FREEZE, 0)

        def DELIMITER(self):
            return self.getToken(postgreSQLParser.DELIMITER, 0)

        def Character_String_Literal(self):
            return self.getToken(postgreSQLParser.Character_String_Literal, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def HEADER(self):
            return self.getToken(postgreSQLParser.HEADER, 0)

        def QUOTE(self):
            return self.getToken(postgreSQLParser.QUOTE, 0)

        def ESCAPE(self):
            return self.getToken(postgreSQLParser.ESCAPE, 0)

        def FORCE(self):
            return self.getToken(postgreSQLParser.FORCE, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def FORCE_QUOTE(self):
            return self.getToken(postgreSQLParser.FORCE_QUOTE, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def FORCE_NOT_NULL(self):
            return self.getToken(postgreSQLParser.FORCE_NOT_NULL, 0)

        def FORCE_NULL(self):
            return self.getToken(postgreSQLParser.FORCE_NULL, 0)

        def ENCODING(self):
            return self.getToken(postgreSQLParser.ENCODING, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_copy_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCopy_option" ):
                listener.enterCopy_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCopy_option" ):
                listener.exitCopy_option(self)




    def copy_option(self):

        localctx = postgreSQLParser.Copy_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 416, self.RULE_copy_option)
        self._la = 0 # Token type
        try:
            self.state = 4811
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,565,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4752
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FORMAT:
                    self.state = 4751
                    self.match(postgreSQLParser.FORMAT)


                self.state = 4754
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CSV or _la==postgreSQLParser.TEXT or _la==postgreSQLParser.BINARY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4755
                self.match(postgreSQLParser.OIDS)
                self.state = 4757
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0):
                    self.state = 4756
                    self.truth_value()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4759
                self.match(postgreSQLParser.FREEZE)
                self.state = 4761
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0):
                    self.state = 4760
                    self.truth_value()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4763
                self.match(postgreSQLParser.DELIMITER)
                self.state = 4765
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AS:
                    self.state = 4764
                    self.match(postgreSQLParser.AS)


                self.state = 4767
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4768
                self.match(postgreSQLParser.NULL)
                self.state = 4770
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AS:
                    self.state = 4769
                    self.match(postgreSQLParser.AS)


                self.state = 4772
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4773
                self.match(postgreSQLParser.HEADER)
                self.state = 4775
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0):
                    self.state = 4774
                    self.truth_value()


                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 4777
                self.match(postgreSQLParser.QUOTE)
                self.state = 4778
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 4779
                self.match(postgreSQLParser.ESCAPE)
                self.state = 4780
                self.match(postgreSQLParser.Character_String_Literal)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 4781
                self.match(postgreSQLParser.FORCE)
                self.state = 4782
                self.match(postgreSQLParser.QUOTE)
                self.state = 4785
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.MULTIPLY]:
                    self.state = 4783
                    self.match(postgreSQLParser.MULTIPLY)
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 4784
                    self.identifier_list()
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 4787
                self.match(postgreSQLParser.FORCE_QUOTE)
                self.state = 4793
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.MULTIPLY]:
                    self.state = 4788
                    self.match(postgreSQLParser.MULTIPLY)
                    pass
                elif token in [postgreSQLParser.LEFT_PAREN]:
                    self.state = 4789
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 4790
                    self.identifier_list()
                    self.state = 4791
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 4795
                self.match(postgreSQLParser.FORCE)
                self.state = 4796
                self.match(postgreSQLParser.NOT)
                self.state = 4797
                self.match(postgreSQLParser.NULL)
                self.state = 4798
                self.identifier_list()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 4799
                self.match(postgreSQLParser.FORCE_NOT_NULL)
                self.state = 4800
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 4801
                self.identifier_list()
                self.state = 4802
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 4804
                self.match(postgreSQLParser.FORCE_NULL)
                self.state = 4805
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 4806
                self.identifier_list()
                self.state = 4807
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 4809
                self.match(postgreSQLParser.ENCODING)
                self.state = 4810
                self.match(postgreSQLParser.Character_String_Literal)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_view_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext
            self.column_names = None # View_columnsContext
            self.v_query = None # Select_stmtContext

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def RECURSIVE(self):
            return self.getToken(postgreSQLParser.RECURSIVE, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WITH)
            else:
                return self.getToken(postgreSQLParser.WITH, i)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def table_space(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_spaceContext,0)


        def with_check_option(self):
            return self.getTypedRuleContext(postgreSQLParser.With_check_optionContext,0)


        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def view_columns(self):
            return self.getTypedRuleContext(postgreSQLParser.View_columnsContext,0)


        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_view_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_view_statement" ):
                listener.enterCreate_view_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_view_statement" ):
                listener.exitCreate_view_statement(self)




    def create_view_statement(self):

        localctx = postgreSQLParser.Create_view_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 418, self.RULE_create_view_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4815
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OR:
                self.state = 4813
                self.match(postgreSQLParser.OR)
                self.state = 4814
                self.match(postgreSQLParser.REPLACE)


            self.state = 4818
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY:
                self.state = 4817
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 4821
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.RECURSIVE:
                self.state = 4820
                self.match(postgreSQLParser.RECURSIVE)


            self.state = 4824
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.MATERIALIZED:
                self.state = 4823
                self.match(postgreSQLParser.MATERIALIZED)


            self.state = 4826
            self.match(postgreSQLParser.VIEW)
            self.state = 4828
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,570,self._ctx)
            if la_ == 1:
                self.state = 4827
                self.if_not_exists()


            self.state = 4830
            localctx.name = self.schema_qualified_name()
            self.state = 4832
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 4831
                localctx.column_names = self.view_columns()


            self.state = 4836
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 4834
                self.match(postgreSQLParser.USING)
                self.state = 4835
                self.identifier()


            self.state = 4840
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 4838
                self.match(postgreSQLParser.WITH)
                self.state = 4839
                self.storage_parameter()


            self.state = 4843
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLESPACE:
                self.state = 4842
                self.table_space()


            self.state = 4845
            self.match(postgreSQLParser.AS)
            self.state = 4846
            localctx.v_query = self.select_stmt()
            self.state = 4848
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,575,self._ctx)
            if la_ == 1:
                self.state = 4847
                self.with_check_option()


            self.state = 4855
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 4850
                self.match(postgreSQLParser.WITH)
                self.state = 4852
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 4851
                    self.match(postgreSQLParser.NO)


                self.state = 4854
                self.match(postgreSQLParser.DATA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_existsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(postgreSQLParser.IF, 0)

        def EXISTS(self):
            return self.getToken(postgreSQLParser.EXISTS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_if_exists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_exists" ):
                listener.enterIf_exists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_exists" ):
                listener.exitIf_exists(self)




    def if_exists(self):

        localctx = postgreSQLParser.If_existsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 420, self.RULE_if_exists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4857
            self.match(postgreSQLParser.IF)
            self.state = 4858
            self.match(postgreSQLParser.EXISTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_not_existsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self):
            return self.getToken(postgreSQLParser.IF, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def EXISTS(self):
            return self.getToken(postgreSQLParser.EXISTS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_if_not_exists

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_not_exists" ):
                listener.enterIf_not_exists(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_not_exists" ):
                listener.exitIf_not_exists(self)




    def if_not_exists(self):

        localctx = postgreSQLParser.If_not_existsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 422, self.RULE_if_not_exists)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4860
            self.match(postgreSQLParser.IF)
            self.state = 4861
            self.match(postgreSQLParser.NOT)
            self.state = 4862
            self.match(postgreSQLParser.EXISTS)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class View_columnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_view_columns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterView_columns" ):
                listener.enterView_columns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitView_columns" ):
                listener.exitView_columns(self)




    def view_columns(self):

        localctx = postgreSQLParser.View_columnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 424, self.RULE_view_columns)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4864
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 4865
            self.identifier()
            self.state = 4870
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 4866
                self.match(postgreSQLParser.COMMA)
                self.state = 4867
                self.identifier()
                self.state = 4872
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 4873
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class With_check_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def CHECK(self):
            return self.getToken(postgreSQLParser.CHECK, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def CASCADED(self):
            return self.getToken(postgreSQLParser.CASCADED, 0)

        def LOCAL(self):
            return self.getToken(postgreSQLParser.LOCAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_with_check_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_check_option" ):
                listener.enterWith_check_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_check_option" ):
                listener.exitWith_check_option(self)




    def with_check_option(self):

        localctx = postgreSQLParser.With_check_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 426, self.RULE_with_check_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4875
            self.match(postgreSQLParser.WITH)
            self.state = 4877
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADED or _la==postgreSQLParser.LOCAL:
                self.state = 4876
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CASCADED or _la==postgreSQLParser.LOCAL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 4879
            self.match(postgreSQLParser.CHECK)
            self.state = 4880
            self.match(postgreSQLParser.OPTION)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_database_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dbname = None # IdentifierContext

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def create_database_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Create_database_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Create_database_optionContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_database_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_database_statement" ):
                listener.enterCreate_database_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_database_statement" ):
                listener.exitCreate_database_statement(self)




    def create_database_statement(self):

        localctx = postgreSQLParser.Create_database_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 428, self.RULE_create_database_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4882
            self.match(postgreSQLParser.DATABASE)
            self.state = 4883
            localctx.dbname = self.identifier()
            self.state = 4892
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONNECTION or _la==postgreSQLParser.ENCODING or _la==postgreSQLParser.OWNER or _la==postgreSQLParser.TABLESPACE or _la==postgreSQLParser.TEMPLATE or ((((_la - 449)) & ~0x3f) == 0 and ((1 << (_la - 449)) & ((1 << (postgreSQLParser.WITH - 449)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 449)) | (1 << (postgreSQLParser.IS_TEMPLATE - 449)) | (1 << (postgreSQLParser.LC_COLLATE - 449)) | (1 << (postgreSQLParser.LC_CTYPE - 449)) | (1 << (postgreSQLParser.LOCALE - 449)))) != 0):
                self.state = 4885
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4884
                    self.match(postgreSQLParser.WITH)


                self.state = 4888 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 4887
                    self.create_database_option()
                    self.state = 4890 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.CONNECTION or _la==postgreSQLParser.ENCODING or _la==postgreSQLParser.OWNER or _la==postgreSQLParser.TABLESPACE or _la==postgreSQLParser.TEMPLATE or ((((_la - 451)) & ~0x3f) == 0 and ((1 << (_la - 451)) & ((1 << (postgreSQLParser.ALLOW_CONNECTIONS - 451)) | (1 << (postgreSQLParser.IS_TEMPLATE - 451)) | (1 << (postgreSQLParser.LC_COLLATE - 451)) | (1 << (postgreSQLParser.LC_CTYPE - 451)) | (1 << (postgreSQLParser.LOCALE - 451)))) != 0)):
                        break



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_database_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OWNER(self):
            return self.getToken(postgreSQLParser.OWNER, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def ENCODING(self):
            return self.getToken(postgreSQLParser.ENCODING, 0)

        def LOCALE(self):
            return self.getToken(postgreSQLParser.LOCALE, 0)

        def LC_COLLATE(self):
            return self.getToken(postgreSQLParser.LC_COLLATE, 0)

        def LC_CTYPE(self):
            return self.getToken(postgreSQLParser.LC_CTYPE, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def alter_database_option(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_database_optionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_database_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_database_option" ):
                listener.enterCreate_database_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_database_option" ):
                listener.exitCreate_database_option(self)




    def create_database_option(self):

        localctx = postgreSQLParser.Create_database_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 430, self.RULE_create_database_option)
        self._la = 0 # Token type
        try:
            self.state = 4904
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ENCODING, postgreSQLParser.OWNER, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMPLATE, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LOCALE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4894
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ENCODING or _la==postgreSQLParser.OWNER or _la==postgreSQLParser.TABLESPACE or _la==postgreSQLParser.TEMPLATE or ((((_la - 487)) & ~0x3f) == 0 and ((1 << (_la - 487)) & ((1 << (postgreSQLParser.LC_COLLATE - 487)) | (1 << (postgreSQLParser.LC_CTYPE - 487)) | (1 << (postgreSQLParser.LOCALE - 487)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4896
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.EQUAL:
                    self.state = 4895
                    self.match(postgreSQLParser.EQUAL)


                self.state = 4901
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 4898
                    self.character_string()
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 4899
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 4900
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.CONNECTION, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.IS_TEMPLATE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4903
                self.alter_database_option()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_database_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def alter_database_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Alter_database_actionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_database_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_database_statement" ):
                listener.enterAlter_database_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_database_statement" ):
                listener.exitAlter_database_statement(self)




    def alter_database_statement(self):

        localctx = postgreSQLParser.Alter_database_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 432, self.RULE_alter_database_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4906
            self.match(postgreSQLParser.DATABASE)
            self.state = 4907
            self.identifier()
            self.state = 4909
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONNECTION or ((((_la - 174)) & ~0x3f) == 0 and ((1 << (_la - 174)) & ((1 << (postgreSQLParser.OWNER - 174)) | (1 << (postgreSQLParser.RENAME - 174)) | (1 << (postgreSQLParser.RESET - 174)) | (1 << (postgreSQLParser.SET - 174)))) != 0) or _la==postgreSQLParser.TABLESPACE or ((((_la - 449)) & ~0x3f) == 0 and ((1 << (_la - 449)) & ((1 << (postgreSQLParser.WITH - 449)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 449)) | (1 << (postgreSQLParser.IS_TEMPLATE - 449)))) != 0):
                self.state = 4908
                self.alter_database_action()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_database_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def alter_database_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Alter_database_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Alter_database_optionContext,i)


        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def rename_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Rename_toContext,0)


        def owner_to(self):
            return self.getTypedRuleContext(postgreSQLParser.Owner_toContext,0)


        def set_tablespace(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_tablespaceContext,0)


        def set_reset_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_reset_parameterContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_database_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_database_action" ):
                listener.enterAlter_database_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_database_action" ):
                listener.exitAlter_database_action(self)




    def alter_database_action(self):

        localctx = postgreSQLParser.Alter_database_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 434, self.RULE_alter_database_action)
        self._la = 0 # Token type
        try:
            self.state = 4935
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,592,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 4912
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4911
                    self.match(postgreSQLParser.WITH)


                self.state = 4915 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 4914
                    self.alter_database_option()
                    self.state = 4917 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.CONNECTION or _la==postgreSQLParser.ALLOW_CONNECTIONS or _la==postgreSQLParser.IS_TEMPLATE):
                        break

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 4920
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 4919
                    self.match(postgreSQLParser.WITH)


                self.state = 4922
                self.match(postgreSQLParser.TABLESPACE)
                self.state = 4924
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.EQUAL:
                    self.state = 4923
                    self.match(postgreSQLParser.EQUAL)


                self.state = 4929
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 4926
                    self.character_string()
                    pass
                elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 4927
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 4928
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 4931
                self.rename_to()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 4932
                self.owner_to()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 4933
                self.set_tablespace()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 4934
                self.set_reset_parameter()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alter_database_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALLOW_CONNECTIONS(self):
            return self.getToken(postgreSQLParser.ALLOW_CONNECTIONS, 0)

        def IS_TEMPLATE(self):
            return self.getToken(postgreSQLParser.IS_TEMPLATE, 0)

        def boolean_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Boolean_valueContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def CONNECTION(self):
            return self.getToken(postgreSQLParser.CONNECTION, 0)

        def LIMIT(self):
            return self.getToken(postgreSQLParser.LIMIT, 0)

        def signed_number_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Signed_number_literalContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_alter_database_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlter_database_option" ):
                listener.enterAlter_database_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlter_database_option" ):
                listener.exitAlter_database_option(self)




    def alter_database_option(self):

        localctx = postgreSQLParser.Alter_database_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 436, self.RULE_alter_database_option)
        self._la = 0 # Token type
        try:
            self.state = 4954
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.IS_TEMPLATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 4937
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ALLOW_CONNECTIONS or _la==postgreSQLParser.IS_TEMPLATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 4939
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.EQUAL:
                    self.state = 4938
                    self.match(postgreSQLParser.EQUAL)


                self.state = 4943
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.OFF, postgreSQLParser.FALSE, postgreSQLParser.ON, postgreSQLParser.TRUE, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 4941
                    self.boolean_value()
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 4942
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.CONNECTION]:
                self.enterOuterAlt(localctx, 2)
                self.state = 4945
                self.match(postgreSQLParser.CONNECTION)
                self.state = 4946
                self.match(postgreSQLParser.LIMIT)
                self.state = 4948
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.EQUAL:
                    self.state = 4947
                    self.match(postgreSQLParser.EQUAL)


                self.state = 4952
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.NUMBER_LITERAL]:
                    self.state = 4950
                    self.signed_number_literal()
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 4951
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_table_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tn = None # Schema_qualified_nameContext
            self.part = None # Partition_byContext

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def define_table(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_tableContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def UNLOGGED(self):
            return self.getToken(postgreSQLParser.UNLOGGED, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def storage_parameter_oid(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameter_oidContext,0)


        def on_commit(self):
            return self.getTypedRuleContext(postgreSQLParser.On_commitContext,0)


        def table_space(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_spaceContext,0)


        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def partition_by(self):
            return self.getTypedRuleContext(postgreSQLParser.Partition_byContext,0)


        def GLOBAL(self):
            return self.getToken(postgreSQLParser.GLOBAL, 0)

        def LOCAL(self):
            return self.getToken(postgreSQLParser.LOCAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_table_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_table_statement" ):
                listener.enterCreate_table_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_table_statement" ):
                listener.exitCreate_table_statement(self)




    def create_table_statement(self):

        localctx = postgreSQLParser.Create_table_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 438, self.RULE_create_table_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4961
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.GLOBAL, postgreSQLParser.LOCAL, postgreSQLParser.TEMP, postgreSQLParser.TEMPORARY]:
                self.state = 4957
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.GLOBAL or _la==postgreSQLParser.LOCAL:
                    self.state = 4956
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.GLOBAL or _la==postgreSQLParser.LOCAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 4959
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.UNLOGGED]:
                self.state = 4960
                self.match(postgreSQLParser.UNLOGGED)
                pass
            elif token in [postgreSQLParser.TABLE]:
                pass
            else:
                pass
            self.state = 4963
            self.match(postgreSQLParser.TABLE)
            self.state = 4965
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,600,self._ctx)
            if la_ == 1:
                self.state = 4964
                self.if_not_exists()


            self.state = 4967
            localctx.tn = self.schema_qualified_name()
            self.state = 4968
            self.define_table()
            self.state = 4970
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.PARTITION:
                self.state = 4969
                localctx.part = self.partition_by()


            self.state = 4974
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 4972
                self.match(postgreSQLParser.USING)
                self.state = 4973
                self.identifier()


            self.state = 4977
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITHOUT or _la==postgreSQLParser.WITH:
                self.state = 4976
                self.storage_parameter_oid()


            self.state = 4980
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ON:
                self.state = 4979
                self.on_commit()


            self.state = 4983
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLESPACE:
                self.state = 4982
                self.table_space()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_table_as_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def UNLOGGED(self):
            return self.getToken(postgreSQLParser.UNLOGGED, 0)

        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def storage_parameter_oid(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameter_oidContext,0)


        def on_commit(self):
            return self.getTypedRuleContext(postgreSQLParser.On_commitContext,0)


        def table_space(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_spaceContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def GLOBAL(self):
            return self.getToken(postgreSQLParser.GLOBAL, 0)

        def LOCAL(self):
            return self.getToken(postgreSQLParser.LOCAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_table_as_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_table_as_statement" ):
                listener.enterCreate_table_as_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_table_as_statement" ):
                listener.exitCreate_table_as_statement(self)




    def create_table_as_statement(self):

        localctx = postgreSQLParser.Create_table_as_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 440, self.RULE_create_table_as_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 4990
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.GLOBAL, postgreSQLParser.LOCAL, postgreSQLParser.TEMP, postgreSQLParser.TEMPORARY]:
                self.state = 4986
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.GLOBAL or _la==postgreSQLParser.LOCAL:
                    self.state = 4985
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.GLOBAL or _la==postgreSQLParser.LOCAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 4988
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.TEMP or _la==postgreSQLParser.TEMPORARY):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.UNLOGGED]:
                self.state = 4989
                self.match(postgreSQLParser.UNLOGGED)
                pass
            elif token in [postgreSQLParser.TABLE]:
                pass
            else:
                pass
            self.state = 4992
            self.match(postgreSQLParser.TABLE)
            self.state = 4994
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,608,self._ctx)
            if la_ == 1:
                self.state = 4993
                self.if_not_exists()


            self.state = 4996
            localctx.name = self.schema_qualified_name()
            self.state = 4998
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 4997
                self.names_in_parens()


            self.state = 5002
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 5000
                self.match(postgreSQLParser.USING)
                self.state = 5001
                self.identifier()


            self.state = 5005
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITHOUT or _la==postgreSQLParser.WITH:
                self.state = 5004
                self.storage_parameter_oid()


            self.state = 5008
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ON:
                self.state = 5007
                self.on_commit()


            self.state = 5011
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLESPACE:
                self.state = 5010
                self.table_space()


            self.state = 5013
            self.match(postgreSQLParser.AS)
            self.state = 5017
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE, postgreSQLParser.WITH, postgreSQLParser.LEFT_PAREN]:
                self.state = 5014
                self.select_stmt()
                pass
            elif token in [postgreSQLParser.EXECUTE]:
                self.state = 5015
                self.match(postgreSQLParser.EXECUTE)
                self.state = 5016
                self.function_call()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 5024
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 5019
                self.match(postgreSQLParser.WITH)
                self.state = 5021
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 5020
                    self.match(postgreSQLParser.NO)


                self.state = 5023
                self.match(postgreSQLParser.DATA)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Create_foreign_table_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def define_server(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_serverContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def define_columns(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_columnsContext,0)


        def define_partition(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_partitionContext,0)


        def if_not_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_not_existsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_create_foreign_table_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCreate_foreign_table_statement" ):
                listener.enterCreate_foreign_table_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCreate_foreign_table_statement" ):
                listener.exitCreate_foreign_table_statement(self)




    def create_foreign_table_statement(self):

        localctx = postgreSQLParser.Create_foreign_table_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 442, self.RULE_create_foreign_table_statement)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5026
            self.match(postgreSQLParser.FOREIGN)
            self.state = 5027
            self.match(postgreSQLParser.TABLE)
            self.state = 5029
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,617,self._ctx)
            if la_ == 1:
                self.state = 5028
                self.if_not_exists()


            self.state = 5031
            localctx.name = self.schema_qualified_name()
            self.state = 5034
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LEFT_PAREN]:
                self.state = 5032
                self.define_columns()
                pass
            elif token in [postgreSQLParser.PARTITION]:
                self.state = 5033
                self.define_partition()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 5036
            self.define_server()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def define_columns(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_columnsContext,0)


        def define_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_typeContext,0)


        def define_partition(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_partitionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_define_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_table" ):
                listener.enterDefine_table(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_table" ):
                listener.exitDefine_table(self)




    def define_table(self):

        localctx = postgreSQLParser.Define_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 444, self.RULE_define_table)
        try:
            self.state = 5041
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5038
                self.define_columns()
                pass
            elif token in [postgreSQLParser.OF]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5039
                self.define_type()
                pass
            elif token in [postgreSQLParser.PARTITION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5040
                self.define_partition()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_partitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.parent_table = None # Schema_qualified_nameContext

        def PARTITION(self):
            return self.getToken(postgreSQLParser.PARTITION, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def for_values_bound(self):
            return self.getTypedRuleContext(postgreSQLParser.For_values_boundContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def list_of_type_column_def(self):
            return self.getTypedRuleContext(postgreSQLParser.List_of_type_column_defContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_define_partition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_partition" ):
                listener.enterDefine_partition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_partition" ):
                listener.exitDefine_partition(self)




    def define_partition(self):

        localctx = postgreSQLParser.Define_partitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 446, self.RULE_define_partition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5043
            self.match(postgreSQLParser.PARTITION)
            self.state = 5044
            self.match(postgreSQLParser.OF)
            self.state = 5045
            localctx.parent_table = self.schema_qualified_name()
            self.state = 5047
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 5046
                self.list_of_type_column_def()


            self.state = 5049
            self.for_values_bound()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class For_values_boundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def VALUES(self):
            return self.getToken(postgreSQLParser.VALUES, 0)

        def partition_bound_spec(self):
            return self.getTypedRuleContext(postgreSQLParser.Partition_bound_specContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_for_values_bound

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFor_values_bound" ):
                listener.enterFor_values_bound(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFor_values_bound" ):
                listener.exitFor_values_bound(self)




    def for_values_bound(self):

        localctx = postgreSQLParser.For_values_boundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 448, self.RULE_for_values_bound)
        try:
            self.state = 5055
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.FOR]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5051
                self.match(postgreSQLParser.FOR)
                self.state = 5052
                self.match(postgreSQLParser.VALUES)
                self.state = 5053
                self.partition_bound_spec()
                pass
            elif token in [postgreSQLParser.DEFAULT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5054
                self.match(postgreSQLParser.DEFAULT)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_bound_specContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def partition_bound_part(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Partition_bound_partContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Partition_bound_partContext,i)


        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def MODULUS(self):
            return self.getToken(postgreSQLParser.MODULUS, 0)

        def NUMBER_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NUMBER_LITERAL)
            else:
                return self.getToken(postgreSQLParser.NUMBER_LITERAL, i)

        def REMAINDER(self):
            return self.getToken(postgreSQLParser.REMAINDER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_partition_bound_spec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_bound_spec" ):
                listener.enterPartition_bound_spec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_bound_spec" ):
                listener.exitPartition_bound_spec(self)




    def partition_bound_spec(self):

        localctx = postgreSQLParser.Partition_bound_specContext(self, self._ctx, self.state)
        self.enterRule(localctx, 450, self.RULE_partition_bound_spec)
        self._la = 0 # Token type
        try:
            self.state = 5082
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.IN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5057
                self.match(postgreSQLParser.IN)
                self.state = 5058
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5059
                self.vex(0)
                self.state = 5064
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 5060
                    self.match(postgreSQLParser.COMMA)
                    self.state = 5061
                    self.vex(0)
                    self.state = 5066
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 5067
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.FROM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5069
                self.match(postgreSQLParser.FROM)
                self.state = 5070
                self.partition_bound_part()
                self.state = 5071
                self.match(postgreSQLParser.TO)
                self.state = 5072
                self.partition_bound_part()
                pass
            elif token in [postgreSQLParser.WITH]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5074
                self.match(postgreSQLParser.WITH)
                self.state = 5075
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5076
                self.match(postgreSQLParser.MODULUS)
                self.state = 5077
                self.match(postgreSQLParser.NUMBER_LITERAL)
                self.state = 5078
                self.match(postgreSQLParser.COMMA)
                self.state = 5079
                self.match(postgreSQLParser.REMAINDER)
                self.state = 5080
                self.match(postgreSQLParser.NUMBER_LITERAL)
                self.state = 5081
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_bound_partContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_partition_bound_part

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_bound_part" ):
                listener.enterPartition_bound_part(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_bound_part" ):
                listener.exitPartition_bound_part(self)




    def partition_bound_part(self):

        localctx = postgreSQLParser.Partition_bound_partContext(self, self._ctx, self.state)
        self.enterRule(localctx, 452, self.RULE_partition_bound_part)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5084
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5085
            self.vex(0)
            self.state = 5090
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5086
                self.match(postgreSQLParser.COMMA)
                self.state = 5087
                self.vex(0)
                self.state = 5092
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 5093
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_columnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def table_column_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_column_defContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_column_defContext,i)


        def INHERITS(self):
            return self.getToken(postgreSQLParser.INHERITS, 0)

        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_define_columns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_columns" ):
                listener.enterDefine_columns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_columns" ):
                listener.exitDefine_columns(self)




    def define_columns(self):

        localctx = postgreSQLParser.Define_columnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 454, self.RULE_define_columns)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5095
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5104
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.LIKE - 320)))) != 0) or ((((_la - 385)) & ~0x3f) == 0 and ((1 << (_la - 385)) & ((1 << (postgreSQLParser.CHECK - 385)) | (1 << (postgreSQLParser.CONSTRAINT - 385)) | (1 << (postgreSQLParser.DEFAULT - 385)) | (1 << (postgreSQLParser.FOREIGN - 385)) | (1 << (postgreSQLParser.NOT - 385)) | (1 << (postgreSQLParser.NULL - 385)) | (1 << (postgreSQLParser.PRIMARY - 385)) | (1 << (postgreSQLParser.REFERENCES - 385)) | (1 << (postgreSQLParser.UNIQUE - 385)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 5096
                self.table_column_def()
                self.state = 5101
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 5097
                    self.match(postgreSQLParser.COMMA)
                    self.state = 5098
                    self.table_column_def()
                    self.state = 5103
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 5106
            self.match(postgreSQLParser.RIGHT_PAREN)
            self.state = 5109
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INHERITS:
                self.state = 5107
                self.match(postgreSQLParser.INHERITS)
                self.state = 5108
                self.names_in_parens()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.type_name = None # Data_typeContext

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def list_of_type_column_def(self):
            return self.getTypedRuleContext(postgreSQLParser.List_of_type_column_defContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_define_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_type" ):
                listener.enterDefine_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_type" ):
                listener.exitDefine_type(self)




    def define_type(self):

        localctx = postgreSQLParser.Define_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 456, self.RULE_define_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5111
            self.match(postgreSQLParser.OF)
            self.state = 5112
            localctx.type_name = self.data_type()
            self.state = 5114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 5113
                self.list_of_type_column_def()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_byContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION(self):
            return self.getToken(postgreSQLParser.PARTITION, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def partition_method(self):
            return self.getTypedRuleContext(postgreSQLParser.Partition_methodContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_partition_by

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_by" ):
                listener.enterPartition_by(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_by" ):
                listener.exitPartition_by(self)




    def partition_by(self):

        localctx = postgreSQLParser.Partition_byContext(self, self._ctx, self.state)
        self.enterRule(localctx, 458, self.RULE_partition_by)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5116
            self.match(postgreSQLParser.PARTITION)
            self.state = 5117
            self.match(postgreSQLParser.BY)
            self.state = 5118
            self.partition_method()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_methodContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def partition_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Partition_columnContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Partition_columnContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def RANGE(self):
            return self.getToken(postgreSQLParser.RANGE, 0)

        def LIST(self):
            return self.getToken(postgreSQLParser.LIST, 0)

        def HASH(self):
            return self.getToken(postgreSQLParser.HASH, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_partition_method

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_method" ):
                listener.enterPartition_method(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_method" ):
                listener.exitPartition_method(self)




    def partition_method(self):

        localctx = postgreSQLParser.Partition_methodContext(self, self._ctx, self.state)
        self.enterRule(localctx, 460, self.RULE_partition_method)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5120
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.RANGE or _la==postgreSQLParser.HASH or _la==postgreSQLParser.LIST):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5121
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5122
            self.partition_column()
            self.state = 5127
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5123
                self.match(postgreSQLParser.COMMA)
                self.state = 5124
                self.partition_column()
                self.state = 5129
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 5130
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_partition_column

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_column" ):
                listener.enterPartition_column(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_column" ):
                listener.exitPartition_column(self)




    def partition_column(self):

        localctx = postgreSQLParser.Partition_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 462, self.RULE_partition_column)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5132
            self.vex(0)
            self.state = 5134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 5133
                self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_serverContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_define_server

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_server" ):
                listener.enterDefine_server(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_server" ):
                listener.exitDefine_server(self)




    def define_server(self):

        localctx = postgreSQLParser.Define_serverContext(self, self._ctx, self.state)
        self.enterRule(localctx, 464, self.RULE_define_server)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5136
            self.match(postgreSQLParser.SERVER)
            self.state = 5137
            self.identifier()
            self.state = 5139
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 5138
                self.define_foreign_options()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Define_foreign_optionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPTIONS(self):
            return self.getToken(postgreSQLParser.OPTIONS, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def foreign_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Foreign_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Foreign_optionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_define_foreign_options

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefine_foreign_options" ):
                listener.enterDefine_foreign_options(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefine_foreign_options" ):
                listener.exitDefine_foreign_options(self)




    def define_foreign_options(self):

        localctx = postgreSQLParser.Define_foreign_optionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 466, self.RULE_define_foreign_options)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5141
            self.match(postgreSQLParser.OPTIONS)
            self.state = 5142
            self.match(postgreSQLParser.LEFT_PAREN)

            self.state = 5143
            self.foreign_option()
            self.state = 5148
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5144
                self.match(postgreSQLParser.COMMA)
                self.state = 5145
                self.foreign_option()
                self.state = 5150
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 5151
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Foreign_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def foreign_option_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Foreign_option_nameContext,0)


        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_foreign_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForeign_option" ):
                listener.enterForeign_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForeign_option" ):
                listener.exitForeign_option(self)




    def foreign_option(self):

        localctx = postgreSQLParser.Foreign_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 468, self.RULE_foreign_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5154
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,633,self._ctx)
            if la_ == 1:
                self.state = 5153
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ADD or _la==postgreSQLParser.DROP or _la==postgreSQLParser.SET):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 5156
            self.foreign_option_name()
            self.state = 5158
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.Character_String_Literal or _la==postgreSQLParser.BeginDollarStringConstant:
                self.state = 5157
                self.character_string()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Foreign_option_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_foreign_option_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterForeign_option_name" ):
                listener.enterForeign_option_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitForeign_option_name" ):
                listener.exitForeign_option_name(self)




    def foreign_option_name(self):

        localctx = postgreSQLParser.Foreign_option_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 470, self.RULE_foreign_option_name)
        try:
            self.state = 5162
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5160
                self.identifier()
                pass
            elif token in [postgreSQLParser.USER]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5161
                self.match(postgreSQLParser.USER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class List_of_type_column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def table_of_type_column_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Table_of_type_column_defContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Table_of_type_column_defContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_list_of_type_column_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterList_of_type_column_def" ):
                listener.enterList_of_type_column_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitList_of_type_column_def" ):
                listener.exitList_of_type_column_def(self)




    def list_of_type_column_def(self):

        localctx = postgreSQLParser.List_of_type_column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 472, self.RULE_list_of_type_column_def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5164
            self.match(postgreSQLParser.LEFT_PAREN)

            self.state = 5165
            self.table_of_type_column_def()
            self.state = 5170
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5166
                self.match(postgreSQLParser.COMMA)
                self.state = 5167
                self.table_of_type_column_def()
                self.state = 5172
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 5173
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def table_column_definition(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_column_definitionContext,0)


        def constraint_common(self):
            return self.getTypedRuleContext(postgreSQLParser.Constraint_commonContext,0)


        def LIKE(self):
            return self.getToken(postgreSQLParser.LIKE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def like_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Like_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Like_optionContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_column_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_column_def" ):
                listener.enterTable_column_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_column_def" ):
                listener.exitTable_column_def(self)




    def table_column_def(self):

        localctx = postgreSQLParser.Table_column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 474, self.RULE_table_column_def)
        self._la = 0 # Token type
        try:
            self.state = 5185
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,638,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5175
                self.table_column_definition()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5176
                self.constraint_common()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5177
                self.match(postgreSQLParser.LIKE)
                self.state = 5178
                self.schema_qualified_name()
                self.state = 5182
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.EXCLUDING or _la==postgreSQLParser.INCLUDING:
                    self.state = 5179
                    self.like_option()
                    self.state = 5184
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_of_type_column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.tabl_constraint = None # Constraint_commonContext

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def OPTIONS(self):
            return self.getToken(postgreSQLParser.OPTIONS, 0)

        def constraint_common(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Constraint_commonContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Constraint_commonContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_of_type_column_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_of_type_column_def" ):
                listener.enterTable_of_type_column_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_of_type_column_def" ):
                listener.exitTable_of_type_column_def(self)




    def table_of_type_column_def(self):

        localctx = postgreSQLParser.Table_of_type_column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 476, self.RULE_table_of_type_column_def)
        self._la = 0 # Token type
        try:
            self.state = 5199
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,641,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5187
                self.identifier()
                self.state = 5190
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 5188
                    self.match(postgreSQLParser.WITH)
                    self.state = 5189
                    self.match(postgreSQLParser.OPTIONS)


                self.state = 5195
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.EXCLUDE or _la==postgreSQLParser.GENERATED or ((((_la - 385)) & ~0x3f) == 0 and ((1 << (_la - 385)) & ((1 << (postgreSQLParser.CHECK - 385)) | (1 << (postgreSQLParser.CONSTRAINT - 385)) | (1 << (postgreSQLParser.DEFAULT - 385)) | (1 << (postgreSQLParser.FOREIGN - 385)) | (1 << (postgreSQLParser.NOT - 385)) | (1 << (postgreSQLParser.NULL - 385)) | (1 << (postgreSQLParser.PRIMARY - 385)) | (1 << (postgreSQLParser.REFERENCES - 385)) | (1 << (postgreSQLParser.UNIQUE - 385)))) != 0):
                    self.state = 5192
                    self.constraint_common()
                    self.state = 5197
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5198
                localctx.tabl_constraint = self.constraint_common()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_column_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.cn = None # IdentifierContext
            self.dt = None # Data_typeContext

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def define_foreign_options(self):
            return self.getTypedRuleContext(postgreSQLParser.Define_foreign_optionsContext,0)


        def collate_identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Collate_identifierContext,0)


        def constraint_common(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Constraint_commonContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Constraint_commonContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_column_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_column_definition" ):
                listener.enterTable_column_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_column_definition" ):
                listener.exitTable_column_definition(self)




    def table_column_definition(self):

        localctx = postgreSQLParser.Table_column_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 478, self.RULE_table_column_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5201
            localctx.cn = self.identifier()
            self.state = 5202
            localctx.dt = self.data_type()
            self.state = 5204
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OPTIONS:
                self.state = 5203
                self.define_foreign_options()


            self.state = 5207
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COLLATE:
                self.state = 5206
                self.collate_identifier()


            self.state = 5212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.EXCLUDE or _la==postgreSQLParser.GENERATED or ((((_la - 385)) & ~0x3f) == 0 and ((1 << (_la - 385)) & ((1 << (postgreSQLParser.CHECK - 385)) | (1 << (postgreSQLParser.CONSTRAINT - 385)) | (1 << (postgreSQLParser.DEFAULT - 385)) | (1 << (postgreSQLParser.FOREIGN - 385)) | (1 << (postgreSQLParser.NOT - 385)) | (1 << (postgreSQLParser.NULL - 385)) | (1 << (postgreSQLParser.PRIMARY - 385)) | (1 << (postgreSQLParser.REFERENCES - 385)) | (1 << (postgreSQLParser.UNIQUE - 385)))) != 0):
                self.state = 5209
                self.constraint_common()
                self.state = 5214
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Like_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INCLUDING(self):
            return self.getToken(postgreSQLParser.INCLUDING, 0)

        def EXCLUDING(self):
            return self.getToken(postgreSQLParser.EXCLUDING, 0)

        def COMMENTS(self):
            return self.getToken(postgreSQLParser.COMMENTS, 0)

        def CONSTRAINTS(self):
            return self.getToken(postgreSQLParser.CONSTRAINTS, 0)

        def DEFAULTS(self):
            return self.getToken(postgreSQLParser.DEFAULTS, 0)

        def GENERATED(self):
            return self.getToken(postgreSQLParser.GENERATED, 0)

        def IDENTITY(self):
            return self.getToken(postgreSQLParser.IDENTITY, 0)

        def INDEXES(self):
            return self.getToken(postgreSQLParser.INDEXES, 0)

        def STORAGE(self):
            return self.getToken(postgreSQLParser.STORAGE, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_like_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLike_option" ):
                listener.enterLike_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLike_option" ):
                listener.exitLike_option(self)




    def like_option(self):

        localctx = postgreSQLParser.Like_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 480, self.RULE_like_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5215
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.EXCLUDING or _la==postgreSQLParser.INCLUDING):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5216
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.DEFAULTS))) != 0) or ((((_la - 95)) & ~0x3f) == 0 and ((1 << (_la - 95)) & ((1 << (postgreSQLParser.GENERATED - 95)) | (1 << (postgreSQLParser.IDENTITY - 95)) | (1 << (postgreSQLParser.INDEXES - 95)))) != 0) or _la==postgreSQLParser.STORAGE or _la==postgreSQLParser.ALL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constraint_commonContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def constr_body(self):
            return self.getTypedRuleContext(postgreSQLParser.Constr_bodyContext,0)


        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def table_deferrable(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_deferrableContext,0)


        def table_initialy_immed(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_initialy_immedContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_constraint_common

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConstraint_common" ):
                listener.enterConstraint_common(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConstraint_common" ):
                listener.exitConstraint_common(self)




    def constraint_common(self):

        localctx = postgreSQLParser.Constraint_commonContext(self, self._ctx, self.state)
        self.enterRule(localctx, 482, self.RULE_constraint_common)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5220
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONSTRAINT:
                self.state = 5218
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 5219
                self.identifier()


            self.state = 5222
            self.constr_body()
            self.state = 5224
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,646,self._ctx)
            if la_ == 1:
                self.state = 5223
                self.table_deferrable()


            self.state = 5227
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INITIALLY:
                self.state = 5226
                self.table_initialy_immed()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Constr_bodyContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return postgreSQLParser.RULE_constr_body

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class Notnullconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)
        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotnullconstr_body" ):
                listener.enterNotnullconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotnullconstr_body" ):
                listener.exitNotnullconstr_body(self)


    class Pkeyconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.pkey = None # Names_in_parensContext
            self.copyFrom(ctx)

        def index_parameters(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_parametersContext,0)

        def UNIQUE(self):
            return self.getToken(postgreSQLParser.UNIQUE, 0)
        def PRIMARY(self):
            return self.getToken(postgreSQLParser.PRIMARY, 0)
        def KEY(self):
            return self.getToken(postgreSQLParser.KEY, 0)
        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPkeyconstr_body" ):
                listener.enterPkeyconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPkeyconstr_body" ):
                listener.exitPkeyconstr_body(self)


    class Defconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.default_expr = None # VexContext
            self.copyFrom(ctx)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)
        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDefconstr_body" ):
                listener.enterDefconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDefconstr_body" ):
                listener.exitDefconstr_body(self)


    class Idconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def identity_body(self):
            return self.getTypedRuleContext(postgreSQLParser.Identity_bodyContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdconstr_body" ):
                listener.enterIdconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdconstr_body" ):
                listener.exitIdconstr_body(self)


    class Fkeyconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.fkey = None # Names_in_parensContext
            self.reft = None # Schema_qualified_nameContext
            self.ref = None # Names_in_parensContext
            self.copyFrom(ctx)

        def REFERENCES(self):
            return self.getToken(postgreSQLParser.REFERENCES, 0)
        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)
        def KEY(self):
            return self.getToken(postgreSQLParser.KEY, 0)
        def MATCH(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.MATCH)
            else:
                return self.getToken(postgreSQLParser.MATCH, i)
        def ON(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ON)
            else:
                return self.getToken(postgreSQLParser.ON, i)
        def action(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.ActionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.ActionContext,i)

        def names_in_parens(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Names_in_parensContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,i)

        def FULL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.FULL)
            else:
                return self.getToken(postgreSQLParser.FULL, i)
        def PARTIAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.PARTIAL)
            else:
                return self.getToken(postgreSQLParser.PARTIAL, i)
        def SIMPLE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SIMPLE)
            else:
                return self.getToken(postgreSQLParser.SIMPLE, i)
        def DELETE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DELETE)
            else:
                return self.getToken(postgreSQLParser.DELETE, i)
        def UPDATE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.UPDATE)
            else:
                return self.getToken(postgreSQLParser.UPDATE, i)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFkeyconstr_body" ):
                listener.enterFkeyconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFkeyconstr_body" ):
                listener.exitFkeyconstr_body(self)


    class Genconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def GENERATED(self):
            return self.getToken(postgreSQLParser.GENERATED, 0)
        def ALWAYS(self):
            return self.getToken(postgreSQLParser.ALWAYS, 0)
        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)
        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)
        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)
        def STORED(self):
            return self.getToken(postgreSQLParser.STORED, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGenconstr_body" ):
                listener.enterGenconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGenconstr_body" ):
                listener.exitGenconstr_body(self)


    class Excludeconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.index_method = None # IdentifierContext
            self.where = None # Token
            self.exp = None # VexContext
            self.copyFrom(ctx)

        def EXCLUDE(self):
            return self.getToken(postgreSQLParser.EXCLUDE, 0)
        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)
        def index_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Index_columnContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Index_columnContext,i)

        def WITH(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WITH)
            else:
                return self.getToken(postgreSQLParser.WITH, i)
        def all_op(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.All_opContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.All_opContext,i)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)
        def index_parameters(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_parametersContext,0)

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)
        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)
        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)
        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExcludeconstr_body" ):
                listener.enterExcludeconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExcludeconstr_body" ):
                listener.exitExcludeconstr_body(self)


    class Checkconstr_bodyContext(Constr_bodyContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a postgreSQLParser.Constr_bodyContext
            super().__init__(parser)
            self.expression = None # VexContext
            self.copyFrom(ctx)

        def CHECK(self):
            return self.getToken(postgreSQLParser.CHECK, 0)
        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)
        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)
        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)
        def INHERIT(self):
            return self.getToken(postgreSQLParser.INHERIT, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCheckconstr_body" ):
                listener.enterCheckconstr_body(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCheckconstr_body" ):
                listener.exitCheckconstr_body(self)



    def constr_body(self):

        localctx = postgreSQLParser.Constr_bodyContext(self, self._ctx, self.state)
        self.enterRule(localctx, 484, self.RULE_constr_body)
        self._la = 0 # Token type
        try:
            self.state = 5306
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,659,self._ctx)
            if la_ == 1:
                localctx = postgreSQLParser.Excludeconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 5229
                self.match(postgreSQLParser.EXCLUDE)
                self.state = 5232
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.USING:
                    self.state = 5230
                    self.match(postgreSQLParser.USING)
                    self.state = 5231
                    localctx.index_method = self.identifier()


                self.state = 5234
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5235
                self.index_column()
                self.state = 5236
                self.match(postgreSQLParser.WITH)
                self.state = 5237
                self.all_op()
                self.state = 5245
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 5238
                    self.match(postgreSQLParser.COMMA)
                    self.state = 5239
                    self.index_column()
                    self.state = 5240
                    self.match(postgreSQLParser.WITH)
                    self.state = 5241
                    self.all_op()
                    self.state = 5247
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 5248
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 5249
                self.index_parameters()
                self.state = 5252
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WHERE:
                    self.state = 5250
                    localctx.where = self.match(postgreSQLParser.WHERE)
                    self.state = 5251
                    localctx.exp = self.vex(0)


                pass

            elif la_ == 2:
                localctx = postgreSQLParser.Fkeyconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 5257
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOREIGN:
                    self.state = 5254
                    self.match(postgreSQLParser.FOREIGN)
                    self.state = 5255
                    self.match(postgreSQLParser.KEY)
                    self.state = 5256
                    localctx.fkey = self.names_in_parens()


                self.state = 5259
                self.match(postgreSQLParser.REFERENCES)
                self.state = 5260
                localctx.reft = self.schema_qualified_name()
                self.state = 5262
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 5261
                    localctx.ref = self.names_in_parens()


                self.state = 5271
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.MATCH or _la==postgreSQLParser.ON:
                    self.state = 5269
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.MATCH]:
                        self.state = 5264
                        self.match(postgreSQLParser.MATCH)
                        self.state = 5265
                        _la = self._input.LA(1)
                        if not(_la==postgreSQLParser.PARTIAL or _la==postgreSQLParser.SIMPLE or _la==postgreSQLParser.FULL):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        pass
                    elif token in [postgreSQLParser.ON]:
                        self.state = 5266
                        self.match(postgreSQLParser.ON)
                        self.state = 5267
                        _la = self._input.LA(1)
                        if not(_la==postgreSQLParser.DELETE or _la==postgreSQLParser.UPDATE):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 5268
                        self.action()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 5273
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 3:
                localctx = postgreSQLParser.Checkconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 3)
                self.state = 5274
                self.match(postgreSQLParser.CHECK)
                self.state = 5275
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5276
                localctx.expression = self.vex(0)
                self.state = 5277
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 5280
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO:
                    self.state = 5278
                    self.match(postgreSQLParser.NO)
                    self.state = 5279
                    self.match(postgreSQLParser.INHERIT)


                pass

            elif la_ == 4:
                localctx = postgreSQLParser.Notnullconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 4)
                self.state = 5283
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 5282
                    self.match(postgreSQLParser.NOT)


                self.state = 5285
                self.match(postgreSQLParser.NULL)
                pass

            elif la_ == 5:
                localctx = postgreSQLParser.Pkeyconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 5)
                self.state = 5289
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.UNIQUE]:
                    self.state = 5286
                    self.match(postgreSQLParser.UNIQUE)
                    pass
                elif token in [postgreSQLParser.PRIMARY]:
                    self.state = 5287
                    self.match(postgreSQLParser.PRIMARY)
                    self.state = 5288
                    self.match(postgreSQLParser.KEY)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 5292
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 5291
                    localctx.pkey = self.names_in_parens()


                self.state = 5294
                self.index_parameters()
                pass

            elif la_ == 6:
                localctx = postgreSQLParser.Defconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 6)
                self.state = 5295
                self.match(postgreSQLParser.DEFAULT)
                self.state = 5296
                localctx.default_expr = self.vex(0)
                pass

            elif la_ == 7:
                localctx = postgreSQLParser.Idconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 7)
                self.state = 5297
                self.identity_body()
                pass

            elif la_ == 8:
                localctx = postgreSQLParser.Genconstr_bodyContext(self, localctx)
                self.enterOuterAlt(localctx, 8)
                self.state = 5298
                self.match(postgreSQLParser.GENERATED)
                self.state = 5299
                self.match(postgreSQLParser.ALWAYS)
                self.state = 5300
                self.match(postgreSQLParser.AS)
                self.state = 5301
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5302
                self.vex(0)
                self.state = 5303
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 5304
                self.match(postgreSQLParser.STORED)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class All_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def op(self):
            return self.getTypedRuleContext(postgreSQLParser.OpContext,0)


        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def NOT_EQUAL(self):
            return self.getToken(postgreSQLParser.NOT_EQUAL, 0)

        def LTH(self):
            return self.getToken(postgreSQLParser.LTH, 0)

        def LEQ(self):
            return self.getToken(postgreSQLParser.LEQ, 0)

        def GTH(self):
            return self.getToken(postgreSQLParser.GTH, 0)

        def GEQ(self):
            return self.getToken(postgreSQLParser.GEQ, 0)

        def PLUS(self):
            return self.getToken(postgreSQLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(postgreSQLParser.MINUS, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(postgreSQLParser.DIVIDE, 0)

        def MODULAR(self):
            return self.getToken(postgreSQLParser.MODULAR, 0)

        def EXP(self):
            return self.getToken(postgreSQLParser.EXP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_all_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAll_op" ):
                listener.enterAll_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAll_op" ):
                listener.exitAll_op(self)




    def all_op(self):

        localctx = postgreSQLParser.All_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 486, self.RULE_all_op)
        try:
            self.state = 5321
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.OPERATOR, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5308
                self.op()
                pass
            elif token in [postgreSQLParser.EQUAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5309
                self.match(postgreSQLParser.EQUAL)
                pass
            elif token in [postgreSQLParser.NOT_EQUAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5310
                self.match(postgreSQLParser.NOT_EQUAL)
                pass
            elif token in [postgreSQLParser.LTH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5311
                self.match(postgreSQLParser.LTH)
                pass
            elif token in [postgreSQLParser.LEQ]:
                self.enterOuterAlt(localctx, 5)
                self.state = 5312
                self.match(postgreSQLParser.LEQ)
                pass
            elif token in [postgreSQLParser.GTH]:
                self.enterOuterAlt(localctx, 6)
                self.state = 5313
                self.match(postgreSQLParser.GTH)
                pass
            elif token in [postgreSQLParser.GEQ]:
                self.enterOuterAlt(localctx, 7)
                self.state = 5314
                self.match(postgreSQLParser.GEQ)
                pass
            elif token in [postgreSQLParser.PLUS]:
                self.enterOuterAlt(localctx, 8)
                self.state = 5315
                self.match(postgreSQLParser.PLUS)
                pass
            elif token in [postgreSQLParser.MINUS]:
                self.enterOuterAlt(localctx, 9)
                self.state = 5316
                self.match(postgreSQLParser.MINUS)
                pass
            elif token in [postgreSQLParser.MULTIPLY]:
                self.enterOuterAlt(localctx, 10)
                self.state = 5317
                self.match(postgreSQLParser.MULTIPLY)
                pass
            elif token in [postgreSQLParser.DIVIDE]:
                self.enterOuterAlt(localctx, 11)
                self.state = 5318
                self.match(postgreSQLParser.DIVIDE)
                pass
            elif token in [postgreSQLParser.MODULAR]:
                self.enterOuterAlt(localctx, 12)
                self.state = 5319
                self.match(postgreSQLParser.MODULAR)
                pass
            elif token in [postgreSQLParser.EXP]:
                self.enterOuterAlt(localctx, 13)
                self.state = 5320
                self.match(postgreSQLParser.EXP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class All_simple_opContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def op_chars(self):
            return self.getTypedRuleContext(postgreSQLParser.Op_charsContext,0)


        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def NOT_EQUAL(self):
            return self.getToken(postgreSQLParser.NOT_EQUAL, 0)

        def LTH(self):
            return self.getToken(postgreSQLParser.LTH, 0)

        def LEQ(self):
            return self.getToken(postgreSQLParser.LEQ, 0)

        def GTH(self):
            return self.getToken(postgreSQLParser.GTH, 0)

        def GEQ(self):
            return self.getToken(postgreSQLParser.GEQ, 0)

        def PLUS(self):
            return self.getToken(postgreSQLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(postgreSQLParser.MINUS, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(postgreSQLParser.DIVIDE, 0)

        def MODULAR(self):
            return self.getToken(postgreSQLParser.MODULAR, 0)

        def EXP(self):
            return self.getToken(postgreSQLParser.EXP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_all_simple_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAll_simple_op" ):
                listener.enterAll_simple_op(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAll_simple_op" ):
                listener.exitAll_simple_op(self)




    def all_simple_op(self):

        localctx = postgreSQLParser.All_simple_opContext(self, self._ctx, self.state)
        self.enterRule(localctx, 488, self.RULE_all_simple_op)
        try:
            self.state = 5336
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5323
                self.op_chars()
                pass
            elif token in [postgreSQLParser.EQUAL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5324
                self.match(postgreSQLParser.EQUAL)
                pass
            elif token in [postgreSQLParser.NOT_EQUAL]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5325
                self.match(postgreSQLParser.NOT_EQUAL)
                pass
            elif token in [postgreSQLParser.LTH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5326
                self.match(postgreSQLParser.LTH)
                pass
            elif token in [postgreSQLParser.LEQ]:
                self.enterOuterAlt(localctx, 5)
                self.state = 5327
                self.match(postgreSQLParser.LEQ)
                pass
            elif token in [postgreSQLParser.GTH]:
                self.enterOuterAlt(localctx, 6)
                self.state = 5328
                self.match(postgreSQLParser.GTH)
                pass
            elif token in [postgreSQLParser.GEQ]:
                self.enterOuterAlt(localctx, 7)
                self.state = 5329
                self.match(postgreSQLParser.GEQ)
                pass
            elif token in [postgreSQLParser.PLUS]:
                self.enterOuterAlt(localctx, 8)
                self.state = 5330
                self.match(postgreSQLParser.PLUS)
                pass
            elif token in [postgreSQLParser.MINUS]:
                self.enterOuterAlt(localctx, 9)
                self.state = 5331
                self.match(postgreSQLParser.MINUS)
                pass
            elif token in [postgreSQLParser.MULTIPLY]:
                self.enterOuterAlt(localctx, 10)
                self.state = 5332
                self.match(postgreSQLParser.MULTIPLY)
                pass
            elif token in [postgreSQLParser.DIVIDE]:
                self.enterOuterAlt(localctx, 11)
                self.state = 5333
                self.match(postgreSQLParser.DIVIDE)
                pass
            elif token in [postgreSQLParser.MODULAR]:
                self.enterOuterAlt(localctx, 12)
                self.state = 5334
                self.match(postgreSQLParser.MODULAR)
                pass
            elif token in [postgreSQLParser.EXP]:
                self.enterOuterAlt(localctx, 13)
                self.state = 5335
                self.match(postgreSQLParser.EXP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Op_charsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OP_CHARS(self):
            return self.getToken(postgreSQLParser.OP_CHARS, 0)

        def LESS_LESS(self):
            return self.getToken(postgreSQLParser.LESS_LESS, 0)

        def GREATER_GREATER(self):
            return self.getToken(postgreSQLParser.GREATER_GREATER, 0)

        def HASH_SIGN(self):
            return self.getToken(postgreSQLParser.HASH_SIGN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_op_chars

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp_chars" ):
                listener.enterOp_chars(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp_chars" ):
                listener.exitOp_chars(self)




    def op_chars(self):

        localctx = postgreSQLParser.Op_charsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 490, self.RULE_op_chars)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5338
            _la = self._input.LA(1)
            if not(((((_la - 611)) & ~0x3f) == 0 and ((1 << (_la - 611)) & ((1 << (postgreSQLParser.LESS_LESS - 611)) | (1 << (postgreSQLParser.GREATER_GREATER - 611)) | (1 << (postgreSQLParser.HASH_SIGN - 611)) | (1 << (postgreSQLParser.OP_CHARS - 611)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Index_parametersContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def including_index(self):
            return self.getTypedRuleContext(postgreSQLParser.Including_indexContext,0)


        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def table_space(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_spaceContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_index_parameters

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndex_parameters" ):
                listener.enterIndex_parameters(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndex_parameters" ):
                listener.exitIndex_parameters(self)




    def index_parameters(self):

        localctx = postgreSQLParser.Index_parametersContext(self, self._ctx, self.state)
        self.enterRule(localctx, 492, self.RULE_index_parameters)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5341
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.INCLUDE:
                self.state = 5340
                self.including_index()


            self.state = 5344
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 5343
                self.with_storage_parameter()


            self.state = 5352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 5346
                self.match(postgreSQLParser.USING)
                self.state = 5347
                self.match(postgreSQLParser.INDEX)
                self.state = 5350
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,664,self._ctx)
                if la_ == 1:
                    self.state = 5348
                    self.table_space()
                    pass

                elif la_ == 2:
                    self.state = 5349
                    self.schema_qualified_name()
                    pass




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Names_in_parensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def names_references(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_referencesContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_names_in_parens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNames_in_parens" ):
                listener.enterNames_in_parens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNames_in_parens" ):
                listener.exitNames_in_parens(self)




    def names_in_parens(self):

        localctx = postgreSQLParser.Names_in_parensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 494, self.RULE_names_in_parens)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5354
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5355
            self.names_references()
            self.state = 5356
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Names_referencesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_names_references

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNames_references" ):
                listener.enterNames_references(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNames_references" ):
                listener.exitNames_references(self)




    def names_references(self):

        localctx = postgreSQLParser.Names_referencesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 496, self.RULE_names_references)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5358
            self.schema_qualified_name()
            self.state = 5363
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5359
                self.match(postgreSQLParser.COMMA)
                self.state = 5360
                self.schema_qualified_name()
                self.state = 5365
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Storage_parameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def storage_parameter_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Storage_parameter_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Storage_parameter_optionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_storage_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorage_parameter" ):
                listener.enterStorage_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorage_parameter" ):
                listener.exitStorage_parameter(self)




    def storage_parameter(self):

        localctx = postgreSQLParser.Storage_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 498, self.RULE_storage_parameter)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5366
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5367
            self.storage_parameter_option()
            self.state = 5372
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5368
                self.match(postgreSQLParser.COMMA)
                self.state = 5369
                self.storage_parameter_option()
                self.state = 5374
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 5375
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Storage_parameter_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def storage_parameter_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameter_nameContext,0)


        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_storage_parameter_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorage_parameter_option" ):
                listener.enterStorage_parameter_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorage_parameter_option" ):
                listener.exitStorage_parameter_option(self)




    def storage_parameter_option(self):

        localctx = postgreSQLParser.Storage_parameter_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 500, self.RULE_storage_parameter_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5377
            self.storage_parameter_name()
            self.state = 5380
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.EQUAL:
                self.state = 5378
                self.match(postgreSQLParser.EQUAL)
                self.state = 5379
                self.vex(0)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Storage_parameter_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def col_label(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Col_labelContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Col_labelContext,i)


        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_storage_parameter_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorage_parameter_name" ):
                listener.enterStorage_parameter_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorage_parameter_name" ):
                listener.exitStorage_parameter_name(self)




    def storage_parameter_name(self):

        localctx = postgreSQLParser.Storage_parameter_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 502, self.RULE_storage_parameter_name)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5382
            self.col_label()
            self.state = 5385
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DOT:
                self.state = 5383
                self.match(postgreSQLParser.DOT)
                self.state = 5384
                self.col_label()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class With_storage_parameterContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.Storage_parameterContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_with_storage_parameter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_storage_parameter" ):
                listener.enterWith_storage_parameter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_storage_parameter" ):
                listener.exitWith_storage_parameter(self)




    def with_storage_parameter(self):

        localctx = postgreSQLParser.With_storage_parameterContext(self, self._ctx, self.state)
        self.enterRule(localctx, 504, self.RULE_with_storage_parameter)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5387
            self.match(postgreSQLParser.WITH)
            self.state = 5388
            self.storage_parameter()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Storage_parameter_oidContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def with_storage_parameter(self):
            return self.getTypedRuleContext(postgreSQLParser.With_storage_parameterContext,0)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def OIDS(self):
            return self.getToken(postgreSQLParser.OIDS, 0)

        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_storage_parameter_oid

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStorage_parameter_oid" ):
                listener.enterStorage_parameter_oid(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStorage_parameter_oid" ):
                listener.exitStorage_parameter_oid(self)




    def storage_parameter_oid(self):

        localctx = postgreSQLParser.Storage_parameter_oidContext(self, self._ctx, self.state)
        self.enterRule(localctx, 506, self.RULE_storage_parameter_oid)
        try:
            self.state = 5395
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,670,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5390
                self.with_storage_parameter()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5391
                self.match(postgreSQLParser.WITH)
                self.state = 5392
                self.match(postgreSQLParser.OIDS)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5393
                self.match(postgreSQLParser.WITHOUT)
                self.state = 5394
                self.match(postgreSQLParser.OIDS)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class On_commitContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def COMMIT(self):
            return self.getToken(postgreSQLParser.COMMIT, 0)

        def PRESERVE(self):
            return self.getToken(postgreSQLParser.PRESERVE, 0)

        def ROWS(self):
            return self.getToken(postgreSQLParser.ROWS, 0)

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_on_commit

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOn_commit" ):
                listener.enterOn_commit(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOn_commit" ):
                listener.exitOn_commit(self)




    def on_commit(self):

        localctx = postgreSQLParser.On_commitContext(self, self._ctx, self.state)
        self.enterRule(localctx, 508, self.RULE_on_commit)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5397
            self.match(postgreSQLParser.ON)
            self.state = 5398
            self.match(postgreSQLParser.COMMIT)
            self.state = 5404
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.PRESERVE]:
                self.state = 5399
                self.match(postgreSQLParser.PRESERVE)
                self.state = 5400
                self.match(postgreSQLParser.ROWS)
                pass
            elif token in [postgreSQLParser.DELETE]:
                self.state = 5401
                self.match(postgreSQLParser.DELETE)
                self.state = 5402
                self.match(postgreSQLParser.ROWS)
                pass
            elif token in [postgreSQLParser.DROP]:
                self.state = 5403
                self.match(postgreSQLParser.DROP)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_spaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_space

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_space" ):
                listener.enterTable_space(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_space" ):
                listener.exitTable_space(self)




    def table_space(self):

        localctx = postgreSQLParser.Table_spaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 510, self.RULE_table_space)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5406
            self.match(postgreSQLParser.TABLESPACE)
            self.state = 5407
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_tablespaceContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def NOWAIT(self):
            return self.getToken(postgreSQLParser.NOWAIT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_tablespace

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_tablespace" ):
                listener.enterSet_tablespace(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_tablespace" ):
                listener.exitSet_tablespace(self)




    def set_tablespace(self):

        localctx = postgreSQLParser.Set_tablespaceContext(self, self._ctx, self.state)
        self.enterRule(localctx, 512, self.RULE_set_tablespace)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5409
            self.match(postgreSQLParser.SET)
            self.state = 5410
            self.match(postgreSQLParser.TABLESPACE)
            self.state = 5411
            self.identifier()
            self.state = 5413
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NOWAIT:
                self.state = 5412
                self.match(postgreSQLParser.NOWAIT)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class ActionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def ACTION(self):
            return self.getToken(postgreSQLParser.ACTION, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAction" ):
                listener.enterAction(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAction" ):
                listener.exitAction(self)




    def action(self):

        localctx = postgreSQLParser.ActionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 514, self.RULE_action)
        self._la = 0 # Token type
        try:
            self.state = 5420
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CASCADE, postgreSQLParser.RESTRICT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5415
                self.cascade_restrict()
                pass
            elif token in [postgreSQLParser.SET]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5416
                self.match(postgreSQLParser.SET)
                self.state = 5417
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.DEFAULT or _la==postgreSQLParser.NULL):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass
            elif token in [postgreSQLParser.NO]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5418
                self.match(postgreSQLParser.NO)
                self.state = 5419
                self.match(postgreSQLParser.ACTION)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Owner_toContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def OWNER(self):
            return self.getToken(postgreSQLParser.OWNER, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def CURRENT_USER(self):
            return self.getToken(postgreSQLParser.CURRENT_USER, 0)

        def SESSION_USER(self):
            return self.getToken(postgreSQLParser.SESSION_USER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_owner_to

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOwner_to" ):
                listener.enterOwner_to(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOwner_to" ):
                listener.exitOwner_to(self)




    def owner_to(self):

        localctx = postgreSQLParser.Owner_toContext(self, self._ctx, self.state)
        self.enterRule(localctx, 516, self.RULE_owner_to)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5422
            self.match(postgreSQLParser.OWNER)
            self.state = 5423
            self.match(postgreSQLParser.TO)
            self.state = 5427
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 5424
                localctx.name = self.identifier()
                pass
            elif token in [postgreSQLParser.CURRENT_USER]:
                self.state = 5425
                self.match(postgreSQLParser.CURRENT_USER)
                pass
            elif token in [postgreSQLParser.SESSION_USER]:
                self.state = 5426
                self.match(postgreSQLParser.SESSION_USER)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Rename_toContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_rename_to

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRename_to" ):
                listener.enterRename_to(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRename_to" ):
                listener.exitRename_to(self)




    def rename_to(self):

        localctx = postgreSQLParser.Rename_toContext(self, self._ctx, self.state)
        self.enterRule(localctx, 518, self.RULE_rename_to)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5429
            self.match(postgreSQLParser.RENAME)
            self.state = 5430
            self.match(postgreSQLParser.TO)
            self.state = 5431
            localctx.name = self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_schemaContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_schema

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_schema" ):
                listener.enterSet_schema(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_schema" ):
                listener.exitSet_schema(self)




    def set_schema(self):

        localctx = postgreSQLParser.Set_schemaContext(self, self._ctx, self.state)
        self.enterRule(localctx, 520, self.RULE_set_schema)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5433
            self.match(postgreSQLParser.SET)
            self.state = 5434
            self.match(postgreSQLParser.SCHEMA)
            self.state = 5435
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_column_privilegeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def INSERT(self):
            return self.getToken(postgreSQLParser.INSERT, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def TRUNCATE(self):
            return self.getToken(postgreSQLParser.TRUNCATE, 0)

        def REFERENCES(self):
            return self.getToken(postgreSQLParser.REFERENCES, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def PRIVILEGES(self):
            return self.getToken(postgreSQLParser.PRIVILEGES, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_column_privilege

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_column_privilege" ):
                listener.enterTable_column_privilege(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_column_privilege" ):
                listener.exitTable_column_privilege(self)




    def table_column_privilege(self):

        localctx = postgreSQLParser.Table_column_privilegeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 522, self.RULE_table_column_privilege)
        self._la = 0 # Token type
        try:
            self.state = 5448
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.SELECT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5437
                self.match(postgreSQLParser.SELECT)
                pass
            elif token in [postgreSQLParser.INSERT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5438
                self.match(postgreSQLParser.INSERT)
                pass
            elif token in [postgreSQLParser.UPDATE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5439
                self.match(postgreSQLParser.UPDATE)
                pass
            elif token in [postgreSQLParser.DELETE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5440
                self.match(postgreSQLParser.DELETE)
                pass
            elif token in [postgreSQLParser.TRUNCATE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 5441
                self.match(postgreSQLParser.TRUNCATE)
                pass
            elif token in [postgreSQLParser.REFERENCES]:
                self.enterOuterAlt(localctx, 6)
                self.state = 5442
                self.match(postgreSQLParser.REFERENCES)
                pass
            elif token in [postgreSQLParser.TRIGGER]:
                self.enterOuterAlt(localctx, 7)
                self.state = 5443
                self.match(postgreSQLParser.TRIGGER)
                pass
            elif token in [postgreSQLParser.ALL]:
                self.enterOuterAlt(localctx, 8)
                self.state = 5444
                self.match(postgreSQLParser.ALL)
                self.state = 5446
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PRIVILEGES:
                    self.state = 5445
                    self.match(postgreSQLParser.PRIVILEGES)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Usage_select_updateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USAGE(self):
            return self.getToken(postgreSQLParser.USAGE, 0)

        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_usage_select_update

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUsage_select_update" ):
                listener.enterUsage_select_update(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUsage_select_update" ):
                listener.exitUsage_select_update(self)




    def usage_select_update(self):

        localctx = postgreSQLParser.Usage_select_updateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 524, self.RULE_usage_select_update)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5450
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.UPDATE or _la==postgreSQLParser.SELECT or _la==postgreSQLParser.USAGE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Partition_by_columnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def PARTITION(self):
            return self.getToken(postgreSQLParser.PARTITION, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_partition_by_columns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPartition_by_columns" ):
                listener.enterPartition_by_columns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPartition_by_columns" ):
                listener.exitPartition_by_columns(self)




    def partition_by_columns(self):

        localctx = postgreSQLParser.Partition_by_columnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 526, self.RULE_partition_by_columns)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5452
            self.match(postgreSQLParser.PARTITION)
            self.state = 5453
            self.match(postgreSQLParser.BY)
            self.state = 5454
            self.vex(0)
            self.state = 5459
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5455
                self.match(postgreSQLParser.COMMA)
                self.state = 5456
                self.vex(0)
                self.state = 5461
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cascade_restrictContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASCADE(self):
            return self.getToken(postgreSQLParser.CASCADE, 0)

        def RESTRICT(self):
            return self.getToken(postgreSQLParser.RESTRICT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_cascade_restrict

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCascade_restrict" ):
                listener.enterCascade_restrict(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCascade_restrict" ):
                listener.exitCascade_restrict(self)




    def cascade_restrict(self):

        localctx = postgreSQLParser.Cascade_restrictContext(self, self._ctx, self.state)
        self.enterRule(localctx, 528, self.RULE_cascade_restrict)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5462
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Collate_identifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.collation = None # Schema_qualified_nameContext

        def COLLATE(self):
            return self.getToken(postgreSQLParser.COLLATE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_collate_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCollate_identifier" ):
                listener.enterCollate_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCollate_identifier" ):
                listener.exitCollate_identifier(self)




    def collate_identifier(self):

        localctx = postgreSQLParser.Collate_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 530, self.RULE_collate_identifier)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5464
            self.match(postgreSQLParser.COLLATE)
            self.state = 5465
            localctx.collation = self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Indirection_varContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def dollar_number(self):
            return self.getTypedRuleContext(postgreSQLParser.Dollar_numberContext,0)


        def indirection_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Indirection_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_indirection_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndirection_var" ):
                listener.enterIndirection_var(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndirection_var" ):
                listener.exitIndirection_var(self)




    def indirection_var(self):

        localctx = postgreSQLParser.Indirection_varContext(self, self._ctx, self.state)
        self.enterRule(localctx, 532, self.RULE_indirection_var)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5469
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 5467
                self.identifier()
                pass
            elif token in [postgreSQLParser.DOLLAR_NUMBER]:
                self.state = 5468
                self.dollar_number()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 5472
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,679,self._ctx)
            if la_ == 1:
                self.state = 5471
                self.indirection_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dollar_numberContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOLLAR_NUMBER(self):
            return self.getToken(postgreSQLParser.DOLLAR_NUMBER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_dollar_number

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDollar_number" ):
                listener.enterDollar_number(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDollar_number" ):
                listener.exitDollar_number(self)




    def dollar_number(self):

        localctx = postgreSQLParser.Dollar_numberContext(self, self._ctx, self.state)
        self.enterRule(localctx, 534, self.RULE_dollar_number)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5474
            self.match(postgreSQLParser.DOLLAR_NUMBER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Indirection_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def indirection(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IndirectionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IndirectionContext,i)


        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_indirection_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndirection_list" ):
                listener.enterIndirection_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndirection_list" ):
                listener.exitIndirection_list(self)




    def indirection_list(self):

        localctx = postgreSQLParser.Indirection_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 536, self.RULE_indirection_list)
        try:
            self.state = 5489
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,682,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5477 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 5476
                        self.indirection()

                    else:
                        raise NoViableAltException(self)
                    self.state = 5479 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,680,self._ctx)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5484
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,681,self._ctx)
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt==1:
                        self.state = 5481
                        self.indirection() 
                    self.state = 5486
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,681,self._ctx)

                self.state = 5487
                self.match(postgreSQLParser.DOT)
                self.state = 5488
                self.match(postgreSQLParser.MULTIPLY)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IndirectionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def col_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Col_labelContext,0)


        def LEFT_BRACKET(self):
            return self.getToken(postgreSQLParser.LEFT_BRACKET, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_BRACKET(self):
            return self.getToken(postgreSQLParser.RIGHT_BRACKET, 0)

        def COLON(self):
            return self.getToken(postgreSQLParser.COLON, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_indirection

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndirection" ):
                listener.enterIndirection(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndirection" ):
                listener.exitIndirection(self)




    def indirection(self):

        localctx = postgreSQLParser.IndirectionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 538, self.RULE_indirection)
        self._la = 0 # Token type
        try:
            self.state = 5506
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,685,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5491
                self.match(postgreSQLParser.DOT)
                self.state = 5492
                self.col_label()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5493
                self.match(postgreSQLParser.LEFT_BRACKET)
                self.state = 5494
                self.vex(0)
                self.state = 5495
                self.match(postgreSQLParser.RIGHT_BRACKET)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5497
                self.match(postgreSQLParser.LEFT_BRACKET)
                self.state = 5499
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                    self.state = 5498
                    self.vex(0)


                self.state = 5501
                self.match(postgreSQLParser.COLON)
                self.state = 5503
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                    self.state = 5502
                    self.vex(0)


                self.state = 5505
                self.match(postgreSQLParser.RIGHT_BRACKET)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_database_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def FORCE(self):
            return self.getToken(postgreSQLParser.FORCE, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_database_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_database_statement" ):
                listener.enterDrop_database_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_database_statement" ):
                listener.exitDrop_database_statement(self)




    def drop_database_statement(self):

        localctx = postgreSQLParser.Drop_database_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 540, self.RULE_drop_database_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5508
            self.match(postgreSQLParser.DATABASE)
            self.state = 5510
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,686,self._ctx)
            if la_ == 1:
                self.state = 5509
                self.if_exists()


            self.state = 5512
            self.identifier()
            self.state = 5519
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH or _la==postgreSQLParser.LEFT_PAREN:
                self.state = 5514
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WITH:
                    self.state = 5513
                    self.match(postgreSQLParser.WITH)


                self.state = 5516
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5517
                self.match(postgreSQLParser.FORCE)
                self.state = 5518
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_function_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # Schema_qualified_nameContext

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def function_args(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_argsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_function_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_function_statement" ):
                listener.enterDrop_function_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_function_statement" ):
                listener.exitDrop_function_statement(self)




    def drop_function_statement(self):

        localctx = postgreSQLParser.Drop_function_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 542, self.RULE_drop_function_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5521
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.AGGREGATE or _la==postgreSQLParser.FUNCTION or _la==postgreSQLParser.PROCEDURE):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 5523
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,689,self._ctx)
            if la_ == 1:
                self.state = 5522
                self.if_exists()


            self.state = 5525
            localctx.name = self.schema_qualified_name()
            self.state = 5527
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 5526
                self.function_args()


            self.state = 5530
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 5529
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_trigger_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.table_name = None # Schema_qualified_nameContext

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_trigger_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_trigger_statement" ):
                listener.enterDrop_trigger_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_trigger_statement" ):
                listener.exitDrop_trigger_statement(self)




    def drop_trigger_statement(self):

        localctx = postgreSQLParser.Drop_trigger_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 544, self.RULE_drop_trigger_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5532
            self.match(postgreSQLParser.TRIGGER)
            self.state = 5534
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,692,self._ctx)
            if la_ == 1:
                self.state = 5533
                self.if_exists()


            self.state = 5536
            localctx.name = self.identifier()
            self.state = 5537
            self.match(postgreSQLParser.ON)
            self.state = 5538
            localctx.table_name = self.schema_qualified_name()
            self.state = 5540
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 5539
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_rule_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def RULE(self):
            return self.getToken(postgreSQLParser.RULE, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_rule_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_rule_statement" ):
                listener.enterDrop_rule_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_rule_statement" ):
                listener.exitDrop_rule_statement(self)




    def drop_rule_statement(self):

        localctx = postgreSQLParser.Drop_rule_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 546, self.RULE_drop_rule_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5542
            self.match(postgreSQLParser.RULE)
            self.state = 5544
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,694,self._ctx)
            if la_ == 1:
                self.state = 5543
                self.if_exists()


            self.state = 5546
            localctx.name = self.identifier()
            self.state = 5547
            self.match(postgreSQLParser.ON)
            self.state = 5548
            self.schema_qualified_name()
            self.state = 5550
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 5549
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Drop_statementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def if_exist_names_restrict_cascade(self):
            return self.getTypedRuleContext(postgreSQLParser.If_exist_names_restrict_cascadeContext,0)


        def ACCESS(self):
            return self.getToken(postgreSQLParser.ACCESS, 0)

        def METHOD(self):
            return self.getToken(postgreSQLParser.METHOD, 0)

        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def CONVERSION(self):
            return self.getToken(postgreSQLParser.CONVERSION, 0)

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def STATISTICS(self):
            return self.getToken(postgreSQLParser.STATISTICS, 0)

        def SUBSCRIPTION(self):
            return self.getToken(postgreSQLParser.SUBSCRIPTION, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def CONCURRENTLY(self):
            return self.getToken(postgreSQLParser.CONCURRENTLY, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_drop_statements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDrop_statements" ):
                listener.enterDrop_statements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDrop_statements" ):
                listener.exitDrop_statements(self)




    def drop_statements(self):

        localctx = postgreSQLParser.Drop_statementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 548, self.RULE_drop_statements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5593
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,700,self._ctx)
            if la_ == 1:
                self.state = 5552
                self.match(postgreSQLParser.ACCESS)
                self.state = 5553
                self.match(postgreSQLParser.METHOD)
                pass

            elif la_ == 2:
                self.state = 5554
                self.match(postgreSQLParser.COLLATION)
                pass

            elif la_ == 3:
                self.state = 5555
                self.match(postgreSQLParser.CONVERSION)
                pass

            elif la_ == 4:
                self.state = 5556
                self.match(postgreSQLParser.DOMAIN)
                pass

            elif la_ == 5:
                self.state = 5557
                self.match(postgreSQLParser.EVENT)
                self.state = 5558
                self.match(postgreSQLParser.TRIGGER)
                pass

            elif la_ == 6:
                self.state = 5559
                self.match(postgreSQLParser.EXTENSION)
                pass

            elif la_ == 7:
                self.state = 5560
                self.match(postgreSQLParser.GROUP)
                pass

            elif la_ == 8:
                self.state = 5562
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOREIGN:
                    self.state = 5561
                    self.match(postgreSQLParser.FOREIGN)


                self.state = 5564
                self.match(postgreSQLParser.TABLE)
                pass

            elif la_ == 9:
                self.state = 5565
                self.match(postgreSQLParser.FOREIGN)
                self.state = 5566
                self.match(postgreSQLParser.DATA)
                self.state = 5567
                self.match(postgreSQLParser.WRAPPER)
                pass

            elif la_ == 10:
                self.state = 5568
                self.match(postgreSQLParser.INDEX)
                self.state = 5570
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CONCURRENTLY:
                    self.state = 5569
                    self.match(postgreSQLParser.CONCURRENTLY)


                pass

            elif la_ == 11:
                self.state = 5573
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.MATERIALIZED:
                    self.state = 5572
                    self.match(postgreSQLParser.MATERIALIZED)


                self.state = 5575
                self.match(postgreSQLParser.VIEW)
                pass

            elif la_ == 12:
                self.state = 5577
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PROCEDURAL:
                    self.state = 5576
                    self.match(postgreSQLParser.PROCEDURAL)


                self.state = 5579
                self.match(postgreSQLParser.LANGUAGE)
                pass

            elif la_ == 13:
                self.state = 5580
                self.match(postgreSQLParser.PUBLICATION)
                pass

            elif la_ == 14:
                self.state = 5581
                self.match(postgreSQLParser.ROLE)
                pass

            elif la_ == 15:
                self.state = 5582
                self.match(postgreSQLParser.SCHEMA)
                pass

            elif la_ == 16:
                self.state = 5583
                self.match(postgreSQLParser.SEQUENCE)
                pass

            elif la_ == 17:
                self.state = 5584
                self.match(postgreSQLParser.SERVER)
                pass

            elif la_ == 18:
                self.state = 5585
                self.match(postgreSQLParser.STATISTICS)
                pass

            elif la_ == 19:
                self.state = 5586
                self.match(postgreSQLParser.SUBSCRIPTION)
                pass

            elif la_ == 20:
                self.state = 5587
                self.match(postgreSQLParser.TABLESPACE)
                pass

            elif la_ == 21:
                self.state = 5588
                self.match(postgreSQLParser.TYPE)
                pass

            elif la_ == 22:
                self.state = 5589
                self.match(postgreSQLParser.TEXT)
                self.state = 5590
                self.match(postgreSQLParser.SEARCH)
                self.state = 5591
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONFIGURATION or _la==postgreSQLParser.DICTIONARY or _la==postgreSQLParser.PARSER or _la==postgreSQLParser.TEMPLATE):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 23:
                self.state = 5592
                self.match(postgreSQLParser.USER)
                pass


            self.state = 5595
            self.if_exist_names_restrict_cascade()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_exist_names_restrict_cascadeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def names_references(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_referencesContext,0)


        def if_exists(self):
            return self.getTypedRuleContext(postgreSQLParser.If_existsContext,0)


        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_if_exist_names_restrict_cascade

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_exist_names_restrict_cascade" ):
                listener.enterIf_exist_names_restrict_cascade(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_exist_names_restrict_cascade" ):
                listener.exitIf_exist_names_restrict_cascade(self)




    def if_exist_names_restrict_cascade(self):

        localctx = postgreSQLParser.If_exist_names_restrict_cascadeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 550, self.RULE_if_exist_names_restrict_cascade)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5598
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,701,self._ctx)
            if la_ == 1:
                self.state = 5597
                self.if_exists()


            self.state = 5600
            self.names_references()
            self.state = 5602
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 5601
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Id_tokenContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def Identifier(self):
            return self.getToken(postgreSQLParser.Identifier, 0)

        def QuotedIdentifier(self):
            return self.getToken(postgreSQLParser.QuotedIdentifier, 0)

        def tokens_nonkeyword(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_nonkeywordContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_id_token

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterId_token" ):
                listener.enterId_token(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitId_token" ):
                listener.exitId_token(self)




    def id_token(self):

        localctx = postgreSQLParser.Id_tokenContext(self, self._ctx, self.state)
        self.enterRule(localctx, 552, self.RULE_id_token)
        try:
            self.state = 5607
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.Identifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5604
                self.match(postgreSQLParser.Identifier)
                pass
            elif token in [postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5605
                self.match(postgreSQLParser.QuotedIdentifier)
                pass
            elif token in [postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5606
                self.tokens_nonkeyword()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class IdentifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_token(self):
            return self.getTypedRuleContext(postgreSQLParser.Id_tokenContext,0)


        def tokens_nonreserved(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_nonreservedContext,0)


        def tokens_nonreserved_except_function_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_nonreserved_except_function_typeContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier" ):
                listener.enterIdentifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier" ):
                listener.exitIdentifier(self)




    def identifier(self):

        localctx = postgreSQLParser.IdentifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 554, self.RULE_identifier)
        try:
            self.state = 5612
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5609
                self.id_token()
                pass
            elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5610
                self.tokens_nonreserved()
                pass
            elif token in [postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5611
                self.tokens_nonreserved_except_function_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Identifier_nontypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_token(self):
            return self.getTypedRuleContext(postgreSQLParser.Id_tokenContext,0)


        def tokens_nonreserved(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_nonreservedContext,0)


        def tokens_reserved_except_function_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_reserved_except_function_typeContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_identifier_nontype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier_nontype" ):
                listener.enterIdentifier_nontype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier_nontype" ):
                listener.exitIdentifier_nontype(self)




    def identifier_nontype(self):

        localctx = postgreSQLParser.Identifier_nontypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 556, self.RULE_identifier_nontype)
        try:
            self.state = 5617
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5614
                self.id_token()
                pass
            elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5615
                self.tokens_nonreserved()
                pass
            elif token in [postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5616
                self.tokens_reserved_except_function_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Col_labelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def id_token(self):
            return self.getTypedRuleContext(postgreSQLParser.Id_tokenContext,0)


        def tokens_reserved(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_reservedContext,0)


        def tokens_nonreserved(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_nonreservedContext,0)


        def tokens_reserved_except_function_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_reserved_except_function_typeContext,0)


        def tokens_nonreserved_except_function_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Tokens_nonreserved_except_function_typeContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_col_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCol_label" ):
                listener.enterCol_label(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCol_label" ):
                listener.exitCol_label(self)




    def col_label(self):

        localctx = postgreSQLParser.Col_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 558, self.RULE_col_label)
        try:
            self.state = 5624
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 5619
                self.id_token()
                pass
            elif token in [postgreSQLParser.ALL, postgreSQLParser.ANALYZE, postgreSQLParser.AND, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.AS, postgreSQLParser.ASC, postgreSQLParser.ASYMMETRIC, postgreSQLParser.BOTH, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CHECK, postgreSQLParser.COLLATE, postgreSQLParser.COLUMN, postgreSQLParser.CONSTRAINT, postgreSQLParser.CREATE, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_ROLE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.DEFAULT, postgreSQLParser.DEFERRABLE, postgreSQLParser.DESC, postgreSQLParser.DISTINCT, postgreSQLParser.DO, postgreSQLParser.ELSE, postgreSQLParser.END, postgreSQLParser.EXCEPT, postgreSQLParser.FALSE, postgreSQLParser.FETCH, postgreSQLParser.FOR, postgreSQLParser.FOREIGN, postgreSQLParser.FROM, postgreSQLParser.GRANT, postgreSQLParser.GROUP, postgreSQLParser.HAVING, postgreSQLParser.IN, postgreSQLParser.INITIALLY, postgreSQLParser.INTERSECT, postgreSQLParser.INTO, postgreSQLParser.LATERAL, postgreSQLParser.LEADING, postgreSQLParser.LIMIT, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.OFFSET, postgreSQLParser.ON, postgreSQLParser.ONLY, postgreSQLParser.OR, postgreSQLParser.ORDER, postgreSQLParser.PLACING, postgreSQLParser.PRIMARY, postgreSQLParser.REFERENCES, postgreSQLParser.RETURNING, postgreSQLParser.SELECT, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.SYMMETRIC, postgreSQLParser.TABLE, postgreSQLParser.THEN, postgreSQLParser.TO, postgreSQLParser.TRAILING, postgreSQLParser.TRUE, postgreSQLParser.UNION, postgreSQLParser.UNIQUE, postgreSQLParser.USER, postgreSQLParser.USING, postgreSQLParser.VARIADIC, postgreSQLParser.WHEN, postgreSQLParser.WHERE, postgreSQLParser.WINDOW, postgreSQLParser.WITH]:
                self.enterOuterAlt(localctx, 2)
                self.state = 5620
                self.tokens_reserved()
                pass
            elif token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 5621
                self.tokens_nonreserved()
                pass
            elif token in [postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 5622
                self.tokens_reserved_except_function_type()
                pass
            elif token in [postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE]:
                self.enterOuterAlt(localctx, 5)
                self.state = 5623
                self.tokens_nonreserved_except_function_type()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tokens_nonreservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ABORT(self):
            return self.getToken(postgreSQLParser.ABORT, 0)

        def ABSOLUTE(self):
            return self.getToken(postgreSQLParser.ABSOLUTE, 0)

        def ACCESS(self):
            return self.getToken(postgreSQLParser.ACCESS, 0)

        def ACTION(self):
            return self.getToken(postgreSQLParser.ACTION, 0)

        def ADD(self):
            return self.getToken(postgreSQLParser.ADD, 0)

        def ADMIN(self):
            return self.getToken(postgreSQLParser.ADMIN, 0)

        def AFTER(self):
            return self.getToken(postgreSQLParser.AFTER, 0)

        def AGGREGATE(self):
            return self.getToken(postgreSQLParser.AGGREGATE, 0)

        def ALSO(self):
            return self.getToken(postgreSQLParser.ALSO, 0)

        def ALTER(self):
            return self.getToken(postgreSQLParser.ALTER, 0)

        def ALWAYS(self):
            return self.getToken(postgreSQLParser.ALWAYS, 0)

        def ASSERTION(self):
            return self.getToken(postgreSQLParser.ASSERTION, 0)

        def ASSIGNMENT(self):
            return self.getToken(postgreSQLParser.ASSIGNMENT, 0)

        def AT(self):
            return self.getToken(postgreSQLParser.AT, 0)

        def ATTACH(self):
            return self.getToken(postgreSQLParser.ATTACH, 0)

        def ATTRIBUTE(self):
            return self.getToken(postgreSQLParser.ATTRIBUTE, 0)

        def BACKWARD(self):
            return self.getToken(postgreSQLParser.BACKWARD, 0)

        def BEFORE(self):
            return self.getToken(postgreSQLParser.BEFORE, 0)

        def BEGIN(self):
            return self.getToken(postgreSQLParser.BEGIN, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def CACHE(self):
            return self.getToken(postgreSQLParser.CACHE, 0)

        def CALL(self):
            return self.getToken(postgreSQLParser.CALL, 0)

        def CALLED(self):
            return self.getToken(postgreSQLParser.CALLED, 0)

        def CASCADE(self):
            return self.getToken(postgreSQLParser.CASCADE, 0)

        def CASCADED(self):
            return self.getToken(postgreSQLParser.CASCADED, 0)

        def CATALOG(self):
            return self.getToken(postgreSQLParser.CATALOG, 0)

        def CHAIN(self):
            return self.getToken(postgreSQLParser.CHAIN, 0)

        def CHARACTERISTICS(self):
            return self.getToken(postgreSQLParser.CHARACTERISTICS, 0)

        def CHECKPOINT(self):
            return self.getToken(postgreSQLParser.CHECKPOINT, 0)

        def CLASS(self):
            return self.getToken(postgreSQLParser.CLASS, 0)

        def CLOSE(self):
            return self.getToken(postgreSQLParser.CLOSE, 0)

        def CLUSTER(self):
            return self.getToken(postgreSQLParser.CLUSTER, 0)

        def COLUMNS(self):
            return self.getToken(postgreSQLParser.COLUMNS, 0)

        def COMMENT(self):
            return self.getToken(postgreSQLParser.COMMENT, 0)

        def COMMENTS(self):
            return self.getToken(postgreSQLParser.COMMENTS, 0)

        def COMMIT(self):
            return self.getToken(postgreSQLParser.COMMIT, 0)

        def COMMITTED(self):
            return self.getToken(postgreSQLParser.COMMITTED, 0)

        def CONFIGURATION(self):
            return self.getToken(postgreSQLParser.CONFIGURATION, 0)

        def CONFLICT(self):
            return self.getToken(postgreSQLParser.CONFLICT, 0)

        def CONNECTION(self):
            return self.getToken(postgreSQLParser.CONNECTION, 0)

        def CONSTRAINTS(self):
            return self.getToken(postgreSQLParser.CONSTRAINTS, 0)

        def CONTENT(self):
            return self.getToken(postgreSQLParser.CONTENT, 0)

        def CONTINUE(self):
            return self.getToken(postgreSQLParser.CONTINUE, 0)

        def CONVERSION(self):
            return self.getToken(postgreSQLParser.CONVERSION, 0)

        def COPY(self):
            return self.getToken(postgreSQLParser.COPY, 0)

        def COST(self):
            return self.getToken(postgreSQLParser.COST, 0)

        def CSV(self):
            return self.getToken(postgreSQLParser.CSV, 0)

        def CUBE(self):
            return self.getToken(postgreSQLParser.CUBE, 0)

        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def CURSOR(self):
            return self.getToken(postgreSQLParser.CURSOR, 0)

        def CYCLE(self):
            return self.getToken(postgreSQLParser.CYCLE, 0)

        def DATA(self):
            return self.getToken(postgreSQLParser.DATA, 0)

        def DATABASE(self):
            return self.getToken(postgreSQLParser.DATABASE, 0)

        def DAY(self):
            return self.getToken(postgreSQLParser.DAY, 0)

        def DEALLOCATE(self):
            return self.getToken(postgreSQLParser.DEALLOCATE, 0)

        def DECLARE(self):
            return self.getToken(postgreSQLParser.DECLARE, 0)

        def DEFAULTS(self):
            return self.getToken(postgreSQLParser.DEFAULTS, 0)

        def DEFERRED(self):
            return self.getToken(postgreSQLParser.DEFERRED, 0)

        def DEFINER(self):
            return self.getToken(postgreSQLParser.DEFINER, 0)

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def DELIMITER(self):
            return self.getToken(postgreSQLParser.DELIMITER, 0)

        def DELIMITERS(self):
            return self.getToken(postgreSQLParser.DELIMITERS, 0)

        def DEPENDS(self):
            return self.getToken(postgreSQLParser.DEPENDS, 0)

        def DETACH(self):
            return self.getToken(postgreSQLParser.DETACH, 0)

        def DICTIONARY(self):
            return self.getToken(postgreSQLParser.DICTIONARY, 0)

        def DISABLE(self):
            return self.getToken(postgreSQLParser.DISABLE, 0)

        def DISCARD(self):
            return self.getToken(postgreSQLParser.DISCARD, 0)

        def DOCUMENT(self):
            return self.getToken(postgreSQLParser.DOCUMENT, 0)

        def DOMAIN(self):
            return self.getToken(postgreSQLParser.DOMAIN, 0)

        def DOUBLE(self):
            return self.getToken(postgreSQLParser.DOUBLE, 0)

        def DROP(self):
            return self.getToken(postgreSQLParser.DROP, 0)

        def EACH(self):
            return self.getToken(postgreSQLParser.EACH, 0)

        def ENABLE(self):
            return self.getToken(postgreSQLParser.ENABLE, 0)

        def ENCODING(self):
            return self.getToken(postgreSQLParser.ENCODING, 0)

        def ENCRYPTED(self):
            return self.getToken(postgreSQLParser.ENCRYPTED, 0)

        def ENUM(self):
            return self.getToken(postgreSQLParser.ENUM, 0)

        def ESCAPE(self):
            return self.getToken(postgreSQLParser.ESCAPE, 0)

        def EVENT(self):
            return self.getToken(postgreSQLParser.EVENT, 0)

        def EXCLUDE(self):
            return self.getToken(postgreSQLParser.EXCLUDE, 0)

        def EXCLUDING(self):
            return self.getToken(postgreSQLParser.EXCLUDING, 0)

        def EXCLUSIVE(self):
            return self.getToken(postgreSQLParser.EXCLUSIVE, 0)

        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def EXPLAIN(self):
            return self.getToken(postgreSQLParser.EXPLAIN, 0)

        def EXPRESSION(self):
            return self.getToken(postgreSQLParser.EXPRESSION, 0)

        def EXTENSION(self):
            return self.getToken(postgreSQLParser.EXTENSION, 0)

        def EXTERNAL(self):
            return self.getToken(postgreSQLParser.EXTERNAL, 0)

        def FAMILY(self):
            return self.getToken(postgreSQLParser.FAMILY, 0)

        def FILTER(self):
            return self.getToken(postgreSQLParser.FILTER, 0)

        def FIRST(self):
            return self.getToken(postgreSQLParser.FIRST, 0)

        def FOLLOWING(self):
            return self.getToken(postgreSQLParser.FOLLOWING, 0)

        def FORCE(self):
            return self.getToken(postgreSQLParser.FORCE, 0)

        def FORWARD(self):
            return self.getToken(postgreSQLParser.FORWARD, 0)

        def FUNCTION(self):
            return self.getToken(postgreSQLParser.FUNCTION, 0)

        def FUNCTIONS(self):
            return self.getToken(postgreSQLParser.FUNCTIONS, 0)

        def GENERATED(self):
            return self.getToken(postgreSQLParser.GENERATED, 0)

        def GLOBAL(self):
            return self.getToken(postgreSQLParser.GLOBAL, 0)

        def GRANTED(self):
            return self.getToken(postgreSQLParser.GRANTED, 0)

        def GROUPS(self):
            return self.getToken(postgreSQLParser.GROUPS, 0)

        def HANDLER(self):
            return self.getToken(postgreSQLParser.HANDLER, 0)

        def HEADER(self):
            return self.getToken(postgreSQLParser.HEADER, 0)

        def HOLD(self):
            return self.getToken(postgreSQLParser.HOLD, 0)

        def HOUR(self):
            return self.getToken(postgreSQLParser.HOUR, 0)

        def IDENTITY(self):
            return self.getToken(postgreSQLParser.IDENTITY, 0)

        def IF(self):
            return self.getToken(postgreSQLParser.IF, 0)

        def IMMEDIATE(self):
            return self.getToken(postgreSQLParser.IMMEDIATE, 0)

        def IMMUTABLE(self):
            return self.getToken(postgreSQLParser.IMMUTABLE, 0)

        def IMPLICIT(self):
            return self.getToken(postgreSQLParser.IMPLICIT, 0)

        def IMPORT(self):
            return self.getToken(postgreSQLParser.IMPORT, 0)

        def INCLUDE(self):
            return self.getToken(postgreSQLParser.INCLUDE, 0)

        def INCLUDING(self):
            return self.getToken(postgreSQLParser.INCLUDING, 0)

        def INCREMENT(self):
            return self.getToken(postgreSQLParser.INCREMENT, 0)

        def INDEX(self):
            return self.getToken(postgreSQLParser.INDEX, 0)

        def INDEXES(self):
            return self.getToken(postgreSQLParser.INDEXES, 0)

        def INHERIT(self):
            return self.getToken(postgreSQLParser.INHERIT, 0)

        def INHERITS(self):
            return self.getToken(postgreSQLParser.INHERITS, 0)

        def INLINE(self):
            return self.getToken(postgreSQLParser.INLINE, 0)

        def INPUT(self):
            return self.getToken(postgreSQLParser.INPUT, 0)

        def INSENSITIVE(self):
            return self.getToken(postgreSQLParser.INSENSITIVE, 0)

        def INSERT(self):
            return self.getToken(postgreSQLParser.INSERT, 0)

        def INSTEAD(self):
            return self.getToken(postgreSQLParser.INSTEAD, 0)

        def INVOKER(self):
            return self.getToken(postgreSQLParser.INVOKER, 0)

        def ISOLATION(self):
            return self.getToken(postgreSQLParser.ISOLATION, 0)

        def KEY(self):
            return self.getToken(postgreSQLParser.KEY, 0)

        def LABEL(self):
            return self.getToken(postgreSQLParser.LABEL, 0)

        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def LARGE(self):
            return self.getToken(postgreSQLParser.LARGE, 0)

        def LAST(self):
            return self.getToken(postgreSQLParser.LAST, 0)

        def LEAKPROOF(self):
            return self.getToken(postgreSQLParser.LEAKPROOF, 0)

        def LEVEL(self):
            return self.getToken(postgreSQLParser.LEVEL, 0)

        def LISTEN(self):
            return self.getToken(postgreSQLParser.LISTEN, 0)

        def LOAD(self):
            return self.getToken(postgreSQLParser.LOAD, 0)

        def LOCAL(self):
            return self.getToken(postgreSQLParser.LOCAL, 0)

        def LOCATION(self):
            return self.getToken(postgreSQLParser.LOCATION, 0)

        def LOCK(self):
            return self.getToken(postgreSQLParser.LOCK, 0)

        def LOCKED(self):
            return self.getToken(postgreSQLParser.LOCKED, 0)

        def LOGGED(self):
            return self.getToken(postgreSQLParser.LOGGED, 0)

        def MAPPING(self):
            return self.getToken(postgreSQLParser.MAPPING, 0)

        def MATCH(self):
            return self.getToken(postgreSQLParser.MATCH, 0)

        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def MAXVALUE(self):
            return self.getToken(postgreSQLParser.MAXVALUE, 0)

        def METHOD(self):
            return self.getToken(postgreSQLParser.METHOD, 0)

        def MINUTE(self):
            return self.getToken(postgreSQLParser.MINUTE, 0)

        def MINVALUE(self):
            return self.getToken(postgreSQLParser.MINVALUE, 0)

        def MODE(self):
            return self.getToken(postgreSQLParser.MODE, 0)

        def MONTH(self):
            return self.getToken(postgreSQLParser.MONTH, 0)

        def MOVE(self):
            return self.getToken(postgreSQLParser.MOVE, 0)

        def NAME(self):
            return self.getToken(postgreSQLParser.NAME, 0)

        def NAMES(self):
            return self.getToken(postgreSQLParser.NAMES, 0)

        def NEW(self):
            return self.getToken(postgreSQLParser.NEW, 0)

        def NEXT(self):
            return self.getToken(postgreSQLParser.NEXT, 0)

        def NFC(self):
            return self.getToken(postgreSQLParser.NFC, 0)

        def NFD(self):
            return self.getToken(postgreSQLParser.NFD, 0)

        def NFKC(self):
            return self.getToken(postgreSQLParser.NFKC, 0)

        def NFKD(self):
            return self.getToken(postgreSQLParser.NFKD, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def NORMALIZED(self):
            return self.getToken(postgreSQLParser.NORMALIZED, 0)

        def NOTHING(self):
            return self.getToken(postgreSQLParser.NOTHING, 0)

        def NOTIFY(self):
            return self.getToken(postgreSQLParser.NOTIFY, 0)

        def NOWAIT(self):
            return self.getToken(postgreSQLParser.NOWAIT, 0)

        def NULLS(self):
            return self.getToken(postgreSQLParser.NULLS, 0)

        def OBJECT(self):
            return self.getToken(postgreSQLParser.OBJECT, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def OFF(self):
            return self.getToken(postgreSQLParser.OFF, 0)

        def OIDS(self):
            return self.getToken(postgreSQLParser.OIDS, 0)

        def OLD(self):
            return self.getToken(postgreSQLParser.OLD, 0)

        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def OPTION(self):
            return self.getToken(postgreSQLParser.OPTION, 0)

        def OPTIONS(self):
            return self.getToken(postgreSQLParser.OPTIONS, 0)

        def ORDINALITY(self):
            return self.getToken(postgreSQLParser.ORDINALITY, 0)

        def OTHERS(self):
            return self.getToken(postgreSQLParser.OTHERS, 0)

        def OVER(self):
            return self.getToken(postgreSQLParser.OVER, 0)

        def OVERRIDING(self):
            return self.getToken(postgreSQLParser.OVERRIDING, 0)

        def OWNED(self):
            return self.getToken(postgreSQLParser.OWNED, 0)

        def OWNER(self):
            return self.getToken(postgreSQLParser.OWNER, 0)

        def PARALLEL(self):
            return self.getToken(postgreSQLParser.PARALLEL, 0)

        def PARSER(self):
            return self.getToken(postgreSQLParser.PARSER, 0)

        def PARTIAL(self):
            return self.getToken(postgreSQLParser.PARTIAL, 0)

        def PARTITION(self):
            return self.getToken(postgreSQLParser.PARTITION, 0)

        def PASSING(self):
            return self.getToken(postgreSQLParser.PASSING, 0)

        def PASSWORD(self):
            return self.getToken(postgreSQLParser.PASSWORD, 0)

        def PLANS(self):
            return self.getToken(postgreSQLParser.PLANS, 0)

        def POLICY(self):
            return self.getToken(postgreSQLParser.POLICY, 0)

        def PRECEDING(self):
            return self.getToken(postgreSQLParser.PRECEDING, 0)

        def PREPARE(self):
            return self.getToken(postgreSQLParser.PREPARE, 0)

        def PREPARED(self):
            return self.getToken(postgreSQLParser.PREPARED, 0)

        def PRESERVE(self):
            return self.getToken(postgreSQLParser.PRESERVE, 0)

        def PRIOR(self):
            return self.getToken(postgreSQLParser.PRIOR, 0)

        def PRIVILEGES(self):
            return self.getToken(postgreSQLParser.PRIVILEGES, 0)

        def PROCEDURAL(self):
            return self.getToken(postgreSQLParser.PROCEDURAL, 0)

        def PROCEDURE(self):
            return self.getToken(postgreSQLParser.PROCEDURE, 0)

        def PROCEDURES(self):
            return self.getToken(postgreSQLParser.PROCEDURES, 0)

        def PROGRAM(self):
            return self.getToken(postgreSQLParser.PROGRAM, 0)

        def PUBLICATION(self):
            return self.getToken(postgreSQLParser.PUBLICATION, 0)

        def QUOTE(self):
            return self.getToken(postgreSQLParser.QUOTE, 0)

        def RANGE(self):
            return self.getToken(postgreSQLParser.RANGE, 0)

        def READ(self):
            return self.getToken(postgreSQLParser.READ, 0)

        def REASSIGN(self):
            return self.getToken(postgreSQLParser.REASSIGN, 0)

        def RECHECK(self):
            return self.getToken(postgreSQLParser.RECHECK, 0)

        def RECURSIVE(self):
            return self.getToken(postgreSQLParser.RECURSIVE, 0)

        def REF(self):
            return self.getToken(postgreSQLParser.REF, 0)

        def REFERENCING(self):
            return self.getToken(postgreSQLParser.REFERENCING, 0)

        def REFRESH(self):
            return self.getToken(postgreSQLParser.REFRESH, 0)

        def REINDEX(self):
            return self.getToken(postgreSQLParser.REINDEX, 0)

        def RELATIVE(self):
            return self.getToken(postgreSQLParser.RELATIVE, 0)

        def RELEASE(self):
            return self.getToken(postgreSQLParser.RELEASE, 0)

        def RENAME(self):
            return self.getToken(postgreSQLParser.RENAME, 0)

        def REPEATABLE(self):
            return self.getToken(postgreSQLParser.REPEATABLE, 0)

        def REPLACE(self):
            return self.getToken(postgreSQLParser.REPLACE, 0)

        def REPLICA(self):
            return self.getToken(postgreSQLParser.REPLICA, 0)

        def RESET(self):
            return self.getToken(postgreSQLParser.RESET, 0)

        def RESTART(self):
            return self.getToken(postgreSQLParser.RESTART, 0)

        def RESTRICT(self):
            return self.getToken(postgreSQLParser.RESTRICT, 0)

        def RETURNS(self):
            return self.getToken(postgreSQLParser.RETURNS, 0)

        def REVOKE(self):
            return self.getToken(postgreSQLParser.REVOKE, 0)

        def ROLE(self):
            return self.getToken(postgreSQLParser.ROLE, 0)

        def ROLLBACK(self):
            return self.getToken(postgreSQLParser.ROLLBACK, 0)

        def ROLLUP(self):
            return self.getToken(postgreSQLParser.ROLLUP, 0)

        def ROUTINE(self):
            return self.getToken(postgreSQLParser.ROUTINE, 0)

        def ROUTINES(self):
            return self.getToken(postgreSQLParser.ROUTINES, 0)

        def ROWS(self):
            return self.getToken(postgreSQLParser.ROWS, 0)

        def RULE(self):
            return self.getToken(postgreSQLParser.RULE, 0)

        def SAVEPOINT(self):
            return self.getToken(postgreSQLParser.SAVEPOINT, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def SCHEMAS(self):
            return self.getToken(postgreSQLParser.SCHEMAS, 0)

        def SCROLL(self):
            return self.getToken(postgreSQLParser.SCROLL, 0)

        def SEARCH(self):
            return self.getToken(postgreSQLParser.SEARCH, 0)

        def SECOND(self):
            return self.getToken(postgreSQLParser.SECOND, 0)

        def SECURITY(self):
            return self.getToken(postgreSQLParser.SECURITY, 0)

        def SEQUENCE(self):
            return self.getToken(postgreSQLParser.SEQUENCE, 0)

        def SEQUENCES(self):
            return self.getToken(postgreSQLParser.SEQUENCES, 0)

        def SERIALIZABLE(self):
            return self.getToken(postgreSQLParser.SERIALIZABLE, 0)

        def SERVER(self):
            return self.getToken(postgreSQLParser.SERVER, 0)

        def SESSION(self):
            return self.getToken(postgreSQLParser.SESSION, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def SETS(self):
            return self.getToken(postgreSQLParser.SETS, 0)

        def SHARE(self):
            return self.getToken(postgreSQLParser.SHARE, 0)

        def SHOW(self):
            return self.getToken(postgreSQLParser.SHOW, 0)

        def SIMPLE(self):
            return self.getToken(postgreSQLParser.SIMPLE, 0)

        def SKIP_(self):
            return self.getToken(postgreSQLParser.SKIP_, 0)

        def SNAPSHOT(self):
            return self.getToken(postgreSQLParser.SNAPSHOT, 0)

        def SQL(self):
            return self.getToken(postgreSQLParser.SQL, 0)

        def STABLE(self):
            return self.getToken(postgreSQLParser.STABLE, 0)

        def STANDALONE(self):
            return self.getToken(postgreSQLParser.STANDALONE, 0)

        def START(self):
            return self.getToken(postgreSQLParser.START, 0)

        def STATEMENT(self):
            return self.getToken(postgreSQLParser.STATEMENT, 0)

        def STATISTICS(self):
            return self.getToken(postgreSQLParser.STATISTICS, 0)

        def STDIN(self):
            return self.getToken(postgreSQLParser.STDIN, 0)

        def STDOUT(self):
            return self.getToken(postgreSQLParser.STDOUT, 0)

        def STORAGE(self):
            return self.getToken(postgreSQLParser.STORAGE, 0)

        def STORED(self):
            return self.getToken(postgreSQLParser.STORED, 0)

        def STRICT(self):
            return self.getToken(postgreSQLParser.STRICT, 0)

        def STRIP(self):
            return self.getToken(postgreSQLParser.STRIP, 0)

        def SUBSCRIPTION(self):
            return self.getToken(postgreSQLParser.SUBSCRIPTION, 0)

        def SUPPORT(self):
            return self.getToken(postgreSQLParser.SUPPORT, 0)

        def SYSID(self):
            return self.getToken(postgreSQLParser.SYSID, 0)

        def SYSTEM(self):
            return self.getToken(postgreSQLParser.SYSTEM, 0)

        def TABLES(self):
            return self.getToken(postgreSQLParser.TABLES, 0)

        def TABLESPACE(self):
            return self.getToken(postgreSQLParser.TABLESPACE, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def TEMPLATE(self):
            return self.getToken(postgreSQLParser.TEMPLATE, 0)

        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def TEXT(self):
            return self.getToken(postgreSQLParser.TEXT, 0)

        def TIES(self):
            return self.getToken(postgreSQLParser.TIES, 0)

        def TRANSACTION(self):
            return self.getToken(postgreSQLParser.TRANSACTION, 0)

        def TRANSFORM(self):
            return self.getToken(postgreSQLParser.TRANSFORM, 0)

        def TRIGGER(self):
            return self.getToken(postgreSQLParser.TRIGGER, 0)

        def TRUNCATE(self):
            return self.getToken(postgreSQLParser.TRUNCATE, 0)

        def TRUSTED(self):
            return self.getToken(postgreSQLParser.TRUSTED, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def TYPES(self):
            return self.getToken(postgreSQLParser.TYPES, 0)

        def UESCAPE(self):
            return self.getToken(postgreSQLParser.UESCAPE, 0)

        def UNBOUNDED(self):
            return self.getToken(postgreSQLParser.UNBOUNDED, 0)

        def UNCOMMITTED(self):
            return self.getToken(postgreSQLParser.UNCOMMITTED, 0)

        def UNENCRYPTED(self):
            return self.getToken(postgreSQLParser.UNENCRYPTED, 0)

        def UNKNOWN(self):
            return self.getToken(postgreSQLParser.UNKNOWN, 0)

        def UNLISTEN(self):
            return self.getToken(postgreSQLParser.UNLISTEN, 0)

        def UNLOGGED(self):
            return self.getToken(postgreSQLParser.UNLOGGED, 0)

        def UNTIL(self):
            return self.getToken(postgreSQLParser.UNTIL, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def VACUUM(self):
            return self.getToken(postgreSQLParser.VACUUM, 0)

        def VALID(self):
            return self.getToken(postgreSQLParser.VALID, 0)

        def VALIDATE(self):
            return self.getToken(postgreSQLParser.VALIDATE, 0)

        def VALIDATOR(self):
            return self.getToken(postgreSQLParser.VALIDATOR, 0)

        def VALUE(self):
            return self.getToken(postgreSQLParser.VALUE, 0)

        def VARYING(self):
            return self.getToken(postgreSQLParser.VARYING, 0)

        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def VIEW(self):
            return self.getToken(postgreSQLParser.VIEW, 0)

        def VIEWS(self):
            return self.getToken(postgreSQLParser.VIEWS, 0)

        def VOLATILE(self):
            return self.getToken(postgreSQLParser.VOLATILE, 0)

        def WHITESPACE(self):
            return self.getToken(postgreSQLParser.WHITESPACE, 0)

        def WITHIN(self):
            return self.getToken(postgreSQLParser.WITHIN, 0)

        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def WORK(self):
            return self.getToken(postgreSQLParser.WORK, 0)

        def WRAPPER(self):
            return self.getToken(postgreSQLParser.WRAPPER, 0)

        def WRITE(self):
            return self.getToken(postgreSQLParser.WRITE, 0)

        def XML(self):
            return self.getToken(postgreSQLParser.XML, 0)

        def YEAR(self):
            return self.getToken(postgreSQLParser.YEAR, 0)

        def YES(self):
            return self.getToken(postgreSQLParser.YES, 0)

        def ZONE(self):
            return self.getToken(postgreSQLParser.ZONE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_tokens_nonreserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTokens_nonreserved" ):
                listener.enterTokens_nonreserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTokens_nonreserved" ):
                listener.exitTokens_nonreserved(self)




    def tokens_nonreserved(self):

        localctx = postgreSQLParser.Tokens_nonreservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 560, self.RULE_tokens_nonreserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5626
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tokens_nonreserved_except_function_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def BETWEEN(self):
            return self.getToken(postgreSQLParser.BETWEEN, 0)

        def BIGINT(self):
            return self.getToken(postgreSQLParser.BIGINT, 0)

        def BIT(self):
            return self.getToken(postgreSQLParser.BIT, 0)

        def BOOLEAN(self):
            return self.getToken(postgreSQLParser.BOOLEAN, 0)

        def CHAR(self):
            return self.getToken(postgreSQLParser.CHAR, 0)

        def CHARACTER(self):
            return self.getToken(postgreSQLParser.CHARACTER, 0)

        def COALESCE(self):
            return self.getToken(postgreSQLParser.COALESCE, 0)

        def DEC(self):
            return self.getToken(postgreSQLParser.DEC, 0)

        def DECIMAL(self):
            return self.getToken(postgreSQLParser.DECIMAL, 0)

        def EXISTS(self):
            return self.getToken(postgreSQLParser.EXISTS, 0)

        def EXTRACT(self):
            return self.getToken(postgreSQLParser.EXTRACT, 0)

        def FLOAT(self):
            return self.getToken(postgreSQLParser.FLOAT, 0)

        def GREATEST(self):
            return self.getToken(postgreSQLParser.GREATEST, 0)

        def GROUPING(self):
            return self.getToken(postgreSQLParser.GROUPING, 0)

        def INOUT(self):
            return self.getToken(postgreSQLParser.INOUT, 0)

        def INT(self):
            return self.getToken(postgreSQLParser.INT, 0)

        def INTEGER(self):
            return self.getToken(postgreSQLParser.INTEGER, 0)

        def INTERVAL(self):
            return self.getToken(postgreSQLParser.INTERVAL, 0)

        def LEAST(self):
            return self.getToken(postgreSQLParser.LEAST, 0)

        def NATIONAL(self):
            return self.getToken(postgreSQLParser.NATIONAL, 0)

        def NCHAR(self):
            return self.getToken(postgreSQLParser.NCHAR, 0)

        def NONE(self):
            return self.getToken(postgreSQLParser.NONE, 0)

        def NORMALIZE(self):
            return self.getToken(postgreSQLParser.NORMALIZE, 0)

        def NULLIF(self):
            return self.getToken(postgreSQLParser.NULLIF, 0)

        def NUMERIC(self):
            return self.getToken(postgreSQLParser.NUMERIC, 0)

        def OUT(self):
            return self.getToken(postgreSQLParser.OUT, 0)

        def OVERLAY(self):
            return self.getToken(postgreSQLParser.OVERLAY, 0)

        def POSITION(self):
            return self.getToken(postgreSQLParser.POSITION, 0)

        def PRECISION(self):
            return self.getToken(postgreSQLParser.PRECISION, 0)

        def REAL(self):
            return self.getToken(postgreSQLParser.REAL, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def SETOF(self):
            return self.getToken(postgreSQLParser.SETOF, 0)

        def SMALLINT(self):
            return self.getToken(postgreSQLParser.SMALLINT, 0)

        def SUBSTRING(self):
            return self.getToken(postgreSQLParser.SUBSTRING, 0)

        def TIME(self):
            return self.getToken(postgreSQLParser.TIME, 0)

        def TIMESTAMP(self):
            return self.getToken(postgreSQLParser.TIMESTAMP, 0)

        def TREAT(self):
            return self.getToken(postgreSQLParser.TREAT, 0)

        def TRIM(self):
            return self.getToken(postgreSQLParser.TRIM, 0)

        def VALUES(self):
            return self.getToken(postgreSQLParser.VALUES, 0)

        def VARCHAR(self):
            return self.getToken(postgreSQLParser.VARCHAR, 0)

        def XMLATTRIBUTES(self):
            return self.getToken(postgreSQLParser.XMLATTRIBUTES, 0)

        def XMLCONCAT(self):
            return self.getToken(postgreSQLParser.XMLCONCAT, 0)

        def XMLELEMENT(self):
            return self.getToken(postgreSQLParser.XMLELEMENT, 0)

        def XMLEXISTS(self):
            return self.getToken(postgreSQLParser.XMLEXISTS, 0)

        def XMLFOREST(self):
            return self.getToken(postgreSQLParser.XMLFOREST, 0)

        def XMLNAMESPACES(self):
            return self.getToken(postgreSQLParser.XMLNAMESPACES, 0)

        def XMLPARSE(self):
            return self.getToken(postgreSQLParser.XMLPARSE, 0)

        def XMLPI(self):
            return self.getToken(postgreSQLParser.XMLPI, 0)

        def XMLROOT(self):
            return self.getToken(postgreSQLParser.XMLROOT, 0)

        def XMLSERIALIZE(self):
            return self.getToken(postgreSQLParser.XMLSERIALIZE, 0)

        def XMLTABLE(self):
            return self.getToken(postgreSQLParser.XMLTABLE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_tokens_nonreserved_except_function_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTokens_nonreserved_except_function_type" ):
                listener.enterTokens_nonreserved_except_function_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTokens_nonreserved_except_function_type" ):
                listener.exitTokens_nonreserved_except_function_type(self)




    def tokens_nonreserved_except_function_type(self):

        localctx = postgreSQLParser.Tokens_nonreserved_except_function_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 562, self.RULE_tokens_nonreserved_except_function_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5628
            _la = self._input.LA(1)
            if not(((((_la - 300)) & ~0x3f) == 0 and ((1 << (_la - 300)) & ((1 << (postgreSQLParser.BETWEEN - 300)) | (1 << (postgreSQLParser.BIGINT - 300)) | (1 << (postgreSQLParser.BIT - 300)) | (1 << (postgreSQLParser.BOOLEAN - 300)) | (1 << (postgreSQLParser.CHAR - 300)) | (1 << (postgreSQLParser.CHARACTER - 300)) | (1 << (postgreSQLParser.COALESCE - 300)) | (1 << (postgreSQLParser.DEC - 300)) | (1 << (postgreSQLParser.DECIMAL - 300)) | (1 << (postgreSQLParser.EXISTS - 300)) | (1 << (postgreSQLParser.EXTRACT - 300)) | (1 << (postgreSQLParser.FLOAT - 300)) | (1 << (postgreSQLParser.GREATEST - 300)) | (1 << (postgreSQLParser.GROUPING - 300)) | (1 << (postgreSQLParser.INOUT - 300)) | (1 << (postgreSQLParser.INT - 300)) | (1 << (postgreSQLParser.INTEGER - 300)) | (1 << (postgreSQLParser.INTERVAL - 300)) | (1 << (postgreSQLParser.LEAST - 300)) | (1 << (postgreSQLParser.NATIONAL - 300)) | (1 << (postgreSQLParser.NCHAR - 300)) | (1 << (postgreSQLParser.NONE - 300)) | (1 << (postgreSQLParser.NORMALIZE - 300)) | (1 << (postgreSQLParser.NULLIF - 300)) | (1 << (postgreSQLParser.NUMERIC - 300)) | (1 << (postgreSQLParser.OUT - 300)) | (1 << (postgreSQLParser.OVERLAY - 300)) | (1 << (postgreSQLParser.POSITION - 300)) | (1 << (postgreSQLParser.PRECISION - 300)) | (1 << (postgreSQLParser.REAL - 300)) | (1 << (postgreSQLParser.ROW - 300)) | (1 << (postgreSQLParser.SETOF - 300)) | (1 << (postgreSQLParser.SMALLINT - 300)) | (1 << (postgreSQLParser.SUBSTRING - 300)) | (1 << (postgreSQLParser.TIME - 300)) | (1 << (postgreSQLParser.TIMESTAMP - 300)) | (1 << (postgreSQLParser.TREAT - 300)) | (1 << (postgreSQLParser.TRIM - 300)) | (1 << (postgreSQLParser.VALUES - 300)) | (1 << (postgreSQLParser.VARCHAR - 300)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 300)) | (1 << (postgreSQLParser.XMLCONCAT - 300)) | (1 << (postgreSQLParser.XMLELEMENT - 300)) | (1 << (postgreSQLParser.XMLEXISTS - 300)) | (1 << (postgreSQLParser.XMLFOREST - 300)) | (1 << (postgreSQLParser.XMLNAMESPACES - 300)) | (1 << (postgreSQLParser.XMLPARSE - 300)) | (1 << (postgreSQLParser.XMLPI - 300)) | (1 << (postgreSQLParser.XMLROOT - 300)) | (1 << (postgreSQLParser.XMLSERIALIZE - 300)) | (1 << (postgreSQLParser.XMLTABLE - 300)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tokens_reserved_except_function_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def AUTHORIZATION(self):
            return self.getToken(postgreSQLParser.AUTHORIZATION, 0)

        def BINARY(self):
            return self.getToken(postgreSQLParser.BINARY, 0)

        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def CONCURRENTLY(self):
            return self.getToken(postgreSQLParser.CONCURRENTLY, 0)

        def CROSS(self):
            return self.getToken(postgreSQLParser.CROSS, 0)

        def CURRENT_SCHEMA(self):
            return self.getToken(postgreSQLParser.CURRENT_SCHEMA, 0)

        def FREEZE(self):
            return self.getToken(postgreSQLParser.FREEZE, 0)

        def FULL(self):
            return self.getToken(postgreSQLParser.FULL, 0)

        def ILIKE(self):
            return self.getToken(postgreSQLParser.ILIKE, 0)

        def INNER(self):
            return self.getToken(postgreSQLParser.INNER, 0)

        def IS(self):
            return self.getToken(postgreSQLParser.IS, 0)

        def ISNULL(self):
            return self.getToken(postgreSQLParser.ISNULL, 0)

        def JOIN(self):
            return self.getToken(postgreSQLParser.JOIN, 0)

        def LEFT(self):
            return self.getToken(postgreSQLParser.LEFT, 0)

        def LIKE(self):
            return self.getToken(postgreSQLParser.LIKE, 0)

        def NATURAL(self):
            return self.getToken(postgreSQLParser.NATURAL, 0)

        def NOTNULL(self):
            return self.getToken(postgreSQLParser.NOTNULL, 0)

        def OUTER(self):
            return self.getToken(postgreSQLParser.OUTER, 0)

        def OVERLAPS(self):
            return self.getToken(postgreSQLParser.OVERLAPS, 0)

        def RIGHT(self):
            return self.getToken(postgreSQLParser.RIGHT, 0)

        def SIMILAR(self):
            return self.getToken(postgreSQLParser.SIMILAR, 0)

        def TABLESAMPLE(self):
            return self.getToken(postgreSQLParser.TABLESAMPLE, 0)

        def VERBOSE(self):
            return self.getToken(postgreSQLParser.VERBOSE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_tokens_reserved_except_function_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTokens_reserved_except_function_type" ):
                listener.enterTokens_reserved_except_function_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTokens_reserved_except_function_type" ):
                listener.exitTokens_reserved_except_function_type(self)




    def tokens_reserved_except_function_type(self):

        localctx = postgreSQLParser.Tokens_reserved_except_function_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 564, self.RULE_tokens_reserved_except_function_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5630
            _la = self._input.LA(1)
            if not(((((_la - 351)) & ~0x3f) == 0 and ((1 << (_la - 351)) & ((1 << (postgreSQLParser.AUTHORIZATION - 351)) | (1 << (postgreSQLParser.BINARY - 351)) | (1 << (postgreSQLParser.COLLATION - 351)) | (1 << (postgreSQLParser.CONCURRENTLY - 351)) | (1 << (postgreSQLParser.CROSS - 351)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 351)) | (1 << (postgreSQLParser.FREEZE - 351)) | (1 << (postgreSQLParser.FULL - 351)) | (1 << (postgreSQLParser.ILIKE - 351)) | (1 << (postgreSQLParser.INNER - 351)) | (1 << (postgreSQLParser.IS - 351)) | (1 << (postgreSQLParser.ISNULL - 351)) | (1 << (postgreSQLParser.JOIN - 351)) | (1 << (postgreSQLParser.LEFT - 351)) | (1 << (postgreSQLParser.LIKE - 351)) | (1 << (postgreSQLParser.NATURAL - 351)) | (1 << (postgreSQLParser.NOTNULL - 351)) | (1 << (postgreSQLParser.OUTER - 351)) | (1 << (postgreSQLParser.OVERLAPS - 351)) | (1 << (postgreSQLParser.RIGHT - 351)) | (1 << (postgreSQLParser.SIMILAR - 351)) | (1 << (postgreSQLParser.TABLESAMPLE - 351)) | (1 << (postgreSQLParser.VERBOSE - 351)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tokens_reservedContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def ANALYZE(self):
            return self.getToken(postgreSQLParser.ANALYZE, 0)

        def AND(self):
            return self.getToken(postgreSQLParser.AND, 0)

        def ANY(self):
            return self.getToken(postgreSQLParser.ANY, 0)

        def ARRAY(self):
            return self.getToken(postgreSQLParser.ARRAY, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def ASC(self):
            return self.getToken(postgreSQLParser.ASC, 0)

        def ASYMMETRIC(self):
            return self.getToken(postgreSQLParser.ASYMMETRIC, 0)

        def BOTH(self):
            return self.getToken(postgreSQLParser.BOTH, 0)

        def CASE(self):
            return self.getToken(postgreSQLParser.CASE, 0)

        def CAST(self):
            return self.getToken(postgreSQLParser.CAST, 0)

        def CHECK(self):
            return self.getToken(postgreSQLParser.CHECK, 0)

        def COLLATE(self):
            return self.getToken(postgreSQLParser.COLLATE, 0)

        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def CREATE(self):
            return self.getToken(postgreSQLParser.CREATE, 0)

        def CURRENT_CATALOG(self):
            return self.getToken(postgreSQLParser.CURRENT_CATALOG, 0)

        def CURRENT_DATE(self):
            return self.getToken(postgreSQLParser.CURRENT_DATE, 0)

        def CURRENT_ROLE(self):
            return self.getToken(postgreSQLParser.CURRENT_ROLE, 0)

        def CURRENT_TIME(self):
            return self.getToken(postgreSQLParser.CURRENT_TIME, 0)

        def CURRENT_TIMESTAMP(self):
            return self.getToken(postgreSQLParser.CURRENT_TIMESTAMP, 0)

        def CURRENT_USER(self):
            return self.getToken(postgreSQLParser.CURRENT_USER, 0)

        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def DEFERRABLE(self):
            return self.getToken(postgreSQLParser.DEFERRABLE, 0)

        def DESC(self):
            return self.getToken(postgreSQLParser.DESC, 0)

        def DISTINCT(self):
            return self.getToken(postgreSQLParser.DISTINCT, 0)

        def DO(self):
            return self.getToken(postgreSQLParser.DO, 0)

        def ELSE(self):
            return self.getToken(postgreSQLParser.ELSE, 0)

        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def EXCEPT(self):
            return self.getToken(postgreSQLParser.EXCEPT, 0)

        def FALSE(self):
            return self.getToken(postgreSQLParser.FALSE, 0)

        def FETCH(self):
            return self.getToken(postgreSQLParser.FETCH, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def FOREIGN(self):
            return self.getToken(postgreSQLParser.FOREIGN, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def GRANT(self):
            return self.getToken(postgreSQLParser.GRANT, 0)

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def HAVING(self):
            return self.getToken(postgreSQLParser.HAVING, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def INITIALLY(self):
            return self.getToken(postgreSQLParser.INITIALLY, 0)

        def INTERSECT(self):
            return self.getToken(postgreSQLParser.INTERSECT, 0)

        def INTO(self):
            return self.getToken(postgreSQLParser.INTO, 0)

        def LATERAL(self):
            return self.getToken(postgreSQLParser.LATERAL, 0)

        def LEADING(self):
            return self.getToken(postgreSQLParser.LEADING, 0)

        def LIMIT(self):
            return self.getToken(postgreSQLParser.LIMIT, 0)

        def LOCALTIME(self):
            return self.getToken(postgreSQLParser.LOCALTIME, 0)

        def LOCALTIMESTAMP(self):
            return self.getToken(postgreSQLParser.LOCALTIMESTAMP, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def OFFSET(self):
            return self.getToken(postgreSQLParser.OFFSET, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def ORDER(self):
            return self.getToken(postgreSQLParser.ORDER, 0)

        def PLACING(self):
            return self.getToken(postgreSQLParser.PLACING, 0)

        def PRIMARY(self):
            return self.getToken(postgreSQLParser.PRIMARY, 0)

        def REFERENCES(self):
            return self.getToken(postgreSQLParser.REFERENCES, 0)

        def RETURNING(self):
            return self.getToken(postgreSQLParser.RETURNING, 0)

        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def SESSION_USER(self):
            return self.getToken(postgreSQLParser.SESSION_USER, 0)

        def SOME(self):
            return self.getToken(postgreSQLParser.SOME, 0)

        def SYMMETRIC(self):
            return self.getToken(postgreSQLParser.SYMMETRIC, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def THEN(self):
            return self.getToken(postgreSQLParser.THEN, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def TRAILING(self):
            return self.getToken(postgreSQLParser.TRAILING, 0)

        def TRUE(self):
            return self.getToken(postgreSQLParser.TRUE, 0)

        def UNION(self):
            return self.getToken(postgreSQLParser.UNION, 0)

        def UNIQUE(self):
            return self.getToken(postgreSQLParser.UNIQUE, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def VARIADIC(self):
            return self.getToken(postgreSQLParser.VARIADIC, 0)

        def WHEN(self):
            return self.getToken(postgreSQLParser.WHEN, 0)

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def WINDOW(self):
            return self.getToken(postgreSQLParser.WINDOW, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_tokens_reserved

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTokens_reserved" ):
                listener.enterTokens_reserved(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTokens_reserved" ):
                listener.exitTokens_reserved(self)




    def tokens_reserved(self):

        localctx = postgreSQLParser.Tokens_reservedContext(self, self._ctx, self.state)
        self.enterRule(localctx, 566, self.RULE_tokens_reserved)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5632
            _la = self._input.LA(1)
            if not(((((_la - 374)) & ~0x3f) == 0 and ((1 << (_la - 374)) & ((1 << (postgreSQLParser.ALL - 374)) | (1 << (postgreSQLParser.ANALYZE - 374)) | (1 << (postgreSQLParser.AND - 374)) | (1 << (postgreSQLParser.ANY - 374)) | (1 << (postgreSQLParser.ARRAY - 374)) | (1 << (postgreSQLParser.AS - 374)) | (1 << (postgreSQLParser.ASC - 374)) | (1 << (postgreSQLParser.ASYMMETRIC - 374)) | (1 << (postgreSQLParser.BOTH - 374)) | (1 << (postgreSQLParser.CASE - 374)) | (1 << (postgreSQLParser.CAST - 374)) | (1 << (postgreSQLParser.CHECK - 374)) | (1 << (postgreSQLParser.COLLATE - 374)) | (1 << (postgreSQLParser.COLUMN - 374)) | (1 << (postgreSQLParser.CONSTRAINT - 374)) | (1 << (postgreSQLParser.CREATE - 374)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 374)) | (1 << (postgreSQLParser.CURRENT_DATE - 374)) | (1 << (postgreSQLParser.CURRENT_ROLE - 374)) | (1 << (postgreSQLParser.CURRENT_TIME - 374)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 374)) | (1 << (postgreSQLParser.CURRENT_USER - 374)) | (1 << (postgreSQLParser.DEFAULT - 374)) | (1 << (postgreSQLParser.DEFERRABLE - 374)) | (1 << (postgreSQLParser.DESC - 374)) | (1 << (postgreSQLParser.DISTINCT - 374)) | (1 << (postgreSQLParser.DO - 374)) | (1 << (postgreSQLParser.ELSE - 374)) | (1 << (postgreSQLParser.END - 374)) | (1 << (postgreSQLParser.EXCEPT - 374)) | (1 << (postgreSQLParser.FALSE - 374)) | (1 << (postgreSQLParser.FETCH - 374)) | (1 << (postgreSQLParser.FOR - 374)) | (1 << (postgreSQLParser.FOREIGN - 374)) | (1 << (postgreSQLParser.FROM - 374)) | (1 << (postgreSQLParser.GRANT - 374)) | (1 << (postgreSQLParser.GROUP - 374)) | (1 << (postgreSQLParser.HAVING - 374)) | (1 << (postgreSQLParser.IN - 374)) | (1 << (postgreSQLParser.INITIALLY - 374)) | (1 << (postgreSQLParser.INTERSECT - 374)) | (1 << (postgreSQLParser.INTO - 374)) | (1 << (postgreSQLParser.LATERAL - 374)) | (1 << (postgreSQLParser.LEADING - 374)) | (1 << (postgreSQLParser.LIMIT - 374)) | (1 << (postgreSQLParser.LOCALTIME - 374)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 374)) | (1 << (postgreSQLParser.NOT - 374)) | (1 << (postgreSQLParser.NULL - 374)) | (1 << (postgreSQLParser.OFFSET - 374)) | (1 << (postgreSQLParser.ON - 374)) | (1 << (postgreSQLParser.ONLY - 374)) | (1 << (postgreSQLParser.OR - 374)) | (1 << (postgreSQLParser.ORDER - 374)) | (1 << (postgreSQLParser.PLACING - 374)) | (1 << (postgreSQLParser.PRIMARY - 374)) | (1 << (postgreSQLParser.REFERENCES - 374)) | (1 << (postgreSQLParser.RETURNING - 374)) | (1 << (postgreSQLParser.SELECT - 374)) | (1 << (postgreSQLParser.SESSION_USER - 374)) | (1 << (postgreSQLParser.SOME - 374)) | (1 << (postgreSQLParser.SYMMETRIC - 374)) | (1 << (postgreSQLParser.TABLE - 374)) | (1 << (postgreSQLParser.THEN - 374)))) != 0) or ((((_la - 438)) & ~0x3f) == 0 and ((1 << (_la - 438)) & ((1 << (postgreSQLParser.TO - 438)) | (1 << (postgreSQLParser.TRAILING - 438)) | (1 << (postgreSQLParser.TRUE - 438)) | (1 << (postgreSQLParser.UNION - 438)) | (1 << (postgreSQLParser.UNIQUE - 438)) | (1 << (postgreSQLParser.USER - 438)) | (1 << (postgreSQLParser.USING - 438)) | (1 << (postgreSQLParser.VARIADIC - 438)) | (1 << (postgreSQLParser.WHEN - 438)) | (1 << (postgreSQLParser.WHERE - 438)) | (1 << (postgreSQLParser.WINDOW - 438)) | (1 << (postgreSQLParser.WITH - 438)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Tokens_nonkeywordContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ALIGNMENT(self):
            return self.getToken(postgreSQLParser.ALIGNMENT, 0)

        def ALLOW_CONNECTIONS(self):
            return self.getToken(postgreSQLParser.ALLOW_CONNECTIONS, 0)

        def BASETYPE(self):
            return self.getToken(postgreSQLParser.BASETYPE, 0)

        def BUFFERS(self):
            return self.getToken(postgreSQLParser.BUFFERS, 0)

        def BYPASSRLS(self):
            return self.getToken(postgreSQLParser.BYPASSRLS, 0)

        def CANONICAL(self):
            return self.getToken(postgreSQLParser.CANONICAL, 0)

        def CATEGORY(self):
            return self.getToken(postgreSQLParser.CATEGORY, 0)

        def COLLATABLE(self):
            return self.getToken(postgreSQLParser.COLLATABLE, 0)

        def COMBINEFUNC(self):
            return self.getToken(postgreSQLParser.COMBINEFUNC, 0)

        def COMMUTATOR(self):
            return self.getToken(postgreSQLParser.COMMUTATOR, 0)

        def CONNECT(self):
            return self.getToken(postgreSQLParser.CONNECT, 0)

        def COSTS(self):
            return self.getToken(postgreSQLParser.COSTS, 0)

        def CREATEDB(self):
            return self.getToken(postgreSQLParser.CREATEDB, 0)

        def CREATEROLE(self):
            return self.getToken(postgreSQLParser.CREATEROLE, 0)

        def DESERIALFUNC(self):
            return self.getToken(postgreSQLParser.DESERIALFUNC, 0)

        def DETERMINISTIC(self):
            return self.getToken(postgreSQLParser.DETERMINISTIC, 0)

        def DISABLE_PAGE_SKIPPING(self):
            return self.getToken(postgreSQLParser.DISABLE_PAGE_SKIPPING, 0)

        def ELEMENT(self):
            return self.getToken(postgreSQLParser.ELEMENT, 0)

        def EXTENDED(self):
            return self.getToken(postgreSQLParser.EXTENDED, 0)

        def FINALFUNC(self):
            return self.getToken(postgreSQLParser.FINALFUNC, 0)

        def FINALFUNC_EXTRA(self):
            return self.getToken(postgreSQLParser.FINALFUNC_EXTRA, 0)

        def FINALFUNC_MODIFY(self):
            return self.getToken(postgreSQLParser.FINALFUNC_MODIFY, 0)

        def FORCE_NOT_NULL(self):
            return self.getToken(postgreSQLParser.FORCE_NOT_NULL, 0)

        def FORCE_NULL(self):
            return self.getToken(postgreSQLParser.FORCE_NULL, 0)

        def FORCE_QUOTE(self):
            return self.getToken(postgreSQLParser.FORCE_QUOTE, 0)

        def FORMAT(self):
            return self.getToken(postgreSQLParser.FORMAT, 0)

        def GETTOKEN(self):
            return self.getToken(postgreSQLParser.GETTOKEN, 0)

        def HASH(self):
            return self.getToken(postgreSQLParser.HASH, 0)

        def HASHES(self):
            return self.getToken(postgreSQLParser.HASHES, 0)

        def HEADLINE(self):
            return self.getToken(postgreSQLParser.HEADLINE, 0)

        def HYPOTHETICAL(self):
            return self.getToken(postgreSQLParser.HYPOTHETICAL, 0)

        def INDEX_CLEANUP(self):
            return self.getToken(postgreSQLParser.INDEX_CLEANUP, 0)

        def INIT(self):
            return self.getToken(postgreSQLParser.INIT, 0)

        def INITCOND(self):
            return self.getToken(postgreSQLParser.INITCOND, 0)

        def INTERNALLENGTH(self):
            return self.getToken(postgreSQLParser.INTERNALLENGTH, 0)

        def IS_TEMPLATE(self):
            return self.getToken(postgreSQLParser.IS_TEMPLATE, 0)

        def JSON(self):
            return self.getToken(postgreSQLParser.JSON, 0)

        def LC_COLLATE(self):
            return self.getToken(postgreSQLParser.LC_COLLATE, 0)

        def LC_CTYPE(self):
            return self.getToken(postgreSQLParser.LC_CTYPE, 0)

        def LEFTARG(self):
            return self.getToken(postgreSQLParser.LEFTARG, 0)

        def LEXIZE(self):
            return self.getToken(postgreSQLParser.LEXIZE, 0)

        def LEXTYPES(self):
            return self.getToken(postgreSQLParser.LEXTYPES, 0)

        def LIST(self):
            return self.getToken(postgreSQLParser.LIST, 0)

        def LOCALE(self):
            return self.getToken(postgreSQLParser.LOCALE, 0)

        def LOGIN(self):
            return self.getToken(postgreSQLParser.LOGIN, 0)

        def MAIN(self):
            return self.getToken(postgreSQLParser.MAIN, 0)

        def MERGES(self):
            return self.getToken(postgreSQLParser.MERGES, 0)

        def MFINALFUNC(self):
            return self.getToken(postgreSQLParser.MFINALFUNC, 0)

        def MFINALFUNC_EXTRA(self):
            return self.getToken(postgreSQLParser.MFINALFUNC_EXTRA, 0)

        def MFINALFUNC_MODIFY(self):
            return self.getToken(postgreSQLParser.MFINALFUNC_MODIFY, 0)

        def MINITCOND(self):
            return self.getToken(postgreSQLParser.MINITCOND, 0)

        def MINVFUNC(self):
            return self.getToken(postgreSQLParser.MINVFUNC, 0)

        def MODULUS(self):
            return self.getToken(postgreSQLParser.MODULUS, 0)

        def MSFUNC(self):
            return self.getToken(postgreSQLParser.MSFUNC, 0)

        def MSSPACE(self):
            return self.getToken(postgreSQLParser.MSSPACE, 0)

        def MSTYPE(self):
            return self.getToken(postgreSQLParser.MSTYPE, 0)

        def NEGATOR(self):
            return self.getToken(postgreSQLParser.NEGATOR, 0)

        def NOBYPASSRLS(self):
            return self.getToken(postgreSQLParser.NOBYPASSRLS, 0)

        def NOCREATEDB(self):
            return self.getToken(postgreSQLParser.NOCREATEDB, 0)

        def NOCREATEROLE(self):
            return self.getToken(postgreSQLParser.NOCREATEROLE, 0)

        def NOINHERIT(self):
            return self.getToken(postgreSQLParser.NOINHERIT, 0)

        def NOLOGIN(self):
            return self.getToken(postgreSQLParser.NOLOGIN, 0)

        def NOREPLICATION(self):
            return self.getToken(postgreSQLParser.NOREPLICATION, 0)

        def NOSUPERUSER(self):
            return self.getToken(postgreSQLParser.NOSUPERUSER, 0)

        def OUTPUT(self):
            return self.getToken(postgreSQLParser.OUTPUT, 0)

        def PASSEDBYVALUE(self):
            return self.getToken(postgreSQLParser.PASSEDBYVALUE, 0)

        def PATH(self):
            return self.getToken(postgreSQLParser.PATH, 0)

        def PERMISSIVE(self):
            return self.getToken(postgreSQLParser.PERMISSIVE, 0)

        def PLAIN(self):
            return self.getToken(postgreSQLParser.PLAIN, 0)

        def PREFERRED(self):
            return self.getToken(postgreSQLParser.PREFERRED, 0)

        def PROVIDER(self):
            return self.getToken(postgreSQLParser.PROVIDER, 0)

        def READ_ONLY(self):
            return self.getToken(postgreSQLParser.READ_ONLY, 0)

        def READ_WRITE(self):
            return self.getToken(postgreSQLParser.READ_WRITE, 0)

        def RECEIVE(self):
            return self.getToken(postgreSQLParser.RECEIVE, 0)

        def REMAINDER(self):
            return self.getToken(postgreSQLParser.REMAINDER, 0)

        def REPLICATION(self):
            return self.getToken(postgreSQLParser.REPLICATION, 0)

        def RESTRICTED(self):
            return self.getToken(postgreSQLParser.RESTRICTED, 0)

        def RESTRICTIVE(self):
            return self.getToken(postgreSQLParser.RESTRICTIVE, 0)

        def RIGHTARG(self):
            return self.getToken(postgreSQLParser.RIGHTARG, 0)

        def SAFE(self):
            return self.getToken(postgreSQLParser.SAFE, 0)

        def SEND(self):
            return self.getToken(postgreSQLParser.SEND, 0)

        def SERIALFUNC(self):
            return self.getToken(postgreSQLParser.SERIALFUNC, 0)

        def SETTINGS(self):
            return self.getToken(postgreSQLParser.SETTINGS, 0)

        def SFUNC(self):
            return self.getToken(postgreSQLParser.SFUNC, 0)

        def SHAREABLE(self):
            return self.getToken(postgreSQLParser.SHAREABLE, 0)

        def SKIP_LOCKED(self):
            return self.getToken(postgreSQLParser.SKIP_LOCKED, 0)

        def SORTOP(self):
            return self.getToken(postgreSQLParser.SORTOP, 0)

        def SSPACE(self):
            return self.getToken(postgreSQLParser.SSPACE, 0)

        def STYPE(self):
            return self.getToken(postgreSQLParser.STYPE, 0)

        def SUBTYPE_DIFF(self):
            return self.getToken(postgreSQLParser.SUBTYPE_DIFF, 0)

        def SUBTYPE_OPCLASS(self):
            return self.getToken(postgreSQLParser.SUBTYPE_OPCLASS, 0)

        def SUBTYPE(self):
            return self.getToken(postgreSQLParser.SUBTYPE, 0)

        def SUMMARY(self):
            return self.getToken(postgreSQLParser.SUMMARY, 0)

        def SUPERUSER(self):
            return self.getToken(postgreSQLParser.SUPERUSER, 0)

        def TIMING(self):
            return self.getToken(postgreSQLParser.TIMING, 0)

        def TYPMOD_IN(self):
            return self.getToken(postgreSQLParser.TYPMOD_IN, 0)

        def TYPMOD_OUT(self):
            return self.getToken(postgreSQLParser.TYPMOD_OUT, 0)

        def UNSAFE(self):
            return self.getToken(postgreSQLParser.UNSAFE, 0)

        def USAGE(self):
            return self.getToken(postgreSQLParser.USAGE, 0)

        def VARIABLE(self):
            return self.getToken(postgreSQLParser.VARIABLE, 0)

        def WAL(self):
            return self.getToken(postgreSQLParser.WAL, 0)

        def YAML(self):
            return self.getToken(postgreSQLParser.YAML, 0)

        def ALIAS(self):
            return self.getToken(postgreSQLParser.ALIAS, 0)

        def ASSERT(self):
            return self.getToken(postgreSQLParser.ASSERT, 0)

        def CONSTANT(self):
            return self.getToken(postgreSQLParser.CONSTANT, 0)

        def DATATYPE(self):
            return self.getToken(postgreSQLParser.DATATYPE, 0)

        def DEBUG(self):
            return self.getToken(postgreSQLParser.DEBUG, 0)

        def DETAIL(self):
            return self.getToken(postgreSQLParser.DETAIL, 0)

        def DIAGNOSTICS(self):
            return self.getToken(postgreSQLParser.DIAGNOSTICS, 0)

        def ELSEIF(self):
            return self.getToken(postgreSQLParser.ELSEIF, 0)

        def ELSIF(self):
            return self.getToken(postgreSQLParser.ELSIF, 0)

        def ERRCODE(self):
            return self.getToken(postgreSQLParser.ERRCODE, 0)

        def EXIT(self):
            return self.getToken(postgreSQLParser.EXIT, 0)

        def EXCEPTION(self):
            return self.getToken(postgreSQLParser.EXCEPTION, 0)

        def FOREACH(self):
            return self.getToken(postgreSQLParser.FOREACH, 0)

        def GET(self):
            return self.getToken(postgreSQLParser.GET, 0)

        def HINT(self):
            return self.getToken(postgreSQLParser.HINT, 0)

        def INFO(self):
            return self.getToken(postgreSQLParser.INFO, 0)

        def LOG(self):
            return self.getToken(postgreSQLParser.LOG, 0)

        def LOOP(self):
            return self.getToken(postgreSQLParser.LOOP, 0)

        def MESSAGE(self):
            return self.getToken(postgreSQLParser.MESSAGE, 0)

        def NOTICE(self):
            return self.getToken(postgreSQLParser.NOTICE, 0)

        def OPEN(self):
            return self.getToken(postgreSQLParser.OPEN, 0)

        def PERFORM(self):
            return self.getToken(postgreSQLParser.PERFORM, 0)

        def QUERY(self):
            return self.getToken(postgreSQLParser.QUERY, 0)

        def RAISE(self):
            return self.getToken(postgreSQLParser.RAISE, 0)

        def RECORD(self):
            return self.getToken(postgreSQLParser.RECORD, 0)

        def RETURN(self):
            return self.getToken(postgreSQLParser.RETURN, 0)

        def REVERSE(self):
            return self.getToken(postgreSQLParser.REVERSE, 0)

        def ROWTYPE(self):
            return self.getToken(postgreSQLParser.ROWTYPE, 0)

        def SLICE(self):
            return self.getToken(postgreSQLParser.SLICE, 0)

        def SQLSTATE(self):
            return self.getToken(postgreSQLParser.SQLSTATE, 0)

        def STACKED(self):
            return self.getToken(postgreSQLParser.STACKED, 0)

        def WARNING(self):
            return self.getToken(postgreSQLParser.WARNING, 0)

        def WHILE(self):
            return self.getToken(postgreSQLParser.WHILE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_tokens_nonkeyword

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTokens_nonkeyword" ):
                listener.enterTokens_nonkeyword(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTokens_nonkeyword" ):
                listener.exitTokens_nonkeyword(self)




    def tokens_nonkeyword(self):

        localctx = postgreSQLParser.Tokens_nonkeywordContext(self, self._ctx, self.state)
        self.enterRule(localctx, 568, self.RULE_tokens_nonkeyword)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5634
            _la = self._input.LA(1)
            if not(((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_qualified_name_nontypeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.schema = None # IdentifierContext

        def identifier_nontype(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_nontypeContext,0)


        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_qualified_name_nontype

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_qualified_name_nontype" ):
                listener.enterSchema_qualified_name_nontype(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_qualified_name_nontype" ):
                listener.exitSchema_qualified_name_nontype(self)




    def schema_qualified_name_nontype(self):

        localctx = postgreSQLParser.Schema_qualified_name_nontypeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 570, self.RULE_schema_qualified_name_nontype)
        try:
            self.state = 5641
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,707,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5636
                self.identifier_nontype()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5637
                localctx.schema = self.identifier()
                self.state = 5638
                self.match(postgreSQLParser.DOT)
                self.state = 5639
                self.identifier_nontype()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_type_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_list" ):
                listener.enterType_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_list" ):
                listener.exitType_list(self)




    def type_list(self):

        localctx = postgreSQLParser.Type_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 572, self.RULE_type_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5643
            self.data_type()
            self.state = 5648
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 5644
                self.match(postgreSQLParser.COMMA)
                self.state = 5645
                self.data_type()
                self.state = 5650
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def predefined_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Predefined_typeContext,0)


        def SETOF(self):
            return self.getToken(postgreSQLParser.SETOF, 0)

        def ARRAY(self):
            return self.getToken(postgreSQLParser.ARRAY, 0)

        def array_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Array_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Array_typeContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_data_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_type" ):
                listener.enterData_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_type" ):
                listener.exitData_type(self)




    def data_type(self):

        localctx = postgreSQLParser.Data_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 574, self.RULE_data_type)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5652
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,709,self._ctx)
            if la_ == 1:
                self.state = 5651
                self.match(postgreSQLParser.SETOF)


            self.state = 5654
            self.predefined_type()
            self.state = 5664
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,712,self._ctx)
            if la_ == 1:
                self.state = 5655
                self.match(postgreSQLParser.ARRAY)
                self.state = 5657
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,710,self._ctx)
                if la_ == 1:
                    self.state = 5656
                    self.array_type()



            elif la_ == 2:
                self.state = 5660 
                self._errHandler.sync(self)
                _alt = 1
                while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                    if _alt == 1:
                        self.state = 5659
                        self.array_type()

                    else:
                        raise NoViableAltException(self)
                    self.state = 5662 
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,711,self._ctx)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(postgreSQLParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(postgreSQLParser.RIGHT_BRACKET, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_array_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_type" ):
                listener.enterArray_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_type" ):
                listener.exitArray_type(self)




    def array_type(self):

        localctx = postgreSQLParser.Array_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 576, self.RULE_array_type)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5666
            self.match(postgreSQLParser.LEFT_BRACKET)
            self.state = 5668
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NUMBER_LITERAL:
                self.state = 5667
                self.match(postgreSQLParser.NUMBER_LITERAL)


            self.state = 5670
            self.match(postgreSQLParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Predefined_typeContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.dlen = None # Type_lengthContext
            self.prec = None # Precision_paramContext

        def BIGINT(self):
            return self.getToken(postgreSQLParser.BIGINT, 0)

        def BIT(self):
            return self.getToken(postgreSQLParser.BIT, 0)

        def VARYING(self):
            return self.getToken(postgreSQLParser.VARYING, 0)

        def type_length(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_lengthContext,0)


        def BOOLEAN(self):
            return self.getToken(postgreSQLParser.BOOLEAN, 0)

        def DEC(self):
            return self.getToken(postgreSQLParser.DEC, 0)

        def precision_param(self):
            return self.getTypedRuleContext(postgreSQLParser.Precision_paramContext,0)


        def DECIMAL(self):
            return self.getToken(postgreSQLParser.DECIMAL, 0)

        def DOUBLE(self):
            return self.getToken(postgreSQLParser.DOUBLE, 0)

        def PRECISION(self):
            return self.getToken(postgreSQLParser.PRECISION, 0)

        def FLOAT(self):
            return self.getToken(postgreSQLParser.FLOAT, 0)

        def INT(self):
            return self.getToken(postgreSQLParser.INT, 0)

        def INTEGER(self):
            return self.getToken(postgreSQLParser.INTEGER, 0)

        def INTERVAL(self):
            return self.getToken(postgreSQLParser.INTERVAL, 0)

        def interval_field(self):
            return self.getTypedRuleContext(postgreSQLParser.Interval_fieldContext,0)


        def CHARACTER(self):
            return self.getToken(postgreSQLParser.CHARACTER, 0)

        def CHAR(self):
            return self.getToken(postgreSQLParser.CHAR, 0)

        def NATIONAL(self):
            return self.getToken(postgreSQLParser.NATIONAL, 0)

        def NCHAR(self):
            return self.getToken(postgreSQLParser.NCHAR, 0)

        def NUMERIC(self):
            return self.getToken(postgreSQLParser.NUMERIC, 0)

        def REAL(self):
            return self.getToken(postgreSQLParser.REAL, 0)

        def SMALLINT(self):
            return self.getToken(postgreSQLParser.SMALLINT, 0)

        def TIME(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.TIME)
            else:
                return self.getToken(postgreSQLParser.TIME, i)

        def ZONE(self):
            return self.getToken(postgreSQLParser.ZONE, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def WITHOUT(self):
            return self.getToken(postgreSQLParser.WITHOUT, 0)

        def TIMESTAMP(self):
            return self.getToken(postgreSQLParser.TIMESTAMP, 0)

        def VARCHAR(self):
            return self.getToken(postgreSQLParser.VARCHAR, 0)

        def schema_qualified_name_nontype(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_name_nontypeContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_predefined_type

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPredefined_type" ):
                listener.enterPredefined_type(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPredefined_type" ):
                listener.exitPredefined_type(self)




    def predefined_type(self):

        localctx = postgreSQLParser.Predefined_typeContext(self, self._ctx, self.state)
        self.enterRule(localctx, 578, self.RULE_predefined_type)
        self._la = 0 # Token type
        try:
            self.state = 5763
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,734,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5672
                self.match(postgreSQLParser.BIGINT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5673
                self.match(postgreSQLParser.BIT)
                self.state = 5675
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,714,self._ctx)
                if la_ == 1:
                    self.state = 5674
                    self.match(postgreSQLParser.VARYING)


                self.state = 5678
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,715,self._ctx)
                if la_ == 1:
                    self.state = 5677
                    localctx.dlen = self.type_length()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5680
                self.match(postgreSQLParser.BOOLEAN)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5681
                self.match(postgreSQLParser.DEC)
                self.state = 5683
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,716,self._ctx)
                if la_ == 1:
                    self.state = 5682
                    localctx.prec = self.precision_param()


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 5685
                self.match(postgreSQLParser.DECIMAL)
                self.state = 5687
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,717,self._ctx)
                if la_ == 1:
                    self.state = 5686
                    localctx.prec = self.precision_param()


                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 5689
                self.match(postgreSQLParser.DOUBLE)
                self.state = 5690
                self.match(postgreSQLParser.PRECISION)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 5691
                self.match(postgreSQLParser.FLOAT)
                self.state = 5693
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,718,self._ctx)
                if la_ == 1:
                    self.state = 5692
                    localctx.prec = self.precision_param()


                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 5695
                self.match(postgreSQLParser.INT)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 5696
                self.match(postgreSQLParser.INTEGER)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 5697
                self.match(postgreSQLParser.INTERVAL)
                self.state = 5699
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,719,self._ctx)
                if la_ == 1:
                    self.state = 5698
                    self.interval_field()


                self.state = 5702
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,720,self._ctx)
                if la_ == 1:
                    self.state = 5701
                    localctx.dlen = self.type_length()


                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 5705
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NATIONAL:
                    self.state = 5704
                    self.match(postgreSQLParser.NATIONAL)


                self.state = 5707
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CHAR or _la==postgreSQLParser.CHARACTER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 5709
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,722,self._ctx)
                if la_ == 1:
                    self.state = 5708
                    self.match(postgreSQLParser.VARYING)


                self.state = 5712
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,723,self._ctx)
                if la_ == 1:
                    self.state = 5711
                    localctx.dlen = self.type_length()


                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 5714
                self.match(postgreSQLParser.NCHAR)
                self.state = 5716
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,724,self._ctx)
                if la_ == 1:
                    self.state = 5715
                    self.match(postgreSQLParser.VARYING)


                self.state = 5719
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,725,self._ctx)
                if la_ == 1:
                    self.state = 5718
                    localctx.dlen = self.type_length()


                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 5721
                self.match(postgreSQLParser.NUMERIC)
                self.state = 5723
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,726,self._ctx)
                if la_ == 1:
                    self.state = 5722
                    localctx.prec = self.precision_param()


                pass

            elif la_ == 14:
                self.enterOuterAlt(localctx, 14)
                self.state = 5725
                self.match(postgreSQLParser.REAL)
                pass

            elif la_ == 15:
                self.enterOuterAlt(localctx, 15)
                self.state = 5726
                self.match(postgreSQLParser.SMALLINT)
                pass

            elif la_ == 16:
                self.enterOuterAlt(localctx, 16)
                self.state = 5727
                self.match(postgreSQLParser.TIME)
                self.state = 5729
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,727,self._ctx)
                if la_ == 1:
                    self.state = 5728
                    localctx.dlen = self.type_length()


                self.state = 5734
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,728,self._ctx)
                if la_ == 1:
                    self.state = 5731
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.WITHOUT or _la==postgreSQLParser.WITH):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 5732
                    self.match(postgreSQLParser.TIME)
                    self.state = 5733
                    self.match(postgreSQLParser.ZONE)


                pass

            elif la_ == 17:
                self.enterOuterAlt(localctx, 17)
                self.state = 5736
                self.match(postgreSQLParser.TIMESTAMP)
                self.state = 5738
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,729,self._ctx)
                if la_ == 1:
                    self.state = 5737
                    localctx.dlen = self.type_length()


                self.state = 5743
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,730,self._ctx)
                if la_ == 1:
                    self.state = 5740
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.WITHOUT or _la==postgreSQLParser.WITH):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 5741
                    self.match(postgreSQLParser.TIME)
                    self.state = 5742
                    self.match(postgreSQLParser.ZONE)


                pass

            elif la_ == 18:
                self.enterOuterAlt(localctx, 18)
                self.state = 5745
                self.match(postgreSQLParser.VARCHAR)
                self.state = 5747
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,731,self._ctx)
                if la_ == 1:
                    self.state = 5746
                    localctx.dlen = self.type_length()


                pass

            elif la_ == 19:
                self.enterOuterAlt(localctx, 19)
                self.state = 5749
                self.schema_qualified_name_nontype()
                self.state = 5761
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,733,self._ctx)
                if la_ == 1:
                    self.state = 5750
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 5751
                    self.vex(0)
                    self.state = 5756
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 5752
                        self.match(postgreSQLParser.COMMA)
                        self.state = 5753
                        self.vex(0)
                        self.state = 5758
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 5759
                    self.match(postgreSQLParser.RIGHT_PAREN)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Interval_fieldContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def YEAR(self):
            return self.getToken(postgreSQLParser.YEAR, 0)

        def MONTH(self):
            return self.getToken(postgreSQLParser.MONTH, 0)

        def DAY(self):
            return self.getToken(postgreSQLParser.DAY, 0)

        def HOUR(self):
            return self.getToken(postgreSQLParser.HOUR, 0)

        def MINUTE(self):
            return self.getToken(postgreSQLParser.MINUTE, 0)

        def SECOND(self):
            return self.getToken(postgreSQLParser.SECOND, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_interval_field

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterval_field" ):
                listener.enterInterval_field(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterval_field" ):
                listener.exitInterval_field(self)




    def interval_field(self):

        localctx = postgreSQLParser.Interval_fieldContext(self, self._ctx, self.state)
        self.enterRule(localctx, 580, self.RULE_interval_field)
        try:
            self.state = 5792
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,735,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 5765
                self.match(postgreSQLParser.YEAR)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 5766
                self.match(postgreSQLParser.MONTH)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 5767
                self.match(postgreSQLParser.DAY)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 5768
                self.match(postgreSQLParser.HOUR)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 5769
                self.match(postgreSQLParser.MINUTE)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 5770
                self.match(postgreSQLParser.SECOND)
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 5771
                self.match(postgreSQLParser.YEAR)
                self.state = 5772
                self.match(postgreSQLParser.TO)
                self.state = 5773
                self.match(postgreSQLParser.MONTH)
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 5774
                self.match(postgreSQLParser.DAY)
                self.state = 5775
                self.match(postgreSQLParser.TO)
                self.state = 5776
                self.match(postgreSQLParser.HOUR)
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 5777
                self.match(postgreSQLParser.DAY)
                self.state = 5778
                self.match(postgreSQLParser.TO)
                self.state = 5779
                self.match(postgreSQLParser.MINUTE)
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 5780
                self.match(postgreSQLParser.DAY)
                self.state = 5781
                self.match(postgreSQLParser.TO)
                self.state = 5782
                self.match(postgreSQLParser.SECOND)
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 5783
                self.match(postgreSQLParser.HOUR)
                self.state = 5784
                self.match(postgreSQLParser.TO)
                self.state = 5785
                self.match(postgreSQLParser.MINUTE)
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 5786
                self.match(postgreSQLParser.HOUR)
                self.state = 5787
                self.match(postgreSQLParser.TO)
                self.state = 5788
                self.match(postgreSQLParser.SECOND)
                pass

            elif la_ == 13:
                self.enterOuterAlt(localctx, 13)
                self.state = 5789
                self.match(postgreSQLParser.MINUTE)
                self.state = 5790
                self.match(postgreSQLParser.TO)
                self.state = 5791
                self.match(postgreSQLParser.SECOND)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_lengthContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_type_length

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_length" ):
                listener.enterType_length(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_length" ):
                listener.exitType_length(self)




    def type_length(self):

        localctx = postgreSQLParser.Type_lengthContext(self, self._ctx, self.state)
        self.enterRule(localctx, 582, self.RULE_type_length)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5794
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5795
            self.match(postgreSQLParser.NUMBER_LITERAL)
            self.state = 5796
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Precision_paramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.precision = None # Token
            self.scale = None # Token

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def NUMBER_LITERAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NUMBER_LITERAL)
            else:
                return self.getToken(postgreSQLParser.NUMBER_LITERAL, i)

        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_precision_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPrecision_param" ):
                listener.enterPrecision_param(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPrecision_param" ):
                listener.exitPrecision_param(self)




    def precision_param(self):

        localctx = postgreSQLParser.Precision_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 584, self.RULE_precision_param)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5798
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 5799
            localctx.precision = self.match(postgreSQLParser.NUMBER_LITERAL)
            self.state = 5802
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COMMA:
                self.state = 5800
                self.match(postgreSQLParser.COMMA)
                self.state = 5801
                localctx.scale = self.match(postgreSQLParser.NUMBER_LITERAL)


            self.state = 5804
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def indirection_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Indirection_listContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def PLUS(self):
            return self.getToken(postgreSQLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(postgreSQLParser.MINUS, 0)

        def op(self):
            return self.getTypedRuleContext(postgreSQLParser.OpContext,0)


        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def value_expression_primary(self):
            return self.getTypedRuleContext(postgreSQLParser.Value_expression_primaryContext,0)


        def AT(self):
            return self.getToken(postgreSQLParser.AT, 0)

        def TIME(self):
            return self.getToken(postgreSQLParser.TIME, 0)

        def ZONE(self):
            return self.getToken(postgreSQLParser.ZONE, 0)

        def EXP(self):
            return self.getToken(postgreSQLParser.EXP, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(postgreSQLParser.DIVIDE, 0)

        def MODULAR(self):
            return self.getToken(postgreSQLParser.MODULAR, 0)

        def BETWEEN(self):
            return self.getToken(postgreSQLParser.BETWEEN, 0)

        def vex_b(self):
            return self.getTypedRuleContext(postgreSQLParser.Vex_bContext,0)


        def AND(self):
            return self.getToken(postgreSQLParser.AND, 0)

        def ASYMMETRIC(self):
            return self.getToken(postgreSQLParser.ASYMMETRIC, 0)

        def SYMMETRIC(self):
            return self.getToken(postgreSQLParser.SYMMETRIC, 0)

        def LIKE(self):
            return self.getToken(postgreSQLParser.LIKE, 0)

        def ILIKE(self):
            return self.getToken(postgreSQLParser.ILIKE, 0)

        def SIMILAR(self):
            return self.getToken(postgreSQLParser.SIMILAR, 0)

        def TO(self):
            return self.getToken(postgreSQLParser.TO, 0)

        def ESCAPE(self):
            return self.getToken(postgreSQLParser.ESCAPE, 0)

        def LTH(self):
            return self.getToken(postgreSQLParser.LTH, 0)

        def GTH(self):
            return self.getToken(postgreSQLParser.GTH, 0)

        def LEQ(self):
            return self.getToken(postgreSQLParser.LEQ, 0)

        def GEQ(self):
            return self.getToken(postgreSQLParser.GEQ, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def NOT_EQUAL(self):
            return self.getToken(postgreSQLParser.NOT_EQUAL, 0)

        def IS(self):
            return self.getToken(postgreSQLParser.IS, 0)

        def DISTINCT(self):
            return self.getToken(postgreSQLParser.DISTINCT, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def OR(self):
            return self.getToken(postgreSQLParser.OR, 0)

        def CAST_EXPRESSION(self):
            return self.getToken(postgreSQLParser.CAST_EXPRESSION, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def collate_identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Collate_identifierContext,0)


        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def select_stmt_no_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmt_no_parensContext,0)


        def truth_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Truth_valueContext,0)


        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def DOCUMENT(self):
            return self.getToken(postgreSQLParser.DOCUMENT, 0)

        def UNKNOWN(self):
            return self.getToken(postgreSQLParser.UNKNOWN, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def type_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_listContext,0)


        def ISNULL(self):
            return self.getToken(postgreSQLParser.ISNULL, 0)

        def NOTNULL(self):
            return self.getToken(postgreSQLParser.NOTNULL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_vex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVex" ):
                listener.enterVex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVex" ):
                listener.exitVex(self)



    def vex(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = postgreSQLParser.VexContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 586
        self.enterRecursionRule(localctx, 586, self.RULE_vex, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5831
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,739,self._ctx)
            if la_ == 1:
                self.state = 5807
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5808
                self.vex(0)
                self.state = 5809
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 5811
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,737,self._ctx)
                if la_ == 1:
                    self.state = 5810
                    self.indirection_list()


                pass

            elif la_ == 2:
                self.state = 5813
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5814
                self.vex(0)
                self.state = 5817 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 5815
                    self.match(postgreSQLParser.COMMA)
                    self.state = 5816
                    self.vex(0)
                    self.state = 5819 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.COMMA):
                        break

                self.state = 5821
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 3:
                self.state = 5823
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 5824
                self.vex(24)
                pass

            elif la_ == 4:
                self.state = 5825
                self.op()
                self.state = 5826
                self.vex(18)
                pass

            elif la_ == 5:
                self.state = 5828
                self.match(postgreSQLParser.NOT)
                self.state = 5829
                self.vex(4)
                pass

            elif la_ == 6:
                self.state = 5830
                self.value_expression_primary()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 5968
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,756,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 5966
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,755,self._ctx)
                    if la_ == 1:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5833
                        if not self.precpred(self._ctx, 23):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 23)")
                        self.state = 5834
                        self.match(postgreSQLParser.AT)
                        self.state = 5835
                        self.match(postgreSQLParser.TIME)
                        self.state = 5836
                        self.match(postgreSQLParser.ZONE)
                        self.state = 5837
                        self.vex(24)
                        pass

                    elif la_ == 2:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5838
                        if not self.precpred(self._ctx, 22):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 22)")
                        self.state = 5839
                        self.match(postgreSQLParser.EXP)
                        self.state = 5840
                        self.vex(23)
                        pass

                    elif la_ == 3:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5841
                        if not self.precpred(self._ctx, 21):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 21)")
                        self.state = 5842
                        _la = self._input.LA(1)
                        if not(((((_la - 599)) & ~0x3f) == 0 and ((1 << (_la - 599)) & ((1 << (postgreSQLParser.MULTIPLY - 599)) | (1 << (postgreSQLParser.DIVIDE - 599)) | (1 << (postgreSQLParser.MODULAR - 599)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 5843
                        self.vex(22)
                        pass

                    elif la_ == 4:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5844
                        if not self.precpred(self._ctx, 20):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 20)")
                        self.state = 5845
                        _la = self._input.LA(1)
                        if not(_la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 5846
                        self.vex(21)
                        pass

                    elif la_ == 5:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5847
                        if not self.precpred(self._ctx, 19):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 19)")
                        self.state = 5848
                        self.op()
                        self.state = 5849
                        self.vex(20)
                        pass

                    elif la_ == 6:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5851
                        if not self.precpred(self._ctx, 15):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 15)")
                        self.state = 5853
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5852
                            self.match(postgreSQLParser.NOT)


                        self.state = 5855
                        self.match(postgreSQLParser.BETWEEN)
                        self.state = 5857
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.ASYMMETRIC or _la==postgreSQLParser.SYMMETRIC:
                            self.state = 5856
                            _la = self._input.LA(1)
                            if not(_la==postgreSQLParser.ASYMMETRIC or _la==postgreSQLParser.SYMMETRIC):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()


                        self.state = 5859
                        self.vex_b(0)
                        self.state = 5860
                        self.match(postgreSQLParser.AND)
                        self.state = 5861
                        self.vex(16)
                        pass

                    elif la_ == 7:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5863
                        if not self.precpred(self._ctx, 14):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 14)")
                        self.state = 5865
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5864
                            self.match(postgreSQLParser.NOT)


                        self.state = 5871
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.LIKE]:
                            self.state = 5867
                            self.match(postgreSQLParser.LIKE)
                            pass
                        elif token in [postgreSQLParser.ILIKE]:
                            self.state = 5868
                            self.match(postgreSQLParser.ILIKE)
                            pass
                        elif token in [postgreSQLParser.SIMILAR]:
                            self.state = 5869
                            self.match(postgreSQLParser.SIMILAR)
                            self.state = 5870
                            self.match(postgreSQLParser.TO)
                            pass
                        else:
                            raise NoViableAltException(self)

                        self.state = 5873
                        self.vex(15)
                        pass

                    elif la_ == 8:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5874
                        if not self.precpred(self._ctx, 13):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 13)")
                        self.state = 5876
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5875
                            self.match(postgreSQLParser.NOT)


                        self.state = 5882
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.LIKE]:
                            self.state = 5878
                            self.match(postgreSQLParser.LIKE)
                            pass
                        elif token in [postgreSQLParser.ILIKE]:
                            self.state = 5879
                            self.match(postgreSQLParser.ILIKE)
                            pass
                        elif token in [postgreSQLParser.SIMILAR]:
                            self.state = 5880
                            self.match(postgreSQLParser.SIMILAR)
                            self.state = 5881
                            self.match(postgreSQLParser.TO)
                            pass
                        else:
                            raise NoViableAltException(self)

                        self.state = 5884
                        self.vex(0)
                        self.state = 5885
                        self.match(postgreSQLParser.ESCAPE)
                        self.state = 5886
                        self.vex(14)
                        pass

                    elif la_ == 9:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5888
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 5889
                        _la = self._input.LA(1)
                        if not(((((_la - 586)) & ~0x3f) == 0 and ((1 << (_la - 586)) & ((1 << (postgreSQLParser.EQUAL - 586)) | (1 << (postgreSQLParser.NOT_EQUAL - 586)) | (1 << (postgreSQLParser.LTH - 586)) | (1 << (postgreSQLParser.LEQ - 586)) | (1 << (postgreSQLParser.GTH - 586)) | (1 << (postgreSQLParser.GEQ - 586)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 5890
                        self.vex(13)
                        pass

                    elif la_ == 10:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5891
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 5892
                        self.match(postgreSQLParser.IS)
                        self.state = 5894
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5893
                            self.match(postgreSQLParser.NOT)


                        self.state = 5896
                        self.match(postgreSQLParser.DISTINCT)
                        self.state = 5897
                        self.match(postgreSQLParser.FROM)
                        self.state = 5898
                        self.vex(11)
                        pass

                    elif la_ == 11:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5899
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 5900
                        self.match(postgreSQLParser.AND)
                        self.state = 5901
                        self.vex(4)
                        pass

                    elif la_ == 12:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5902
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 5903
                        self.match(postgreSQLParser.OR)
                        self.state = 5904
                        self.vex(3)
                        pass

                    elif la_ == 13:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5905
                        if not self.precpred(self._ctx, 28):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 28)")
                        self.state = 5906
                        self.match(postgreSQLParser.CAST_EXPRESSION)
                        self.state = 5907
                        self.data_type()
                        pass

                    elif la_ == 14:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5908
                        if not self.precpred(self._ctx, 25):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 25)")
                        self.state = 5909
                        self.collate_identifier()
                        pass

                    elif la_ == 15:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5910
                        if not self.precpred(self._ctx, 17):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 17)")
                        self.state = 5911
                        self.op()
                        pass

                    elif la_ == 16:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5912
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 5914
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5913
                            self.match(postgreSQLParser.NOT)


                        self.state = 5916
                        self.match(postgreSQLParser.IN)
                        self.state = 5917
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 5927
                        self._errHandler.sync(self)
                        la_ = self._interp.adaptivePredict(self._input,749,self._ctx)
                        if la_ == 1:
                            self.state = 5918
                            self.select_stmt_no_parens()
                            pass

                        elif la_ == 2:
                            self.state = 5919
                            self.vex(0)
                            self.state = 5924
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            while _la==postgreSQLParser.COMMA:
                                self.state = 5920
                                self.match(postgreSQLParser.COMMA)
                                self.state = 5921
                                self.vex(0)
                                self.state = 5926
                                self._errHandler.sync(self)
                                _la = self._input.LA(1)

                            pass


                        self.state = 5929
                        self.match(postgreSQLParser.RIGHT_PAREN)
                        pass

                    elif la_ == 17:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5931
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 5932
                        self.match(postgreSQLParser.IS)
                        self.state = 5934
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5933
                            self.match(postgreSQLParser.NOT)


                        self.state = 5938
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.FALSE, postgreSQLParser.ON, postgreSQLParser.TRUE]:
                            self.state = 5936
                            self.truth_value()
                            pass
                        elif token in [postgreSQLParser.NULL]:
                            self.state = 5937
                            self.match(postgreSQLParser.NULL)
                            pass
                        else:
                            raise NoViableAltException(self)

                        pass

                    elif la_ == 18:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5940
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 5941
                        self.match(postgreSQLParser.IS)
                        self.state = 5943
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5942
                            self.match(postgreSQLParser.NOT)


                        self.state = 5945
                        self.match(postgreSQLParser.DOCUMENT)
                        pass

                    elif la_ == 19:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5946
                        if not self.precpred(self._ctx, 8):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 8)")
                        self.state = 5947
                        self.match(postgreSQLParser.IS)
                        self.state = 5949
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5948
                            self.match(postgreSQLParser.NOT)


                        self.state = 5951
                        self.match(postgreSQLParser.UNKNOWN)
                        pass

                    elif la_ == 20:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5952
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 5953
                        self.match(postgreSQLParser.IS)
                        self.state = 5955
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 5954
                            self.match(postgreSQLParser.NOT)


                        self.state = 5957
                        self.match(postgreSQLParser.OF)
                        self.state = 5958
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 5959
                        self.type_list()
                        self.state = 5960
                        self.match(postgreSQLParser.RIGHT_PAREN)
                        pass

                    elif la_ == 21:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5962
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 5963
                        self.match(postgreSQLParser.ISNULL)
                        pass

                    elif la_ == 22:
                        localctx = postgreSQLParser.VexContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex)
                        self.state = 5964
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 5965
                        self.match(postgreSQLParser.NOTNULL)
                        pass

             
                self.state = 5970
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,756,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Vex_bContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def indirection_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Indirection_listContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def vex_b(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Vex_bContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Vex_bContext,i)


        def PLUS(self):
            return self.getToken(postgreSQLParser.PLUS, 0)

        def MINUS(self):
            return self.getToken(postgreSQLParser.MINUS, 0)

        def op(self):
            return self.getTypedRuleContext(postgreSQLParser.OpContext,0)


        def value_expression_primary(self):
            return self.getTypedRuleContext(postgreSQLParser.Value_expression_primaryContext,0)


        def EXP(self):
            return self.getToken(postgreSQLParser.EXP, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def DIVIDE(self):
            return self.getToken(postgreSQLParser.DIVIDE, 0)

        def MODULAR(self):
            return self.getToken(postgreSQLParser.MODULAR, 0)

        def LTH(self):
            return self.getToken(postgreSQLParser.LTH, 0)

        def GTH(self):
            return self.getToken(postgreSQLParser.GTH, 0)

        def LEQ(self):
            return self.getToken(postgreSQLParser.LEQ, 0)

        def GEQ(self):
            return self.getToken(postgreSQLParser.GEQ, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def NOT_EQUAL(self):
            return self.getToken(postgreSQLParser.NOT_EQUAL, 0)

        def IS(self):
            return self.getToken(postgreSQLParser.IS, 0)

        def DISTINCT(self):
            return self.getToken(postgreSQLParser.DISTINCT, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def CAST_EXPRESSION(self):
            return self.getToken(postgreSQLParser.CAST_EXPRESSION, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def DOCUMENT(self):
            return self.getToken(postgreSQLParser.DOCUMENT, 0)

        def UNKNOWN(self):
            return self.getToken(postgreSQLParser.UNKNOWN, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def type_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_vex_b

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVex_b" ):
                listener.enterVex_b(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVex_b" ):
                listener.exitVex_b(self)



    def vex_b(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = postgreSQLParser.Vex_bContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 588
        self.enterRecursionRule(localctx, 588, self.RULE_vex_b, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 5994
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,759,self._ctx)
            if la_ == 1:
                self.state = 5972
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5973
                self.vex(0)
                self.state = 5974
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 5976
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,757,self._ctx)
                if la_ == 1:
                    self.state = 5975
                    self.indirection_list()


                pass

            elif la_ == 2:
                self.state = 5978
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 5979
                self.vex(0)
                self.state = 5982 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 5980
                    self.match(postgreSQLParser.COMMA)
                    self.state = 5981
                    self.vex(0)
                    self.state = 5984 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==postgreSQLParser.COMMA):
                        break

                self.state = 5986
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 3:
                self.state = 5988
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 5989
                self.vex_b(13)
                pass

            elif la_ == 4:
                self.state = 5990
                self.op()
                self.state = 5991
                self.vex_b(8)
                pass

            elif la_ == 5:
                self.state = 5993
                self.value_expression_primary()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 6049
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,765,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 6047
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,764,self._ctx)
                    if la_ == 1:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 5996
                        if not self.precpred(self._ctx, 12):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 12)")
                        self.state = 5997
                        self.match(postgreSQLParser.EXP)
                        self.state = 5998
                        self.vex_b(13)
                        pass

                    elif la_ == 2:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 5999
                        if not self.precpred(self._ctx, 11):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 11)")
                        self.state = 6000
                        _la = self._input.LA(1)
                        if not(((((_la - 599)) & ~0x3f) == 0 and ((1 << (_la - 599)) & ((1 << (postgreSQLParser.MULTIPLY - 599)) | (1 << (postgreSQLParser.DIVIDE - 599)) | (1 << (postgreSQLParser.MODULAR - 599)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6001
                        self.vex_b(12)
                        pass

                    elif la_ == 3:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6002
                        if not self.precpred(self._ctx, 10):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 10)")
                        self.state = 6003
                        _la = self._input.LA(1)
                        if not(_la==postgreSQLParser.PLUS or _la==postgreSQLParser.MINUS):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6004
                        self.vex_b(11)
                        pass

                    elif la_ == 4:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6005
                        if not self.precpred(self._ctx, 9):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 9)")
                        self.state = 6006
                        self.op()
                        self.state = 6007
                        self.vex_b(10)
                        pass

                    elif la_ == 5:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6009
                        if not self.precpred(self._ctx, 6):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 6)")
                        self.state = 6010
                        _la = self._input.LA(1)
                        if not(((((_la - 586)) & ~0x3f) == 0 and ((1 << (_la - 586)) & ((1 << (postgreSQLParser.EQUAL - 586)) | (1 << (postgreSQLParser.NOT_EQUAL - 586)) | (1 << (postgreSQLParser.LTH - 586)) | (1 << (postgreSQLParser.LEQ - 586)) | (1 << (postgreSQLParser.GTH - 586)) | (1 << (postgreSQLParser.GEQ - 586)))) != 0)):
                            self._errHandler.recoverInline(self)
                        else:
                            self._errHandler.reportMatch(self)
                            self.consume()
                        self.state = 6011
                        self.vex_b(7)
                        pass

                    elif la_ == 6:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6012
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 6013
                        self.match(postgreSQLParser.IS)
                        self.state = 6015
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 6014
                            self.match(postgreSQLParser.NOT)


                        self.state = 6017
                        self.match(postgreSQLParser.DISTINCT)
                        self.state = 6018
                        self.match(postgreSQLParser.FROM)
                        self.state = 6019
                        self.vex_b(6)
                        pass

                    elif la_ == 7:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6020
                        if not self.precpred(self._ctx, 16):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 16)")
                        self.state = 6021
                        self.match(postgreSQLParser.CAST_EXPRESSION)
                        self.state = 6022
                        self.data_type()
                        pass

                    elif la_ == 8:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6023
                        if not self.precpred(self._ctx, 7):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 7)")
                        self.state = 6024
                        self.op()
                        pass

                    elif la_ == 9:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6025
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 6026
                        self.match(postgreSQLParser.IS)
                        self.state = 6028
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 6027
                            self.match(postgreSQLParser.NOT)


                        self.state = 6030
                        self.match(postgreSQLParser.DOCUMENT)
                        pass

                    elif la_ == 10:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6031
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 6032
                        self.match(postgreSQLParser.IS)
                        self.state = 6034
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 6033
                            self.match(postgreSQLParser.NOT)


                        self.state = 6036
                        self.match(postgreSQLParser.UNKNOWN)
                        pass

                    elif la_ == 11:
                        localctx = postgreSQLParser.Vex_bContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_vex_b)
                        self.state = 6037
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 6038
                        self.match(postgreSQLParser.IS)
                        self.state = 6040
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.NOT:
                            self.state = 6039
                            self.match(postgreSQLParser.NOT)


                        self.state = 6042
                        self.match(postgreSQLParser.OF)
                        self.state = 6043
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 6044
                        self.type_list()
                        self.state = 6045
                        self.match(postgreSQLParser.RIGHT_PAREN)
                        pass

             
                self.state = 6051
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,765,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class OpContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def op_chars(self):
            return self.getTypedRuleContext(postgreSQLParser.Op_charsContext,0)


        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def all_simple_op(self):
            return self.getTypedRuleContext(postgreSQLParser.All_simple_opContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_op

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOp" ):
                listener.enterOp(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOp" ):
                listener.exitOp(self)




    def op(self):

        localctx = postgreSQLParser.OpContext(self, self._ctx, self.state)
        self.enterRule(localctx, 590, self.RULE_op)
        try:
            self.state = 6060
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6052
                self.op_chars()
                pass
            elif token in [postgreSQLParser.OPERATOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6053
                self.match(postgreSQLParser.OPERATOR)
                self.state = 6054
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6055
                self.identifier()
                self.state = 6056
                self.match(postgreSQLParser.DOT)
                self.state = 6057
                self.all_simple_op()
                self.state = 6058
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class All_op_refContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def all_simple_op(self):
            return self.getTypedRuleContext(postgreSQLParser.All_simple_opContext,0)


        def OPERATOR(self):
            return self.getToken(postgreSQLParser.OPERATOR, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DOT(self):
            return self.getToken(postgreSQLParser.DOT, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_all_op_ref

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAll_op_ref" ):
                listener.enterAll_op_ref(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAll_op_ref" ):
                listener.exitAll_op_ref(self)




    def all_op_ref(self):

        localctx = postgreSQLParser.All_op_refContext(self, self._ctx, self.state)
        self.enterRule(localctx, 592, self.RULE_all_op_ref)
        try:
            self.state = 6070
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.EQUAL, postgreSQLParser.NOT_EQUAL, postgreSQLParser.LTH, postgreSQLParser.LEQ, postgreSQLParser.GTH, postgreSQLParser.GEQ, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.DIVIDE, postgreSQLParser.MODULAR, postgreSQLParser.EXP, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6062
                self.all_simple_op()
                pass
            elif token in [postgreSQLParser.OPERATOR]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6063
                self.match(postgreSQLParser.OPERATOR)
                self.state = 6064
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6065
                self.identifier()
                self.state = 6066
                self.match(postgreSQLParser.DOT)
                self.state = 6067
                self.all_simple_op()
                self.state = 6068
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Datetime_overlapsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def OVERLAPS(self):
            return self.getToken(postgreSQLParser.OVERLAPS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_datetime_overlaps

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDatetime_overlaps" ):
                listener.enterDatetime_overlaps(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDatetime_overlaps" ):
                listener.exitDatetime_overlaps(self)




    def datetime_overlaps(self):

        localctx = postgreSQLParser.Datetime_overlapsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 594, self.RULE_datetime_overlaps)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6072
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6073
            self.vex(0)
            self.state = 6074
            self.match(postgreSQLParser.COMMA)
            self.state = 6075
            self.vex(0)
            self.state = 6076
            self.match(postgreSQLParser.RIGHT_PAREN)
            self.state = 6077
            self.match(postgreSQLParser.OVERLAPS)
            self.state = 6078
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6079
            self.vex(0)
            self.state = 6080
            self.match(postgreSQLParser.COMMA)
            self.state = 6081
            self.vex(0)
            self.state = 6082
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Value_expression_primaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_value_specification(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_value_specificationContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def select_stmt_no_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmt_no_parensContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def indirection_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Indirection_listContext,0)


        def case_expression(self):
            return self.getTypedRuleContext(postgreSQLParser.Case_expressionContext,0)


        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def comparison_mod(self):
            return self.getTypedRuleContext(postgreSQLParser.Comparison_modContext,0)


        def EXISTS(self):
            return self.getToken(postgreSQLParser.EXISTS, 0)

        def table_subquery(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_subqueryContext,0)


        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def indirection_var(self):
            return self.getTypedRuleContext(postgreSQLParser.Indirection_varContext,0)


        def array_expression(self):
            return self.getTypedRuleContext(postgreSQLParser.Array_expressionContext,0)


        def type_coercion(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_coercionContext,0)


        def datetime_overlaps(self):
            return self.getTypedRuleContext(postgreSQLParser.Datetime_overlapsContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_value_expression_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValue_expression_primary" ):
                listener.enterValue_expression_primary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValue_expression_primary" ):
                listener.exitValue_expression_primary(self)




    def value_expression_primary(self):

        localctx = postgreSQLParser.Value_expression_primaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 596, self.RULE_value_expression_primary)
        try:
            self.state = 6102
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,769,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6084
                self.unsigned_value_specification()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6085
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6086
                self.select_stmt_no_parens()
                self.state = 6087
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 6089
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,768,self._ctx)
                if la_ == 1:
                    self.state = 6088
                    self.indirection_list()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6091
                self.case_expression()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6092
                self.match(postgreSQLParser.NULL)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 6093
                self.match(postgreSQLParser.MULTIPLY)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 6094
                self.comparison_mod()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 6095
                self.match(postgreSQLParser.EXISTS)
                self.state = 6096
                self.table_subquery()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 6097
                self.function_call()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 6098
                self.indirection_var()
                pass

            elif la_ == 10:
                self.enterOuterAlt(localctx, 10)
                self.state = 6099
                self.array_expression()
                pass

            elif la_ == 11:
                self.enterOuterAlt(localctx, 11)
                self.state = 6100
                self.type_coercion()
                pass

            elif la_ == 12:
                self.enterOuterAlt(localctx, 12)
                self.state = 6101
                self.datetime_overlaps()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_value_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def unsigned_numeric_literal(self):
            return self.getTypedRuleContext(postgreSQLParser.Unsigned_numeric_literalContext,0)


        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def truth_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Truth_valueContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_unsigned_value_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_value_specification" ):
                listener.enterUnsigned_value_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_value_specification" ):
                listener.exitUnsigned_value_specification(self)




    def unsigned_value_specification(self):

        localctx = postgreSQLParser.Unsigned_value_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 598, self.RULE_unsigned_value_specification)
        try:
            self.state = 6107
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6104
                self.unsigned_numeric_literal()
                pass
            elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6105
                self.character_string()
                pass
            elif token in [postgreSQLParser.FALSE, postgreSQLParser.ON, postgreSQLParser.TRUE]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6106
                self.truth_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Unsigned_numeric_literalContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def REAL_NUMBER(self):
            return self.getToken(postgreSQLParser.REAL_NUMBER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_unsigned_numeric_literal

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUnsigned_numeric_literal" ):
                listener.enterUnsigned_numeric_literal(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUnsigned_numeric_literal" ):
                listener.exitUnsigned_numeric_literal(self)




    def unsigned_numeric_literal(self):

        localctx = postgreSQLParser.Unsigned_numeric_literalContext(self, self._ctx, self.state)
        self.enterRule(localctx, 600, self.RULE_unsigned_numeric_literal)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6109
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.NUMBER_LITERAL or _la==postgreSQLParser.REAL_NUMBER):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Truth_valueContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUE(self):
            return self.getToken(postgreSQLParser.TRUE, 0)

        def FALSE(self):
            return self.getToken(postgreSQLParser.FALSE, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_truth_value

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTruth_value" ):
                listener.enterTruth_value(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTruth_value" ):
                listener.exitTruth_value(self)




    def truth_value(self):

        localctx = postgreSQLParser.Truth_valueContext(self, self._ctx, self.state)
        self.enterRule(localctx, 602, self.RULE_truth_value)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6111
            _la = self._input.LA(1)
            if not(((((_la - 404)) & ~0x3f) == 0 and ((1 << (_la - 404)) & ((1 << (postgreSQLParser.FALSE - 404)) | (1 << (postgreSQLParser.ON - 404)) | (1 << (postgreSQLParser.TRUE - 404)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._vex = None # VexContext
            self.r = list() # of VexContexts

        def CASE(self):
            return self.getToken(postgreSQLParser.CASE, 0)

        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WHEN)
            else:
                return self.getToken(postgreSQLParser.WHEN, i)

        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.THEN)
            else:
                return self.getToken(postgreSQLParser.THEN, i)

        def ELSE(self):
            return self.getToken(postgreSQLParser.ELSE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_case_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCase_expression" ):
                listener.enterCase_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCase_expression" ):
                listener.exitCase_expression(self)




    def case_expression(self):

        localctx = postgreSQLParser.Case_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 604, self.RULE_case_expression)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6113
            self.match(postgreSQLParser.CASE)
            self.state = 6115
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                self.state = 6114
                self.vex(0)


            self.state = 6122 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 6117
                self.match(postgreSQLParser.WHEN)
                self.state = 6118
                self.vex(0)
                self.state = 6119
                self.match(postgreSQLParser.THEN)
                self.state = 6120
                localctx._vex = self.vex(0)
                localctx.r.append(localctx._vex)
                self.state = 6124 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==postgreSQLParser.WHEN):
                    break

            self.state = 6128
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ELSE:
                self.state = 6126
                self.match(postgreSQLParser.ELSE)
                self.state = 6127
                localctx._vex = self.vex(0)
                localctx.r.append(localctx._vex)


            self.state = 6130
            self.match(postgreSQLParser.END)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cast_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def CAST(self):
            return self.getToken(postgreSQLParser.CAST, 0)

        def TREAT(self):
            return self.getToken(postgreSQLParser.TREAT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_cast_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCast_specification" ):
                listener.enterCast_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCast_specification" ):
                listener.exitCast_specification(self)




    def cast_specification(self):

        localctx = postgreSQLParser.Cast_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 606, self.RULE_cast_specification)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6132
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.TREAT or _la==postgreSQLParser.CAST):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6133
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6134
            self.vex(0)
            self.state = 6135
            self.match(postgreSQLParser.AS)
            self.state = 6136
            self.data_type()
            self.state = 6137
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_callContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name_nontype(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_name_nontypeContext,0)


        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def vex_or_named_notation(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Vex_or_named_notationContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Vex_or_named_notationContext,i)


        def WITHIN(self):
            return self.getToken(postgreSQLParser.WITHIN, 0)

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def orderby_clause(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Orderby_clauseContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Orderby_clauseContext,i)


        def filter_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Filter_clauseContext,0)


        def OVER(self):
            return self.getToken(postgreSQLParser.OVER, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def window_definition(self):
            return self.getTypedRuleContext(postgreSQLParser.Window_definitionContext,0)


        def set_qualifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_qualifierContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def function_construct(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_constructContext,0)


        def extract_function(self):
            return self.getTypedRuleContext(postgreSQLParser.Extract_functionContext,0)


        def system_function(self):
            return self.getTypedRuleContext(postgreSQLParser.System_functionContext,0)


        def date_time_function(self):
            return self.getTypedRuleContext(postgreSQLParser.Date_time_functionContext,0)


        def string_value_function(self):
            return self.getTypedRuleContext(postgreSQLParser.String_value_functionContext,0)


        def xml_function(self):
            return self.getTypedRuleContext(postgreSQLParser.Xml_functionContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_call

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_call" ):
                listener.enterFunction_call(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_call" ):
                listener.exitFunction_call(self)




    def function_call(self):

        localctx = postgreSQLParser.Function_callContext(self, self._ctx, self.state)
        self.enterRule(localctx, 608, self.RULE_function_call)
        self._la = 0 # Token type
        try:
            self.state = 6182
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,782,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6139
                self.schema_qualified_name_nontype()
                self.state = 6140
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6155
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.DISTINCT - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)) | (1 << (postgreSQLParser.VARIADIC - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                    self.state = 6142
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,774,self._ctx)
                    if la_ == 1:
                        self.state = 6141
                        self.set_qualifier()


                    self.state = 6144
                    self.vex_or_named_notation()
                    self.state = 6149
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 6145
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6146
                        self.vex_or_named_notation()
                        self.state = 6151
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 6153
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.ORDER:
                        self.state = 6152
                        self.orderby_clause()




                self.state = 6157
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 6164
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,778,self._ctx)
                if la_ == 1:
                    self.state = 6158
                    self.match(postgreSQLParser.WITHIN)
                    self.state = 6159
                    self.match(postgreSQLParser.GROUP)
                    self.state = 6160
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 6161
                    self.orderby_clause()
                    self.state = 6162
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 6167
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,779,self._ctx)
                if la_ == 1:
                    self.state = 6166
                    self.filter_clause()


                self.state = 6174
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,781,self._ctx)
                if la_ == 1:
                    self.state = 6169
                    self.match(postgreSQLParser.OVER)
                    self.state = 6172
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                        self.state = 6170
                        self.identifier()
                        pass
                    elif token in [postgreSQLParser.LEFT_PAREN]:
                        self.state = 6171
                        self.window_definition()
                        pass
                    else:
                        raise NoViableAltException(self)



                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6176
                self.function_construct()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6177
                self.extract_function()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6178
                self.system_function()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 6179
                self.date_time_function()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 6180
                self.string_value_function()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 6181
                self.xml_function()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Vex_or_named_notationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.argname = None # IdentifierContext

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def VARIADIC(self):
            return self.getToken(postgreSQLParser.VARIADIC, 0)

        def pointer(self):
            return self.getTypedRuleContext(postgreSQLParser.PointerContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_vex_or_named_notation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVex_or_named_notation" ):
                listener.enterVex_or_named_notation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVex_or_named_notation" ):
                listener.exitVex_or_named_notation(self)




    def vex_or_named_notation(self):

        localctx = postgreSQLParser.Vex_or_named_notationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 610, self.RULE_vex_or_named_notation)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6185
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.VARIADIC:
                self.state = 6184
                self.match(postgreSQLParser.VARIADIC)


            self.state = 6190
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,784,self._ctx)
            if la_ == 1:
                self.state = 6187
                localctx.argname = self.identifier()
                self.state = 6188
                self.pointer()


            self.state = 6192
            self.vex(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PointerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EQUAL_GTH(self):
            return self.getToken(postgreSQLParser.EQUAL_GTH, 0)

        def COLON_EQUAL(self):
            return self.getToken(postgreSQLParser.COLON_EQUAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_pointer

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPointer" ):
                listener.enterPointer(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPointer" ):
                listener.exitPointer(self)




    def pointer(self):

        localctx = postgreSQLParser.PointerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 612, self.RULE_pointer)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6194
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.EQUAL_GTH or _la==postgreSQLParser.COLON_EQUAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_constructContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COALESCE(self):
            return self.getToken(postgreSQLParser.COALESCE, 0)

        def GREATEST(self):
            return self.getToken(postgreSQLParser.GREATEST, 0)

        def GROUPING(self):
            return self.getToken(postgreSQLParser.GROUPING, 0)

        def LEAST(self):
            return self.getToken(postgreSQLParser.LEAST, 0)

        def NULLIF(self):
            return self.getToken(postgreSQLParser.NULLIF, 0)

        def XMLCONCAT(self):
            return self.getToken(postgreSQLParser.XMLCONCAT, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_construct

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_construct" ):
                listener.enterFunction_construct(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_construct" ):
                listener.exitFunction_construct(self)




    def function_construct(self):

        localctx = postgreSQLParser.Function_constructContext(self, self._ctx, self.state)
        self.enterRule(localctx, 614, self.RULE_function_construct)
        self._la = 0 # Token type
        try:
            self.state = 6221
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.COALESCE, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.LEAST, postgreSQLParser.NULLIF, postgreSQLParser.XMLCONCAT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6196
                _la = self._input.LA(1)
                if not(((((_la - 306)) & ~0x3f) == 0 and ((1 << (_la - 306)) & ((1 << (postgreSQLParser.COALESCE - 306)) | (1 << (postgreSQLParser.GREATEST - 306)) | (1 << (postgreSQLParser.GROUPING - 306)) | (1 << (postgreSQLParser.LEAST - 306)) | (1 << (postgreSQLParser.NULLIF - 306)) | (1 << (postgreSQLParser.XMLCONCAT - 306)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6197
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6198
                self.vex(0)
                self.state = 6203
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6199
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6200
                    self.vex(0)
                    self.state = 6205
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6206
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.ROW]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6208
                self.match(postgreSQLParser.ROW)
                self.state = 6209
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6218
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                    self.state = 6210
                    self.vex(0)
                    self.state = 6215
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 6211
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6212
                        self.vex(0)
                        self.state = 6217
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 6220
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Extract_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXTRACT(self):
            return self.getToken(postgreSQLParser.EXTRACT, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_extract_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExtract_function" ):
                listener.enterExtract_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExtract_function" ):
                listener.exitExtract_function(self)




    def extract_function(self):

        localctx = postgreSQLParser.Extract_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 616, self.RULE_extract_function)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6223
            self.match(postgreSQLParser.EXTRACT)
            self.state = 6224
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6227
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 6225
                self.identifier()
                pass
            elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.state = 6226
                self.character_string()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 6229
            self.match(postgreSQLParser.FROM)
            self.state = 6230
            self.vex(0)
            self.state = 6231
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class System_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURRENT_CATALOG(self):
            return self.getToken(postgreSQLParser.CURRENT_CATALOG, 0)

        def CURRENT_SCHEMA(self):
            return self.getToken(postgreSQLParser.CURRENT_SCHEMA, 0)

        def CURRENT_USER(self):
            return self.getToken(postgreSQLParser.CURRENT_USER, 0)

        def SESSION_USER(self):
            return self.getToken(postgreSQLParser.SESSION_USER, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def cast_specification(self):
            return self.getTypedRuleContext(postgreSQLParser.Cast_specificationContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_system_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSystem_function" ):
                listener.enterSystem_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSystem_function" ):
                listener.exitSystem_function(self)




    def system_function(self):

        localctx = postgreSQLParser.System_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 618, self.RULE_system_function)
        try:
            self.state = 6239
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CURRENT_CATALOG]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6233
                self.match(postgreSQLParser.CURRENT_CATALOG)
                pass
            elif token in [postgreSQLParser.CURRENT_SCHEMA]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6234
                self.match(postgreSQLParser.CURRENT_SCHEMA)
                pass
            elif token in [postgreSQLParser.CURRENT_USER]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6235
                self.match(postgreSQLParser.CURRENT_USER)
                pass
            elif token in [postgreSQLParser.SESSION_USER]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6236
                self.match(postgreSQLParser.SESSION_USER)
                pass
            elif token in [postgreSQLParser.USER]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6237
                self.match(postgreSQLParser.USER)
                pass
            elif token in [postgreSQLParser.TREAT, postgreSQLParser.CAST]:
                self.enterOuterAlt(localctx, 6)
                self.state = 6238
                self.cast_specification()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Date_time_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CURRENT_DATE(self):
            return self.getToken(postgreSQLParser.CURRENT_DATE, 0)

        def CURRENT_TIME(self):
            return self.getToken(postgreSQLParser.CURRENT_TIME, 0)

        def type_length(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_lengthContext,0)


        def CURRENT_TIMESTAMP(self):
            return self.getToken(postgreSQLParser.CURRENT_TIMESTAMP, 0)

        def LOCALTIME(self):
            return self.getToken(postgreSQLParser.LOCALTIME, 0)

        def LOCALTIMESTAMP(self):
            return self.getToken(postgreSQLParser.LOCALTIMESTAMP, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_date_time_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate_time_function" ):
                listener.enterDate_time_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate_time_function" ):
                listener.exitDate_time_function(self)




    def date_time_function(self):

        localctx = postgreSQLParser.Date_time_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 620, self.RULE_date_time_function)
        try:
            self.state = 6258
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.CURRENT_DATE]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6241
                self.match(postgreSQLParser.CURRENT_DATE)
                pass
            elif token in [postgreSQLParser.CURRENT_TIME]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6242
                self.match(postgreSQLParser.CURRENT_TIME)
                self.state = 6244
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,791,self._ctx)
                if la_ == 1:
                    self.state = 6243
                    self.type_length()


                pass
            elif token in [postgreSQLParser.CURRENT_TIMESTAMP]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6246
                self.match(postgreSQLParser.CURRENT_TIMESTAMP)
                self.state = 6248
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,792,self._ctx)
                if la_ == 1:
                    self.state = 6247
                    self.type_length()


                pass
            elif token in [postgreSQLParser.LOCALTIME]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6250
                self.match(postgreSQLParser.LOCALTIME)
                self.state = 6252
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,793,self._ctx)
                if la_ == 1:
                    self.state = 6251
                    self.type_length()


                pass
            elif token in [postgreSQLParser.LOCALTIMESTAMP]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6254
                self.match(postgreSQLParser.LOCALTIMESTAMP)
                self.state = 6256
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,794,self._ctx)
                if la_ == 1:
                    self.state = 6255
                    self.type_length()


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class String_value_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.chars = None # VexContext
            self.vstr = None # VexContext

        def TRIM(self):
            return self.getToken(postgreSQLParser.TRIM, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def LEADING(self):
            return self.getToken(postgreSQLParser.LEADING, 0)

        def TRAILING(self):
            return self.getToken(postgreSQLParser.TRAILING, 0)

        def BOTH(self):
            return self.getToken(postgreSQLParser.BOTH, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def SUBSTRING(self):
            return self.getToken(postgreSQLParser.SUBSTRING, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def POSITION(self):
            return self.getToken(postgreSQLParser.POSITION, 0)

        def vex_b(self):
            return self.getTypedRuleContext(postgreSQLParser.Vex_bContext,0)


        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def OVERLAY(self):
            return self.getToken(postgreSQLParser.OVERLAY, 0)

        def PLACING(self):
            return self.getToken(postgreSQLParser.PLACING, 0)

        def COLLATION(self):
            return self.getToken(postgreSQLParser.COLLATION, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_string_value_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterString_value_function" ):
                listener.enterString_value_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitString_value_function" ):
                listener.exitString_value_function(self)




    def string_value_function(self):

        localctx = postgreSQLParser.String_value_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 622, self.RULE_string_value_function)
        self._la = 0 # Token type
        try:
            self.state = 6327
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.TRIM]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6260
                self.match(postgreSQLParser.TRIM)
                self.state = 6261
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6263
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 382)) & ~0x3f) == 0 and ((1 << (_la - 382)) & ((1 << (postgreSQLParser.BOTH - 382)) | (1 << (postgreSQLParser.LEADING - 382)) | (1 << (postgreSQLParser.TRAILING - 382)))) != 0):
                    self.state = 6262
                    _la = self._input.LA(1)
                    if not(((((_la - 382)) & ~0x3f) == 0 and ((1 << (_la - 382)) & ((1 << (postgreSQLParser.BOTH - 382)) | (1 << (postgreSQLParser.LEADING - 382)) | (1 << (postgreSQLParser.TRAILING - 382)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 6277
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,799,self._ctx)
                if la_ == 1:
                    self.state = 6265
                    localctx.chars = self.vex(0)
                    self.state = 6266
                    self.match(postgreSQLParser.FROM)
                    self.state = 6267
                    localctx.vstr = self.vex(0)
                    pass

                elif la_ == 2:
                    self.state = 6270
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.FROM:
                        self.state = 6269
                        self.match(postgreSQLParser.FROM)


                    self.state = 6272
                    localctx.vstr = self.vex(0)
                    self.state = 6275
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.COMMA:
                        self.state = 6273
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6274
                        localctx.chars = self.vex(0)


                    pass


                self.state = 6279
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.SUBSTRING]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6281
                self.match(postgreSQLParser.SUBSTRING)
                self.state = 6282
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6283
                self.vex(0)
                self.state = 6288
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6284
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6285
                    self.vex(0)
                    self.state = 6290
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6293
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FROM:
                    self.state = 6291
                    self.match(postgreSQLParser.FROM)
                    self.state = 6292
                    self.vex(0)


                self.state = 6297
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOR:
                    self.state = 6295
                    self.match(postgreSQLParser.FOR)
                    self.state = 6296
                    self.vex(0)


                self.state = 6299
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.POSITION]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6301
                self.match(postgreSQLParser.POSITION)
                self.state = 6302
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6303
                self.vex_b(0)
                self.state = 6304
                self.match(postgreSQLParser.IN)
                self.state = 6305
                self.vex(0)
                self.state = 6306
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.OVERLAY]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6308
                self.match(postgreSQLParser.OVERLAY)
                self.state = 6309
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6310
                self.vex(0)
                self.state = 6311
                self.match(postgreSQLParser.PLACING)
                self.state = 6312
                self.vex(0)
                self.state = 6313
                self.match(postgreSQLParser.FROM)
                self.state = 6314
                self.vex(0)
                self.state = 6317
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOR:
                    self.state = 6315
                    self.match(postgreSQLParser.FOR)
                    self.state = 6316
                    self.vex(0)


                self.state = 6319
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.COLLATION]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6321
                self.match(postgreSQLParser.COLLATION)
                self.state = 6322
                self.match(postgreSQLParser.FOR)
                self.state = 6323
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6324
                self.vex(0)
                self.state = 6325
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Xml_functionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext
            self.attname = None # IdentifierContext

        def XMLELEMENT(self):
            return self.getToken(postgreSQLParser.XMLELEMENT, 0)

        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def NAME(self):
            return self.getToken(postgreSQLParser.NAME, 0)

        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def XMLATTRIBUTES(self):
            return self.getToken(postgreSQLParser.XMLATTRIBUTES, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.AS)
            else:
                return self.getToken(postgreSQLParser.AS, i)

        def XMLFOREST(self):
            return self.getToken(postgreSQLParser.XMLFOREST, 0)

        def XMLPI(self):
            return self.getToken(postgreSQLParser.XMLPI, 0)

        def XMLROOT(self):
            return self.getToken(postgreSQLParser.XMLROOT, 0)

        def VERSION(self):
            return self.getToken(postgreSQLParser.VERSION, 0)

        def NO(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.NO)
            else:
                return self.getToken(postgreSQLParser.NO, i)

        def VALUE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.VALUE)
            else:
                return self.getToken(postgreSQLParser.VALUE, i)

        def STANDALONE(self):
            return self.getToken(postgreSQLParser.STANDALONE, 0)

        def YES(self):
            return self.getToken(postgreSQLParser.YES, 0)

        def XMLEXISTS(self):
            return self.getToken(postgreSQLParser.XMLEXISTS, 0)

        def PASSING(self):
            return self.getToken(postgreSQLParser.PASSING, 0)

        def BY(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.BY)
            else:
                return self.getToken(postgreSQLParser.BY, i)

        def REF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.REF)
            else:
                return self.getToken(postgreSQLParser.REF, i)

        def XMLPARSE(self):
            return self.getToken(postgreSQLParser.XMLPARSE, 0)

        def DOCUMENT(self):
            return self.getToken(postgreSQLParser.DOCUMENT, 0)

        def CONTENT(self):
            return self.getToken(postgreSQLParser.CONTENT, 0)

        def XMLSERIALIZE(self):
            return self.getToken(postgreSQLParser.XMLSERIALIZE, 0)

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def XMLTABLE(self):
            return self.getToken(postgreSQLParser.XMLTABLE, 0)

        def COLUMNS(self):
            return self.getToken(postgreSQLParser.COLUMNS, 0)

        def xml_table_column(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Xml_table_columnContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Xml_table_columnContext,i)


        def XMLNAMESPACES(self):
            return self.getToken(postgreSQLParser.XMLNAMESPACES, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_xml_function

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXml_function" ):
                listener.enterXml_function(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXml_function" ):
                listener.exitXml_function(self)




    def xml_function(self):

        localctx = postgreSQLParser.Xml_functionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 624, self.RULE_xml_function)
        self._la = 0 # Token type
        try:
            self.state = 6490
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.XMLELEMENT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6329
                self.match(postgreSQLParser.XMLELEMENT)
                self.state = 6330
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6331
                self.match(postgreSQLParser.NAME)
                self.state = 6332
                localctx.name = self.identifier()
                self.state = 6354
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,808,self._ctx)
                if la_ == 1:
                    self.state = 6333
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6334
                    self.match(postgreSQLParser.XMLATTRIBUTES)
                    self.state = 6335
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 6336
                    self.vex(0)
                    self.state = 6339
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.AS:
                        self.state = 6337
                        self.match(postgreSQLParser.AS)
                        self.state = 6338
                        localctx.attname = self.identifier()


                    self.state = 6349
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 6341
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6342
                        self.vex(0)
                        self.state = 6345
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        if _la==postgreSQLParser.AS:
                            self.state = 6343
                            self.match(postgreSQLParser.AS)
                            self.state = 6344
                            localctx.attname = self.identifier()


                        self.state = 6351
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 6352
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 6360
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6356
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6357
                    self.vex(0)
                    self.state = 6362
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6363
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLFOREST]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6365
                self.match(postgreSQLParser.XMLFOREST)
                self.state = 6366
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6367
                self.vex(0)
                self.state = 6370
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AS:
                    self.state = 6368
                    self.match(postgreSQLParser.AS)
                    self.state = 6369
                    localctx.name = self.identifier()


                self.state = 6380
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6372
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6373
                    self.vex(0)
                    self.state = 6376
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.AS:
                        self.state = 6374
                        self.match(postgreSQLParser.AS)
                        self.state = 6375
                        localctx.name = self.identifier()


                    self.state = 6382
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6383
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLPI]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6385
                self.match(postgreSQLParser.XMLPI)
                self.state = 6386
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6387
                self.match(postgreSQLParser.NAME)
                self.state = 6388
                localctx.name = self.identifier()
                self.state = 6391
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COMMA:
                    self.state = 6389
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6390
                    self.vex(0)


                self.state = 6393
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLROOT]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6395
                self.match(postgreSQLParser.XMLROOT)
                self.state = 6396
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6397
                self.vex(0)
                self.state = 6398
                self.match(postgreSQLParser.COMMA)
                self.state = 6399
                self.match(postgreSQLParser.VERSION)
                self.state = 6403
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,814,self._ctx)
                if la_ == 1:
                    self.state = 6400
                    self.vex(0)
                    pass

                elif la_ == 2:
                    self.state = 6401
                    self.match(postgreSQLParser.NO)
                    self.state = 6402
                    self.match(postgreSQLParser.VALUE)
                    pass


                self.state = 6413
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COMMA:
                    self.state = 6405
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6406
                    self.match(postgreSQLParser.STANDALONE)
                    self.state = 6411
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,815,self._ctx)
                    if la_ == 1:
                        self.state = 6407
                        self.match(postgreSQLParser.YES)
                        pass

                    elif la_ == 2:
                        self.state = 6408
                        self.match(postgreSQLParser.NO)
                        pass

                    elif la_ == 3:
                        self.state = 6409
                        self.match(postgreSQLParser.NO)
                        self.state = 6410
                        self.match(postgreSQLParser.VALUE)
                        pass




                self.state = 6415
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLEXISTS]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6417
                self.match(postgreSQLParser.XMLEXISTS)
                self.state = 6418
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6419
                self.vex(0)
                self.state = 6420
                self.match(postgreSQLParser.PASSING)
                self.state = 6423
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,817,self._ctx)
                if la_ == 1:
                    self.state = 6421
                    self.match(postgreSQLParser.BY)
                    self.state = 6422
                    self.match(postgreSQLParser.REF)


                self.state = 6425
                self.vex(0)
                self.state = 6428
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.BY:
                    self.state = 6426
                    self.match(postgreSQLParser.BY)
                    self.state = 6427
                    self.match(postgreSQLParser.REF)


                self.state = 6430
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLPARSE]:
                self.enterOuterAlt(localctx, 6)
                self.state = 6432
                self.match(postgreSQLParser.XMLPARSE)
                self.state = 6433
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6434
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONTENT or _la==postgreSQLParser.DOCUMENT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6435
                self.vex(0)
                self.state = 6436
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLSERIALIZE]:
                self.enterOuterAlt(localctx, 7)
                self.state = 6438
                self.match(postgreSQLParser.XMLSERIALIZE)
                self.state = 6439
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6440
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONTENT or _la==postgreSQLParser.DOCUMENT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6441
                self.vex(0)
                self.state = 6442
                self.match(postgreSQLParser.AS)
                self.state = 6443
                self.data_type()
                self.state = 6444
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.XMLTABLE]:
                self.enterOuterAlt(localctx, 8)
                self.state = 6446
                self.match(postgreSQLParser.XMLTABLE)
                self.state = 6447
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6466
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,820,self._ctx)
                if la_ == 1:
                    self.state = 6448
                    self.match(postgreSQLParser.XMLNAMESPACES)
                    self.state = 6449
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 6450
                    self.vex(0)
                    self.state = 6451
                    self.match(postgreSQLParser.AS)
                    self.state = 6452
                    localctx.name = self.identifier()
                    self.state = 6460
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 6453
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6454
                        self.vex(0)
                        self.state = 6455
                        self.match(postgreSQLParser.AS)
                        self.state = 6456
                        localctx.name = self.identifier()
                        self.state = 6462
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 6463
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    self.state = 6464
                    self.match(postgreSQLParser.COMMA)


                self.state = 6468
                self.vex(0)
                self.state = 6469
                self.match(postgreSQLParser.PASSING)
                self.state = 6472
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,821,self._ctx)
                if la_ == 1:
                    self.state = 6470
                    self.match(postgreSQLParser.BY)
                    self.state = 6471
                    self.match(postgreSQLParser.REF)


                self.state = 6474
                self.vex(0)
                self.state = 6477
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.BY:
                    self.state = 6475
                    self.match(postgreSQLParser.BY)
                    self.state = 6476
                    self.match(postgreSQLParser.REF)


                self.state = 6479
                self.match(postgreSQLParser.COLUMNS)
                self.state = 6480
                self.xml_table_column()
                self.state = 6485
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6481
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6482
                    self.xml_table_column()
                    self.state = 6487
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6488
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Xml_table_columnContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.name = None # IdentifierContext

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def ORDINALITY(self):
            return self.getToken(postgreSQLParser.ORDINALITY, 0)

        def PATH(self):
            return self.getToken(postgreSQLParser.PATH, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_xml_table_column

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterXml_table_column" ):
                listener.enterXml_table_column(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitXml_table_column" ):
                listener.exitXml_table_column(self)




    def xml_table_column(self):

        localctx = postgreSQLParser.Xml_table_columnContext(self, self._ctx, self.state)
        self.enterRule(localctx, 626, self.RULE_xml_table_column)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6492
            localctx.name = self.identifier()
            self.state = 6510
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 6493
                self.data_type()
                self.state = 6496
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.PATH:
                    self.state = 6494
                    self.match(postgreSQLParser.PATH)
                    self.state = 6495
                    self.vex(0)


                self.state = 6500
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.DEFAULT:
                    self.state = 6498
                    self.match(postgreSQLParser.DEFAULT)
                    self.state = 6499
                    self.vex(0)


                self.state = 6506
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT or _la==postgreSQLParser.NULL:
                    self.state = 6503
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.NOT:
                        self.state = 6502
                        self.match(postgreSQLParser.NOT)


                    self.state = 6505
                    self.match(postgreSQLParser.NULL)


                pass
            elif token in [postgreSQLParser.FOR]:
                self.state = 6508
                self.match(postgreSQLParser.FOR)
                self.state = 6509
                self.match(postgreSQLParser.ORDINALITY)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comparison_modContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def ANY(self):
            return self.getToken(postgreSQLParser.ANY, 0)

        def SOME(self):
            return self.getToken(postgreSQLParser.SOME, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def select_stmt_no_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmt_no_parensContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_comparison_mod

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComparison_mod" ):
                listener.enterComparison_mod(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComparison_mod" ):
                listener.exitComparison_mod(self)




    def comparison_mod(self):

        localctx = postgreSQLParser.Comparison_modContext(self, self._ctx, self.state)
        self.enterRule(localctx, 628, self.RULE_comparison_mod)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6512
            _la = self._input.LA(1)
            if not(((((_la - 374)) & ~0x3f) == 0 and ((1 << (_la - 374)) & ((1 << (postgreSQLParser.ALL - 374)) | (1 << (postgreSQLParser.ANY - 374)) | (1 << (postgreSQLParser.SOME - 374)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6513
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6516
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,830,self._ctx)
            if la_ == 1:
                self.state = 6514
                self.vex(0)
                pass

            elif la_ == 2:
                self.state = 6515
                self.select_stmt_no_parens()
                pass


            self.state = 6518
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Filter_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def FILTER(self):
            return self.getToken(postgreSQLParser.FILTER, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_filter_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilter_clause" ):
                listener.enterFilter_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilter_clause" ):
                listener.exitFilter_clause(self)




    def filter_clause(self):

        localctx = postgreSQLParser.Filter_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 630, self.RULE_filter_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6520
            self.match(postgreSQLParser.FILTER)
            self.state = 6521
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6522
            self.match(postgreSQLParser.WHERE)
            self.state = 6523
            self.vex(0)
            self.state = 6524
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Window_definitionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def partition_by_columns(self):
            return self.getTypedRuleContext(postgreSQLParser.Partition_by_columnsContext,0)


        def orderby_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Orderby_clauseContext,0)


        def frame_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Frame_clauseContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_window_definition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWindow_definition" ):
                listener.enterWindow_definition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWindow_definition" ):
                listener.exitWindow_definition(self)




    def window_definition(self):

        localctx = postgreSQLParser.Window_definitionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 632, self.RULE_window_definition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6526
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6528
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,831,self._ctx)
            if la_ == 1:
                self.state = 6527
                self.identifier()


            self.state = 6531
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.PARTITION:
                self.state = 6530
                self.partition_by_columns()


            self.state = 6534
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ORDER:
                self.state = 6533
                self.orderby_clause()


            self.state = 6537
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.GROUPS or _la==postgreSQLParser.RANGE or _la==postgreSQLParser.ROWS:
                self.state = 6536
                self.frame_clause()


            self.state = 6539
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RANGE(self):
            return self.getToken(postgreSQLParser.RANGE, 0)

        def ROWS(self):
            return self.getToken(postgreSQLParser.ROWS, 0)

        def GROUPS(self):
            return self.getToken(postgreSQLParser.GROUPS, 0)

        def frame_bound(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Frame_boundContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Frame_boundContext,i)


        def BETWEEN(self):
            return self.getToken(postgreSQLParser.BETWEEN, 0)

        def AND(self):
            return self.getToken(postgreSQLParser.AND, 0)

        def EXCLUDE(self):
            return self.getToken(postgreSQLParser.EXCLUDE, 0)

        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def TIES(self):
            return self.getToken(postgreSQLParser.TIES, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def OTHERS(self):
            return self.getToken(postgreSQLParser.OTHERS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_frame_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_clause" ):
                listener.enterFrame_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_clause" ):
                listener.exitFrame_clause(self)




    def frame_clause(self):

        localctx = postgreSQLParser.Frame_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 634, self.RULE_frame_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6541
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.GROUPS or _la==postgreSQLParser.RANGE or _la==postgreSQLParser.ROWS):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 6548
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,835,self._ctx)
            if la_ == 1:
                self.state = 6542
                self.frame_bound()
                pass

            elif la_ == 2:
                self.state = 6543
                self.match(postgreSQLParser.BETWEEN)
                self.state = 6544
                self.frame_bound()
                self.state = 6545
                self.match(postgreSQLParser.AND)
                self.state = 6546
                self.frame_bound()
                pass


            self.state = 6559
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.EXCLUDE:
                self.state = 6550
                self.match(postgreSQLParser.EXCLUDE)
                self.state = 6557
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.CURRENT]:
                    self.state = 6551
                    self.match(postgreSQLParser.CURRENT)
                    self.state = 6552
                    self.match(postgreSQLParser.ROW)
                    pass
                elif token in [postgreSQLParser.GROUP]:
                    self.state = 6553
                    self.match(postgreSQLParser.GROUP)
                    pass
                elif token in [postgreSQLParser.TIES]:
                    self.state = 6554
                    self.match(postgreSQLParser.TIES)
                    pass
                elif token in [postgreSQLParser.NO]:
                    self.state = 6555
                    self.match(postgreSQLParser.NO)
                    self.state = 6556
                    self.match(postgreSQLParser.OTHERS)
                    pass
                else:
                    raise NoViableAltException(self)



        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Frame_boundContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def PRECEDING(self):
            return self.getToken(postgreSQLParser.PRECEDING, 0)

        def FOLLOWING(self):
            return self.getToken(postgreSQLParser.FOLLOWING, 0)

        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_frame_bound

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrame_bound" ):
                listener.enterFrame_bound(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrame_bound" ):
                listener.exitFrame_bound(self)




    def frame_bound(self):

        localctx = postgreSQLParser.Frame_boundContext(self, self._ctx, self.state)
        self.enterRule(localctx, 636, self.RULE_frame_bound)
        self._la = 0 # Token type
        try:
            self.state = 6566
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,838,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6561
                self.vex(0)
                self.state = 6562
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.FOLLOWING or _la==postgreSQLParser.PRECEDING):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6564
                self.match(postgreSQLParser.CURRENT)
                self.state = 6565
                self.match(postgreSQLParser.ROW)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_expressionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ARRAY(self):
            return self.getToken(postgreSQLParser.ARRAY, 0)

        def array_elements(self):
            return self.getTypedRuleContext(postgreSQLParser.Array_elementsContext,0)


        def table_subquery(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_subqueryContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_array_expression

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_expression" ):
                listener.enterArray_expression(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_expression" ):
                listener.exitArray_expression(self)




    def array_expression(self):

        localctx = postgreSQLParser.Array_expressionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 638, self.RULE_array_expression)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6568
            self.match(postgreSQLParser.ARRAY)
            self.state = 6571
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LEFT_BRACKET]:
                self.state = 6569
                self.array_elements()
                pass
            elif token in [postgreSQLParser.LEFT_PAREN]:
                self.state = 6570
                self.table_subquery()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Array_elementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_BRACKET(self):
            return self.getToken(postgreSQLParser.LEFT_BRACKET, 0)

        def RIGHT_BRACKET(self):
            return self.getToken(postgreSQLParser.RIGHT_BRACKET, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def array_elements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Array_elementsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Array_elementsContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_array_elements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArray_elements" ):
                listener.enterArray_elements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArray_elements" ):
                listener.exitArray_elements(self)




    def array_elements(self):

        localctx = postgreSQLParser.Array_elementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 640, self.RULE_array_elements)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6573
            self.match(postgreSQLParser.LEFT_BRACKET)
            self.state = 6588
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LEFT_BRACKET - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                self.state = 6576
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 6574
                    self.vex(0)
                    pass
                elif token in [postgreSQLParser.LEFT_BRACKET]:
                    self.state = 6575
                    self.array_elements()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 6585
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6578
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6581
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                        self.state = 6579
                        self.vex(0)
                        pass
                    elif token in [postgreSQLParser.LEFT_BRACKET]:
                        self.state = 6580
                        self.array_elements()
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 6587
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 6590
            self.match(postgreSQLParser.RIGHT_BRACKET)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_coercionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def INTERVAL(self):
            return self.getToken(postgreSQLParser.INTERVAL, 0)

        def interval_field(self):
            return self.getTypedRuleContext(postgreSQLParser.Interval_fieldContext,0)


        def type_length(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_lengthContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_type_coercion

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_coercion" ):
                listener.enterType_coercion(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_coercion" ):
                listener.exitType_coercion(self)




    def type_coercion(self):

        localctx = postgreSQLParser.Type_coercionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 642, self.RULE_type_coercion)
        try:
            self.state = 6601
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,845,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6592
                self.data_type()
                self.state = 6593
                self.character_string()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6595
                self.match(postgreSQLParser.INTERVAL)
                self.state = 6596
                self.character_string()
                self.state = 6597
                self.interval_field()
                self.state = 6599
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,844,self._ctx)
                if la_ == 1:
                    self.state = 6598
                    self.type_length()


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Schema_qualified_nameContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def DOT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DOT)
            else:
                return self.getToken(postgreSQLParser.DOT, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_schema_qualified_name

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSchema_qualified_name" ):
                listener.enterSchema_qualified_name(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSchema_qualified_name" ):
                listener.exitSchema_qualified_name(self)




    def schema_qualified_name(self):

        localctx = postgreSQLParser.Schema_qualified_nameContext(self, self._ctx, self.state)
        self.enterRule(localctx, 644, self.RULE_schema_qualified_name)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6603
            self.identifier()
            self.state = 6610
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,847,self._ctx)
            if la_ == 1:
                self.state = 6604
                self.match(postgreSQLParser.DOT)
                self.state = 6605
                self.identifier()
                self.state = 6608
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,846,self._ctx)
                if la_ == 1:
                    self.state = 6606
                    self.match(postgreSQLParser.DOT)
                    self.state = 6607
                    self.identifier()




        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Set_qualifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DISTINCT(self):
            return self.getToken(postgreSQLParser.DISTINCT, 0)

        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_set_qualifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSet_qualifier" ):
                listener.enterSet_qualifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSet_qualifier" ):
                listener.exitSet_qualifier(self)




    def set_qualifier(self):

        localctx = postgreSQLParser.Set_qualifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 646, self.RULE_set_qualifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6612
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.ALL or _la==postgreSQLParser.DISTINCT):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Table_subqueryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_table_subquery

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTable_subquery" ):
                listener.enterTable_subquery(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTable_subquery" ):
                listener.exitTable_subquery(self)




    def table_subquery(self):

        localctx = postgreSQLParser.Table_subqueryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 648, self.RULE_table_subquery)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6614
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6615
            self.select_stmt()
            self.state = 6616
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_ops(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_opsContext,0)


        def with_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.With_clauseContext,0)


        def after_ops(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.After_opsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.After_opsContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_stmt" ):
                listener.enterSelect_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_stmt" ):
                listener.exitSelect_stmt(self)




    def select_stmt(self):

        localctx = postgreSQLParser.Select_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 650, self.RULE_select_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6619
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 6618
                self.with_clause()


            self.state = 6621
            self.select_ops(0)
            self.state = 6625
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 405)) & ~0x3f) == 0 and ((1 << (_la - 405)) & ((1 << (postgreSQLParser.FETCH - 405)) | (1 << (postgreSQLParser.FOR - 405)) | (1 << (postgreSQLParser.LIMIT - 405)) | (1 << (postgreSQLParser.OFFSET - 405)) | (1 << (postgreSQLParser.ORDER - 405)))) != 0):
                self.state = 6622
                self.after_ops()
                self.state = 6627
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class After_opsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def orderby_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Orderby_clauseContext,0)


        def LIMIT(self):
            return self.getToken(postgreSQLParser.LIMIT, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def ALL(self):
            return self.getToken(postgreSQLParser.ALL, 0)

        def OFFSET(self):
            return self.getToken(postgreSQLParser.OFFSET, 0)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def ROWS(self):
            return self.getToken(postgreSQLParser.ROWS, 0)

        def FETCH(self):
            return self.getToken(postgreSQLParser.FETCH, 0)

        def FIRST(self):
            return self.getToken(postgreSQLParser.FIRST, 0)

        def NEXT(self):
            return self.getToken(postgreSQLParser.NEXT, 0)

        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def TIES(self):
            return self.getToken(postgreSQLParser.TIES, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def KEY(self):
            return self.getToken(postgreSQLParser.KEY, 0)

        def SHARE(self):
            return self.getToken(postgreSQLParser.SHARE, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def schema_qualified_name(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Schema_qualified_nameContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,i)


        def NOWAIT(self):
            return self.getToken(postgreSQLParser.NOWAIT, 0)

        def SKIP_(self):
            return self.getToken(postgreSQLParser.SKIP_, 0)

        def LOCKED(self):
            return self.getToken(postgreSQLParser.LOCKED, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_after_ops

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAfter_ops" ):
                listener.enterAfter_ops(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAfter_ops" ):
                listener.exitAfter_ops(self)




    def after_ops(self):

        localctx = postgreSQLParser.After_opsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 652, self.RULE_after_ops)
        self._la = 0 # Token type
        try:
            self.state = 6676
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ORDER]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6628
                self.orderby_clause()
                pass
            elif token in [postgreSQLParser.LIMIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6629
                self.match(postgreSQLParser.LIMIT)
                self.state = 6632
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,850,self._ctx)
                if la_ == 1:
                    self.state = 6630
                    self.vex(0)
                    pass

                elif la_ == 2:
                    self.state = 6631
                    self.match(postgreSQLParser.ALL)
                    pass


                pass
            elif token in [postgreSQLParser.OFFSET]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6634
                self.match(postgreSQLParser.OFFSET)
                self.state = 6635
                self.vex(0)
                self.state = 6637
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ROWS or _la==postgreSQLParser.ROW:
                    self.state = 6636
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.ROWS or _la==postgreSQLParser.ROW):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                pass
            elif token in [postgreSQLParser.FETCH]:
                self.enterOuterAlt(localctx, 4)
                self.state = 6639
                self.match(postgreSQLParser.FETCH)
                self.state = 6640
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.FIRST or _la==postgreSQLParser.NEXT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6642
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,852,self._ctx)
                if la_ == 1:
                    self.state = 6641
                    self.vex(0)


                self.state = 6644
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ROWS or _la==postgreSQLParser.ROW):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6648
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,853,self._ctx)
                if la_ == 1:
                    self.state = 6645
                    self.match(postgreSQLParser.ONLY)

                elif la_ == 2:
                    self.state = 6646
                    self.match(postgreSQLParser.WITH)
                    self.state = 6647
                    self.match(postgreSQLParser.TIES)


                pass
            elif token in [postgreSQLParser.FOR]:
                self.enterOuterAlt(localctx, 5)
                self.state = 6650
                self.match(postgreSQLParser.FOR)
                self.state = 6658
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.UPDATE]:
                    self.state = 6651
                    self.match(postgreSQLParser.UPDATE)
                    pass
                elif token in [postgreSQLParser.NO]:
                    self.state = 6652
                    self.match(postgreSQLParser.NO)
                    self.state = 6653
                    self.match(postgreSQLParser.KEY)
                    self.state = 6654
                    self.match(postgreSQLParser.UPDATE)
                    pass
                elif token in [postgreSQLParser.SHARE]:
                    self.state = 6655
                    self.match(postgreSQLParser.SHARE)
                    pass
                elif token in [postgreSQLParser.KEY]:
                    self.state = 6656
                    self.match(postgreSQLParser.KEY)
                    self.state = 6657
                    self.match(postgreSQLParser.SHARE)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 6669
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.OF:
                    self.state = 6660
                    self.match(postgreSQLParser.OF)
                    self.state = 6661
                    self.schema_qualified_name()
                    self.state = 6666
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 6662
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6663
                        self.schema_qualified_name()
                        self.state = 6668
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 6674
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.NOWAIT]:
                    self.state = 6671
                    self.match(postgreSQLParser.NOWAIT)
                    pass
                elif token in [postgreSQLParser.SKIP_]:
                    self.state = 6672
                    self.match(postgreSQLParser.SKIP_)
                    self.state = 6673
                    self.match(postgreSQLParser.LOCKED)
                    pass
                elif token in [postgreSQLParser.EOF, postgreSQLParser.FETCH, postgreSQLParser.FOR, postgreSQLParser.LIMIT, postgreSQLParser.OFFSET, postgreSQLParser.ON, postgreSQLParser.ORDER, postgreSQLParser.RETURNING, postgreSQLParser.WITH, postgreSQLParser.LOOP, postgreSQLParser.SEMI_COLON, postgreSQLParser.RIGHT_PAREN]:
                    pass
                else:
                    pass
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_stmt_no_parensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_ops_no_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_ops_no_parensContext,0)


        def with_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.With_clauseContext,0)


        def after_ops(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.After_opsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.After_opsContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_stmt_no_parens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_stmt_no_parens" ):
                listener.enterSelect_stmt_no_parens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_stmt_no_parens" ):
                listener.exitSelect_stmt_no_parens(self)




    def select_stmt_no_parens(self):

        localctx = postgreSQLParser.Select_stmt_no_parensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 654, self.RULE_select_stmt_no_parens)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6679
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 6678
                self.with_clause()


            self.state = 6681
            self.select_ops_no_parens()
            self.state = 6685
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 405)) & ~0x3f) == 0 and ((1 << (_la - 405)) & ((1 << (postgreSQLParser.FETCH - 405)) | (1 << (postgreSQLParser.FOR - 405)) | (1 << (postgreSQLParser.LIMIT - 405)) | (1 << (postgreSQLParser.OFFSET - 405)) | (1 << (postgreSQLParser.ORDER - 405)))) != 0):
                self.state = 6682
                self.after_ops()
                self.state = 6687
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class With_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def with_query(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.With_queryContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.With_queryContext,i)


        def RECURSIVE(self):
            return self.getToken(postgreSQLParser.RECURSIVE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_with_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_clause" ):
                listener.enterWith_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_clause" ):
                listener.exitWith_clause(self)




    def with_clause(self):

        localctx = postgreSQLParser.With_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 656, self.RULE_with_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6688
            self.match(postgreSQLParser.WITH)
            self.state = 6690
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,861,self._ctx)
            if la_ == 1:
                self.state = 6689
                self.match(postgreSQLParser.RECURSIVE)


            self.state = 6692
            self.with_query()
            self.state = 6697
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 6693
                self.match(postgreSQLParser.COMMA)
                self.state = 6694
                self.with_query()
                self.state = 6699
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class With_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.query_name = None # IdentifierContext
            self._identifier = None # IdentifierContext
            self.column_name = list() # of IdentifierContexts

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def data_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_statementContext,0)


        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def MATERIALIZED(self):
            return self.getToken(postgreSQLParser.MATERIALIZED, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_with_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWith_query" ):
                listener.enterWith_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWith_query" ):
                listener.exitWith_query(self)




    def with_query(self):

        localctx = postgreSQLParser.With_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 658, self.RULE_with_query)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6700
            localctx.query_name = self.identifier()
            self.state = 6712
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LEFT_PAREN:
                self.state = 6701
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6702
                localctx._identifier = self.identifier()
                localctx.column_name.append(localctx._identifier)
                self.state = 6707
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6703
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6704
                    localctx._identifier = self.identifier()
                    localctx.column_name.append(localctx._identifier)
                    self.state = 6709
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6710
                self.match(postgreSQLParser.RIGHT_PAREN)


            self.state = 6714
            self.match(postgreSQLParser.AS)
            self.state = 6719
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.MATERIALIZED or _la==postgreSQLParser.NOT:
                self.state = 6716
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 6715
                    self.match(postgreSQLParser.NOT)


                self.state = 6718
                self.match(postgreSQLParser.MATERIALIZED)


            self.state = 6721
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 6722
            self.data_statement()
            self.state = 6723
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_opsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def select_primary(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_primaryContext,0)


        def select_ops(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Select_opsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Select_opsContext,i)


        def INTERSECT(self):
            return self.getToken(postgreSQLParser.INTERSECT, 0)

        def UNION(self):
            return self.getToken(postgreSQLParser.UNION, 0)

        def EXCEPT(self):
            return self.getToken(postgreSQLParser.EXCEPT, 0)

        def set_qualifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_qualifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_ops

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_ops" ):
                listener.enterSelect_ops(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_ops" ):
                listener.exitSelect_ops(self)



    def select_ops(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = postgreSQLParser.Select_opsContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 660
        self.enterRecursionRule(localctx, 660, self.RULE_select_ops, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6731
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LEFT_PAREN]:
                self.state = 6726
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6727
                self.select_stmt()
                self.state = 6728
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass
            elif token in [postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE]:
                self.state = 6730
                self.select_primary()
                pass
            else:
                raise NoViableAltException(self)

            self._ctx.stop = self._input.LT(-1)
            self.state = 6741
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,869,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    localctx = postgreSQLParser.Select_opsContext(self, _parentctx, _parentState)
                    self.pushNewRecursionContext(localctx, _startState, self.RULE_select_ops)
                    self.state = 6733
                    if not self.precpred(self._ctx, 2):
                        from antlr4.error.Errors import FailedPredicateException
                        raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                    self.state = 6734
                    _la = self._input.LA(1)
                    if not(((((_la - 403)) & ~0x3f) == 0 and ((1 << (_la - 403)) & ((1 << (postgreSQLParser.EXCEPT - 403)) | (1 << (postgreSQLParser.INTERSECT - 403)) | (1 << (postgreSQLParser.UNION - 403)))) != 0)):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 6736
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.ALL or _la==postgreSQLParser.DISTINCT:
                        self.state = 6735
                        self.set_qualifier()


                    self.state = 6738
                    self.select_ops(3) 
                self.state = 6743
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,869,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class Select_ops_no_parensContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_ops(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_opsContext,0)


        def INTERSECT(self):
            return self.getToken(postgreSQLParser.INTERSECT, 0)

        def UNION(self):
            return self.getToken(postgreSQLParser.UNION, 0)

        def EXCEPT(self):
            return self.getToken(postgreSQLParser.EXCEPT, 0)

        def select_primary(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_primaryContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def set_qualifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_qualifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_ops_no_parens

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_ops_no_parens" ):
                listener.enterSelect_ops_no_parens(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_ops_no_parens" ):
                listener.exitSelect_ops_no_parens(self)




    def select_ops_no_parens(self):

        localctx = postgreSQLParser.Select_ops_no_parensContext(self, self._ctx, self.state)
        self.enterRule(localctx, 662, self.RULE_select_ops_no_parens)
        self._la = 0 # Token type
        try:
            self.state = 6757
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,872,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6744
                self.select_ops(0)
                self.state = 6745
                _la = self._input.LA(1)
                if not(((((_la - 403)) & ~0x3f) == 0 and ((1 << (_la - 403)) & ((1 << (postgreSQLParser.EXCEPT - 403)) | (1 << (postgreSQLParser.INTERSECT - 403)) | (1 << (postgreSQLParser.UNION - 403)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 6747
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ALL or _la==postgreSQLParser.DISTINCT:
                    self.state = 6746
                    self.set_qualifier()


                self.state = 6754
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE]:
                    self.state = 6749
                    self.select_primary()
                    pass
                elif token in [postgreSQLParser.LEFT_PAREN]:
                    self.state = 6750
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 6751
                    self.select_stmt()
                    self.state = 6752
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6756
                self.select_primary()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_primaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def SELECT(self):
            return self.getToken(postgreSQLParser.SELECT, 0)

        def set_qualifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Set_qualifierContext,0)


        def select_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_listContext,0)


        def into_table(self):
            return self.getTypedRuleContext(postgreSQLParser.Into_tableContext,0)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def from_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.From_itemContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.From_itemContext,i)


        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def groupby_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Groupby_clauseContext,0)


        def HAVING(self):
            return self.getToken(postgreSQLParser.HAVING, 0)

        def WINDOW(self):
            return self.getToken(postgreSQLParser.WINDOW, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.AS)
            else:
                return self.getToken(postgreSQLParser.AS, i)

        def window_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Window_definitionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Window_definitionContext,i)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def values_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Values_stmtContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_primary" ):
                listener.enterSelect_primary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_primary" ):
                listener.exitSelect_primary(self)




    def select_primary(self):

        localctx = postgreSQLParser.Select_primaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 664, self.RULE_select_primary)
        self._la = 0 # Token type
        try:
            self.state = 6830
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.SELECT]:
                self.enterOuterAlt(localctx, 1)
                self.state = 6759
                self.match(postgreSQLParser.SELECT)
                self.state = 6775
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,875,self._ctx)
                if la_ == 1:
                    self.state = 6760
                    self.set_qualifier()
                    self.state = 6773
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,874,self._ctx)
                    if la_ == 1:
                        self.state = 6761
                        self.match(postgreSQLParser.ON)
                        self.state = 6762
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 6763
                        self.vex(0)
                        self.state = 6768
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==postgreSQLParser.COMMA:
                            self.state = 6764
                            self.match(postgreSQLParser.COMMA)
                            self.state = 6765
                            self.vex(0)
                            self.state = 6770
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 6771
                        self.match(postgreSQLParser.RIGHT_PAREN)




                self.state = 6778
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,876,self._ctx)
                if la_ == 1:
                    self.state = 6777
                    self.select_list()


                self.state = 6781
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,877,self._ctx)
                if la_ == 1:
                    self.state = 6780
                    self.into_table()


                self.state = 6792
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,879,self._ctx)
                if la_ == 1:
                    self.state = 6783
                    self.match(postgreSQLParser.FROM)
                    self.state = 6784
                    self.from_item(0)
                    self.state = 6789
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,878,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 6785
                            self.match(postgreSQLParser.COMMA)
                            self.state = 6786
                            self.from_item(0) 
                        self.state = 6791
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,878,self._ctx)



                self.state = 6796
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,880,self._ctx)
                if la_ == 1:
                    self.state = 6794
                    self.match(postgreSQLParser.WHERE)
                    self.state = 6795
                    self.vex(0)


                self.state = 6799
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,881,self._ctx)
                if la_ == 1:
                    self.state = 6798
                    self.groupby_clause()


                self.state = 6803
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,882,self._ctx)
                if la_ == 1:
                    self.state = 6801
                    self.match(postgreSQLParser.HAVING)
                    self.state = 6802
                    self.vex(0)


                self.state = 6819
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,884,self._ctx)
                if la_ == 1:
                    self.state = 6805
                    self.match(postgreSQLParser.WINDOW)
                    self.state = 6806
                    self.identifier()
                    self.state = 6807
                    self.match(postgreSQLParser.AS)
                    self.state = 6808
                    self.window_definition()
                    self.state = 6816
                    self._errHandler.sync(self)
                    _alt = self._interp.adaptivePredict(self._input,883,self._ctx)
                    while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                        if _alt==1:
                            self.state = 6809
                            self.match(postgreSQLParser.COMMA)
                            self.state = 6810
                            self.identifier()
                            self.state = 6811
                            self.match(postgreSQLParser.AS)
                            self.state = 6812
                            self.window_definition() 
                        self.state = 6818
                        self._errHandler.sync(self)
                        _alt = self._interp.adaptivePredict(self._input,883,self._ctx)



                pass
            elif token in [postgreSQLParser.TABLE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 6821
                self.match(postgreSQLParser.TABLE)
                self.state = 6823
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ONLY:
                    self.state = 6822
                    self.match(postgreSQLParser.ONLY)


                self.state = 6825
                self.schema_qualified_name()
                self.state = 6827
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,886,self._ctx)
                if la_ == 1:
                    self.state = 6826
                    self.match(postgreSQLParser.MULTIPLY)


                pass
            elif token in [postgreSQLParser.VALUES]:
                self.enterOuterAlt(localctx, 3)
                self.state = 6829
                self.values_stmt()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_sublist(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Select_sublistContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Select_sublistContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_list" ):
                listener.enterSelect_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_list" ):
                listener.exitSelect_list(self)




    def select_list(self):

        localctx = postgreSQLParser.Select_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 666, self.RULE_select_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6832
            self.select_sublist()
            self.state = 6837
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,888,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 6833
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6834
                    self.select_sublist() 
                self.state = 6839
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,888,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Select_sublistContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def col_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Col_labelContext,0)


        def id_token(self):
            return self.getTypedRuleContext(postgreSQLParser.Id_tokenContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_select_sublist

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSelect_sublist" ):
                listener.enterSelect_sublist(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSelect_sublist" ):
                listener.exitSelect_sublist(self)




    def select_sublist(self):

        localctx = postgreSQLParser.Select_sublistContext(self, self._ctx, self.state)
        self.enterRule(localctx, 668, self.RULE_select_sublist)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6840
            self.vex(0)
            self.state = 6844
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,889,self._ctx)
            if la_ == 1:
                self.state = 6841
                self.match(postgreSQLParser.AS)
                self.state = 6842
                self.col_label()

            elif la_ == 2:
                self.state = 6843
                self.id_token()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Into_tableContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def INTO(self):
            return self.getToken(postgreSQLParser.INTO, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def TEMPORARY(self):
            return self.getToken(postgreSQLParser.TEMPORARY, 0)

        def TEMP(self):
            return self.getToken(postgreSQLParser.TEMP, 0)

        def UNLOGGED(self):
            return self.getToken(postgreSQLParser.UNLOGGED, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_into_table

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInto_table" ):
                listener.enterInto_table(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInto_table" ):
                listener.exitInto_table(self)




    def into_table(self):

        localctx = postgreSQLParser.Into_tableContext(self, self._ctx, self.state)
        self.enterRule(localctx, 670, self.RULE_into_table)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6846
            self.match(postgreSQLParser.INTO)
            self.state = 6848
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,890,self._ctx)
            if la_ == 1:
                self.state = 6847
                _la = self._input.LA(1)
                if not(((((_la - 259)) & ~0x3f) == 0 and ((1 << (_la - 259)) & ((1 << (postgreSQLParser.TEMP - 259)) | (1 << (postgreSQLParser.TEMPORARY - 259)) | (1 << (postgreSQLParser.UNLOGGED - 259)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()


            self.state = 6851
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLE:
                self.state = 6850
                self.match(postgreSQLParser.TABLE)


            self.state = 6853
            self.schema_qualified_name()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_itemContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def from_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.From_itemContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.From_itemContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def alias_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Alias_clauseContext,0)


        def from_primary(self):
            return self.getTypedRuleContext(postgreSQLParser.From_primaryContext,0)


        def CROSS(self):
            return self.getToken(postgreSQLParser.CROSS, 0)

        def JOIN(self):
            return self.getToken(postgreSQLParser.JOIN, 0)

        def NATURAL(self):
            return self.getToken(postgreSQLParser.NATURAL, 0)

        def INNER(self):
            return self.getToken(postgreSQLParser.INNER, 0)

        def LEFT(self):
            return self.getToken(postgreSQLParser.LEFT, 0)

        def RIGHT(self):
            return self.getToken(postgreSQLParser.RIGHT, 0)

        def FULL(self):
            return self.getToken(postgreSQLParser.FULL, 0)

        def OUTER(self):
            return self.getToken(postgreSQLParser.OUTER, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def names_in_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Names_in_parensContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_from_item

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_item" ):
                listener.enterFrom_item(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_item" ):
                listener.exitFrom_item(self)



    def from_item(self, _p:int=0):
        _parentctx = self._ctx
        _parentState = self.state
        localctx = postgreSQLParser.From_itemContext(self, self._ctx, _parentState)
        _prevctx = localctx
        _startState = 672
        self.enterRecursionRule(localctx, 672, self.RULE_from_item, _p)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 6863
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,893,self._ctx)
            if la_ == 1:
                self.state = 6856
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6857
                self.from_item(0)
                self.state = 6858
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 6860
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,892,self._ctx)
                if la_ == 1:
                    self.state = 6859
                    self.alias_clause()


                pass

            elif la_ == 2:
                self.state = 6862
                self.from_primary()
                pass


            self._ctx.stop = self._input.LT(-1)
            self.state = 6908
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,901,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    if self._parseListeners is not None:
                        self.triggerExitRuleEvent()
                    _prevctx = localctx
                    self.state = 6906
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,900,self._ctx)
                    if la_ == 1:
                        localctx = postgreSQLParser.From_itemContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_from_item)
                        self.state = 6865
                        if not self.precpred(self._ctx, 5):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 5)")
                        self.state = 6866
                        self.match(postgreSQLParser.CROSS)
                        self.state = 6867
                        self.match(postgreSQLParser.JOIN)
                        self.state = 6868
                        self.from_item(6)
                        pass

                    elif la_ == 2:
                        localctx = postgreSQLParser.From_itemContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_from_item)
                        self.state = 6869
                        if not self.precpred(self._ctx, 2):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 2)")
                        self.state = 6870
                        self.match(postgreSQLParser.NATURAL)
                        self.state = 6876
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.INNER]:
                            self.state = 6871
                            self.match(postgreSQLParser.INNER)
                            pass
                        elif token in [postgreSQLParser.FULL, postgreSQLParser.LEFT, postgreSQLParser.RIGHT]:
                            self.state = 6872
                            _la = self._input.LA(1)
                            if not(((((_la - 358)) & ~0x3f) == 0 and ((1 << (_la - 358)) & ((1 << (postgreSQLParser.FULL - 358)) | (1 << (postgreSQLParser.LEFT - 358)) | (1 << (postgreSQLParser.RIGHT - 358)))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 6874
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==postgreSQLParser.OUTER:
                                self.state = 6873
                                self.match(postgreSQLParser.OUTER)


                            pass
                        elif token in [postgreSQLParser.JOIN]:
                            pass
                        else:
                            pass
                        self.state = 6878
                        self.match(postgreSQLParser.JOIN)
                        self.state = 6879
                        self.from_item(3)
                        pass

                    elif la_ == 3:
                        localctx = postgreSQLParser.From_itemContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_from_item)
                        self.state = 6880
                        if not self.precpred(self._ctx, 4):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 4)")
                        self.state = 6886
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.INNER]:
                            self.state = 6881
                            self.match(postgreSQLParser.INNER)
                            pass
                        elif token in [postgreSQLParser.FULL, postgreSQLParser.LEFT, postgreSQLParser.RIGHT]:
                            self.state = 6882
                            _la = self._input.LA(1)
                            if not(((((_la - 358)) & ~0x3f) == 0 and ((1 << (_la - 358)) & ((1 << (postgreSQLParser.FULL - 358)) | (1 << (postgreSQLParser.LEFT - 358)) | (1 << (postgreSQLParser.RIGHT - 358)))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 6884
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==postgreSQLParser.OUTER:
                                self.state = 6883
                                self.match(postgreSQLParser.OUTER)


                            pass
                        elif token in [postgreSQLParser.JOIN]:
                            pass
                        else:
                            pass
                        self.state = 6888
                        self.match(postgreSQLParser.JOIN)
                        self.state = 6889
                        self.from_item(0)
                        self.state = 6890
                        self.match(postgreSQLParser.ON)
                        self.state = 6891
                        self.vex(0)
                        pass

                    elif la_ == 4:
                        localctx = postgreSQLParser.From_itemContext(self, _parentctx, _parentState)
                        self.pushNewRecursionContext(localctx, _startState, self.RULE_from_item)
                        self.state = 6893
                        if not self.precpred(self._ctx, 3):
                            from antlr4.error.Errors import FailedPredicateException
                            raise FailedPredicateException(self, "self.precpred(self._ctx, 3)")
                        self.state = 6899
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.INNER]:
                            self.state = 6894
                            self.match(postgreSQLParser.INNER)
                            pass
                        elif token in [postgreSQLParser.FULL, postgreSQLParser.LEFT, postgreSQLParser.RIGHT]:
                            self.state = 6895
                            _la = self._input.LA(1)
                            if not(((((_la - 358)) & ~0x3f) == 0 and ((1 << (_la - 358)) & ((1 << (postgreSQLParser.FULL - 358)) | (1 << (postgreSQLParser.LEFT - 358)) | (1 << (postgreSQLParser.RIGHT - 358)))) != 0)):
                                self._errHandler.recoverInline(self)
                            else:
                                self._errHandler.reportMatch(self)
                                self.consume()
                            self.state = 6897
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)
                            if _la==postgreSQLParser.OUTER:
                                self.state = 6896
                                self.match(postgreSQLParser.OUTER)


                            pass
                        elif token in [postgreSQLParser.JOIN]:
                            pass
                        else:
                            pass
                        self.state = 6901
                        self.match(postgreSQLParser.JOIN)
                        self.state = 6902
                        self.from_item(0)
                        self.state = 6903
                        self.match(postgreSQLParser.USING)
                        self.state = 6904
                        self.names_in_parens()
                        pass

             
                self.state = 6910
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,901,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.unrollRecursionContexts(_parentctx)
        return localctx


    class From_primaryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.method = None # IdentifierContext
            self.alias = None # IdentifierContext
            self._identifier = None # IdentifierContext
            self.column_alias = list() # of IdentifierContexts

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def alias_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Alias_clauseContext,0)


        def TABLESAMPLE(self):
            return self.getToken(postgreSQLParser.TABLESAMPLE, 0)

        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def REPEATABLE(self):
            return self.getToken(postgreSQLParser.REPEATABLE, 0)

        def table_subquery(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_subqueryContext,0)


        def LATERAL(self):
            return self.getToken(postgreSQLParser.LATERAL, 0)

        def function_call(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_callContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_callContext,i)


        def WITH(self):
            return self.getToken(postgreSQLParser.WITH, 0)

        def ORDINALITY(self):
            return self.getToken(postgreSQLParser.ORDINALITY, 0)

        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.AS)
            else:
                return self.getToken(postgreSQLParser.AS, i)

        def from_function_column_def(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.From_function_column_defContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.From_function_column_defContext,i)


        def ROWS(self):
            return self.getToken(postgreSQLParser.ROWS, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_from_primary

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_primary" ):
                listener.enterFrom_primary(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_primary" ):
                listener.exitFrom_primary(self)




    def from_primary(self):

        localctx = postgreSQLParser.From_primaryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 674, self.RULE_from_primary)
        self._la = 0 # Token type
        try:
            self.state = 7021
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,924,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 6912
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ONLY:
                    self.state = 6911
                    self.match(postgreSQLParser.ONLY)


                self.state = 6914
                self.schema_qualified_name()
                self.state = 6916
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,903,self._ctx)
                if la_ == 1:
                    self.state = 6915
                    self.match(postgreSQLParser.MULTIPLY)


                self.state = 6919
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,904,self._ctx)
                if la_ == 1:
                    self.state = 6918
                    self.alias_clause()


                self.state = 6937
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,907,self._ctx)
                if la_ == 1:
                    self.state = 6921
                    self.match(postgreSQLParser.TABLESAMPLE)
                    self.state = 6922
                    localctx.method = self.identifier()
                    self.state = 6923
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 6924
                    self.vex(0)
                    self.state = 6929
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 6925
                        self.match(postgreSQLParser.COMMA)
                        self.state = 6926
                        self.vex(0)
                        self.state = 6931
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 6932
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    self.state = 6935
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,906,self._ctx)
                    if la_ == 1:
                        self.state = 6933
                        self.match(postgreSQLParser.REPEATABLE)
                        self.state = 6934
                        self.vex(0)




                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 6940
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LATERAL:
                    self.state = 6939
                    self.match(postgreSQLParser.LATERAL)


                self.state = 6942
                self.table_subquery()
                self.state = 6943
                self.alias_clause()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 6946
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LATERAL:
                    self.state = 6945
                    self.match(postgreSQLParser.LATERAL)


                self.state = 6948
                self.function_call()
                self.state = 6951
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,910,self._ctx)
                if la_ == 1:
                    self.state = 6949
                    self.match(postgreSQLParser.WITH)
                    self.state = 6950
                    self.match(postgreSQLParser.ORDINALITY)


                self.state = 6973
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,914,self._ctx)
                if la_ == 1:
                    self.state = 6953
                    self.match(postgreSQLParser.AS)
                    self.state = 6954
                    self.from_function_column_def()

                elif la_ == 2:
                    self.state = 6956
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.AS:
                        self.state = 6955
                        self.match(postgreSQLParser.AS)


                    self.state = 6958
                    localctx.alias = self.identifier()
                    self.state = 6971
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,913,self._ctx)
                    if la_ == 1:
                        self.state = 6959
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 6960
                        localctx._identifier = self.identifier()
                        localctx.column_alias.append(localctx._identifier)
                        self.state = 6965
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==postgreSQLParser.COMMA:
                            self.state = 6961
                            self.match(postgreSQLParser.COMMA)
                            self.state = 6962
                            localctx._identifier = self.identifier()
                            localctx.column_alias.append(localctx._identifier)
                            self.state = 6967
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 6968
                        self.match(postgreSQLParser.RIGHT_PAREN)

                    elif la_ == 2:
                        self.state = 6970
                        self.from_function_column_def()




                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 6976
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LATERAL:
                    self.state = 6975
                    self.match(postgreSQLParser.LATERAL)


                self.state = 6978
                self.match(postgreSQLParser.ROWS)
                self.state = 6979
                self.match(postgreSQLParser.FROM)
                self.state = 6980
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 6981
                self.function_call()
                self.state = 6984
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AS:
                    self.state = 6982
                    self.match(postgreSQLParser.AS)
                    self.state = 6983
                    self.from_function_column_def()


                self.state = 6994
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 6986
                    self.match(postgreSQLParser.COMMA)
                    self.state = 6987
                    self.function_call()
                    self.state = 6990
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.AS:
                        self.state = 6988
                        self.match(postgreSQLParser.AS)
                        self.state = 6989
                        self.from_function_column_def()


                    self.state = 6996
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 6997
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 7000
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,919,self._ctx)
                if la_ == 1:
                    self.state = 6998
                    self.match(postgreSQLParser.WITH)
                    self.state = 6999
                    self.match(postgreSQLParser.ORDINALITY)


                self.state = 7019
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,923,self._ctx)
                if la_ == 1:
                    self.state = 7003
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.AS:
                        self.state = 7002
                        self.match(postgreSQLParser.AS)


                    self.state = 7005
                    self.identifier()
                    self.state = 7017
                    self._errHandler.sync(self)
                    la_ = self._interp.adaptivePredict(self._input,922,self._ctx)
                    if la_ == 1:
                        self.state = 7006
                        self.match(postgreSQLParser.LEFT_PAREN)
                        self.state = 7007
                        self.identifier()
                        self.state = 7012
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)
                        while _la==postgreSQLParser.COMMA:
                            self.state = 7008
                            self.match(postgreSQLParser.COMMA)
                            self.state = 7009
                            self.identifier()
                            self.state = 7014
                            self._errHandler.sync(self)
                            _la = self._input.LA(1)

                        self.state = 7015
                        self.match(postgreSQLParser.RIGHT_PAREN)




                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Alias_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.alias = None # IdentifierContext
            self._identifier = None # IdentifierContext
            self.column_alias = list() # of IdentifierContexts

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_alias_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAlias_clause" ):
                listener.enterAlias_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAlias_clause" ):
                listener.exitAlias_clause(self)




    def alias_clause(self):

        localctx = postgreSQLParser.Alias_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 676, self.RULE_alias_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7024
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.AS:
                self.state = 7023
                self.match(postgreSQLParser.AS)


            self.state = 7026
            localctx.alias = self.identifier()
            self.state = 7038
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,927,self._ctx)
            if la_ == 1:
                self.state = 7027
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 7028
                localctx._identifier = self.identifier()
                localctx.column_alias.append(localctx._identifier)
                self.state = 7033
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7029
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7030
                    localctx._identifier = self.identifier()
                    localctx.column_alias.append(localctx._identifier)
                    self.state = 7035
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 7036
                self.match(postgreSQLParser.RIGHT_PAREN)


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class From_function_column_defContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._identifier = None # IdentifierContext
            self.column_alias = list() # of IdentifierContexts

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_from_function_column_def

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFrom_function_column_def" ):
                listener.enterFrom_function_column_def(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFrom_function_column_def" ):
                listener.exitFrom_function_column_def(self)




    def from_function_column_def(self):

        localctx = postgreSQLParser.From_function_column_defContext(self, self._ctx, self.state)
        self.enterRule(localctx, 678, self.RULE_from_function_column_def)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7040
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 7041
            localctx._identifier = self.identifier()
            localctx.column_alias.append(localctx._identifier)
            self.state = 7042
            self.data_type()
            self.state = 7049
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7043
                self.match(postgreSQLParser.COMMA)
                self.state = 7044
                localctx._identifier = self.identifier()
                localctx.column_alias.append(localctx._identifier)
                self.state = 7045
                self.data_type()
                self.state = 7051
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7052
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Groupby_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def GROUP(self):
            return self.getToken(postgreSQLParser.GROUP, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def grouping_element_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Grouping_element_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_groupby_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGroupby_clause" ):
                listener.enterGroupby_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGroupby_clause" ):
                listener.exitGroupby_clause(self)




    def groupby_clause(self):

        localctx = postgreSQLParser.Groupby_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 680, self.RULE_groupby_clause)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7054
            self.match(postgreSQLParser.GROUP)
            self.state = 7055
            self.match(postgreSQLParser.BY)
            self.state = 7056
            self.grouping_element_list()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Grouping_element_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def grouping_element(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Grouping_elementContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Grouping_elementContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_grouping_element_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrouping_element_list" ):
                listener.enterGrouping_element_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrouping_element_list" ):
                listener.exitGrouping_element_list(self)




    def grouping_element_list(self):

        localctx = postgreSQLParser.Grouping_element_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 682, self.RULE_grouping_element_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7058
            self.grouping_element()
            self.state = 7063
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,929,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7059
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7060
                    self.grouping_element() 
                self.state = 7065
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,929,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Grouping_elementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def grouping_element_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Grouping_element_listContext,0)


        def ROLLUP(self):
            return self.getToken(postgreSQLParser.ROLLUP, 0)

        def CUBE(self):
            return self.getToken(postgreSQLParser.CUBE, 0)

        def GROUPING(self):
            return self.getToken(postgreSQLParser.GROUPING, 0)

        def SETS(self):
            return self.getToken(postgreSQLParser.SETS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_grouping_element

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterGrouping_element" ):
                listener.enterGrouping_element(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitGrouping_element" ):
                listener.exitGrouping_element(self)




    def grouping_element(self):

        localctx = postgreSQLParser.Grouping_elementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 684, self.RULE_grouping_element)
        try:
            self.state = 7079
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,931,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7066
                self.vex(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7067
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 7068
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7073
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ROLLUP]:
                    self.state = 7069
                    self.match(postgreSQLParser.ROLLUP)
                    pass
                elif token in [postgreSQLParser.CUBE]:
                    self.state = 7070
                    self.match(postgreSQLParser.CUBE)
                    pass
                elif token in [postgreSQLParser.GROUPING]:
                    self.state = 7071
                    self.match(postgreSQLParser.GROUPING)
                    self.state = 7072
                    self.match(postgreSQLParser.SETS)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 7075
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 7076
                self.grouping_element_list()
                self.state = 7077
                self.match(postgreSQLParser.RIGHT_PAREN)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Values_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def VALUES(self):
            return self.getToken(postgreSQLParser.VALUES, 0)

        def values_values(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Values_valuesContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Values_valuesContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_values_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValues_stmt" ):
                listener.enterValues_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValues_stmt" ):
                listener.exitValues_stmt(self)




    def values_stmt(self):

        localctx = postgreSQLParser.Values_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 686, self.RULE_values_stmt)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7081
            self.match(postgreSQLParser.VALUES)
            self.state = 7082
            self.values_values()
            self.state = 7087
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,932,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7083
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7084
                    self.values_values() 
                self.state = 7089
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,932,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Values_valuesContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def DEFAULT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DEFAULT)
            else:
                return self.getToken(postgreSQLParser.DEFAULT, i)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_values_values

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterValues_values" ):
                listener.enterValues_values(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitValues_values" ):
                listener.exitValues_values(self)




    def values_values(self):

        localctx = postgreSQLParser.Values_valuesContext(self, self._ctx, self.state)
        self.enterRule(localctx, 688, self.RULE_values_values)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7090
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 7093
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                self.state = 7091
                self.vex(0)
                pass
            elif token in [postgreSQLParser.DEFAULT]:
                self.state = 7092
                self.match(postgreSQLParser.DEFAULT)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 7102
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7095
                self.match(postgreSQLParser.COMMA)
                self.state = 7098
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 7096
                    self.vex(0)
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 7097
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 7104
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7105
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Orderby_clauseContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ORDER(self):
            return self.getToken(postgreSQLParser.ORDER, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def sort_specifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Sort_specifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Sort_specifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_orderby_clause

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrderby_clause" ):
                listener.enterOrderby_clause(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrderby_clause" ):
                listener.exitOrderby_clause(self)




    def orderby_clause(self):

        localctx = postgreSQLParser.Orderby_clauseContext(self, self._ctx, self.state)
        self.enterRule(localctx, 690, self.RULE_orderby_clause)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7107
            self.match(postgreSQLParser.ORDER)
            self.state = 7108
            self.match(postgreSQLParser.BY)
            self.state = 7109
            self.sort_specifier()
            self.state = 7114
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7110
                self.match(postgreSQLParser.COMMA)
                self.state = 7111
                self.sort_specifier()
                self.state = 7116
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Sort_specifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def order_specification(self):
            return self.getTypedRuleContext(postgreSQLParser.Order_specificationContext,0)


        def null_ordering(self):
            return self.getTypedRuleContext(postgreSQLParser.Null_orderingContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_sort_specifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterSort_specifier" ):
                listener.enterSort_specifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitSort_specifier" ):
                listener.exitSort_specifier(self)




    def sort_specifier(self):

        localctx = postgreSQLParser.Sort_specifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 692, self.RULE_sort_specifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7117
            self.vex(0)
            self.state = 7119
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ASC or _la==postgreSQLParser.DESC or _la==postgreSQLParser.USING:
                self.state = 7118
                self.order_specification()


            self.state = 7122
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.NULLS:
                self.state = 7121
                self.null_ordering()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Order_specificationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ASC(self):
            return self.getToken(postgreSQLParser.ASC, 0)

        def DESC(self):
            return self.getToken(postgreSQLParser.DESC, 0)

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def all_op_ref(self):
            return self.getTypedRuleContext(postgreSQLParser.All_op_refContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_order_specification

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOrder_specification" ):
                listener.enterOrder_specification(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOrder_specification" ):
                listener.exitOrder_specification(self)




    def order_specification(self):

        localctx = postgreSQLParser.Order_specificationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 694, self.RULE_order_specification)
        try:
            self.state = 7128
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ASC]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7124
                self.match(postgreSQLParser.ASC)
                pass
            elif token in [postgreSQLParser.DESC]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7125
                self.match(postgreSQLParser.DESC)
                pass
            elif token in [postgreSQLParser.USING]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7126
                self.match(postgreSQLParser.USING)
                self.state = 7127
                self.all_op_ref()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Null_orderingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def NULLS(self):
            return self.getToken(postgreSQLParser.NULLS, 0)

        def FIRST(self):
            return self.getToken(postgreSQLParser.FIRST, 0)

        def LAST(self):
            return self.getToken(postgreSQLParser.LAST, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_null_ordering

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNull_ordering" ):
                listener.enterNull_ordering(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNull_ordering" ):
                listener.exitNull_ordering(self)




    def null_ordering(self):

        localctx = postgreSQLParser.Null_orderingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 696, self.RULE_null_ordering)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7130
            self.match(postgreSQLParser.NULLS)
            self.state = 7131
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.FIRST or _la==postgreSQLParser.LAST):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_stmt_for_psqlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.insert_table_name = None # Schema_qualified_nameContext
            self.alias = None # IdentifierContext

        def INSERT(self):
            return self.getToken(postgreSQLParser.INSERT, 0)

        def INTO(self):
            return self.getToken(postgreSQLParser.INTO, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def VALUES(self):
            return self.getToken(postgreSQLParser.VALUES, 0)

        def with_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.With_clauseContext,0)


        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def OVERRIDING(self):
            return self.getToken(postgreSQLParser.OVERRIDING, 0)

        def VALUE(self):
            return self.getToken(postgreSQLParser.VALUE, 0)

        def insert_columns(self):
            return self.getTypedRuleContext(postgreSQLParser.Insert_columnsContext,0)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def CONFLICT(self):
            return self.getToken(postgreSQLParser.CONFLICT, 0)

        def conflict_action(self):
            return self.getTypedRuleContext(postgreSQLParser.Conflict_actionContext,0)


        def RETURNING(self):
            return self.getToken(postgreSQLParser.RETURNING, 0)

        def select_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_listContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def SYSTEM(self):
            return self.getToken(postgreSQLParser.SYSTEM, 0)

        def USER(self):
            return self.getToken(postgreSQLParser.USER, 0)

        def conflict_object(self):
            return self.getTypedRuleContext(postgreSQLParser.Conflict_objectContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_insert_stmt_for_psql

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_stmt_for_psql" ):
                listener.enterInsert_stmt_for_psql(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_stmt_for_psql" ):
                listener.exitInsert_stmt_for_psql(self)




    def insert_stmt_for_psql(self):

        localctx = postgreSQLParser.Insert_stmt_for_psqlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 698, self.RULE_insert_stmt_for_psql)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7134
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 7133
                self.with_clause()


            self.state = 7136
            self.match(postgreSQLParser.INSERT)
            self.state = 7137
            self.match(postgreSQLParser.INTO)
            self.state = 7138
            localctx.insert_table_name = self.schema_qualified_name()
            self.state = 7141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.AS:
                self.state = 7139
                self.match(postgreSQLParser.AS)
                self.state = 7140
                localctx.alias = self.identifier()


            self.state = 7146
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.OVERRIDING:
                self.state = 7143
                self.match(postgreSQLParser.OVERRIDING)
                self.state = 7144
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.SYSTEM or _la==postgreSQLParser.USER):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7145
                self.match(postgreSQLParser.VALUE)


            self.state = 7149
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,943,self._ctx)
            if la_ == 1:
                self.state = 7148
                self.insert_columns()


            self.state = 7154
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE, postgreSQLParser.WITH, postgreSQLParser.LEFT_PAREN]:
                self.state = 7151
                self.select_stmt()
                pass
            elif token in [postgreSQLParser.DEFAULT]:
                self.state = 7152
                self.match(postgreSQLParser.DEFAULT)
                self.state = 7153
                self.match(postgreSQLParser.VALUES)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 7162
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ON:
                self.state = 7156
                self.match(postgreSQLParser.ON)
                self.state = 7157
                self.match(postgreSQLParser.CONFLICT)
                self.state = 7159
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ON or _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 7158
                    self.conflict_object()


                self.state = 7161
                self.conflict_action()


            self.state = 7166
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.RETURNING:
                self.state = 7164
                self.match(postgreSQLParser.RETURNING)
                self.state = 7165
                self.select_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Insert_columnsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def indirection_identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Indirection_identifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Indirection_identifierContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_insert_columns

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInsert_columns" ):
                listener.enterInsert_columns(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInsert_columns" ):
                listener.exitInsert_columns(self)




    def insert_columns(self):

        localctx = postgreSQLParser.Insert_columnsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 700, self.RULE_insert_columns)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7168
            self.match(postgreSQLParser.LEFT_PAREN)
            self.state = 7169
            self.indirection_identifier()
            self.state = 7174
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7170
                self.match(postgreSQLParser.COMMA)
                self.state = 7171
                self.indirection_identifier()
                self.state = 7176
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7177
            self.match(postgreSQLParser.RIGHT_PAREN)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Indirection_identifierContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def indirection_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Indirection_listContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_indirection_identifier

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIndirection_identifier" ):
                listener.enterIndirection_identifier(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIndirection_identifier" ):
                listener.exitIndirection_identifier(self)




    def indirection_identifier(self):

        localctx = postgreSQLParser.Indirection_identifierContext(self, self._ctx, self.state)
        self.enterRule(localctx, 702, self.RULE_indirection_identifier)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7179
            self.identifier()
            self.state = 7181
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DOT or _la==postgreSQLParser.LEFT_BRACKET:
                self.state = 7180
                self.indirection_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conflict_objectContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def index_sort(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_sortContext,0)


        def index_where(self):
            return self.getTypedRuleContext(postgreSQLParser.Index_whereContext,0)


        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_conflict_object

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConflict_object" ):
                listener.enterConflict_object(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConflict_object" ):
                listener.exitConflict_object(self)




    def conflict_object(self):

        localctx = postgreSQLParser.Conflict_objectContext(self, self._ctx, self.state)
        self.enterRule(localctx, 704, self.RULE_conflict_object)
        self._la = 0 # Token type
        try:
            self.state = 7190
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7183
                self.index_sort()
                self.state = 7185
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WHERE:
                    self.state = 7184
                    self.index_where()


                pass
            elif token in [postgreSQLParser.ON]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7187
                self.match(postgreSQLParser.ON)
                self.state = 7188
                self.match(postgreSQLParser.CONSTRAINT)
                self.state = 7189
                self.identifier()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conflict_actionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(postgreSQLParser.DO, 0)

        def NOTHING(self):
            return self.getToken(postgreSQLParser.NOTHING, 0)

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def update_set(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Update_setContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Update_setContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_conflict_action

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConflict_action" ):
                listener.enterConflict_action(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConflict_action" ):
                listener.exitConflict_action(self)




    def conflict_action(self):

        localctx = postgreSQLParser.Conflict_actionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 706, self.RULE_conflict_action)
        self._la = 0 # Token type
        try:
            self.state = 7209
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,954,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7192
                self.match(postgreSQLParser.DO)
                self.state = 7193
                self.match(postgreSQLParser.NOTHING)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7194
                self.match(postgreSQLParser.DO)
                self.state = 7195
                self.match(postgreSQLParser.UPDATE)
                self.state = 7196
                self.match(postgreSQLParser.SET)
                self.state = 7197
                self.update_set()
                self.state = 7202
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7198
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7199
                    self.update_set()
                    self.state = 7204
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 7207
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WHERE:
                    self.state = 7205
                    self.match(postgreSQLParser.WHERE)
                    self.state = 7206
                    self.vex(0)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Delete_stmt_for_psqlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.delete_table_name = None # Schema_qualified_nameContext
            self.alias = None # IdentifierContext
            self.cursor = None # IdentifierContext

        def DELETE(self):
            return self.getToken(postgreSQLParser.DELETE, 0)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def with_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.With_clauseContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def from_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.From_itemContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.From_itemContext,i)


        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def RETURNING(self):
            return self.getToken(postgreSQLParser.RETURNING, 0)

        def select_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_listContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_delete_stmt_for_psql

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDelete_stmt_for_psql" ):
                listener.enterDelete_stmt_for_psql(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDelete_stmt_for_psql" ):
                listener.exitDelete_stmt_for_psql(self)




    def delete_stmt_for_psql(self):

        localctx = postgreSQLParser.Delete_stmt_for_psqlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 708, self.RULE_delete_stmt_for_psql)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7212
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 7211
                self.with_clause()


            self.state = 7214
            self.match(postgreSQLParser.DELETE)
            self.state = 7215
            self.match(postgreSQLParser.FROM)
            self.state = 7217
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ONLY:
                self.state = 7216
                self.match(postgreSQLParser.ONLY)


            self.state = 7219
            localctx.delete_table_name = self.schema_qualified_name()
            self.state = 7221
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.MULTIPLY:
                self.state = 7220
                self.match(postgreSQLParser.MULTIPLY)


            self.state = 7227
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,959,self._ctx)
            if la_ == 1:
                self.state = 7224
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AS:
                    self.state = 7223
                    self.match(postgreSQLParser.AS)


                self.state = 7226
                localctx.alias = self.identifier()


            self.state = 7238
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 7229
                self.match(postgreSQLParser.USING)
                self.state = 7230
                self.from_item(0)
                self.state = 7235
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7231
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7232
                    self.from_item(0)
                    self.state = 7237
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 7247
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHERE:
                self.state = 7240
                self.match(postgreSQLParser.WHERE)
                self.state = 7245
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,962,self._ctx)
                if la_ == 1:
                    self.state = 7241
                    self.vex(0)
                    pass

                elif la_ == 2:
                    self.state = 7242
                    self.match(postgreSQLParser.CURRENT)
                    self.state = 7243
                    self.match(postgreSQLParser.OF)
                    self.state = 7244
                    localctx.cursor = self.identifier()
                    pass




            self.state = 7251
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.RETURNING:
                self.state = 7249
                self.match(postgreSQLParser.RETURNING)
                self.state = 7250
                self.select_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_stmt_for_psqlContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.update_table_name = None # Schema_qualified_nameContext
            self.alias = None # IdentifierContext
            self.cursor = None # IdentifierContext

        def UPDATE(self):
            return self.getToken(postgreSQLParser.UPDATE, 0)

        def SET(self):
            return self.getToken(postgreSQLParser.SET, 0)

        def update_set(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Update_setContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Update_setContext,i)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def with_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.With_clauseContext,0)


        def ONLY(self):
            return self.getToken(postgreSQLParser.ONLY, 0)

        def MULTIPLY(self):
            return self.getToken(postgreSQLParser.MULTIPLY, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def from_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.From_itemContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.From_itemContext,i)


        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def RETURNING(self):
            return self.getToken(postgreSQLParser.RETURNING, 0)

        def select_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_listContext,0)


        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def OF(self):
            return self.getToken(postgreSQLParser.OF, 0)

        def AS(self):
            return self.getToken(postgreSQLParser.AS, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_update_stmt_for_psql

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate_stmt_for_psql" ):
                listener.enterUpdate_stmt_for_psql(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate_stmt_for_psql" ):
                listener.exitUpdate_stmt_for_psql(self)




    def update_stmt_for_psql(self):

        localctx = postgreSQLParser.Update_stmt_for_psqlContext(self, self._ctx, self.state)
        self.enterRule(localctx, 710, self.RULE_update_stmt_for_psql)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7254
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WITH:
                self.state = 7253
                self.with_clause()


            self.state = 7256
            self.match(postgreSQLParser.UPDATE)
            self.state = 7258
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ONLY:
                self.state = 7257
                self.match(postgreSQLParser.ONLY)


            self.state = 7260
            localctx.update_table_name = self.schema_qualified_name()
            self.state = 7262
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.MULTIPLY:
                self.state = 7261
                self.match(postgreSQLParser.MULTIPLY)


            self.state = 7268
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,969,self._ctx)
            if la_ == 1:
                self.state = 7265
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AS:
                    self.state = 7264
                    self.match(postgreSQLParser.AS)


                self.state = 7267
                localctx.alias = self.identifier()


            self.state = 7270
            self.match(postgreSQLParser.SET)
            self.state = 7271
            self.update_set()
            self.state = 7276
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7272
                self.match(postgreSQLParser.COMMA)
                self.state = 7273
                self.update_set()
                self.state = 7278
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7288
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FROM:
                self.state = 7279
                self.match(postgreSQLParser.FROM)
                self.state = 7280
                self.from_item(0)
                self.state = 7285
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7281
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7282
                    self.from_item(0)
                    self.state = 7287
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 7297
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHERE:
                self.state = 7290
                self.match(postgreSQLParser.WHERE)
                self.state = 7295
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,973,self._ctx)
                if la_ == 1:
                    self.state = 7291
                    self.vex(0)
                    pass

                elif la_ == 2:
                    self.state = 7292
                    self.match(postgreSQLParser.CURRENT)
                    self.state = 7293
                    self.match(postgreSQLParser.OF)
                    self.state = 7294
                    localctx.cursor = self.identifier()
                    pass




            self.state = 7301
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.RETURNING:
                self.state = 7299
                self.match(postgreSQLParser.RETURNING)
                self.state = 7300
                self.select_list()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Update_setContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self._indirection_identifier = None # Indirection_identifierContext
            self.column = list() # of Indirection_identifierContexts
            self._vex = None # VexContext
            self.value = list() # of VexContexts

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def indirection_identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Indirection_identifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Indirection_identifierContext,i)


        def DEFAULT(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DEFAULT)
            else:
                return self.getToken(postgreSQLParser.DEFAULT, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def LEFT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_PAREN)
            else:
                return self.getToken(postgreSQLParser.LEFT_PAREN, i)

        def RIGHT_PAREN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_PAREN)
            else:
                return self.getToken(postgreSQLParser.RIGHT_PAREN, i)

        def table_subquery(self):
            return self.getTypedRuleContext(postgreSQLParser.Table_subqueryContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def ROW(self):
            return self.getToken(postgreSQLParser.ROW, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_update_set

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUpdate_set" ):
                listener.enterUpdate_set(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUpdate_set" ):
                listener.exitUpdate_set(self)




    def update_set(self):

        localctx = postgreSQLParser.Update_setContext(self, self._ctx, self.state)
        self.enterRule(localctx, 712, self.RULE_update_set)
        self._la = 0 # Token type
        try:
            self.state = 7342
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7303
                localctx._indirection_identifier = self.indirection_identifier()
                localctx.column.append(localctx._indirection_identifier)
                self.state = 7304
                self.match(postgreSQLParser.EQUAL)
                self.state = 7307
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 7305
                    localctx._vex = self.vex(0)
                    localctx.value.append(localctx._vex)
                    pass
                elif token in [postgreSQLParser.DEFAULT]:
                    self.state = 7306
                    self.match(postgreSQLParser.DEFAULT)
                    pass
                else:
                    raise NoViableAltException(self)

                pass
            elif token in [postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7309
                self.match(postgreSQLParser.LEFT_PAREN)
                self.state = 7310
                localctx._indirection_identifier = self.indirection_identifier()
                localctx.column.append(localctx._indirection_identifier)
                self.state = 7315
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7311
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7312
                    localctx._indirection_identifier = self.indirection_identifier()
                    localctx.column.append(localctx._indirection_identifier)
                    self.state = 7317
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 7318
                self.match(postgreSQLParser.RIGHT_PAREN)
                self.state = 7319
                self.match(postgreSQLParser.EQUAL)
                self.state = 7321
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ROW:
                    self.state = 7320
                    self.match(postgreSQLParser.ROW)


                self.state = 7340
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,982,self._ctx)
                if la_ == 1:
                    self.state = 7323
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 7326
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                        self.state = 7324
                        localctx._vex = self.vex(0)
                        localctx.value.append(localctx._vex)
                        pass
                    elif token in [postgreSQLParser.DEFAULT]:
                        self.state = 7325
                        self.match(postgreSQLParser.DEFAULT)
                        pass
                    else:
                        raise NoViableAltException(self)

                    self.state = 7335
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 7328
                        self.match(postgreSQLParser.COMMA)
                        self.state = 7331
                        self._errHandler.sync(self)
                        token = self._input.LA(1)
                        if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.AUTHORIZATION, postgreSQLParser.BINARY, postgreSQLParser.COLLATION, postgreSQLParser.CONCURRENTLY, postgreSQLParser.CROSS, postgreSQLParser.CURRENT_SCHEMA, postgreSQLParser.FREEZE, postgreSQLParser.FULL, postgreSQLParser.ILIKE, postgreSQLParser.INNER, postgreSQLParser.IS, postgreSQLParser.ISNULL, postgreSQLParser.JOIN, postgreSQLParser.LEFT, postgreSQLParser.LIKE, postgreSQLParser.NATURAL, postgreSQLParser.NOTNULL, postgreSQLParser.OUTER, postgreSQLParser.OVERLAPS, postgreSQLParser.RIGHT, postgreSQLParser.SIMILAR, postgreSQLParser.TABLESAMPLE, postgreSQLParser.VERBOSE, postgreSQLParser.ALL, postgreSQLParser.ANY, postgreSQLParser.ARRAY, postgreSQLParser.CASE, postgreSQLParser.CAST, postgreSQLParser.CURRENT_CATALOG, postgreSQLParser.CURRENT_DATE, postgreSQLParser.CURRENT_TIME, postgreSQLParser.CURRENT_TIMESTAMP, postgreSQLParser.CURRENT_USER, postgreSQLParser.FALSE, postgreSQLParser.LOCALTIME, postgreSQLParser.LOCALTIMESTAMP, postgreSQLParser.NOT, postgreSQLParser.NULL, postgreSQLParser.ON, postgreSQLParser.SESSION_USER, postgreSQLParser.SOME, postgreSQLParser.TRUE, postgreSQLParser.USER, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.LEFT_PAREN, postgreSQLParser.PLUS, postgreSQLParser.MINUS, postgreSQLParser.MULTIPLY, postgreSQLParser.LESS_LESS, postgreSQLParser.GREATER_GREATER, postgreSQLParser.HASH_SIGN, postgreSQLParser.OP_CHARS, postgreSQLParser.NUMBER_LITERAL, postgreSQLParser.REAL_NUMBER, postgreSQLParser.DOLLAR_NUMBER, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier, postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                            self.state = 7329
                            localctx._vex = self.vex(0)
                            localctx.value.append(localctx._vex)
                            pass
                        elif token in [postgreSQLParser.DEFAULT]:
                            self.state = 7330
                            self.match(postgreSQLParser.DEFAULT)
                            pass
                        else:
                            raise NoViableAltException(self)

                        self.state = 7337
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 7338
                    self.match(postgreSQLParser.RIGHT_PAREN)
                    pass

                elif la_ == 2:
                    self.state = 7339
                    self.table_subquery()
                    pass


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Notify_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.channel = None # IdentifierContext
            self.payload = None # Character_stringContext

        def NOTIFY(self):
            return self.getToken(postgreSQLParser.NOTIFY, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def COMMA(self):
            return self.getToken(postgreSQLParser.COMMA, 0)

        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_notify_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNotify_stmt" ):
                listener.enterNotify_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNotify_stmt" ):
                listener.exitNotify_stmt(self)




    def notify_stmt(self):

        localctx = postgreSQLParser.Notify_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 714, self.RULE_notify_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7344
            self.match(postgreSQLParser.NOTIFY)
            self.state = 7345
            localctx.channel = self.identifier()
            self.state = 7348
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.COMMA:
                self.state = 7346
                self.match(postgreSQLParser.COMMA)
                self.state = 7347
                localctx.payload = self.character_string()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Truncate_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def TRUNCATE(self):
            return self.getToken(postgreSQLParser.TRUNCATE, 0)

        def only_table_multiply(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Only_table_multiplyContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Only_table_multiplyContext,i)


        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def IDENTITY(self):
            return self.getToken(postgreSQLParser.IDENTITY, 0)

        def cascade_restrict(self):
            return self.getTypedRuleContext(postgreSQLParser.Cascade_restrictContext,0)


        def RESTART(self):
            return self.getToken(postgreSQLParser.RESTART, 0)

        def CONTINUE(self):
            return self.getToken(postgreSQLParser.CONTINUE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_truncate_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTruncate_stmt" ):
                listener.enterTruncate_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTruncate_stmt" ):
                listener.exitTruncate_stmt(self)




    def truncate_stmt(self):

        localctx = postgreSQLParser.Truncate_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 716, self.RULE_truncate_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7350
            self.match(postgreSQLParser.TRUNCATE)
            self.state = 7352
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.TABLE:
                self.state = 7351
                self.match(postgreSQLParser.TABLE)


            self.state = 7354
            self.only_table_multiply()
            self.state = 7359
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7355
                self.match(postgreSQLParser.COMMA)
                self.state = 7356
                self.only_table_multiply()
                self.state = 7361
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7364
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CONTINUE or _la==postgreSQLParser.RESTART:
                self.state = 7362
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONTINUE or _la==postgreSQLParser.RESTART):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7363
                self.match(postgreSQLParser.IDENTITY)


            self.state = 7367
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.CASCADE or _la==postgreSQLParser.RESTRICT:
                self.state = 7366
                self.cascade_restrict()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Identifier_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_identifier_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIdentifier_list" ):
                listener.enterIdentifier_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIdentifier_list" ):
                listener.exitIdentifier_list(self)




    def identifier_list(self):

        localctx = postgreSQLParser.Identifier_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 718, self.RULE_identifier_list)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7369
            self.identifier()
            self.state = 7374
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,989,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7370
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7371
                    self.identifier() 
                self.state = 7376
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,989,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Anonymous_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DO(self):
            return self.getToken(postgreSQLParser.DO, 0)

        def character_string(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Character_stringContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,i)


        def LANGUAGE(self):
            return self.getToken(postgreSQLParser.LANGUAGE, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_anonymous_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAnonymous_block" ):
                listener.enterAnonymous_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAnonymous_block" ):
                listener.exitAnonymous_block(self)




    def anonymous_block(self):

        localctx = postgreSQLParser.Anonymous_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 720, self.RULE_anonymous_block)
        self._la = 0 # Token type
        try:
            self.state = 7393
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,993,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7377
                self.match(postgreSQLParser.DO)
                self.state = 7383
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LANGUAGE:
                    self.state = 7378
                    self.match(postgreSQLParser.LANGUAGE)
                    self.state = 7381
                    self._errHandler.sync(self)
                    token = self._input.LA(1)
                    if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                        self.state = 7379
                        self.identifier()
                        pass
                    elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                        self.state = 7380
                        self.character_string()
                        pass
                    else:
                        raise NoViableAltException(self)



                self.state = 7385
                self.character_string()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7386
                self.match(postgreSQLParser.DO)
                self.state = 7387
                self.character_string()
                self.state = 7388
                self.match(postgreSQLParser.LANGUAGE)
                self.state = 7391
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 7389
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.Character_String_Literal, postgreSQLParser.BeginDollarStringConstant]:
                    self.state = 7390
                    self.character_string()
                    pass
                else:
                    raise NoViableAltException(self)

                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Comp_optionsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def HASH_SIGN(self):
            return self.getToken(postgreSQLParser.HASH_SIGN, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def truth_value(self):
            return self.getTypedRuleContext(postgreSQLParser.Truth_valueContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_comp_options

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterComp_options" ):
                listener.enterComp_options(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitComp_options" ):
                listener.exitComp_options(self)




    def comp_options(self):

        localctx = postgreSQLParser.Comp_optionsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 722, self.RULE_comp_options)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7395
            self.match(postgreSQLParser.HASH_SIGN)
            self.state = 7396
            self.identifier()
            self.state = 7399
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 7397
                self.identifier()
                pass
            elif token in [postgreSQLParser.FALSE, postgreSQLParser.ON, postgreSQLParser.TRUE]:
                self.state = 7398
                self.truth_value()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_blockContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.end_label = None # IdentifierContext

        def BEGIN(self):
            return self.getToken(postgreSQLParser.BEGIN, 0)

        def function_statements(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_statementsContext,0)


        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def start_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Start_labelContext,0)


        def declarations(self):
            return self.getTypedRuleContext(postgreSQLParser.DeclarationsContext,0)


        def exception_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Exception_statementContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_block

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_block" ):
                listener.enterFunction_block(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_block" ):
                listener.exitFunction_block(self)




    def function_block(self):

        localctx = postgreSQLParser.Function_blockContext(self, self._ctx, self.state)
        self.enterRule(localctx, 724, self.RULE_function_block)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7402
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.LESS_LESS:
                self.state = 7401
                self.start_label()


            self.state = 7405
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.DECLARE:
                self.state = 7404
                self.declarations()


            self.state = 7407
            self.match(postgreSQLParser.BEGIN)
            self.state = 7408
            self.function_statements()
            self.state = 7410
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.EXCEPTION:
                self.state = 7409
                self.exception_statement()


            self.state = 7412
            self.match(postgreSQLParser.END)
            self.state = 7414
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                self.state = 7413
                localctx.end_label = self.identifier()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Start_labelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LESS_LESS(self):
            return self.getToken(postgreSQLParser.LESS_LESS, 0)

        def col_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Col_labelContext,0)


        def GREATER_GREATER(self):
            return self.getToken(postgreSQLParser.GREATER_GREATER, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_start_label

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterStart_label" ):
                listener.enterStart_label(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitStart_label" ):
                listener.exitStart_label(self)




    def start_label(self):

        localctx = postgreSQLParser.Start_labelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 726, self.RULE_start_label)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7416
            self.match(postgreSQLParser.LESS_LESS)
            self.state = 7417
            self.col_label()
            self.state = 7418
            self.match(postgreSQLParser.GREATER_GREATER)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DECLARE(self):
            return self.getToken(postgreSQLParser.DECLARE, 0)

        def declaration(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.DeclarationContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.DeclarationContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_declarations

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclarations" ):
                listener.enterDeclarations(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclarations" ):
                listener.exitDeclarations(self)




    def declarations(self):

        localctx = postgreSQLParser.DeclarationsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 728, self.RULE_declarations)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7420
            self.match(postgreSQLParser.DECLARE)
            self.state = 7424
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,999,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7421
                    self.declaration() 
                self.state = 7426
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,999,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeclarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def type_declaration(self):
            return self.getTypedRuleContext(postgreSQLParser.Type_declarationContext,0)


        def SEMI_COLON(self):
            return self.getToken(postgreSQLParser.SEMI_COLON, 0)

        def DECLARE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.DECLARE)
            else:
                return self.getToken(postgreSQLParser.DECLARE, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeclaration" ):
                listener.enterDeclaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeclaration" ):
                listener.exitDeclaration(self)




    def declaration(self):

        localctx = postgreSQLParser.DeclarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 730, self.RULE_declaration)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7430
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1000,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7427
                    self.match(postgreSQLParser.DECLARE) 
                self.state = 7432
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1000,self._ctx)

            self.state = 7433
            self.identifier()
            self.state = 7434
            self.type_declaration()
            self.state = 7435
            self.match(postgreSQLParser.SEMI_COLON)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Type_declarationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type_dec(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_type_decContext,0)


        def CONSTANT(self):
            return self.getToken(postgreSQLParser.CONSTANT, 0)

        def collate_identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.Collate_identifierContext,0)


        def NOT(self):
            return self.getToken(postgreSQLParser.NOT, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def DEFAULT(self):
            return self.getToken(postgreSQLParser.DEFAULT, 0)

        def COLON_EQUAL(self):
            return self.getToken(postgreSQLParser.COLON_EQUAL, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def ALIAS(self):
            return self.getToken(postgreSQLParser.ALIAS, 0)

        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def DOLLAR_NUMBER(self):
            return self.getToken(postgreSQLParser.DOLLAR_NUMBER, 0)

        def CURSOR(self):
            return self.getToken(postgreSQLParser.CURSOR, 0)

        def select_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmtContext,0)


        def IS(self):
            return self.getToken(postgreSQLParser.IS, 0)

        def SCROLL(self):
            return self.getToken(postgreSQLParser.SCROLL, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def arguments_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Arguments_listContext,0)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_type_declaration

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterType_declaration" ):
                listener.enterType_declaration(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitType_declaration" ):
                listener.exitType_declaration(self)




    def type_declaration(self):

        localctx = postgreSQLParser.Type_declarationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 732, self.RULE_type_declaration)
        self._la = 0 # Token type
        try:
            self.state = 7473
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1009,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7438
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1001,self._ctx)
                if la_ == 1:
                    self.state = 7437
                    self.match(postgreSQLParser.CONSTANT)


                self.state = 7440
                self.data_type_dec()
                self.state = 7442
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COLLATE:
                    self.state = 7441
                    self.collate_identifier()


                self.state = 7446
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NOT:
                    self.state = 7444
                    self.match(postgreSQLParser.NOT)
                    self.state = 7445
                    self.match(postgreSQLParser.NULL)


                self.state = 7450
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.DEFAULT or _la==postgreSQLParser.EQUAL or _la==postgreSQLParser.COLON_EQUAL:
                    self.state = 7448
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.DEFAULT or _la==postgreSQLParser.EQUAL or _la==postgreSQLParser.COLON_EQUAL):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()
                    self.state = 7449
                    self.vex(0)


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7452
                self.match(postgreSQLParser.ALIAS)
                self.state = 7453
                self.match(postgreSQLParser.FOR)
                self.state = 7456
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                    self.state = 7454
                    self.identifier()
                    pass
                elif token in [postgreSQLParser.DOLLAR_NUMBER]:
                    self.state = 7455
                    self.match(postgreSQLParser.DOLLAR_NUMBER)
                    pass
                else:
                    raise NoViableAltException(self)

                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7462
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO or _la==postgreSQLParser.SCROLL:
                    self.state = 7459
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.NO:
                        self.state = 7458
                        self.match(postgreSQLParser.NO)


                    self.state = 7461
                    self.match(postgreSQLParser.SCROLL)


                self.state = 7464
                self.match(postgreSQLParser.CURSOR)
                self.state = 7469
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 7465
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 7466
                    self.arguments_list()
                    self.state = 7467
                    self.match(postgreSQLParser.RIGHT_PAREN)


                self.state = 7471
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.IS or _la==postgreSQLParser.FOR):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7472
                self.select_stmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Arguments_listContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def data_type(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Data_typeContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_arguments_list

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterArguments_list" ):
                listener.enterArguments_list(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitArguments_list" ):
                listener.exitArguments_list(self)




    def arguments_list(self):

        localctx = postgreSQLParser.Arguments_listContext(self, self._ctx, self.state)
        self.enterRule(localctx, 734, self.RULE_arguments_list)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7475
            self.identifier()
            self.state = 7476
            self.data_type()
            self.state = 7483
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7477
                self.match(postgreSQLParser.COMMA)
                self.state = 7478
                self.identifier()
                self.state = 7479
                self.data_type()
                self.state = 7485
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Data_type_decContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_type(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_typeContext,0)


        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def MODULAR(self):
            return self.getToken(postgreSQLParser.MODULAR, 0)

        def TYPE(self):
            return self.getToken(postgreSQLParser.TYPE, 0)

        def schema_qualified_name_nontype(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_name_nontypeContext,0)


        def ROWTYPE(self):
            return self.getToken(postgreSQLParser.ROWTYPE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_data_type_dec

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterData_type_dec" ):
                listener.enterData_type_dec(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitData_type_dec" ):
                listener.exitData_type_dec(self)




    def data_type_dec(self):

        localctx = postgreSQLParser.Data_type_decContext(self, self._ctx, self.state)
        self.enterRule(localctx, 736, self.RULE_data_type_dec)
        try:
            self.state = 7495
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1011,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7486
                self.data_type()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7487
                self.schema_qualified_name()
                self.state = 7488
                self.match(postgreSQLParser.MODULAR)
                self.state = 7489
                self.match(postgreSQLParser.TYPE)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7491
                self.schema_qualified_name_nontype()
                self.state = 7492
                self.match(postgreSQLParser.MODULAR)
                self.state = 7493
                self.match(postgreSQLParser.ROWTYPE)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Exception_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXCEPTION(self):
            return self.getToken(postgreSQLParser.EXCEPTION, 0)

        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WHEN)
            else:
                return self.getToken(postgreSQLParser.WHEN, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.THEN)
            else:
                return self.getToken(postgreSQLParser.THEN, i)

        def function_statements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_statementsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_statementsContext,i)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_exception_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterException_statement" ):
                listener.enterException_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitException_statement" ):
                listener.exitException_statement(self)




    def exception_statement(self):

        localctx = postgreSQLParser.Exception_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 738, self.RULE_exception_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7497
            self.match(postgreSQLParser.EXCEPTION)
            self.state = 7503 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 7498
                self.match(postgreSQLParser.WHEN)
                self.state = 7499
                self.vex(0)
                self.state = 7500
                self.match(postgreSQLParser.THEN)
                self.state = 7501
                self.function_statements()
                self.state = 7505 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==postgreSQLParser.WHEN):
                    break

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_statementsContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_statement(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_statementContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_statementContext,i)


        def SEMI_COLON(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.SEMI_COLON)
            else:
                return self.getToken(postgreSQLParser.SEMI_COLON, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_statements

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_statements" ):
                listener.enterFunction_statements(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_statements" ):
                listener.exitFunction_statements(self)




    def function_statements(self):

        localctx = postgreSQLParser.Function_statementsContext(self, self._ctx, self.state)
        self.enterRule(localctx, 740, self.RULE_function_statements)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7512
            self._errHandler.sync(self)
            _alt = self._interp.adaptivePredict(self._input,1013,self._ctx)
            while _alt!=2 and _alt!=ATN.INVALID_ALT_NUMBER:
                if _alt==1:
                    self.state = 7507
                    self.function_statement()
                    self.state = 7508
                    self.match(postgreSQLParser.SEMI_COLON) 
                self.state = 7514
                self._errHandler.sync(self)
                _alt = self._interp.adaptivePredict(self._input,1013,self._ctx)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Function_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def function_block(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_blockContext,0)


        def base_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Base_statementContext,0)


        def control_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Control_statementContext,0)


        def transaction_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Transaction_statementContext,0)


        def cursor_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Cursor_statementContext,0)


        def message_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Message_statementContext,0)


        def schema_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_statementContext,0)


        def plpgsql_query(self):
            return self.getTypedRuleContext(postgreSQLParser.Plpgsql_queryContext,0)


        def additional_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Additional_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_function_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFunction_statement" ):
                listener.enterFunction_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFunction_statement" ):
                listener.exitFunction_statement(self)




    def function_statement(self):

        localctx = postgreSQLParser.Function_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 742, self.RULE_function_statement)
        try:
            self.state = 7524
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1014,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7515
                self.function_block()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7516
                self.base_statement()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7517
                self.control_statement()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7518
                self.transaction_statement()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7519
                self.cursor_statement()
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 7520
                self.message_statement()
                pass

            elif la_ == 7:
                self.enterOuterAlt(localctx, 7)
                self.state = 7521
                self.schema_statement()
                pass

            elif la_ == 8:
                self.enterOuterAlt(localctx, 8)
                self.state = 7522
                self.plpgsql_query()
                pass

            elif la_ == 9:
                self.enterOuterAlt(localctx, 9)
                self.state = 7523
                self.additional_statement()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Base_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def assign_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Assign_stmtContext,0)


        def PERFORM(self):
            return self.getToken(postgreSQLParser.PERFORM, 0)

        def perform_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Perform_stmtContext,0)


        def GET(self):
            return self.getToken(postgreSQLParser.GET, 0)

        def DIAGNOSTICS(self):
            return self.getToken(postgreSQLParser.DIAGNOSTICS, 0)

        def diagnostic_option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Diagnostic_optionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Diagnostic_optionContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def CURRENT(self):
            return self.getToken(postgreSQLParser.CURRENT, 0)

        def STACKED(self):
            return self.getToken(postgreSQLParser.STACKED, 0)

        def NULL(self):
            return self.getToken(postgreSQLParser.NULL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_base_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterBase_statement" ):
                listener.enterBase_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitBase_statement" ):
                listener.exitBase_statement(self)




    def base_statement(self):

        localctx = postgreSQLParser.Base_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 744, self.RULE_base_statement)
        self._la = 0 # Token type
        try:
            self.state = 7543
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1017,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7526
                self.assign_stmt()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7527
                self.match(postgreSQLParser.PERFORM)
                self.state = 7528
                self.perform_stmt()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7529
                self.match(postgreSQLParser.GET)
                self.state = 7531
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.CURRENT or _la==postgreSQLParser.STACKED:
                    self.state = 7530
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.CURRENT or _la==postgreSQLParser.STACKED):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 7533
                self.match(postgreSQLParser.DIAGNOSTICS)
                self.state = 7534
                self.diagnostic_option()
                self.state = 7539
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7535
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7536
                    self.diagnostic_option()
                    self.state = 7541
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7542
                self.match(postgreSQLParser.NULL)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VarContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def schema_qualified_name(self):
            return self.getTypedRuleContext(postgreSQLParser.Schema_qualified_nameContext,0)


        def DOLLAR_NUMBER(self):
            return self.getToken(postgreSQLParser.DOLLAR_NUMBER, 0)

        def LEFT_BRACKET(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LEFT_BRACKET)
            else:
                return self.getToken(postgreSQLParser.LEFT_BRACKET, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def RIGHT_BRACKET(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.RIGHT_BRACKET)
            else:
                return self.getToken(postgreSQLParser.RIGHT_BRACKET, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_var

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVar" ):
                listener.enterVar(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVar" ):
                listener.exitVar(self)




    def var(self):

        localctx = postgreSQLParser.VarContext(self, self._ctx, self.state)
        self.enterRule(localctx, 746, self.RULE_var)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7547
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.ABORT, postgreSQLParser.ABSOLUTE, postgreSQLParser.ACCESS, postgreSQLParser.ACTION, postgreSQLParser.ADD, postgreSQLParser.ADMIN, postgreSQLParser.AFTER, postgreSQLParser.AGGREGATE, postgreSQLParser.ALSO, postgreSQLParser.ALTER, postgreSQLParser.ALWAYS, postgreSQLParser.ASSERTION, postgreSQLParser.ASSIGNMENT, postgreSQLParser.AT, postgreSQLParser.ATTACH, postgreSQLParser.ATTRIBUTE, postgreSQLParser.BACKWARD, postgreSQLParser.BEFORE, postgreSQLParser.BEGIN, postgreSQLParser.BY, postgreSQLParser.CACHE, postgreSQLParser.CALL, postgreSQLParser.CALLED, postgreSQLParser.CASCADE, postgreSQLParser.CASCADED, postgreSQLParser.CATALOG, postgreSQLParser.CHAIN, postgreSQLParser.CHARACTERISTICS, postgreSQLParser.CHECKPOINT, postgreSQLParser.CLASS, postgreSQLParser.CLOSE, postgreSQLParser.CLUSTER, postgreSQLParser.COLUMNS, postgreSQLParser.COMMENT, postgreSQLParser.COMMENTS, postgreSQLParser.COMMIT, postgreSQLParser.COMMITTED, postgreSQLParser.CONFIGURATION, postgreSQLParser.CONFLICT, postgreSQLParser.CONNECTION, postgreSQLParser.CONSTRAINTS, postgreSQLParser.CONTENT, postgreSQLParser.CONTINUE, postgreSQLParser.CONVERSION, postgreSQLParser.COPY, postgreSQLParser.COST, postgreSQLParser.CSV, postgreSQLParser.CUBE, postgreSQLParser.CURRENT, postgreSQLParser.CURSOR, postgreSQLParser.CYCLE, postgreSQLParser.DATA, postgreSQLParser.DATABASE, postgreSQLParser.DAY, postgreSQLParser.DEALLOCATE, postgreSQLParser.DECLARE, postgreSQLParser.DEFAULTS, postgreSQLParser.DEFERRED, postgreSQLParser.DEFINER, postgreSQLParser.DELETE, postgreSQLParser.DELIMITER, postgreSQLParser.DELIMITERS, postgreSQLParser.DEPENDS, postgreSQLParser.DETACH, postgreSQLParser.DICTIONARY, postgreSQLParser.DISABLE, postgreSQLParser.DISCARD, postgreSQLParser.DOCUMENT, postgreSQLParser.DOMAIN, postgreSQLParser.DOUBLE, postgreSQLParser.DROP, postgreSQLParser.EACH, postgreSQLParser.ENABLE, postgreSQLParser.ENCODING, postgreSQLParser.ENCRYPTED, postgreSQLParser.ENUM, postgreSQLParser.ESCAPE, postgreSQLParser.EVENT, postgreSQLParser.EXCLUDE, postgreSQLParser.EXCLUDING, postgreSQLParser.EXCLUSIVE, postgreSQLParser.EXECUTE, postgreSQLParser.EXPLAIN, postgreSQLParser.EXPRESSION, postgreSQLParser.EXTENSION, postgreSQLParser.EXTERNAL, postgreSQLParser.FAMILY, postgreSQLParser.FILTER, postgreSQLParser.FIRST, postgreSQLParser.FOLLOWING, postgreSQLParser.FORCE, postgreSQLParser.FORWARD, postgreSQLParser.FUNCTION, postgreSQLParser.FUNCTIONS, postgreSQLParser.GENERATED, postgreSQLParser.GLOBAL, postgreSQLParser.GRANTED, postgreSQLParser.GROUPS, postgreSQLParser.HANDLER, postgreSQLParser.HEADER, postgreSQLParser.HOLD, postgreSQLParser.HOUR, postgreSQLParser.IDENTITY, postgreSQLParser.IF, postgreSQLParser.IMMEDIATE, postgreSQLParser.IMMUTABLE, postgreSQLParser.IMPLICIT, postgreSQLParser.IMPORT, postgreSQLParser.INCLUDE, postgreSQLParser.INCLUDING, postgreSQLParser.INCREMENT, postgreSQLParser.INDEX, postgreSQLParser.INDEXES, postgreSQLParser.INHERIT, postgreSQLParser.INHERITS, postgreSQLParser.INLINE, postgreSQLParser.INPUT, postgreSQLParser.INSENSITIVE, postgreSQLParser.INSERT, postgreSQLParser.INSTEAD, postgreSQLParser.INVOKER, postgreSQLParser.ISOLATION, postgreSQLParser.KEY, postgreSQLParser.LABEL, postgreSQLParser.LANGUAGE, postgreSQLParser.LARGE, postgreSQLParser.LAST, postgreSQLParser.LEAKPROOF, postgreSQLParser.LEVEL, postgreSQLParser.LISTEN, postgreSQLParser.LOAD, postgreSQLParser.LOCAL, postgreSQLParser.LOCATION, postgreSQLParser.LOCK, postgreSQLParser.LOCKED, postgreSQLParser.LOGGED, postgreSQLParser.MAPPING, postgreSQLParser.MATCH, postgreSQLParser.MATERIALIZED, postgreSQLParser.MAXVALUE, postgreSQLParser.METHOD, postgreSQLParser.MINUTE, postgreSQLParser.MINVALUE, postgreSQLParser.MODE, postgreSQLParser.MONTH, postgreSQLParser.MOVE, postgreSQLParser.NAME, postgreSQLParser.NAMES, postgreSQLParser.NEW, postgreSQLParser.NEXT, postgreSQLParser.NFC, postgreSQLParser.NFD, postgreSQLParser.NFKC, postgreSQLParser.NFKD, postgreSQLParser.NO, postgreSQLParser.NORMALIZED, postgreSQLParser.NOTHING, postgreSQLParser.NOTIFY, postgreSQLParser.NOWAIT, postgreSQLParser.NULLS, postgreSQLParser.OBJECT, postgreSQLParser.OF, postgreSQLParser.OFF, postgreSQLParser.OIDS, postgreSQLParser.OLD, postgreSQLParser.OPERATOR, postgreSQLParser.OPTION, postgreSQLParser.OPTIONS, postgreSQLParser.ORDINALITY, postgreSQLParser.OTHERS, postgreSQLParser.OVER, postgreSQLParser.OVERRIDING, postgreSQLParser.OWNED, postgreSQLParser.OWNER, postgreSQLParser.PARALLEL, postgreSQLParser.PARSER, postgreSQLParser.PARTIAL, postgreSQLParser.PARTITION, postgreSQLParser.PASSING, postgreSQLParser.PASSWORD, postgreSQLParser.PLANS, postgreSQLParser.POLICY, postgreSQLParser.PRECEDING, postgreSQLParser.PREPARE, postgreSQLParser.PREPARED, postgreSQLParser.PRESERVE, postgreSQLParser.PRIOR, postgreSQLParser.PRIVILEGES, postgreSQLParser.PROCEDURAL, postgreSQLParser.PROCEDURE, postgreSQLParser.PROCEDURES, postgreSQLParser.PROGRAM, postgreSQLParser.PUBLICATION, postgreSQLParser.QUOTE, postgreSQLParser.RANGE, postgreSQLParser.READ, postgreSQLParser.REASSIGN, postgreSQLParser.RECHECK, postgreSQLParser.RECURSIVE, postgreSQLParser.REF, postgreSQLParser.REFERENCING, postgreSQLParser.REFRESH, postgreSQLParser.REINDEX, postgreSQLParser.RELATIVE, postgreSQLParser.RELEASE, postgreSQLParser.RENAME, postgreSQLParser.REPEATABLE, postgreSQLParser.REPLACE, postgreSQLParser.REPLICA, postgreSQLParser.RESET, postgreSQLParser.RESTART, postgreSQLParser.RESTRICT, postgreSQLParser.RETURNS, postgreSQLParser.REVOKE, postgreSQLParser.ROLE, postgreSQLParser.ROLLBACK, postgreSQLParser.ROLLUP, postgreSQLParser.ROUTINE, postgreSQLParser.ROUTINES, postgreSQLParser.ROWS, postgreSQLParser.RULE, postgreSQLParser.SAVEPOINT, postgreSQLParser.SCHEMA, postgreSQLParser.SCHEMAS, postgreSQLParser.SCROLL, postgreSQLParser.SEARCH, postgreSQLParser.SECOND, postgreSQLParser.SECURITY, postgreSQLParser.SEQUENCE, postgreSQLParser.SEQUENCES, postgreSQLParser.SERIALIZABLE, postgreSQLParser.SERVER, postgreSQLParser.SESSION, postgreSQLParser.SET, postgreSQLParser.SETS, postgreSQLParser.SHARE, postgreSQLParser.SHOW, postgreSQLParser.SIMPLE, postgreSQLParser.SKIP_, postgreSQLParser.SNAPSHOT, postgreSQLParser.SQL, postgreSQLParser.STABLE, postgreSQLParser.STANDALONE, postgreSQLParser.START, postgreSQLParser.STATEMENT, postgreSQLParser.STATISTICS, postgreSQLParser.STDIN, postgreSQLParser.STDOUT, postgreSQLParser.STORAGE, postgreSQLParser.STORED, postgreSQLParser.STRICT, postgreSQLParser.STRIP, postgreSQLParser.SUBSCRIPTION, postgreSQLParser.SUPPORT, postgreSQLParser.SYSID, postgreSQLParser.SYSTEM, postgreSQLParser.TABLES, postgreSQLParser.TABLESPACE, postgreSQLParser.TEMP, postgreSQLParser.TEMPLATE, postgreSQLParser.TEMPORARY, postgreSQLParser.TEXT, postgreSQLParser.TIES, postgreSQLParser.TRANSACTION, postgreSQLParser.TRANSFORM, postgreSQLParser.TRIGGER, postgreSQLParser.TRUNCATE, postgreSQLParser.TRUSTED, postgreSQLParser.TYPE, postgreSQLParser.TYPES, postgreSQLParser.UESCAPE, postgreSQLParser.UNBOUNDED, postgreSQLParser.UNCOMMITTED, postgreSQLParser.UNENCRYPTED, postgreSQLParser.UNKNOWN, postgreSQLParser.UNLISTEN, postgreSQLParser.UNLOGGED, postgreSQLParser.UNTIL, postgreSQLParser.UPDATE, postgreSQLParser.VACUUM, postgreSQLParser.VALID, postgreSQLParser.VALIDATE, postgreSQLParser.VALIDATOR, postgreSQLParser.VALUE, postgreSQLParser.VARYING, postgreSQLParser.VERSION, postgreSQLParser.VIEW, postgreSQLParser.VIEWS, postgreSQLParser.VOLATILE, postgreSQLParser.WHITESPACE, postgreSQLParser.WITHIN, postgreSQLParser.WITHOUT, postgreSQLParser.WORK, postgreSQLParser.WRAPPER, postgreSQLParser.WRITE, postgreSQLParser.XML, postgreSQLParser.YEAR, postgreSQLParser.YES, postgreSQLParser.ZONE, postgreSQLParser.BETWEEN, postgreSQLParser.BIGINT, postgreSQLParser.BIT, postgreSQLParser.BOOLEAN, postgreSQLParser.CHAR, postgreSQLParser.CHARACTER, postgreSQLParser.COALESCE, postgreSQLParser.DEC, postgreSQLParser.DECIMAL, postgreSQLParser.EXISTS, postgreSQLParser.EXTRACT, postgreSQLParser.FLOAT, postgreSQLParser.GREATEST, postgreSQLParser.GROUPING, postgreSQLParser.INOUT, postgreSQLParser.INT, postgreSQLParser.INTEGER, postgreSQLParser.INTERVAL, postgreSQLParser.LEAST, postgreSQLParser.NATIONAL, postgreSQLParser.NCHAR, postgreSQLParser.NONE, postgreSQLParser.NORMALIZE, postgreSQLParser.NULLIF, postgreSQLParser.NUMERIC, postgreSQLParser.OUT, postgreSQLParser.OVERLAY, postgreSQLParser.POSITION, postgreSQLParser.PRECISION, postgreSQLParser.REAL, postgreSQLParser.ROW, postgreSQLParser.SETOF, postgreSQLParser.SMALLINT, postgreSQLParser.SUBSTRING, postgreSQLParser.TIME, postgreSQLParser.TIMESTAMP, postgreSQLParser.TREAT, postgreSQLParser.TRIM, postgreSQLParser.VALUES, postgreSQLParser.VARCHAR, postgreSQLParser.XMLATTRIBUTES, postgreSQLParser.XMLCONCAT, postgreSQLParser.XMLELEMENT, postgreSQLParser.XMLEXISTS, postgreSQLParser.XMLFOREST, postgreSQLParser.XMLNAMESPACES, postgreSQLParser.XMLPARSE, postgreSQLParser.XMLPI, postgreSQLParser.XMLROOT, postgreSQLParser.XMLSERIALIZE, postgreSQLParser.XMLTABLE, postgreSQLParser.ALIGNMENT, postgreSQLParser.ALLOW_CONNECTIONS, postgreSQLParser.BASETYPE, postgreSQLParser.BUFFERS, postgreSQLParser.BYPASSRLS, postgreSQLParser.CANONICAL, postgreSQLParser.CATEGORY, postgreSQLParser.COLLATABLE, postgreSQLParser.COMBINEFUNC, postgreSQLParser.COMMUTATOR, postgreSQLParser.CONNECT, postgreSQLParser.COSTS, postgreSQLParser.CREATEDB, postgreSQLParser.CREATEROLE, postgreSQLParser.DESERIALFUNC, postgreSQLParser.DETERMINISTIC, postgreSQLParser.DISABLE_PAGE_SKIPPING, postgreSQLParser.ELEMENT, postgreSQLParser.EXTENDED, postgreSQLParser.FINALFUNC, postgreSQLParser.FINALFUNC_EXTRA, postgreSQLParser.FINALFUNC_MODIFY, postgreSQLParser.FORCE_NOT_NULL, postgreSQLParser.FORCE_NULL, postgreSQLParser.FORCE_QUOTE, postgreSQLParser.FORMAT, postgreSQLParser.GETTOKEN, postgreSQLParser.HASH, postgreSQLParser.HASHES, postgreSQLParser.HEADLINE, postgreSQLParser.HYPOTHETICAL, postgreSQLParser.INDEX_CLEANUP, postgreSQLParser.INIT, postgreSQLParser.INITCOND, postgreSQLParser.INTERNALLENGTH, postgreSQLParser.IS_TEMPLATE, postgreSQLParser.JSON, postgreSQLParser.LC_COLLATE, postgreSQLParser.LC_CTYPE, postgreSQLParser.LEFTARG, postgreSQLParser.LEXIZE, postgreSQLParser.LEXTYPES, postgreSQLParser.LIST, postgreSQLParser.LOCALE, postgreSQLParser.LOGIN, postgreSQLParser.MAIN, postgreSQLParser.MERGES, postgreSQLParser.MFINALFUNC, postgreSQLParser.MFINALFUNC_EXTRA, postgreSQLParser.MFINALFUNC_MODIFY, postgreSQLParser.MINITCOND, postgreSQLParser.MINVFUNC, postgreSQLParser.MODULUS, postgreSQLParser.MSFUNC, postgreSQLParser.MSSPACE, postgreSQLParser.MSTYPE, postgreSQLParser.NEGATOR, postgreSQLParser.NOBYPASSRLS, postgreSQLParser.NOCREATEDB, postgreSQLParser.NOCREATEROLE, postgreSQLParser.NOINHERIT, postgreSQLParser.NOLOGIN, postgreSQLParser.NOREPLICATION, postgreSQLParser.NOSUPERUSER, postgreSQLParser.OUTPUT, postgreSQLParser.PASSEDBYVALUE, postgreSQLParser.PATH, postgreSQLParser.PERMISSIVE, postgreSQLParser.PLAIN, postgreSQLParser.PREFERRED, postgreSQLParser.PROVIDER, postgreSQLParser.READ_ONLY, postgreSQLParser.READ_WRITE, postgreSQLParser.RECEIVE, postgreSQLParser.REMAINDER, postgreSQLParser.REPLICATION, postgreSQLParser.RESTRICTED, postgreSQLParser.RESTRICTIVE, postgreSQLParser.RIGHTARG, postgreSQLParser.SAFE, postgreSQLParser.SEND, postgreSQLParser.SERIALFUNC, postgreSQLParser.SETTINGS, postgreSQLParser.SFUNC, postgreSQLParser.SHAREABLE, postgreSQLParser.SKIP_LOCKED, postgreSQLParser.SORTOP, postgreSQLParser.SSPACE, postgreSQLParser.STYPE, postgreSQLParser.SUBTYPE_DIFF, postgreSQLParser.SUBTYPE_OPCLASS, postgreSQLParser.SUBTYPE, postgreSQLParser.SUMMARY, postgreSQLParser.SUPERUSER, postgreSQLParser.TIMING, postgreSQLParser.TYPMOD_IN, postgreSQLParser.TYPMOD_OUT, postgreSQLParser.UNSAFE, postgreSQLParser.USAGE, postgreSQLParser.VARIABLE, postgreSQLParser.WAL, postgreSQLParser.YAML, postgreSQLParser.ALIAS, postgreSQLParser.ASSERT, postgreSQLParser.CONSTANT, postgreSQLParser.DATATYPE, postgreSQLParser.DEBUG, postgreSQLParser.DETAIL, postgreSQLParser.DIAGNOSTICS, postgreSQLParser.ELSEIF, postgreSQLParser.ELSIF, postgreSQLParser.ERRCODE, postgreSQLParser.EXIT, postgreSQLParser.EXCEPTION, postgreSQLParser.FOREACH, postgreSQLParser.GET, postgreSQLParser.HINT, postgreSQLParser.INFO, postgreSQLParser.LOG, postgreSQLParser.LOOP, postgreSQLParser.MESSAGE, postgreSQLParser.NOTICE, postgreSQLParser.OPEN, postgreSQLParser.PERFORM, postgreSQLParser.QUERY, postgreSQLParser.RAISE, postgreSQLParser.RECORD, postgreSQLParser.RETURN, postgreSQLParser.REVERSE, postgreSQLParser.ROWTYPE, postgreSQLParser.SLICE, postgreSQLParser.SQLSTATE, postgreSQLParser.STACKED, postgreSQLParser.WARNING, postgreSQLParser.WHILE, postgreSQLParser.Identifier, postgreSQLParser.QuotedIdentifier]:
                self.state = 7545
                self.schema_qualified_name()
                pass
            elif token in [postgreSQLParser.DOLLAR_NUMBER]:
                self.state = 7546
                self.match(postgreSQLParser.DOLLAR_NUMBER)
                pass
            else:
                raise NoViableAltException(self)

            self.state = 7555
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.LEFT_BRACKET:
                self.state = 7549
                self.match(postgreSQLParser.LEFT_BRACKET)
                self.state = 7550
                self.vex(0)
                self.state = 7551
                self.match(postgreSQLParser.RIGHT_BRACKET)
                self.state = 7557
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Diagnostic_optionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(postgreSQLParser.VarContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def COLON_EQUAL(self):
            return self.getToken(postgreSQLParser.COLON_EQUAL, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_diagnostic_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDiagnostic_option" ):
                listener.enterDiagnostic_option(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDiagnostic_option" ):
                listener.exitDiagnostic_option(self)




    def diagnostic_option(self):

        localctx = postgreSQLParser.Diagnostic_optionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 748, self.RULE_diagnostic_option)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7558
            self.var()
            self.state = 7559
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.EQUAL or _la==postgreSQLParser.COLON_EQUAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 7560
            self.identifier()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Perform_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def select_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_listContext,0)


        def set_qualifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Set_qualifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Set_qualifierContext,i)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def from_item(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.From_itemContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.From_itemContext,i)


        def WHERE(self):
            return self.getToken(postgreSQLParser.WHERE, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def groupby_clause(self):
            return self.getTypedRuleContext(postgreSQLParser.Groupby_clauseContext,0)


        def HAVING(self):
            return self.getToken(postgreSQLParser.HAVING, 0)

        def WINDOW(self):
            return self.getToken(postgreSQLParser.WINDOW, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def AS(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.AS)
            else:
                return self.getToken(postgreSQLParser.AS, i)

        def window_definition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Window_definitionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Window_definitionContext,i)


        def select_ops(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_opsContext,0)


        def after_ops(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.After_opsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.After_opsContext,i)


        def INTERSECT(self):
            return self.getToken(postgreSQLParser.INTERSECT, 0)

        def UNION(self):
            return self.getToken(postgreSQLParser.UNION, 0)

        def EXCEPT(self):
            return self.getToken(postgreSQLParser.EXCEPT, 0)

        def ON(self):
            return self.getToken(postgreSQLParser.ON, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_perform_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPerform_stmt" ):
                listener.enterPerform_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPerform_stmt" ):
                listener.exitPerform_stmt(self)




    def perform_stmt(self):

        localctx = postgreSQLParser.Perform_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 750, self.RULE_perform_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7577
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1022,self._ctx)
            if la_ == 1:
                self.state = 7562
                self.set_qualifier()
                self.state = 7575
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1021,self._ctx)
                if la_ == 1:
                    self.state = 7563
                    self.match(postgreSQLParser.ON)
                    self.state = 7564
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 7565
                    self.vex(0)
                    self.state = 7570
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 7566
                        self.match(postgreSQLParser.COMMA)
                        self.state = 7567
                        self.vex(0)
                        self.state = 7572
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 7573
                    self.match(postgreSQLParser.RIGHT_PAREN)




            self.state = 7579
            self.select_list()
            self.state = 7589
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.FROM:
                self.state = 7580
                self.match(postgreSQLParser.FROM)
                self.state = 7581
                self.from_item(0)
                self.state = 7586
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7582
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7583
                    self.from_item(0)
                    self.state = 7588
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 7593
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WHERE:
                self.state = 7591
                self.match(postgreSQLParser.WHERE)
                self.state = 7592
                self.vex(0)


            self.state = 7596
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.GROUP:
                self.state = 7595
                self.groupby_clause()


            self.state = 7600
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.HAVING:
                self.state = 7598
                self.match(postgreSQLParser.HAVING)
                self.state = 7599
                self.vex(0)


            self.state = 7616
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.WINDOW:
                self.state = 7602
                self.match(postgreSQLParser.WINDOW)
                self.state = 7603
                self.identifier()
                self.state = 7604
                self.match(postgreSQLParser.AS)
                self.state = 7605
                self.window_definition()
                self.state = 7613
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7606
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7607
                    self.identifier()
                    self.state = 7608
                    self.match(postgreSQLParser.AS)
                    self.state = 7609
                    self.window_definition()
                    self.state = 7615
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)



            self.state = 7623
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if ((((_la - 403)) & ~0x3f) == 0 and ((1 << (_la - 403)) & ((1 << (postgreSQLParser.EXCEPT - 403)) | (1 << (postgreSQLParser.INTERSECT - 403)) | (1 << (postgreSQLParser.UNION - 403)))) != 0):
                self.state = 7618
                _la = self._input.LA(1)
                if not(((((_la - 403)) & ~0x3f) == 0 and ((1 << (_la - 403)) & ((1 << (postgreSQLParser.EXCEPT - 403)) | (1 << (postgreSQLParser.INTERSECT - 403)) | (1 << (postgreSQLParser.UNION - 403)))) != 0)):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7620
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.ALL or _la==postgreSQLParser.DISTINCT:
                    self.state = 7619
                    self.set_qualifier()


                self.state = 7622
                self.select_ops(0)


            self.state = 7628
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while ((((_la - 405)) & ~0x3f) == 0 and ((1 << (_la - 405)) & ((1 << (postgreSQLParser.FETCH - 405)) | (1 << (postgreSQLParser.FOR - 405)) | (1 << (postgreSQLParser.LIMIT - 405)) | (1 << (postgreSQLParser.OFFSET - 405)) | (1 << (postgreSQLParser.ORDER - 405)))) != 0):
                self.state = 7625
                self.after_ops()
                self.state = 7630
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Assign_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def var(self):
            return self.getTypedRuleContext(postgreSQLParser.VarContext,0)


        def COLON_EQUAL(self):
            return self.getToken(postgreSQLParser.COLON_EQUAL, 0)

        def EQUAL(self):
            return self.getToken(postgreSQLParser.EQUAL, 0)

        def select_stmt_no_parens(self):
            return self.getTypedRuleContext(postgreSQLParser.Select_stmt_no_parensContext,0)


        def perform_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Perform_stmtContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_assign_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAssign_stmt" ):
                listener.enterAssign_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAssign_stmt" ):
                listener.exitAssign_stmt(self)




    def assign_stmt(self):

        localctx = postgreSQLParser.Assign_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 752, self.RULE_assign_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7631
            self.var()
            self.state = 7632
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.EQUAL or _la==postgreSQLParser.COLON_EQUAL):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
            self.state = 7635
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1033,self._ctx)
            if la_ == 1:
                self.state = 7633
                self.select_stmt_no_parens()
                pass

            elif la_ == 2:
                self.state = 7634
                self.perform_stmt()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Execute_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def EXECUTE(self):
            return self.getToken(postgreSQLParser.EXECUTE, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def using_vex(self):
            return self.getTypedRuleContext(postgreSQLParser.Using_vexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_execute_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterExecute_stmt" ):
                listener.enterExecute_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitExecute_stmt" ):
                listener.exitExecute_stmt(self)




    def execute_stmt(self):

        localctx = postgreSQLParser.Execute_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 754, self.RULE_execute_stmt)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7637
            self.match(postgreSQLParser.EXECUTE)
            self.state = 7638
            self.vex(0)
            self.state = 7640
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.USING:
                self.state = 7639
                self.using_vex()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Control_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def return_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Return_stmtContext,0)


        def CALL(self):
            return self.getToken(postgreSQLParser.CALL, 0)

        def function_call(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_callContext,0)


        def if_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.If_statementContext,0)


        def case_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Case_statementContext,0)


        def loop_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Loop_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_control_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterControl_statement" ):
                listener.enterControl_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitControl_statement" ):
                listener.exitControl_statement(self)




    def control_statement(self):

        localctx = postgreSQLParser.Control_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 756, self.RULE_control_statement)
        try:
            self.state = 7648
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.RETURN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7642
                self.return_stmt()
                pass
            elif token in [postgreSQLParser.CALL]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7643
                self.match(postgreSQLParser.CALL)
                self.state = 7644
                self.function_call()
                pass
            elif token in [postgreSQLParser.IF]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7645
                self.if_statement()
                pass
            elif token in [postgreSQLParser.CASE]:
                self.enterOuterAlt(localctx, 4)
                self.state = 7646
                self.case_statement()
                pass
            elif token in [postgreSQLParser.CONTINUE, postgreSQLParser.FOR, postgreSQLParser.EXIT, postgreSQLParser.FOREACH, postgreSQLParser.LOOP, postgreSQLParser.WHILE, postgreSQLParser.LESS_LESS]:
                self.enterOuterAlt(localctx, 5)
                self.state = 7647
                self.loop_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Cursor_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def OPEN(self):
            return self.getToken(postgreSQLParser.OPEN, 0)

        def var(self):
            return self.getTypedRuleContext(postgreSQLParser.VarContext,0)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def plpgsql_query(self):
            return self.getTypedRuleContext(postgreSQLParser.Plpgsql_queryContext,0)


        def SCROLL(self):
            return self.getToken(postgreSQLParser.SCROLL, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.OptionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.OptionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def FETCH(self):
            return self.getToken(postgreSQLParser.FETCH, 0)

        def fetch_move_direction(self):
            return self.getTypedRuleContext(postgreSQLParser.Fetch_move_directionContext,0)


        def FROM(self):
            return self.getToken(postgreSQLParser.FROM, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def MOVE(self):
            return self.getToken(postgreSQLParser.MOVE, 0)

        def CLOSE(self):
            return self.getToken(postgreSQLParser.CLOSE, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_cursor_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCursor_statement" ):
                listener.enterCursor_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCursor_statement" ):
                listener.exitCursor_statement(self)




    def cursor_statement(self):

        localctx = postgreSQLParser.Cursor_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 758, self.RULE_cursor_statement)
        self._la = 0 # Token type
        try:
            self.state = 7694
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1044,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7650
                self.match(postgreSQLParser.OPEN)
                self.state = 7651
                self.var()
                self.state = 7656
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.NO or _la==postgreSQLParser.SCROLL:
                    self.state = 7653
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.NO:
                        self.state = 7652
                        self.match(postgreSQLParser.NO)


                    self.state = 7655
                    self.match(postgreSQLParser.SCROLL)


                self.state = 7658
                self.match(postgreSQLParser.FOR)
                self.state = 7659
                self.plpgsql_query()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7661
                self.match(postgreSQLParser.OPEN)
                self.state = 7662
                self.var()
                self.state = 7674
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 7663
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 7664
                    self.option()
                    self.state = 7669
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 7665
                        self.match(postgreSQLParser.COMMA)
                        self.state = 7666
                        self.option()
                        self.state = 7671
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 7672
                    self.match(postgreSQLParser.RIGHT_PAREN)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7676
                self.match(postgreSQLParser.FETCH)
                self.state = 7678
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1040,self._ctx)
                if la_ == 1:
                    self.state = 7677
                    self.fetch_move_direction()


                self.state = 7681
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FROM or _la==postgreSQLParser.IN:
                    self.state = 7680
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.FROM or _la==postgreSQLParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 7683
                self.var()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7684
                self.match(postgreSQLParser.MOVE)
                self.state = 7686
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1042,self._ctx)
                if la_ == 1:
                    self.state = 7685
                    self.fetch_move_direction()


                self.state = 7689
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FROM or _la==postgreSQLParser.IN:
                    self.state = 7688
                    _la = self._input.LA(1)
                    if not(_la==postgreSQLParser.FROM or _la==postgreSQLParser.IN):
                        self._errHandler.recoverInline(self)
                    else:
                        self._errHandler.reportMatch(self)
                        self.consume()


                self.state = 7691
                self.var()
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7692
                self.match(postgreSQLParser.CLOSE)
                self.state = 7693
                self.var()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class OptionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def COLON_EQUAL(self):
            return self.getToken(postgreSQLParser.COLON_EQUAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_option

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterOption" ):
                listener.enterOption(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitOption" ):
                listener.exitOption(self)




    def option(self):

        localctx = postgreSQLParser.OptionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 760, self.RULE_option)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7699
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1045,self._ctx)
            if la_ == 1:
                self.state = 7696
                self.identifier()
                self.state = 7697
                self.match(postgreSQLParser.COLON_EQUAL)


            self.state = 7701
            self.vex(0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Transaction_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def COMMIT(self):
            return self.getToken(postgreSQLParser.COMMIT, 0)

        def ROLLBACK(self):
            return self.getToken(postgreSQLParser.ROLLBACK, 0)

        def AND(self):
            return self.getToken(postgreSQLParser.AND, 0)

        def CHAIN(self):
            return self.getToken(postgreSQLParser.CHAIN, 0)

        def NO(self):
            return self.getToken(postgreSQLParser.NO, 0)

        def lock_table(self):
            return self.getTypedRuleContext(postgreSQLParser.Lock_tableContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_transaction_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTransaction_statement" ):
                listener.enterTransaction_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTransaction_statement" ):
                listener.exitTransaction_statement(self)




    def transaction_statement(self):

        localctx = postgreSQLParser.Transaction_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 762, self.RULE_transaction_statement)
        self._la = 0 # Token type
        try:
            self.state = 7712
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.COMMIT, postgreSQLParser.ROLLBACK]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7703
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.COMMIT or _la==postgreSQLParser.ROLLBACK):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7709
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.AND:
                    self.state = 7704
                    self.match(postgreSQLParser.AND)
                    self.state = 7706
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==postgreSQLParser.NO:
                        self.state = 7705
                        self.match(postgreSQLParser.NO)


                    self.state = 7708
                    self.match(postgreSQLParser.CHAIN)


                pass
            elif token in [postgreSQLParser.LOCK]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7711
                self.lock_table()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Message_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RAISE(self):
            return self.getToken(postgreSQLParser.RAISE, 0)

        def log_level(self):
            return self.getTypedRuleContext(postgreSQLParser.Log_levelContext,0)


        def character_string(self):
            return self.getTypedRuleContext(postgreSQLParser.Character_stringContext,0)


        def raise_using(self):
            return self.getTypedRuleContext(postgreSQLParser.Raise_usingContext,0)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def SQLSTATE(self):
            return self.getToken(postgreSQLParser.SQLSTATE, 0)

        def ASSERT(self):
            return self.getToken(postgreSQLParser.ASSERT, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_message_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMessage_statement" ):
                listener.enterMessage_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMessage_statement" ):
                listener.exitMessage_statement(self)




    def message_statement(self):

        localctx = postgreSQLParser.Message_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 764, self.RULE_message_statement)
        self._la = 0 # Token type
        try:
            self.state = 7754
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1058,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7714
                self.match(postgreSQLParser.RAISE)
                self.state = 7716
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 556)) & ~0x3f) == 0 and ((1 << (_la - 556)) & ((1 << (postgreSQLParser.DEBUG - 556)) | (1 << (postgreSQLParser.EXCEPTION - 556)) | (1 << (postgreSQLParser.INFO - 556)) | (1 << (postgreSQLParser.LOG - 556)) | (1 << (postgreSQLParser.NOTICE - 556)) | (1 << (postgreSQLParser.WARNING - 556)))) != 0):
                    self.state = 7715
                    self.log_level()


                self.state = 7726
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.Character_String_Literal or _la==postgreSQLParser.BeginDollarStringConstant:
                    self.state = 7718
                    self.character_string()
                    self.state = 7723
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 7719
                        self.match(postgreSQLParser.COMMA)
                        self.state = 7720
                        self.vex(0)
                        self.state = 7725
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)



                self.state = 7729
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.USING:
                    self.state = 7728
                    self.raise_using()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7731
                self.match(postgreSQLParser.RAISE)
                self.state = 7733
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1053,self._ctx)
                if la_ == 1:
                    self.state = 7732
                    self.log_level()


                self.state = 7735
                self.identifier()
                self.state = 7737
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.USING:
                    self.state = 7736
                    self.raise_using()


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7739
                self.match(postgreSQLParser.RAISE)
                self.state = 7741
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if ((((_la - 556)) & ~0x3f) == 0 and ((1 << (_la - 556)) & ((1 << (postgreSQLParser.DEBUG - 556)) | (1 << (postgreSQLParser.EXCEPTION - 556)) | (1 << (postgreSQLParser.INFO - 556)) | (1 << (postgreSQLParser.LOG - 556)) | (1 << (postgreSQLParser.NOTICE - 556)) | (1 << (postgreSQLParser.WARNING - 556)))) != 0):
                    self.state = 7740
                    self.log_level()


                self.state = 7743
                self.match(postgreSQLParser.SQLSTATE)
                self.state = 7744
                self.character_string()
                self.state = 7746
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.USING:
                    self.state = 7745
                    self.raise_using()


                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7748
                self.match(postgreSQLParser.ASSERT)
                self.state = 7749
                self.vex(0)
                self.state = 7752
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.COMMA:
                    self.state = 7750
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7751
                    self.vex(0)


                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Log_levelContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DEBUG(self):
            return self.getToken(postgreSQLParser.DEBUG, 0)

        def LOG(self):
            return self.getToken(postgreSQLParser.LOG, 0)

        def INFO(self):
            return self.getToken(postgreSQLParser.INFO, 0)

        def NOTICE(self):
            return self.getToken(postgreSQLParser.NOTICE, 0)

        def WARNING(self):
            return self.getToken(postgreSQLParser.WARNING, 0)

        def EXCEPTION(self):
            return self.getToken(postgreSQLParser.EXCEPTION, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_log_level

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLog_level" ):
                listener.enterLog_level(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLog_level" ):
                listener.exitLog_level(self)




    def log_level(self):

        localctx = postgreSQLParser.Log_levelContext(self, self._ctx, self.state)
        self.enterRule(localctx, 766, self.RULE_log_level)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7756
            _la = self._input.LA(1)
            if not(((((_la - 556)) & ~0x3f) == 0 and ((1 << (_la - 556)) & ((1 << (postgreSQLParser.DEBUG - 556)) | (1 << (postgreSQLParser.EXCEPTION - 556)) | (1 << (postgreSQLParser.INFO - 556)) | (1 << (postgreSQLParser.LOG - 556)) | (1 << (postgreSQLParser.NOTICE - 556)) | (1 << (postgreSQLParser.WARNING - 556)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Raise_usingContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def raise_param(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Raise_paramContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Raise_paramContext,i)


        def EQUAL(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.EQUAL)
            else:
                return self.getToken(postgreSQLParser.EQUAL, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_raise_using

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaise_using" ):
                listener.enterRaise_using(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaise_using" ):
                listener.exitRaise_using(self)




    def raise_using(self):

        localctx = postgreSQLParser.Raise_usingContext(self, self._ctx, self.state)
        self.enterRule(localctx, 768, self.RULE_raise_using)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7758
            self.match(postgreSQLParser.USING)
            self.state = 7759
            self.raise_param()
            self.state = 7760
            self.match(postgreSQLParser.EQUAL)
            self.state = 7761
            self.vex(0)
            self.state = 7769
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7762
                self.match(postgreSQLParser.COMMA)
                self.state = 7763
                self.raise_param()
                self.state = 7764
                self.match(postgreSQLParser.EQUAL)
                self.state = 7765
                self.vex(0)
                self.state = 7771
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Raise_paramContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def MESSAGE(self):
            return self.getToken(postgreSQLParser.MESSAGE, 0)

        def DETAIL(self):
            return self.getToken(postgreSQLParser.DETAIL, 0)

        def HINT(self):
            return self.getToken(postgreSQLParser.HINT, 0)

        def ERRCODE(self):
            return self.getToken(postgreSQLParser.ERRCODE, 0)

        def COLUMN(self):
            return self.getToken(postgreSQLParser.COLUMN, 0)

        def CONSTRAINT(self):
            return self.getToken(postgreSQLParser.CONSTRAINT, 0)

        def DATATYPE(self):
            return self.getToken(postgreSQLParser.DATATYPE, 0)

        def TABLE(self):
            return self.getToken(postgreSQLParser.TABLE, 0)

        def SCHEMA(self):
            return self.getToken(postgreSQLParser.SCHEMA, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_raise_param

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterRaise_param" ):
                listener.enterRaise_param(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitRaise_param" ):
                listener.exitRaise_param(self)




    def raise_param(self):

        localctx = postgreSQLParser.Raise_paramContext(self, self._ctx, self.state)
        self.enterRule(localctx, 770, self.RULE_raise_param)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7772
            _la = self._input.LA(1)
            if not(_la==postgreSQLParser.SCHEMA or ((((_la - 387)) & ~0x3f) == 0 and ((1 << (_la - 387)) & ((1 << (postgreSQLParser.COLUMN - 387)) | (1 << (postgreSQLParser.CONSTRAINT - 387)) | (1 << (postgreSQLParser.TABLE - 387)))) != 0) or ((((_la - 555)) & ~0x3f) == 0 and ((1 << (_la - 555)) & ((1 << (postgreSQLParser.DATATYPE - 555)) | (1 << (postgreSQLParser.DETAIL - 555)) | (1 << (postgreSQLParser.ERRCODE - 555)) | (1 << (postgreSQLParser.HINT - 555)) | (1 << (postgreSQLParser.MESSAGE - 555)))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Return_stmtContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def RETURN(self):
            return self.getToken(postgreSQLParser.RETURN, 0)

        def perform_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Perform_stmtContext,0)


        def NEXT(self):
            return self.getToken(postgreSQLParser.NEXT, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def QUERY(self):
            return self.getToken(postgreSQLParser.QUERY, 0)

        def plpgsql_query(self):
            return self.getTypedRuleContext(postgreSQLParser.Plpgsql_queryContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_return_stmt

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterReturn_stmt" ):
                listener.enterReturn_stmt(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitReturn_stmt" ):
                listener.exitReturn_stmt(self)




    def return_stmt(self):

        localctx = postgreSQLParser.Return_stmtContext(self, self._ctx, self.state)
        self.enterRule(localctx, 772, self.RULE_return_stmt)
        self._la = 0 # Token type
        try:
            self.state = 7784
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1061,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7774
                self.match(postgreSQLParser.RETURN)
                self.state = 7776
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.DISTINCT - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                    self.state = 7775
                    self.perform_stmt()


                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7778
                self.match(postgreSQLParser.RETURN)
                self.state = 7779
                self.match(postgreSQLParser.NEXT)
                self.state = 7780
                self.vex(0)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7781
                self.match(postgreSQLParser.RETURN)
                self.state = 7782
                self.match(postgreSQLParser.QUERY)
                self.state = 7783
                self.plpgsql_query()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Loop_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def LOOP(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.LOOP)
            else:
                return self.getToken(postgreSQLParser.LOOP, i)

        def function_statements(self):
            return self.getTypedRuleContext(postgreSQLParser.Function_statementsContext,0)


        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def start_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Start_labelContext,0)


        def loop_start(self):
            return self.getTypedRuleContext(postgreSQLParser.Loop_startContext,0)


        def identifier(self):
            return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,0)


        def EXIT(self):
            return self.getToken(postgreSQLParser.EXIT, 0)

        def CONTINUE(self):
            return self.getToken(postgreSQLParser.CONTINUE, 0)

        def col_label(self):
            return self.getTypedRuleContext(postgreSQLParser.Col_labelContext,0)


        def WHEN(self):
            return self.getToken(postgreSQLParser.WHEN, 0)

        def vex(self):
            return self.getTypedRuleContext(postgreSQLParser.VexContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_loop_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop_statement" ):
                listener.enterLoop_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop_statement" ):
                listener.exitLoop_statement(self)




    def loop_statement(self):

        localctx = postgreSQLParser.Loop_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 774, self.RULE_loop_statement)
        self._la = 0 # Token type
        try:
            self.state = 7807
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.FOR, postgreSQLParser.FOREACH, postgreSQLParser.LOOP, postgreSQLParser.WHILE, postgreSQLParser.LESS_LESS]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7787
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LESS_LESS:
                    self.state = 7786
                    self.start_label()


                self.state = 7790
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.FOR or _la==postgreSQLParser.FOREACH or _la==postgreSQLParser.WHILE:
                    self.state = 7789
                    self.loop_start()


                self.state = 7792
                self.match(postgreSQLParser.LOOP)
                self.state = 7793
                self.function_statements()
                self.state = 7794
                self.match(postgreSQLParser.END)
                self.state = 7795
                self.match(postgreSQLParser.LOOP)
                self.state = 7797
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)))) != 0):
                    self.state = 7796
                    self.identifier()


                pass
            elif token in [postgreSQLParser.CONTINUE, postgreSQLParser.EXIT]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7799
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.CONTINUE or _la==postgreSQLParser.EXIT):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7801
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1065,self._ctx)
                if la_ == 1:
                    self.state = 7800
                    self.col_label()


                self.state = 7805
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.WHEN:
                    self.state = 7803
                    self.match(postgreSQLParser.WHEN)
                    self.state = 7804
                    self.vex(0)


                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Loop_startContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser
            self.alias = None # IdentifierContext
            self.cursor = None # IdentifierContext

        def WHILE(self):
            return self.getToken(postgreSQLParser.WHILE, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def FOR(self):
            return self.getToken(postgreSQLParser.FOR, 0)

        def IN(self):
            return self.getToken(postgreSQLParser.IN, 0)

        def DOUBLE_DOT(self):
            return self.getToken(postgreSQLParser.DOUBLE_DOT, 0)

        def identifier(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.IdentifierContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.IdentifierContext,i)


        def REVERSE(self):
            return self.getToken(postgreSQLParser.REVERSE, 0)

        def BY(self):
            return self.getToken(postgreSQLParser.BY, 0)

        def identifier_list(self):
            return self.getTypedRuleContext(postgreSQLParser.Identifier_listContext,0)


        def plpgsql_query(self):
            return self.getTypedRuleContext(postgreSQLParser.Plpgsql_queryContext,0)


        def LEFT_PAREN(self):
            return self.getToken(postgreSQLParser.LEFT_PAREN, 0)

        def option(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.OptionContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.OptionContext,i)


        def RIGHT_PAREN(self):
            return self.getToken(postgreSQLParser.RIGHT_PAREN, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def FOREACH(self):
            return self.getToken(postgreSQLParser.FOREACH, 0)

        def ARRAY(self):
            return self.getToken(postgreSQLParser.ARRAY, 0)

        def SLICE(self):
            return self.getToken(postgreSQLParser.SLICE, 0)

        def NUMBER_LITERAL(self):
            return self.getToken(postgreSQLParser.NUMBER_LITERAL, 0)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_loop_start

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterLoop_start" ):
                listener.enterLoop_start(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitLoop_start" ):
                listener.exitLoop_start(self)




    def loop_start(self):

        localctx = postgreSQLParser.Loop_startContext(self, self._ctx, self.state)
        self.enterRule(localctx, 776, self.RULE_loop_start)
        self._la = 0 # Token type
        try:
            self.state = 7856
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,1073,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 7809
                self.match(postgreSQLParser.WHILE)
                self.state = 7810
                self.vex(0)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 7811
                self.match(postgreSQLParser.FOR)
                self.state = 7812
                localctx.alias = self.identifier()
                self.state = 7813
                self.match(postgreSQLParser.IN)
                self.state = 7815
                self._errHandler.sync(self)
                la_ = self._interp.adaptivePredict(self._input,1068,self._ctx)
                if la_ == 1:
                    self.state = 7814
                    self.match(postgreSQLParser.REVERSE)


                self.state = 7817
                self.vex(0)
                self.state = 7818
                self.match(postgreSQLParser.DOUBLE_DOT)
                self.state = 7819
                self.vex(0)
                self.state = 7822
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.BY:
                    self.state = 7820
                    self.match(postgreSQLParser.BY)
                    self.state = 7821
                    self.vex(0)


                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 7824
                self.match(postgreSQLParser.FOR)
                self.state = 7825
                self.identifier_list()
                self.state = 7826
                self.match(postgreSQLParser.IN)
                self.state = 7827
                self.plpgsql_query()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 7829
                self.match(postgreSQLParser.FOR)
                self.state = 7830
                localctx.cursor = self.identifier()
                self.state = 7831
                self.match(postgreSQLParser.IN)
                self.state = 7832
                self.identifier()
                self.state = 7844
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.LEFT_PAREN:
                    self.state = 7833
                    self.match(postgreSQLParser.LEFT_PAREN)
                    self.state = 7834
                    self.option()
                    self.state = 7839
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    while _la==postgreSQLParser.COMMA:
                        self.state = 7835
                        self.match(postgreSQLParser.COMMA)
                        self.state = 7836
                        self.option()
                        self.state = 7841
                        self._errHandler.sync(self)
                        _la = self._input.LA(1)

                    self.state = 7842
                    self.match(postgreSQLParser.RIGHT_PAREN)


                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 7846
                self.match(postgreSQLParser.FOREACH)
                self.state = 7847
                self.identifier_list()
                self.state = 7850
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==postgreSQLParser.SLICE:
                    self.state = 7848
                    self.match(postgreSQLParser.SLICE)
                    self.state = 7849
                    self.match(postgreSQLParser.NUMBER_LITERAL)


                self.state = 7852
                self.match(postgreSQLParser.IN)
                self.state = 7853
                self.match(postgreSQLParser.ARRAY)
                self.state = 7854
                self.vex(0)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Using_vexContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def USING(self):
            return self.getToken(postgreSQLParser.USING, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_using_vex

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterUsing_vex" ):
                listener.enterUsing_vex(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitUsing_vex" ):
                listener.exitUsing_vex(self)




    def using_vex(self):

        localctx = postgreSQLParser.Using_vexContext(self, self._ctx, self.state)
        self.enterRule(localctx, 778, self.RULE_using_vex)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7858
            self.match(postgreSQLParser.USING)
            self.state = 7859
            self.vex(0)
            self.state = 7864
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.COMMA:
                self.state = 7860
                self.match(postgreSQLParser.COMMA)
                self.state = 7861
                self.vex(0)
                self.state = 7866
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class If_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def IF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.IF)
            else:
                return self.getToken(postgreSQLParser.IF, i)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.THEN)
            else:
                return self.getToken(postgreSQLParser.THEN, i)

        def function_statements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_statementsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_statementsContext,i)


        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def ELSE(self):
            return self.getToken(postgreSQLParser.ELSE, 0)

        def ELSIF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ELSIF)
            else:
                return self.getToken(postgreSQLParser.ELSIF, i)

        def ELSEIF(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.ELSEIF)
            else:
                return self.getToken(postgreSQLParser.ELSEIF, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_if_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterIf_statement" ):
                listener.enterIf_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitIf_statement" ):
                listener.exitIf_statement(self)




    def if_statement(self):

        localctx = postgreSQLParser.If_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 780, self.RULE_if_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7867
            self.match(postgreSQLParser.IF)
            self.state = 7868
            self.vex(0)
            self.state = 7869
            self.match(postgreSQLParser.THEN)
            self.state = 7870
            self.function_statements()
            self.state = 7878
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while _la==postgreSQLParser.ELSEIF or _la==postgreSQLParser.ELSIF:
                self.state = 7871
                _la = self._input.LA(1)
                if not(_la==postgreSQLParser.ELSEIF or _la==postgreSQLParser.ELSIF):
                    self._errHandler.recoverInline(self)
                else:
                    self._errHandler.reportMatch(self)
                    self.consume()
                self.state = 7872
                self.vex(0)
                self.state = 7873
                self.match(postgreSQLParser.THEN)
                self.state = 7874
                self.function_statements()
                self.state = 7880
                self._errHandler.sync(self)
                _la = self._input.LA(1)

            self.state = 7883
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ELSE:
                self.state = 7881
                self.match(postgreSQLParser.ELSE)
                self.state = 7882
                self.function_statements()


            self.state = 7885
            self.match(postgreSQLParser.END)
            self.state = 7886
            self.match(postgreSQLParser.IF)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Case_statementContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def CASE(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.CASE)
            else:
                return self.getToken(postgreSQLParser.CASE, i)

        def END(self):
            return self.getToken(postgreSQLParser.END, 0)

        def vex(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.VexContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.VexContext,i)


        def WHEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.WHEN)
            else:
                return self.getToken(postgreSQLParser.WHEN, i)

        def THEN(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.THEN)
            else:
                return self.getToken(postgreSQLParser.THEN, i)

        def function_statements(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(postgreSQLParser.Function_statementsContext)
            else:
                return self.getTypedRuleContext(postgreSQLParser.Function_statementsContext,i)


        def ELSE(self):
            return self.getToken(postgreSQLParser.ELSE, 0)

        def COMMA(self, i:int=None):
            if i is None:
                return self.getTokens(postgreSQLParser.COMMA)
            else:
                return self.getToken(postgreSQLParser.COMMA, i)

        def getRuleIndex(self):
            return postgreSQLParser.RULE_case_statement

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterCase_statement" ):
                listener.enterCase_statement(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitCase_statement" ):
                listener.exitCase_statement(self)




    def case_statement(self):

        localctx = postgreSQLParser.Case_statementContext(self, self._ctx, self.state)
        self.enterRule(localctx, 782, self.RULE_case_statement)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 7888
            self.match(postgreSQLParser.CASE)
            self.state = 7890
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << postgreSQLParser.ABORT) | (1 << postgreSQLParser.ABSOLUTE) | (1 << postgreSQLParser.ACCESS) | (1 << postgreSQLParser.ACTION) | (1 << postgreSQLParser.ADD) | (1 << postgreSQLParser.ADMIN) | (1 << postgreSQLParser.AFTER) | (1 << postgreSQLParser.AGGREGATE) | (1 << postgreSQLParser.ALSO) | (1 << postgreSQLParser.ALTER) | (1 << postgreSQLParser.ALWAYS) | (1 << postgreSQLParser.ASSERTION) | (1 << postgreSQLParser.ASSIGNMENT) | (1 << postgreSQLParser.AT) | (1 << postgreSQLParser.ATTACH) | (1 << postgreSQLParser.ATTRIBUTE) | (1 << postgreSQLParser.BACKWARD) | (1 << postgreSQLParser.BEFORE) | (1 << postgreSQLParser.BEGIN) | (1 << postgreSQLParser.BY) | (1 << postgreSQLParser.CACHE) | (1 << postgreSQLParser.CALL) | (1 << postgreSQLParser.CALLED) | (1 << postgreSQLParser.CASCADE) | (1 << postgreSQLParser.CASCADED) | (1 << postgreSQLParser.CATALOG) | (1 << postgreSQLParser.CHAIN) | (1 << postgreSQLParser.CHARACTERISTICS) | (1 << postgreSQLParser.CHECKPOINT) | (1 << postgreSQLParser.CLASS) | (1 << postgreSQLParser.CLOSE) | (1 << postgreSQLParser.CLUSTER) | (1 << postgreSQLParser.COLUMNS) | (1 << postgreSQLParser.COMMENT) | (1 << postgreSQLParser.COMMENTS) | (1 << postgreSQLParser.COMMIT) | (1 << postgreSQLParser.COMMITTED) | (1 << postgreSQLParser.CONFIGURATION) | (1 << postgreSQLParser.CONFLICT) | (1 << postgreSQLParser.CONNECTION) | (1 << postgreSQLParser.CONSTRAINTS) | (1 << postgreSQLParser.CONTENT) | (1 << postgreSQLParser.CONTINUE) | (1 << postgreSQLParser.CONVERSION) | (1 << postgreSQLParser.COPY) | (1 << postgreSQLParser.COST) | (1 << postgreSQLParser.CSV) | (1 << postgreSQLParser.CUBE) | (1 << postgreSQLParser.CURRENT) | (1 << postgreSQLParser.CURSOR) | (1 << postgreSQLParser.CYCLE) | (1 << postgreSQLParser.DATA) | (1 << postgreSQLParser.DATABASE) | (1 << postgreSQLParser.DAY) | (1 << postgreSQLParser.DEALLOCATE) | (1 << postgreSQLParser.DECLARE) | (1 << postgreSQLParser.DEFAULTS) | (1 << postgreSQLParser.DEFERRED) | (1 << postgreSQLParser.DEFINER) | (1 << postgreSQLParser.DELETE) | (1 << postgreSQLParser.DELIMITER) | (1 << postgreSQLParser.DELIMITERS) | (1 << postgreSQLParser.DEPENDS))) != 0) or ((((_la - 64)) & ~0x3f) == 0 and ((1 << (_la - 64)) & ((1 << (postgreSQLParser.DETACH - 64)) | (1 << (postgreSQLParser.DICTIONARY - 64)) | (1 << (postgreSQLParser.DISABLE - 64)) | (1 << (postgreSQLParser.DISCARD - 64)) | (1 << (postgreSQLParser.DOCUMENT - 64)) | (1 << (postgreSQLParser.DOMAIN - 64)) | (1 << (postgreSQLParser.DOUBLE - 64)) | (1 << (postgreSQLParser.DROP - 64)) | (1 << (postgreSQLParser.EACH - 64)) | (1 << (postgreSQLParser.ENABLE - 64)) | (1 << (postgreSQLParser.ENCODING - 64)) | (1 << (postgreSQLParser.ENCRYPTED - 64)) | (1 << (postgreSQLParser.ENUM - 64)) | (1 << (postgreSQLParser.ESCAPE - 64)) | (1 << (postgreSQLParser.EVENT - 64)) | (1 << (postgreSQLParser.EXCLUDE - 64)) | (1 << (postgreSQLParser.EXCLUDING - 64)) | (1 << (postgreSQLParser.EXCLUSIVE - 64)) | (1 << (postgreSQLParser.EXECUTE - 64)) | (1 << (postgreSQLParser.EXPLAIN - 64)) | (1 << (postgreSQLParser.EXPRESSION - 64)) | (1 << (postgreSQLParser.EXTENSION - 64)) | (1 << (postgreSQLParser.EXTERNAL - 64)) | (1 << (postgreSQLParser.FAMILY - 64)) | (1 << (postgreSQLParser.FILTER - 64)) | (1 << (postgreSQLParser.FIRST - 64)) | (1 << (postgreSQLParser.FOLLOWING - 64)) | (1 << (postgreSQLParser.FORCE - 64)) | (1 << (postgreSQLParser.FORWARD - 64)) | (1 << (postgreSQLParser.FUNCTION - 64)) | (1 << (postgreSQLParser.FUNCTIONS - 64)) | (1 << (postgreSQLParser.GENERATED - 64)) | (1 << (postgreSQLParser.GLOBAL - 64)) | (1 << (postgreSQLParser.GRANTED - 64)) | (1 << (postgreSQLParser.GROUPS - 64)) | (1 << (postgreSQLParser.HANDLER - 64)) | (1 << (postgreSQLParser.HEADER - 64)) | (1 << (postgreSQLParser.HOLD - 64)) | (1 << (postgreSQLParser.HOUR - 64)) | (1 << (postgreSQLParser.IDENTITY - 64)) | (1 << (postgreSQLParser.IF - 64)) | (1 << (postgreSQLParser.IMMEDIATE - 64)) | (1 << (postgreSQLParser.IMMUTABLE - 64)) | (1 << (postgreSQLParser.IMPLICIT - 64)) | (1 << (postgreSQLParser.IMPORT - 64)) | (1 << (postgreSQLParser.INCLUDE - 64)) | (1 << (postgreSQLParser.INCLUDING - 64)) | (1 << (postgreSQLParser.INCREMENT - 64)) | (1 << (postgreSQLParser.INDEX - 64)) | (1 << (postgreSQLParser.INDEXES - 64)) | (1 << (postgreSQLParser.INHERIT - 64)) | (1 << (postgreSQLParser.INHERITS - 64)) | (1 << (postgreSQLParser.INLINE - 64)) | (1 << (postgreSQLParser.INPUT - 64)) | (1 << (postgreSQLParser.INSENSITIVE - 64)) | (1 << (postgreSQLParser.INSERT - 64)) | (1 << (postgreSQLParser.INSTEAD - 64)) | (1 << (postgreSQLParser.INVOKER - 64)) | (1 << (postgreSQLParser.ISOLATION - 64)) | (1 << (postgreSQLParser.KEY - 64)) | (1 << (postgreSQLParser.LABEL - 64)) | (1 << (postgreSQLParser.LANGUAGE - 64)) | (1 << (postgreSQLParser.LARGE - 64)) | (1 << (postgreSQLParser.LAST - 64)))) != 0) or ((((_la - 128)) & ~0x3f) == 0 and ((1 << (_la - 128)) & ((1 << (postgreSQLParser.LEAKPROOF - 128)) | (1 << (postgreSQLParser.LEVEL - 128)) | (1 << (postgreSQLParser.LISTEN - 128)) | (1 << (postgreSQLParser.LOAD - 128)) | (1 << (postgreSQLParser.LOCAL - 128)) | (1 << (postgreSQLParser.LOCATION - 128)) | (1 << (postgreSQLParser.LOCK - 128)) | (1 << (postgreSQLParser.LOCKED - 128)) | (1 << (postgreSQLParser.LOGGED - 128)) | (1 << (postgreSQLParser.MAPPING - 128)) | (1 << (postgreSQLParser.MATCH - 128)) | (1 << (postgreSQLParser.MATERIALIZED - 128)) | (1 << (postgreSQLParser.MAXVALUE - 128)) | (1 << (postgreSQLParser.METHOD - 128)) | (1 << (postgreSQLParser.MINUTE - 128)) | (1 << (postgreSQLParser.MINVALUE - 128)) | (1 << (postgreSQLParser.MODE - 128)) | (1 << (postgreSQLParser.MONTH - 128)) | (1 << (postgreSQLParser.MOVE - 128)) | (1 << (postgreSQLParser.NAME - 128)) | (1 << (postgreSQLParser.NAMES - 128)) | (1 << (postgreSQLParser.NEW - 128)) | (1 << (postgreSQLParser.NEXT - 128)) | (1 << (postgreSQLParser.NFC - 128)) | (1 << (postgreSQLParser.NFD - 128)) | (1 << (postgreSQLParser.NFKC - 128)) | (1 << (postgreSQLParser.NFKD - 128)) | (1 << (postgreSQLParser.NO - 128)) | (1 << (postgreSQLParser.NORMALIZED - 128)) | (1 << (postgreSQLParser.NOTHING - 128)) | (1 << (postgreSQLParser.NOTIFY - 128)) | (1 << (postgreSQLParser.NOWAIT - 128)) | (1 << (postgreSQLParser.NULLS - 128)) | (1 << (postgreSQLParser.OBJECT - 128)) | (1 << (postgreSQLParser.OF - 128)) | (1 << (postgreSQLParser.OFF - 128)) | (1 << (postgreSQLParser.OIDS - 128)) | (1 << (postgreSQLParser.OLD - 128)) | (1 << (postgreSQLParser.OPERATOR - 128)) | (1 << (postgreSQLParser.OPTION - 128)) | (1 << (postgreSQLParser.OPTIONS - 128)) | (1 << (postgreSQLParser.ORDINALITY - 128)) | (1 << (postgreSQLParser.OTHERS - 128)) | (1 << (postgreSQLParser.OVER - 128)) | (1 << (postgreSQLParser.OVERRIDING - 128)) | (1 << (postgreSQLParser.OWNED - 128)) | (1 << (postgreSQLParser.OWNER - 128)) | (1 << (postgreSQLParser.PARALLEL - 128)) | (1 << (postgreSQLParser.PARSER - 128)) | (1 << (postgreSQLParser.PARTIAL - 128)) | (1 << (postgreSQLParser.PARTITION - 128)) | (1 << (postgreSQLParser.PASSING - 128)) | (1 << (postgreSQLParser.PASSWORD - 128)) | (1 << (postgreSQLParser.PLANS - 128)) | (1 << (postgreSQLParser.POLICY - 128)) | (1 << (postgreSQLParser.PRECEDING - 128)) | (1 << (postgreSQLParser.PREPARE - 128)) | (1 << (postgreSQLParser.PREPARED - 128)) | (1 << (postgreSQLParser.PRESERVE - 128)) | (1 << (postgreSQLParser.PRIOR - 128)) | (1 << (postgreSQLParser.PRIVILEGES - 128)) | (1 << (postgreSQLParser.PROCEDURAL - 128)) | (1 << (postgreSQLParser.PROCEDURE - 128)) | (1 << (postgreSQLParser.PROCEDURES - 128)))) != 0) or ((((_la - 192)) & ~0x3f) == 0 and ((1 << (_la - 192)) & ((1 << (postgreSQLParser.PROGRAM - 192)) | (1 << (postgreSQLParser.PUBLICATION - 192)) | (1 << (postgreSQLParser.QUOTE - 192)) | (1 << (postgreSQLParser.RANGE - 192)) | (1 << (postgreSQLParser.READ - 192)) | (1 << (postgreSQLParser.REASSIGN - 192)) | (1 << (postgreSQLParser.RECHECK - 192)) | (1 << (postgreSQLParser.RECURSIVE - 192)) | (1 << (postgreSQLParser.REF - 192)) | (1 << (postgreSQLParser.REFERENCING - 192)) | (1 << (postgreSQLParser.REFRESH - 192)) | (1 << (postgreSQLParser.REINDEX - 192)) | (1 << (postgreSQLParser.RELATIVE - 192)) | (1 << (postgreSQLParser.RELEASE - 192)) | (1 << (postgreSQLParser.RENAME - 192)) | (1 << (postgreSQLParser.REPEATABLE - 192)) | (1 << (postgreSQLParser.REPLACE - 192)) | (1 << (postgreSQLParser.REPLICA - 192)) | (1 << (postgreSQLParser.RESET - 192)) | (1 << (postgreSQLParser.RESTART - 192)) | (1 << (postgreSQLParser.RESTRICT - 192)) | (1 << (postgreSQLParser.RETURNS - 192)) | (1 << (postgreSQLParser.REVOKE - 192)) | (1 << (postgreSQLParser.ROLE - 192)) | (1 << (postgreSQLParser.ROLLBACK - 192)) | (1 << (postgreSQLParser.ROLLUP - 192)) | (1 << (postgreSQLParser.ROUTINE - 192)) | (1 << (postgreSQLParser.ROUTINES - 192)) | (1 << (postgreSQLParser.ROWS - 192)) | (1 << (postgreSQLParser.RULE - 192)) | (1 << (postgreSQLParser.SAVEPOINT - 192)) | (1 << (postgreSQLParser.SCHEMA - 192)) | (1 << (postgreSQLParser.SCHEMAS - 192)) | (1 << (postgreSQLParser.SCROLL - 192)) | (1 << (postgreSQLParser.SEARCH - 192)) | (1 << (postgreSQLParser.SECOND - 192)) | (1 << (postgreSQLParser.SECURITY - 192)) | (1 << (postgreSQLParser.SEQUENCE - 192)) | (1 << (postgreSQLParser.SEQUENCES - 192)) | (1 << (postgreSQLParser.SERIALIZABLE - 192)) | (1 << (postgreSQLParser.SERVER - 192)) | (1 << (postgreSQLParser.SESSION - 192)) | (1 << (postgreSQLParser.SET - 192)) | (1 << (postgreSQLParser.SETS - 192)) | (1 << (postgreSQLParser.SHARE - 192)) | (1 << (postgreSQLParser.SHOW - 192)) | (1 << (postgreSQLParser.SIMPLE - 192)) | (1 << (postgreSQLParser.SKIP_ - 192)) | (1 << (postgreSQLParser.SNAPSHOT - 192)) | (1 << (postgreSQLParser.SQL - 192)) | (1 << (postgreSQLParser.STABLE - 192)) | (1 << (postgreSQLParser.STANDALONE - 192)) | (1 << (postgreSQLParser.START - 192)) | (1 << (postgreSQLParser.STATEMENT - 192)) | (1 << (postgreSQLParser.STATISTICS - 192)) | (1 << (postgreSQLParser.STDIN - 192)) | (1 << (postgreSQLParser.STDOUT - 192)) | (1 << (postgreSQLParser.STORAGE - 192)) | (1 << (postgreSQLParser.STORED - 192)) | (1 << (postgreSQLParser.STRICT - 192)) | (1 << (postgreSQLParser.STRIP - 192)) | (1 << (postgreSQLParser.SUBSCRIPTION - 192)) | (1 << (postgreSQLParser.SUPPORT - 192)) | (1 << (postgreSQLParser.SYSID - 192)))) != 0) or ((((_la - 256)) & ~0x3f) == 0 and ((1 << (_la - 256)) & ((1 << (postgreSQLParser.SYSTEM - 256)) | (1 << (postgreSQLParser.TABLES - 256)) | (1 << (postgreSQLParser.TABLESPACE - 256)) | (1 << (postgreSQLParser.TEMP - 256)) | (1 << (postgreSQLParser.TEMPLATE - 256)) | (1 << (postgreSQLParser.TEMPORARY - 256)) | (1 << (postgreSQLParser.TEXT - 256)) | (1 << (postgreSQLParser.TIES - 256)) | (1 << (postgreSQLParser.TRANSACTION - 256)) | (1 << (postgreSQLParser.TRANSFORM - 256)) | (1 << (postgreSQLParser.TRIGGER - 256)) | (1 << (postgreSQLParser.TRUNCATE - 256)) | (1 << (postgreSQLParser.TRUSTED - 256)) | (1 << (postgreSQLParser.TYPE - 256)) | (1 << (postgreSQLParser.TYPES - 256)) | (1 << (postgreSQLParser.UESCAPE - 256)) | (1 << (postgreSQLParser.UNBOUNDED - 256)) | (1 << (postgreSQLParser.UNCOMMITTED - 256)) | (1 << (postgreSQLParser.UNENCRYPTED - 256)) | (1 << (postgreSQLParser.UNKNOWN - 256)) | (1 << (postgreSQLParser.UNLISTEN - 256)) | (1 << (postgreSQLParser.UNLOGGED - 256)) | (1 << (postgreSQLParser.UNTIL - 256)) | (1 << (postgreSQLParser.UPDATE - 256)) | (1 << (postgreSQLParser.VACUUM - 256)) | (1 << (postgreSQLParser.VALID - 256)) | (1 << (postgreSQLParser.VALIDATE - 256)) | (1 << (postgreSQLParser.VALIDATOR - 256)) | (1 << (postgreSQLParser.VALUE - 256)) | (1 << (postgreSQLParser.VARYING - 256)) | (1 << (postgreSQLParser.VERSION - 256)) | (1 << (postgreSQLParser.VIEW - 256)) | (1 << (postgreSQLParser.VIEWS - 256)) | (1 << (postgreSQLParser.VOLATILE - 256)) | (1 << (postgreSQLParser.WHITESPACE - 256)) | (1 << (postgreSQLParser.WITHIN - 256)) | (1 << (postgreSQLParser.WITHOUT - 256)) | (1 << (postgreSQLParser.WORK - 256)) | (1 << (postgreSQLParser.WRAPPER - 256)) | (1 << (postgreSQLParser.WRITE - 256)) | (1 << (postgreSQLParser.XML - 256)) | (1 << (postgreSQLParser.YEAR - 256)) | (1 << (postgreSQLParser.YES - 256)) | (1 << (postgreSQLParser.ZONE - 256)) | (1 << (postgreSQLParser.BETWEEN - 256)) | (1 << (postgreSQLParser.BIGINT - 256)) | (1 << (postgreSQLParser.BIT - 256)) | (1 << (postgreSQLParser.BOOLEAN - 256)) | (1 << (postgreSQLParser.CHAR - 256)) | (1 << (postgreSQLParser.CHARACTER - 256)) | (1 << (postgreSQLParser.COALESCE - 256)) | (1 << (postgreSQLParser.DEC - 256)) | (1 << (postgreSQLParser.DECIMAL - 256)) | (1 << (postgreSQLParser.EXISTS - 256)) | (1 << (postgreSQLParser.EXTRACT - 256)) | (1 << (postgreSQLParser.FLOAT - 256)) | (1 << (postgreSQLParser.GREATEST - 256)) | (1 << (postgreSQLParser.GROUPING - 256)) | (1 << (postgreSQLParser.INOUT - 256)) | (1 << (postgreSQLParser.INT - 256)) | (1 << (postgreSQLParser.INTEGER - 256)) | (1 << (postgreSQLParser.INTERVAL - 256)) | (1 << (postgreSQLParser.LEAST - 256)) | (1 << (postgreSQLParser.NATIONAL - 256)))) != 0) or ((((_la - 320)) & ~0x3f) == 0 and ((1 << (_la - 320)) & ((1 << (postgreSQLParser.NCHAR - 320)) | (1 << (postgreSQLParser.NONE - 320)) | (1 << (postgreSQLParser.NORMALIZE - 320)) | (1 << (postgreSQLParser.NULLIF - 320)) | (1 << (postgreSQLParser.NUMERIC - 320)) | (1 << (postgreSQLParser.OUT - 320)) | (1 << (postgreSQLParser.OVERLAY - 320)) | (1 << (postgreSQLParser.POSITION - 320)) | (1 << (postgreSQLParser.PRECISION - 320)) | (1 << (postgreSQLParser.REAL - 320)) | (1 << (postgreSQLParser.ROW - 320)) | (1 << (postgreSQLParser.SETOF - 320)) | (1 << (postgreSQLParser.SMALLINT - 320)) | (1 << (postgreSQLParser.SUBSTRING - 320)) | (1 << (postgreSQLParser.TIME - 320)) | (1 << (postgreSQLParser.TIMESTAMP - 320)) | (1 << (postgreSQLParser.TREAT - 320)) | (1 << (postgreSQLParser.TRIM - 320)) | (1 << (postgreSQLParser.VALUES - 320)) | (1 << (postgreSQLParser.VARCHAR - 320)) | (1 << (postgreSQLParser.XMLATTRIBUTES - 320)) | (1 << (postgreSQLParser.XMLCONCAT - 320)) | (1 << (postgreSQLParser.XMLELEMENT - 320)) | (1 << (postgreSQLParser.XMLEXISTS - 320)) | (1 << (postgreSQLParser.XMLFOREST - 320)) | (1 << (postgreSQLParser.XMLNAMESPACES - 320)) | (1 << (postgreSQLParser.XMLPARSE - 320)) | (1 << (postgreSQLParser.XMLPI - 320)) | (1 << (postgreSQLParser.XMLROOT - 320)) | (1 << (postgreSQLParser.XMLSERIALIZE - 320)) | (1 << (postgreSQLParser.XMLTABLE - 320)) | (1 << (postgreSQLParser.AUTHORIZATION - 320)) | (1 << (postgreSQLParser.BINARY - 320)) | (1 << (postgreSQLParser.COLLATION - 320)) | (1 << (postgreSQLParser.CONCURRENTLY - 320)) | (1 << (postgreSQLParser.CROSS - 320)) | (1 << (postgreSQLParser.CURRENT_SCHEMA - 320)) | (1 << (postgreSQLParser.FREEZE - 320)) | (1 << (postgreSQLParser.FULL - 320)) | (1 << (postgreSQLParser.ILIKE - 320)) | (1 << (postgreSQLParser.INNER - 320)) | (1 << (postgreSQLParser.IS - 320)) | (1 << (postgreSQLParser.ISNULL - 320)) | (1 << (postgreSQLParser.JOIN - 320)) | (1 << (postgreSQLParser.LEFT - 320)) | (1 << (postgreSQLParser.LIKE - 320)) | (1 << (postgreSQLParser.NATURAL - 320)) | (1 << (postgreSQLParser.NOTNULL - 320)) | (1 << (postgreSQLParser.OUTER - 320)) | (1 << (postgreSQLParser.OVERLAPS - 320)) | (1 << (postgreSQLParser.RIGHT - 320)) | (1 << (postgreSQLParser.SIMILAR - 320)) | (1 << (postgreSQLParser.TABLESAMPLE - 320)) | (1 << (postgreSQLParser.VERBOSE - 320)) | (1 << (postgreSQLParser.ALL - 320)) | (1 << (postgreSQLParser.ANY - 320)) | (1 << (postgreSQLParser.ARRAY - 320)) | (1 << (postgreSQLParser.CASE - 320)))) != 0) or ((((_la - 384)) & ~0x3f) == 0 and ((1 << (_la - 384)) & ((1 << (postgreSQLParser.CAST - 384)) | (1 << (postgreSQLParser.CURRENT_CATALOG - 384)) | (1 << (postgreSQLParser.CURRENT_DATE - 384)) | (1 << (postgreSQLParser.CURRENT_TIME - 384)) | (1 << (postgreSQLParser.CURRENT_TIMESTAMP - 384)) | (1 << (postgreSQLParser.CURRENT_USER - 384)) | (1 << (postgreSQLParser.FALSE - 384)) | (1 << (postgreSQLParser.LOCALTIME - 384)) | (1 << (postgreSQLParser.LOCALTIMESTAMP - 384)) | (1 << (postgreSQLParser.NOT - 384)) | (1 << (postgreSQLParser.NULL - 384)) | (1 << (postgreSQLParser.ON - 384)) | (1 << (postgreSQLParser.SESSION_USER - 384)) | (1 << (postgreSQLParser.SOME - 384)) | (1 << (postgreSQLParser.TRUE - 384)) | (1 << (postgreSQLParser.USER - 384)))) != 0) or ((((_la - 450)) & ~0x3f) == 0 and ((1 << (_la - 450)) & ((1 << (postgreSQLParser.ALIGNMENT - 450)) | (1 << (postgreSQLParser.ALLOW_CONNECTIONS - 450)) | (1 << (postgreSQLParser.BASETYPE - 450)) | (1 << (postgreSQLParser.BUFFERS - 450)) | (1 << (postgreSQLParser.BYPASSRLS - 450)) | (1 << (postgreSQLParser.CANONICAL - 450)) | (1 << (postgreSQLParser.CATEGORY - 450)) | (1 << (postgreSQLParser.COLLATABLE - 450)) | (1 << (postgreSQLParser.COMBINEFUNC - 450)) | (1 << (postgreSQLParser.COMMUTATOR - 450)) | (1 << (postgreSQLParser.CONNECT - 450)) | (1 << (postgreSQLParser.COSTS - 450)) | (1 << (postgreSQLParser.CREATEDB - 450)) | (1 << (postgreSQLParser.CREATEROLE - 450)) | (1 << (postgreSQLParser.DESERIALFUNC - 450)) | (1 << (postgreSQLParser.DETERMINISTIC - 450)) | (1 << (postgreSQLParser.DISABLE_PAGE_SKIPPING - 450)) | (1 << (postgreSQLParser.ELEMENT - 450)) | (1 << (postgreSQLParser.EXTENDED - 450)) | (1 << (postgreSQLParser.FINALFUNC - 450)) | (1 << (postgreSQLParser.FINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.FINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.FORCE_NOT_NULL - 450)) | (1 << (postgreSQLParser.FORCE_NULL - 450)) | (1 << (postgreSQLParser.FORCE_QUOTE - 450)) | (1 << (postgreSQLParser.FORMAT - 450)) | (1 << (postgreSQLParser.GETTOKEN - 450)) | (1 << (postgreSQLParser.HASH - 450)) | (1 << (postgreSQLParser.HASHES - 450)) | (1 << (postgreSQLParser.HEADLINE - 450)) | (1 << (postgreSQLParser.HYPOTHETICAL - 450)) | (1 << (postgreSQLParser.INDEX_CLEANUP - 450)) | (1 << (postgreSQLParser.INIT - 450)) | (1 << (postgreSQLParser.INITCOND - 450)) | (1 << (postgreSQLParser.INTERNALLENGTH - 450)) | (1 << (postgreSQLParser.IS_TEMPLATE - 450)) | (1 << (postgreSQLParser.JSON - 450)) | (1 << (postgreSQLParser.LC_COLLATE - 450)) | (1 << (postgreSQLParser.LC_CTYPE - 450)) | (1 << (postgreSQLParser.LEFTARG - 450)) | (1 << (postgreSQLParser.LEXIZE - 450)) | (1 << (postgreSQLParser.LEXTYPES - 450)) | (1 << (postgreSQLParser.LIST - 450)) | (1 << (postgreSQLParser.LOCALE - 450)) | (1 << (postgreSQLParser.LOGIN - 450)) | (1 << (postgreSQLParser.MAIN - 450)) | (1 << (postgreSQLParser.MERGES - 450)) | (1 << (postgreSQLParser.MFINALFUNC - 450)) | (1 << (postgreSQLParser.MFINALFUNC_EXTRA - 450)) | (1 << (postgreSQLParser.MFINALFUNC_MODIFY - 450)) | (1 << (postgreSQLParser.MINITCOND - 450)) | (1 << (postgreSQLParser.MINVFUNC - 450)) | (1 << (postgreSQLParser.MODULUS - 450)) | (1 << (postgreSQLParser.MSFUNC - 450)) | (1 << (postgreSQLParser.MSSPACE - 450)) | (1 << (postgreSQLParser.MSTYPE - 450)) | (1 << (postgreSQLParser.NEGATOR - 450)) | (1 << (postgreSQLParser.NOBYPASSRLS - 450)) | (1 << (postgreSQLParser.NOCREATEDB - 450)) | (1 << (postgreSQLParser.NOCREATEROLE - 450)) | (1 << (postgreSQLParser.NOINHERIT - 450)) | (1 << (postgreSQLParser.NOLOGIN - 450)) | (1 << (postgreSQLParser.NOREPLICATION - 450)) | (1 << (postgreSQLParser.NOSUPERUSER - 450)))) != 0) or ((((_la - 514)) & ~0x3f) == 0 and ((1 << (_la - 514)) & ((1 << (postgreSQLParser.OUTPUT - 514)) | (1 << (postgreSQLParser.PASSEDBYVALUE - 514)) | (1 << (postgreSQLParser.PATH - 514)) | (1 << (postgreSQLParser.PERMISSIVE - 514)) | (1 << (postgreSQLParser.PLAIN - 514)) | (1 << (postgreSQLParser.PREFERRED - 514)) | (1 << (postgreSQLParser.PROVIDER - 514)) | (1 << (postgreSQLParser.READ_ONLY - 514)) | (1 << (postgreSQLParser.READ_WRITE - 514)) | (1 << (postgreSQLParser.RECEIVE - 514)) | (1 << (postgreSQLParser.REMAINDER - 514)) | (1 << (postgreSQLParser.REPLICATION - 514)) | (1 << (postgreSQLParser.RESTRICTED - 514)) | (1 << (postgreSQLParser.RESTRICTIVE - 514)) | (1 << (postgreSQLParser.RIGHTARG - 514)) | (1 << (postgreSQLParser.SAFE - 514)) | (1 << (postgreSQLParser.SEND - 514)) | (1 << (postgreSQLParser.SERIALFUNC - 514)) | (1 << (postgreSQLParser.SETTINGS - 514)) | (1 << (postgreSQLParser.SFUNC - 514)) | (1 << (postgreSQLParser.SHAREABLE - 514)) | (1 << (postgreSQLParser.SKIP_LOCKED - 514)) | (1 << (postgreSQLParser.SORTOP - 514)) | (1 << (postgreSQLParser.SSPACE - 514)) | (1 << (postgreSQLParser.STYPE - 514)) | (1 << (postgreSQLParser.SUBTYPE_DIFF - 514)) | (1 << (postgreSQLParser.SUBTYPE_OPCLASS - 514)) | (1 << (postgreSQLParser.SUBTYPE - 514)) | (1 << (postgreSQLParser.SUMMARY - 514)) | (1 << (postgreSQLParser.SUPERUSER - 514)) | (1 << (postgreSQLParser.TIMING - 514)) | (1 << (postgreSQLParser.TYPMOD_IN - 514)) | (1 << (postgreSQLParser.TYPMOD_OUT - 514)) | (1 << (postgreSQLParser.UNSAFE - 514)) | (1 << (postgreSQLParser.USAGE - 514)) | (1 << (postgreSQLParser.VARIABLE - 514)) | (1 << (postgreSQLParser.WAL - 514)) | (1 << (postgreSQLParser.YAML - 514)) | (1 << (postgreSQLParser.ALIAS - 514)) | (1 << (postgreSQLParser.ASSERT - 514)) | (1 << (postgreSQLParser.CONSTANT - 514)) | (1 << (postgreSQLParser.DATATYPE - 514)) | (1 << (postgreSQLParser.DEBUG - 514)) | (1 << (postgreSQLParser.DETAIL - 514)) | (1 << (postgreSQLParser.DIAGNOSTICS - 514)) | (1 << (postgreSQLParser.ELSEIF - 514)) | (1 << (postgreSQLParser.ELSIF - 514)) | (1 << (postgreSQLParser.ERRCODE - 514)) | (1 << (postgreSQLParser.EXIT - 514)) | (1 << (postgreSQLParser.EXCEPTION - 514)) | (1 << (postgreSQLParser.FOREACH - 514)) | (1 << (postgreSQLParser.GET - 514)) | (1 << (postgreSQLParser.HINT - 514)) | (1 << (postgreSQLParser.INFO - 514)) | (1 << (postgreSQLParser.LOG - 514)) | (1 << (postgreSQLParser.LOOP - 514)) | (1 << (postgreSQLParser.MESSAGE - 514)) | (1 << (postgreSQLParser.NOTICE - 514)) | (1 << (postgreSQLParser.OPEN - 514)) | (1 << (postgreSQLParser.PERFORM - 514)) | (1 << (postgreSQLParser.QUERY - 514)) | (1 << (postgreSQLParser.RAISE - 514)) | (1 << (postgreSQLParser.RECORD - 514)) | (1 << (postgreSQLParser.RETURN - 514)))) != 0) or ((((_la - 578)) & ~0x3f) == 0 and ((1 << (_la - 578)) & ((1 << (postgreSQLParser.REVERSE - 578)) | (1 << (postgreSQLParser.ROWTYPE - 578)) | (1 << (postgreSQLParser.SLICE - 578)) | (1 << (postgreSQLParser.SQLSTATE - 578)) | (1 << (postgreSQLParser.STACKED - 578)) | (1 << (postgreSQLParser.WARNING - 578)) | (1 << (postgreSQLParser.WHILE - 578)) | (1 << (postgreSQLParser.LEFT_PAREN - 578)) | (1 << (postgreSQLParser.PLUS - 578)) | (1 << (postgreSQLParser.MINUS - 578)) | (1 << (postgreSQLParser.MULTIPLY - 578)) | (1 << (postgreSQLParser.LESS_LESS - 578)) | (1 << (postgreSQLParser.GREATER_GREATER - 578)) | (1 << (postgreSQLParser.HASH_SIGN - 578)) | (1 << (postgreSQLParser.OP_CHARS - 578)) | (1 << (postgreSQLParser.NUMBER_LITERAL - 578)) | (1 << (postgreSQLParser.REAL_NUMBER - 578)) | (1 << (postgreSQLParser.DOLLAR_NUMBER - 578)) | (1 << (postgreSQLParser.Identifier - 578)) | (1 << (postgreSQLParser.QuotedIdentifier - 578)) | (1 << (postgreSQLParser.Character_String_Literal - 578)) | (1 << (postgreSQLParser.BeginDollarStringConstant - 578)))) != 0):
                self.state = 7889
                self.vex(0)


            self.state = 7904 
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while True:
                self.state = 7892
                self.match(postgreSQLParser.WHEN)
                self.state = 7893
                self.vex(0)
                self.state = 7898
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==postgreSQLParser.COMMA:
                    self.state = 7894
                    self.match(postgreSQLParser.COMMA)
                    self.state = 7895
                    self.vex(0)
                    self.state = 7900
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 7901
                self.match(postgreSQLParser.THEN)
                self.state = 7902
                self.function_statements()
                self.state = 7906 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if not (_la==postgreSQLParser.WHEN):
                    break

            self.state = 7910
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==postgreSQLParser.ELSE:
                self.state = 7908
                self.match(postgreSQLParser.ELSE)
                self.state = 7909
                self.function_statements()


            self.state = 7912
            self.match(postgreSQLParser.END)
            self.state = 7913
            self.match(postgreSQLParser.CASE)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Plpgsql_queryContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def data_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Data_statementContext,0)


        def execute_stmt(self):
            return self.getTypedRuleContext(postgreSQLParser.Execute_stmtContext,0)


        def show_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Show_statementContext,0)


        def explain_statement(self):
            return self.getTypedRuleContext(postgreSQLParser.Explain_statementContext,0)


        def getRuleIndex(self):
            return postgreSQLParser.RULE_plpgsql_query

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPlpgsql_query" ):
                listener.enterPlpgsql_query(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPlpgsql_query" ):
                listener.exitPlpgsql_query(self)




    def plpgsql_query(self):

        localctx = postgreSQLParser.Plpgsql_queryContext(self, self._ctx, self.state)
        self.enterRule(localctx, 784, self.RULE_plpgsql_query)
        try:
            self.state = 7919
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [postgreSQLParser.DELETE, postgreSQLParser.INSERT, postgreSQLParser.UPDATE, postgreSQLParser.VALUES, postgreSQLParser.SELECT, postgreSQLParser.TABLE, postgreSQLParser.WITH, postgreSQLParser.LEFT_PAREN]:
                self.enterOuterAlt(localctx, 1)
                self.state = 7915
                self.data_statement()
                pass
            elif token in [postgreSQLParser.EXECUTE]:
                self.enterOuterAlt(localctx, 2)
                self.state = 7916
                self.execute_stmt()
                pass
            elif token in [postgreSQLParser.SHOW]:
                self.enterOuterAlt(localctx, 3)
                self.state = 7917
                self.show_statement()
                pass
            elif token in [postgreSQLParser.EXPLAIN]:
                self.enterOuterAlt(localctx, 4)
                self.state = 7918
                self.explain_statement()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx



    def sempred(self, localctx:RuleContext, ruleIndex:int, predIndex:int):
        if self._predicates == None:
            self._predicates = dict()
        self._predicates[293] = self.vex_sempred
        self._predicates[294] = self.vex_b_sempred
        self._predicates[330] = self.select_ops_sempred
        self._predicates[336] = self.from_item_sempred
        pred = self._predicates.get(ruleIndex, None)
        if pred is None:
            raise Exception("No predicate with index:" + str(ruleIndex))
        else:
            return pred(localctx, predIndex)

    def vex_sempred(self, localctx:VexContext, predIndex:int):
            if predIndex == 0:
                return self.precpred(self._ctx, 23)
         

            if predIndex == 1:
                return self.precpred(self._ctx, 22)
         

            if predIndex == 2:
                return self.precpred(self._ctx, 21)
         

            if predIndex == 3:
                return self.precpred(self._ctx, 20)
         

            if predIndex == 4:
                return self.precpred(self._ctx, 19)
         

            if predIndex == 5:
                return self.precpred(self._ctx, 15)
         

            if predIndex == 6:
                return self.precpred(self._ctx, 14)
         

            if predIndex == 7:
                return self.precpred(self._ctx, 13)
         

            if predIndex == 8:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 9:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 10:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 11:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 12:
                return self.precpred(self._ctx, 28)
         

            if predIndex == 13:
                return self.precpred(self._ctx, 25)
         

            if predIndex == 14:
                return self.precpred(self._ctx, 17)
         

            if predIndex == 15:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 16:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 17:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 18:
                return self.precpred(self._ctx, 8)
         

            if predIndex == 19:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 20:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 21:
                return self.precpred(self._ctx, 5)
         

    def vex_b_sempred(self, localctx:Vex_bContext, predIndex:int):
            if predIndex == 22:
                return self.precpred(self._ctx, 12)
         

            if predIndex == 23:
                return self.precpred(self._ctx, 11)
         

            if predIndex == 24:
                return self.precpred(self._ctx, 10)
         

            if predIndex == 25:
                return self.precpred(self._ctx, 9)
         

            if predIndex == 26:
                return self.precpred(self._ctx, 6)
         

            if predIndex == 27:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 28:
                return self.precpred(self._ctx, 16)
         

            if predIndex == 29:
                return self.precpred(self._ctx, 7)
         

            if predIndex == 30:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 31:
                return self.precpred(self._ctx, 3)
         

            if predIndex == 32:
                return self.precpred(self._ctx, 2)
         

    def select_ops_sempred(self, localctx:Select_opsContext, predIndex:int):
            if predIndex == 33:
                return self.precpred(self._ctx, 2)
         

    def from_item_sempred(self, localctx:From_itemContext, predIndex:int):
            if predIndex == 34:
                return self.precpred(self._ctx, 5)
         

            if predIndex == 35:
                return self.precpred(self._ctx, 2)
         

            if predIndex == 36:
                return self.precpred(self._ctx, 4)
         

            if predIndex == 37:
                return self.precpred(self._ctx, 3)
         




